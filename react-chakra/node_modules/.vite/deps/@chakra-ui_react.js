import {
  require_jsx_runtime
} from "./chunk-RLMGAKMB.js";
import {
  require_react_dom
} from "./chunk-BCXODTBQ.js";
import {
  __commonJS,
  __export,
  __toESM,
  require_react
} from "./chunk-2YIMICFJ.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment14 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal2 = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement3(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment14;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal2;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement3;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics2(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics2(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e) {
            }
          }
        }
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics2;
  }
});

// node_modules/@ark-ui/react/dist/components/format/format-byte.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/dom-query/dist/index.mjs
var dataAttr = (guard) => guard ? "" : void 0;
var ariaAttr = (guard) => guard ? "true" : void 0;
var MAX_Z_INDEX = 2147483647;
var ELEMENT_NODE = 1;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;
var isObject = (v) => typeof v === "object" && v !== null;
var isHTMLElement = (el) => isObject(el) && el.nodeType === ELEMENT_NODE && typeof el.nodeName === "string";
var isDocument = (el) => isObject(el) && el.nodeType === DOCUMENT_NODE;
var isWindow = (el) => isObject(el) && el === el.window;
var getNodeName = (node2) => {
  if (isHTMLElement(node2)) return node2.localName || "";
  return "#document";
};
function isRootElement(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
var isNode = (el) => isObject(el) && el.nodeType !== void 0;
var isShadowRoot = (el) => isNode(el) && el.nodeType === DOCUMENT_FRAGMENT_NODE && "host" in el;
function contains(parent, child) {
  if (!parent || !child) return false;
  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false;
  return parent === child || parent.contains(child);
}
function getDocument(el) {
  if (isDocument(el)) return el;
  if (isWindow(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
function getDocumentElement(el) {
  return getDocument(el).documentElement;
}
function getWindow(el) {
  var _a7;
  if (isShadowRoot(el)) return getWindow(el.host);
  if (isDocument(el)) return el.defaultView ?? window;
  if (isHTMLElement(el)) return ((_a7 = el.ownerDocument) == null ? void 0 : _a7.defaultView) ?? window;
  return window;
}
function getActiveElement(rootNode) {
  let activeElement = rootNode.activeElement;
  while (activeElement == null ? void 0 : activeElement.shadowRoot) {
    const el = activeElement.shadowRoot.activeElement;
    if (el === activeElement) break;
    else activeElement = el;
  }
  return activeElement;
}
var isDom = () => typeof document !== "undefined";
function getPlatform() {
  const agent = navigator.userAgentData;
  return (agent == null ? void 0 : agent.platform) ?? navigator.platform;
}
var pt = (v) => isDom() && v.test(getPlatform());
var ua = (v) => isDom() && v.test(navigator.userAgent);
var vn = (v) => isDom() && v.test(navigator.vendor);
var isMac = () => pt(/^Mac/);
var isSafari = () => isApple() && vn(/apple/i);
var isFirefox = () => ua(/firefox\//i);
var isApple = () => pt(/mac|iphone|ipad|ipod/i);
var isIos = () => pt(/iP(hone|ad|od)|iOS/);
function getBeforeInputValue(event) {
  const { selectionStart, selectionEnd, value } = event.currentTarget;
  return value.slice(0, selectionStart) + event.data + value.slice(selectionEnd);
}
function getComposedPath(event) {
  var _a7, _b6, _c5;
  return ((_a7 = event.composedPath) == null ? void 0 : _a7.call(event)) ?? ((_c5 = (_b6 = event.nativeEvent) == null ? void 0 : _b6.composedPath) == null ? void 0 : _c5.call(_b6));
}
function getEventTarget(event) {
  const composedPath = getComposedPath(event);
  return (composedPath == null ? void 0 : composedPath[0]) ?? event.target;
}
var isSelfTarget = (event) => {
  return contains(event.currentTarget, getEventTarget(event));
};
function isOpeningInNewTab(event) {
  const element = event.currentTarget;
  if (!element) return false;
  const isAppleDevice = isApple();
  if (isAppleDevice && !event.metaKey) return false;
  if (!isAppleDevice && !event.ctrlKey) return false;
  const localName = element.localName;
  if (localName === "a") return true;
  if (localName === "button" && element.type === "submit") return true;
  if (localName === "input" && element.type === "submit") return true;
  return false;
}
function isDownloadingEvent(event) {
  const element = event.currentTarget;
  if (!element) return false;
  const localName = element.localName;
  if (!event.altKey) return false;
  if (localName === "a") return true;
  if (localName === "button" && element.type === "submit") return true;
  if (localName === "input" && element.type === "submit") return true;
  return false;
}
function isComposingEvent(event) {
  var _a7;
  return ((_a7 = event.nativeEvent) == null ? void 0 : _a7.isComposing) ?? event.isComposing;
}
var defaultItemToId = (v) => v.id;
function itemById(v, id, itemToId = defaultItemToId) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId(v, id, itemToId = defaultItemToId) {
  const item = itemById(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
function nextById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
  return v[idx];
}
function prevById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  if (idx === -1) return loop ? v[v.length - 1] : null;
  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
  return v[idx];
}
var sanitize = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText = (item) => sanitize(item.dataset.valuetext ?? item.textContent ?? "");
var match = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText(v, text, currentId, itemToId = defaultItemToId) {
  const index = currentId ? indexOfId(v, currentId, itemToId) : -1;
  let items = currentId ? wrap(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match(getValueText(item), text));
}
function getByTypeaheadImpl(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead = Object.assign(getByTypeaheadImpl, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent
});
function isValidTypeaheadEvent(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var styleCache = /* @__PURE__ */ new WeakMap();
function getComputedStyle2(el) {
  if (!styleCache.has(el)) {
    styleCache.set(el, getWindow(el).getComputedStyle(el));
  }
  return styleCache.get(el);
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
var isHTMLElement2 = (element) => typeof element === "object" && element !== null && element.nodeType === 1;
var isFrame = (element) => isHTMLElement2(element) && element.tagName === "IFRAME";
function isVisible(el) {
  if (!isHTMLElement2(el)) return false;
  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;
}
function hasNegativeTabIndex(element) {
  const tabIndex = parseInt(element.getAttribute("tabindex") || "0", 10);
  return tabIndex < 0;
}
var focusableSelector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
var getFocusables = (container, includeContainer = false) => {
  if (!container) return [];
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  const include = includeContainer == true || includeContainer == "if-empty" && elements.length === 0;
  if (include && isHTMLElement2(container) && isFocusable(container)) {
    elements.unshift(container);
  }
  const focusableElements = elements.filter(isFocusable);
  focusableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      focusableElements.splice(i, 1, ...getFocusables(frameBody));
    }
  });
  return focusableElements;
};
function isFocusable(element) {
  if (!element || element.closest("[inert]")) return false;
  return element.matches(focusableSelector) && isVisible(element);
}
function getTabbables(container, includeContainer) {
  if (!container) return [];
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  const tabbableElements = elements.filter(isTabbable);
  if (includeContainer && isTabbable(container)) {
    tabbableElements.unshift(container);
  }
  tabbableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      const allFrameTabbable = getTabbables(frameBody);
      tabbableElements.splice(i, 1, ...allFrameTabbable);
    }
  });
  if (!tabbableElements.length && includeContainer) {
    return elements;
  }
  return tabbableElements;
}
function isTabbable(el) {
  if (el != null && el.tabIndex > 0) return true;
  return isFocusable(el) && !hasNegativeTabIndex(el);
}
function getTabbableEdges(container, includeContainer) {
  const elements = getTabbables(container, includeContainer);
  const first3 = elements[0] || null;
  const last3 = elements[elements.length - 1] || null;
  return [first3, last3];
}
function getNextTabbable(container, current) {
  const tabbables = getTabbables(container);
  const doc = (container == null ? void 0 : container.ownerDocument) || document;
  const currentElement = current ?? doc.activeElement;
  if (!currentElement) return null;
  const index = tabbables.indexOf(currentElement);
  return tabbables[index + 1] || null;
}
function getInitialFocus(options) {
  const { root, getInitialEl, filter, enabled = true } = options;
  if (!enabled) return;
  let node2 = null;
  node2 || (node2 = typeof getInitialEl === "function" ? getInitialEl() : getInitialEl);
  node2 || (node2 = root == null ? void 0 : root.querySelector("[data-autofocus],[autofocus]"));
  if (!node2) {
    const tabbables = getTabbables(root);
    node2 = filter ? tabbables.filter(filter)[0] : tabbables[0];
  }
  return node2 || root || void 0;
}
function isValidTabEvent(event) {
  const container = event.currentTarget;
  if (!container) return false;
  const [firstTabbable, lastTabbable] = getTabbableEdges(container);
  const doc = container.ownerDocument || document;
  if (doc.activeElement === firstTabbable && event.shiftKey) return false;
  if (doc.activeElement === lastTabbable && !event.shiftKey) return false;
  if (!firstTabbable && !lastTabbable) return false;
  return true;
}
function isEditableElement(el) {
  if (el == null || !isHTMLElement(el)) {
    return false;
  }
  try {
    const win = getWindow(el);
    return el instanceof win.HTMLInputElement && el.selectionStart != null || /(textarea|select)/.test(el.localName) || el.isContentEditable;
  } catch {
    return false;
  }
}
var OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;
function isOverflowElement(el) {
  const win = getWindow(el);
  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el);
  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function nextTick(fn) {
  const set22 = /* @__PURE__ */ new Set();
  function raf28(fn2) {
    const id = globalThis.requestAnimationFrame(fn2);
    set22.add(() => globalThis.cancelAnimationFrame(id));
  }
  raf28(() => raf28(fn));
  return function cleanup() {
    set22.forEach((fn2) => fn2());
  };
}
function raf(fn) {
  const id = globalThis.requestAnimationFrame(fn);
  return () => {
    globalThis.cancelAnimationFrame(id);
  };
}
function observeAttributesImpl(node2, options) {
  if (!node2) return;
  const { attributes, callback: fn } = options;
  const win = node2.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver((changes) => {
    for (const change of changes) {
      if (change.type === "attributes" && change.attributeName && attributes.includes(change.attributeName)) {
        fn(change);
      }
    }
  });
  obs.observe(node2, { attributes: true, attributeFilter: attributes });
  return () => obs.disconnect();
}
function observeAttributes(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(observeAttributesImpl(node2, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function observeChildrenImpl(node2, options) {
  const { callback: fn } = options;
  if (!node2) return;
  const win = node2.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver(fn);
  obs.observe(node2, { childList: true, subtree: true });
  return () => obs.disconnect();
}
function observeChildren(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(observeChildrenImpl(node2, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function getNearestOverflowAncestor(el) {
  const parentNode = getParentNode(el);
  if (isRootElement(parentNode)) {
    return getDocument(parentNode).body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(el, list = []) {
  const scrollableAncestor = getNearestOverflowAncestor(el);
  const isBody = scrollableAncestor === el.ownerDocument.body;
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));
}
function proxyTabFocusImpl(container, options = {}) {
  const { triggerElement, onFocus } = options;
  const doc = (container == null ? void 0 : container.ownerDocument) || document;
  const body = doc.body;
  function onKeyDown(event) {
    if (event.key !== "Tab") return;
    let elementToFocus = null;
    const [firstTabbable, lastTabbable] = getTabbableEdges(container, true);
    const noTabbableElements = !firstTabbable && !lastTabbable;
    if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {
      elementToFocus = triggerElement;
    } else if (!event.shiftKey && doc.activeElement === triggerElement) {
      elementToFocus = firstTabbable;
    } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {
      elementToFocus = getNextTabbable(body, triggerElement);
    }
    if (!elementToFocus) return;
    event.preventDefault();
    if (typeof onFocus === "function") {
      onFocus(elementToFocus);
    } else {
      elementToFocus.focus();
    }
  }
  doc == null ? void 0 : doc.addEventListener("keydown", onKeyDown, true);
  return () => {
    doc == null ? void 0 : doc.removeEventListener("keydown", onKeyDown, true);
  };
}
function proxyTabFocus(container, options) {
  const { defer, triggerElement, ...restOptions } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof container === "function" ? container() : container;
      const trigger = typeof triggerElement === "function" ? triggerElement() : triggerElement;
      cleanups2.push(proxyTabFocusImpl(node2, { triggerElement: trigger, ...restOptions }));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function queryAll(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function query(root, selector) {
  return (root == null ? void 0 : root.querySelector(selector)) ?? null;
}
function createScope(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => getActiveElement(dom61.getRootNode(ctx)),
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
function isScrollable(el) {
  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;
}
function scrollIntoView(el, options) {
  const { rootEl, ...scrollOptions } = options || {};
  if (!el || !rootEl) {
    return;
  }
  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) {
    return;
  }
  el.scrollIntoView(scrollOptions);
}
var cleanups = /* @__PURE__ */ new WeakMap();
function set(element, key, setup) {
  if (!cleanups.has(element)) {
    cleanups.set(element, /* @__PURE__ */ new Map());
  }
  const elementCleanups = cleanups.get(element);
  const prevCleanup = elementCleanups.get(key);
  if (!prevCleanup) {
    elementCleanups.set(key, setup());
    return () => {
      var _a7;
      (_a7 = elementCleanups.get(key)) == null ? void 0 : _a7();
      elementCleanups.delete(key);
    };
  }
  const cleanup = setup();
  const nextCleanup = () => {
    cleanup();
    prevCleanup();
    elementCleanups.delete(key);
  };
  elementCleanups.set(key, nextCleanup);
  return () => {
    const isCurrent = elementCleanups.get(key) === nextCleanup;
    if (!isCurrent) return;
    cleanup();
    elementCleanups.set(key, prevCleanup);
  };
}
function setStyle(element, style) {
  if (!element) return () => {
  };
  const setup = () => {
    const prevStyle = element.style.cssText;
    Object.assign(element.style, style);
    return () => {
      element.style.cssText = prevStyle;
    };
  };
  return set(element, "style", setup);
}
var visuallyHiddenStyle = {
  border: "0",
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0",
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap",
  wordWrap: "normal"
};
var fps = 1e3 / 60;
function waitForElement(query22, cb) {
  const el = query22();
  if (isHTMLElement(el) && el.isConnected) {
    cb(el);
    return () => void 0;
  } else {
    const timerId = setInterval(() => {
      const el2 = query22();
      if (isHTMLElement(el2) && el2.isConnected) {
        cb(el2);
        clearInterval(timerId);
      }
    }, fps);
    return () => clearInterval(timerId);
  }
}
function waitForElements(queries, cb) {
  const cleanups2 = [];
  queries == null ? void 0 : queries.forEach((query22) => {
    const clean = waitForElement(query22, cb);
    cleanups2.push(clean);
  });
  return () => {
    cleanups2.forEach((fn) => fn());
  };
}

// node_modules/@zag-js/i18n-utils/dist/index.mjs
function i18nCache(Ins) {
  const formatterCache = /* @__PURE__ */ new Map();
  return function create(locale, options) {
    const cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
    if (formatterCache.has(cacheKey)) {
      return formatterCache.get(cacheKey);
    }
    let formatter = new Ins(locale, options);
    formatterCache.set(cacheKey, formatter);
    return formatter;
  };
}
var collatorCache = i18nCache(Intl.Collator);
var getNumberFormatter = i18nCache(Intl.NumberFormat);
function formatNumber(v, locale, options = {}) {
  const formatter = getNumberFormatter(locale, options);
  return formatter.format(v);
}
var bitPrefixes = ["", "kilo", "mega", "giga", "tera"];
var bytePrefixes = ["", "kilo", "mega", "giga", "tera", "peta"];
var formatBytes = (bytes, locale = "en-US", options = {}) => {
  if (isNaN(bytes)) return "";
  if (bytes === 0) return "0 B";
  const { unit = "byte", unitDisplay = "short" } = options;
  const prefix3 = unit === "bit" ? bitPrefixes : bytePrefixes;
  const index = Math.max(0, Math.min(Math.floor(Math.log10(bytes) / 3), prefix3.length - 1));
  const _unit = prefix3[index] + unit;
  const _unitDisplay = unitDisplay || "short";
  const v = parseFloat((bytes / Math.pow(1e3, index)).toPrecision(3));
  return formatNumber(v, locale, {
    style: "unit",
    unit: _unit,
    unitDisplay: _unitDisplay
  });
};
var getListFormatter = i18nCache(Intl.ListFormat);
var getRelativeTimeFormatter = i18nCache(Intl.RelativeTimeFormat);
var MINUTE_TO_MS = 1e3 * 60;
var HOUR_TO_MS = 1e3 * 60 * 60;
var DAY_TO_MS = 1e3 * 60 * 60 * 24;
var WEEK_TO_MS = 1e3 * 60 * 60 * 24 * 7;
var MONTH_TO_MS = 1e3 * 60 * 60 * 24 * 30;
var YEAR_TO_MS = 1e3 * 60 * 60 * 24 * 365;
var RTL_SCRIPTS = /* @__PURE__ */ new Set([
  "Avst",
  "Arab",
  "Armi",
  "Syrc",
  "Samr",
  "Mand",
  "Thaa",
  "Mend",
  "Nkoo",
  "Adlm",
  "Rohg",
  "Hebr"
]);
var RTL_LANGS = /* @__PURE__ */ new Set([
  "ae",
  "ar",
  "arc",
  "bcc",
  "bqi",
  "ckb",
  "dv",
  "fa",
  "glk",
  "he",
  "ku",
  "mzn",
  "nqo",
  "pnb",
  "ps",
  "sd",
  "ug",
  "ur",
  "yi"
]);
function isRTL(locale) {
  if (Intl.Locale) {
    const script = new Intl.Locale(locale).maximize().script ?? "";
    return RTL_SCRIPTS.has(script);
  }
  const lang = locale.split("-")[0];
  return RTL_LANGS.has(lang);
}

// node_modules/@ark-ui/react/dist/components/format/format-byte.js
var import_react2 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/create-context.js
var import_react = __toESM(require_react(), 1);
function getErrorMessage(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext(options = {}) {
  const {
    name,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options;
  const Context = (0, import_react.createContext)(defaultValue);
  Context.displayName = name;
  function useContext$1() {
    var _a7;
    const context = (0, import_react.useContext)(Context);
    if (!context && strict) {
      const error = new Error(errorMessage ?? getErrorMessage(hookName, providerName));
      error.name = "ContextError";
      (_a7 = Error.captureStackTrace) == null ? void 0 : _a7.call(Error, error, useContext$1);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext$1, Context];
}

// node_modules/@ark-ui/react/dist/providers/locale/use-locale-context.js
var [LocaleContextProvider, useLocaleContext] = createContext({
  name: "LocaleContext",
  hookName: "useLocaleContext",
  providerName: "<LocaleProvider />",
  strict: false,
  defaultValue: { dir: "ltr", locale: "en-US" }
});

// node_modules/@ark-ui/react/dist/components/format/format-byte.js
var FormatByte = (props52) => {
  const { value, ...intlOptions } = props52;
  const { locale } = useLocaleContext();
  const text = (0, import_react2.useMemo)(() => formatBytes(value, locale, intlOptions), [value, locale, intlOptions]);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: text });
};
FormatByte.displayName = "FormatByte";

// node_modules/@ark-ui/react/dist/components/format/format-number.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var FormatNumber = (props52) => {
  const { value, ...intlOptions } = props52;
  const { locale } = useLocaleContext();
  const text = (0, import_react3.useMemo)(() => formatNumber(value, locale, intlOptions), [value, locale, intlOptions]);
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: text });
};
FormatNumber.displayName = "FormatNumber";

// node_modules/@ark-ui/react/dist/components/format/format.js
var format_exports = {};
__export(format_exports, {
  Byte: () => FormatByte,
  Number: () => FormatNumber
});

// node_modules/@chakra-ui/react/dist/esm/components/format/index.js
var FormatNumber2 = format_exports.Number;
var FormatByte2 = format_exports.Byte;

// node_modules/@chakra-ui/react/dist/esm/components/theme.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/cx.js
var cx = (...classNames) => classNames.filter(Boolean).map((r) => r.trim()).join(" ");

// node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);

// node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache2[arg] === void 0) cache2[arg] = fn(arg);
    return cache2[arg];
  };
}

// node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);

// node_modules/@emotion/react/dist/emotion-element-7a1343fa.browser.development.esm.js
var React2 = __toESM(require_react());
var import_react4 = __toESM(require_react());

// node_modules/@emotion/sheet/dist/emotion-sheet.development.esm.js
var isDevelopment = true;
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
  return void 0;
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? !isDevelopment : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    {
      var isImportRule3 = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
      if (isImportRule3 && this._alreadyInsertedOrderInsensitiveRule) {
        console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule3;
    }
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
        if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
          console.error('There was a problem inserting the following rule: "' + rule + '"', e);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
    {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };
  return StyleSheet2;
}();

// node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match2(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}

// node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props52, children, length2) {
  return { value, root, parent, type, props: props52, children, line, column, length: length2, return: "" };
}
function copy(root, props52) {
  return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props52);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index) {
  while (!token(peek()))
    next();
  return slice(index, position);
}

// node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset4 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props52 = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset4:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent, index, offset4, rules, points, type, props52 = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset4 === 0)
                parse(characters2, root, reference, reference, props52, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props52 = [], length2), children), rules, children, length2, points, rule ? props52 : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index = offset4 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset4 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset4 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index, offset4, rules, points, type, props52, children, length2) {
  var post = offset4 - 1;
  var rule = offset4 === 0 ? rules : [""];
  var size4 = sizeof(rule);
  for (var i = 0, j = 0, k = 0; i < index; ++i)
    for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size4; ++x)
      if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
        props52[k++] = z;
  return node(value, root, parent, offset4 === 0 ? RULESET : type, props52, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify(element, index, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

// node_modules/stylis/src/Middleware.js
function middleware(collection4) {
  var length2 = sizeof(collection4);
  return function(element, index, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection4[i](element, index, children, callback) || "";
    return output;
  };
}

// node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js
var weakMemoize = function weakMemoize2(func) {
  var cache2 = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache2.has(arg)) {
      return cache2.get(arg);
    }
    var ret = func(arg);
    cache2.set(arg, ret);
    return ret;
  };
};

// node_modules/@emotion/cache/dist/emotion-cache.browser.development.esm.js
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index] = 1;
        }
        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;
      case 2:
        parsed[index] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index] = peek() === 58 ? "&\f" : "";
          points[index] = parsed[index].length;
          break;
        }
      default:
        parsed[index] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
var isIgnoringComment = function isIgnoringComment2(element) {
  return element.type === "comm" && element.children.indexOf(ignoreFlag) > -1;
};
var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm2(cache2) {
  return function(element, index, children) {
    if (element.type !== "rule" || cache2.compat) return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
    if (unsafePseudoClasses) {
      var isNested = !!element.parent;
      var commentContainer = isNested ? element.parent.children : (
        // global rule at the root level
        children
      );
      for (var i = commentContainer.length - 1; i >= 0; i--) {
        var node2 = commentContainer[i];
        if (node2.line < element.line) {
          break;
        }
        if (node2.column < element.column) {
          if (isIgnoringComment(node2)) {
            return;
          }
          break;
        }
      }
      unsafePseudoClasses.forEach(function(unsafePseudoClass) {
        console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
      });
    }
  };
};
var isImportRule = function isImportRule2(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};
var isPrependedWithRegularRules = function isPrependedWithRegularRules2(index, children) {
  for (var i = index - 1; i >= 0; i--) {
    if (!isImportRule(children[i])) {
      return true;
    }
  }
  return false;
};
var nullifyElement = function nullifyElement2(element) {
  element.type = "";
  element.value = "";
  element["return"] = "";
  element.children = "";
  element.props = "";
};
var incorrectImportAlarm = function incorrectImportAlarm2(element, index, children) {
  if (!isImportRule(element)) {
    return;
  }
  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};
function prefix2(value, length2) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        case 115:
          return ~indexof(value, "stretch") ? prefix2(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index, children, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix2(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine(element.props, function(value) {
          switch (match2(value, /(::plac\w+|:read-\w+)/)) {
            case ":read-only":
            case ":read-write":
              return serialize([copy(element, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            case "::placeholder":
              return serialize([copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (!key) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
  }
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  {
    if (/[^a-z-]/.test(key)) {
      throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
    }
  }
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache2.compat;
      }
    }), incorrectImportAlarm);
  }
  {
    var currentSheet;
    var finalizingPlugins = [stringify, function(element) {
      if (!element.root) {
        if (element["return"]) {
          currentSheet.insert(element["return"]);
        } else if (element.value && element.type !== COMMENT) {
          currentSheet.insert(element.value + "{}");
        }
      }
    }];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles) {
      return serialize(compile(styles), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      if (serialized.map !== void 0) {
        currentSheet = {
          insert: function insert2(rule) {
            sheet.insert(rule + serialized.map);
          }
        };
      }
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache2.inserted[serialized.name] = true;
      }
    };
  }
  var cache2 = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache2.sheet.hydrate(nodesToHydrate);
  return cache2;
};

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.esm.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());

// node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
  var className = cache2.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache2.registered[className] === void 0
  ) {
    cache2.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache2, serialized, isStringTag) {
  registerStyles(cache2, serialized, isStringTag);
  var className = cache2.key + "-" + serialized.name;
  if (cache2.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};

// node_modules/@emotion/hash/dist/emotion-hash.esm.js
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = /* Math.imul(h, m): */
  (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}

// node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

// node_modules/@emotion/serialize/dist/emotion-serialize.development.esm.js
var isDevelopment2 = true;
var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match50, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
{
  contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  contentValues = ["normal", "none", "initial", "inherit", "unset"];
  oldProcessStyleValue = processStyleValue;
  msPattern = /^-ms-/;
  hyphenPattern = /-(.)/g;
  hyphenatedCache = {};
  processStyleValue = function processStyleValue3(key, value) {
    if (key === "content") {
      if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }
    var processed = oldProcessStyleValue(key, value);
    if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }
    return processed;
  };
}
var contentValuePattern;
var contentValues;
var oldProcessStyleValue;
var msPattern;
var hyphenPattern;
var hyphenatedCache;
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    if (String(componentSelector) === "NO_COMPONENT_SELECTOR") {
      throw new Error(noComponentSelectorMessage);
    }
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes2 = interpolation;
      if (keyframes2.anim === 1) {
        cursor = {
          name: keyframes2.name,
          styles: keyframes2.styles,
          next: cursor
        };
        return keyframes2.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next3 = serializedStyles.next;
        if (next3 !== void 0) {
          while (next3 !== void 0) {
            cursor = {
              name: next3.name,
              styles: next3.styles,
              next: cursor
            };
            next3 = next3.next;
          }
        }
        var styles = serializedStyles.styles + ";";
        if (serializedStyles.map !== void 0) {
          styles += serializedStyles.map;
        }
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      } else {
        console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      }
      break;
    }
    case "string":
      {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function(_match, _p1, p2) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, "") + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\ncss`" + replaced + "`");
        }
      }
      break;
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];
      if (typeof value !== "object") {
        var asString = value;
        if (registered != null && registered[asString] !== void 0) {
          string += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (key === "NO_COMPONENT_SELECTOR" && isDevelopment2) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i3 = 0; _i3 < value.length; _i3++) {
            if (isProcessableValue(value[_i3])) {
              string += processStyleName(key) + ":" + processStyleValue(key, value[_i3]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key) {
            case "animation":
            case "animationName": {
              string += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              if (key === "undefined") {
                console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
              }
              string += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var sourceMapPattern;
{
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
}
var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    if (asTemplateStringsArr[0] === void 0) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }
    styles += asTemplateStringsArr[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      var templateStringsArr = strings;
      if (templateStringsArr[i] === void 0) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles += templateStringsArr[i];
    }
  }
  var sourceMap;
  {
    styles = styles.replace(sourceMapPattern, function(match51) {
      sourceMap = match51;
      return "";
    });
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match50;
  while ((match50 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + match50[1];
  }
  var name = murmur2(styles) + identifierName;
  {
    var devStyles = {
      name,
      styles,
      map: sourceMap,
      next: cursor,
      toString: function toString() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
    return devStyles;
  }
}

// node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js
var React = __toESM(require_react());
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect2 = React["useInsertionEffect"] ? React["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect2 || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect2 || React.useLayoutEffect;

// node_modules/@emotion/react/dist/emotion-element-7a1343fa.browser.development.esm.js
var EmotionCacheContext = React2.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? createCache({
    key: "css"
  }) : null
);
{
  EmotionCacheContext.displayName = "EmotionCacheContext";
}
var CacheProvider = EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return (0, import_react4.forwardRef)(function(props52, ref36) {
    var cache2 = (0, import_react4.useContext)(EmotionCacheContext);
    return func(props52, cache2, ref36);
  });
};
var ThemeContext = React2.createContext({});
{
  ThemeContext.displayName = "EmotionThemeContext";
}
var getTheme = function getTheme2(outerTheme, theme) {
  if (typeof theme === "function") {
    var mergedTheme = theme(outerTheme);
    if (mergedTheme == null || typeof mergedTheme !== "object" || Array.isArray(mergedTheme)) {
      throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
    }
    return mergedTheme;
  }
  if (theme == null || typeof theme !== "object" || Array.isArray(theme)) {
    throw new Error("[ThemeProvider] Please make your theme prop a plain object");
  }
  return _extends({}, outerTheme, theme);
};
var createCacheWithTheme = weakMemoize(function(outerTheme) {
  return weakMemoize(function(theme) {
    return getTheme(outerTheme, theme);
  });
});
var hasOwn = {}.hasOwnProperty;
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__";
var Insertion = function Insertion2(_ref) {
  var cache2 = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
  registerStyles(cache2, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag);
  });
  return null;
};
var Emotion = withEmotionCache(
  /* <any, any> */
  function(props52, cache2, ref36) {
    var cssProp = props52.css;
    if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
      cssProp = cache2.registered[cssProp];
    }
    var WrappedComponent = props52[typePropName];
    var registeredStyles = [cssProp];
    var className = "";
    if (typeof props52.className === "string") {
      className = getRegisteredStyles(cache2.registered, registeredStyles, props52.className);
    } else if (props52.className != null) {
      className = props52.className + " ";
    }
    var serialized = serializeStyles(registeredStyles, void 0, React2.useContext(ThemeContext));
    if (serialized.name.indexOf("-") === -1) {
      var labelFromStack = props52[labelPropName];
      if (labelFromStack) {
        serialized = serializeStyles([serialized, "label:" + labelFromStack + ";"]);
      }
    }
    className += cache2.key + "-" + serialized.name;
    var newProps = {};
    for (var key in props52) {
      if (hasOwn.call(props52, key) && key !== "css" && key !== typePropName && key !== labelPropName) {
        newProps[key] = props52[key];
      }
    }
    newProps.className = className;
    if (ref36) {
      newProps.ref = ref36;
    }
    return React2.createElement(React2.Fragment, null, React2.createElement(Insertion, {
      cache: cache2,
      serialized,
      isStringTag: typeof WrappedComponent === "string"
    }), React2.createElement(WrappedComponent, newProps));
  }
);
{
  Emotion.displayName = "EmotionCssPropInternal";
}

// node_modules/@emotion/react/dist/emotion-react.browser.development.esm.js
var React3 = __toESM(require_react());
var import_hoist_non_react_statics2 = __toESM(require_hoist_non_react_statics_cjs());
var isDevelopment3 = true;
var pkg = {
  name: "@emotion/react",
  version: "11.13.3",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  exports: {
    ".": {
      types: {
        "import": "./dist/emotion-react.cjs.mjs",
        "default": "./dist/emotion-react.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./dist/emotion-react.development.edge-light.esm.js",
          "import": "./dist/emotion-react.development.edge-light.cjs.mjs",
          "default": "./dist/emotion-react.development.edge-light.cjs.js"
        },
        worker: {
          module: "./dist/emotion-react.development.edge-light.esm.js",
          "import": "./dist/emotion-react.development.edge-light.cjs.mjs",
          "default": "./dist/emotion-react.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./dist/emotion-react.development.edge-light.esm.js",
          "import": "./dist/emotion-react.development.edge-light.cjs.mjs",
          "default": "./dist/emotion-react.development.edge-light.cjs.js"
        },
        browser: {
          module: "./dist/emotion-react.browser.development.esm.js",
          "import": "./dist/emotion-react.browser.development.cjs.mjs",
          "default": "./dist/emotion-react.browser.development.cjs.js"
        },
        module: "./dist/emotion-react.development.esm.js",
        "import": "./dist/emotion-react.development.cjs.mjs",
        "default": "./dist/emotion-react.development.cjs.js"
      },
      "edge-light": {
        module: "./dist/emotion-react.edge-light.esm.js",
        "import": "./dist/emotion-react.edge-light.cjs.mjs",
        "default": "./dist/emotion-react.edge-light.cjs.js"
      },
      worker: {
        module: "./dist/emotion-react.edge-light.esm.js",
        "import": "./dist/emotion-react.edge-light.cjs.mjs",
        "default": "./dist/emotion-react.edge-light.cjs.js"
      },
      workerd: {
        module: "./dist/emotion-react.edge-light.esm.js",
        "import": "./dist/emotion-react.edge-light.cjs.mjs",
        "default": "./dist/emotion-react.edge-light.cjs.js"
      },
      browser: {
        module: "./dist/emotion-react.browser.esm.js",
        "import": "./dist/emotion-react.browser.cjs.mjs",
        "default": "./dist/emotion-react.browser.cjs.js"
      },
      module: "./dist/emotion-react.esm.js",
      "import": "./dist/emotion-react.cjs.mjs",
      "default": "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      types: {
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
        },
        worker: {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
        },
        browser: {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.cjs.js"
        },
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.cjs.js"
      },
      "edge-light": {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
      },
      worker: {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
      },
      workerd: {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
      },
      browser: {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.cjs.js"
      },
      module: "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js",
      "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
      "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      types: {
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
        },
        worker: {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
        },
        browser: {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.cjs.js"
        },
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.cjs.js"
      },
      "edge-light": {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
      },
      worker: {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
      },
      workerd: {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
      },
      browser: {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.cjs.js"
      },
      module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js",
      "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
      "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      types: {
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
        },
        worker: {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
        },
        browser: {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.cjs.js"
        },
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.cjs.js"
      },
      "edge-light": {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
      },
      worker: {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
      },
      workerd: {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
      },
      browser: {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.cjs.js"
      },
      module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js",
      "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
      "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": {
      types: {
        "import": "./macro.d.mts",
        "default": "./macro.d.ts"
      },
      "default": "./macro.js"
    }
  },
  imports: {
    "#is-development": {
      development: "./src/conditions/true.js",
      "default": "./src/conditions/false.js"
    },
    "#is-browser": {
      "edge-light": "./src/conditions/false.js",
      workerd: "./src/conditions/false.js",
      worker: "./src/conditions/false.js",
      browser: "./src/conditions/true.js",
      "default": "./src/conditions/is-browser.js"
    }
  },
  types: "types/index.d.ts",
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/*.d.ts",
    "macro.*"
  ],
  sideEffects: false,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.12.0",
    "@emotion/cache": "^11.13.0",
    "@emotion/serialize": "^1.3.1",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.1.0",
    "@emotion/utils": "^1.4.0",
    "@emotion/weak-memoize": "^0.4.0",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: true
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.13.0",
    "@emotion/css-prettifier": "1.1.4",
    "@emotion/server": "11.11.0",
    "@emotion/styled": "11.13.0",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^5.4.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.js",
      "./jsx-runtime.js",
      "./jsx-dev-runtime.js",
      "./_isolated-hnrs.js"
    ],
    umdName: "emotionReact",
    exports: {
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            "import": "./macro.d.mts",
            "default": "./macro.d.ts"
          },
          "default": "./macro.js"
        }
      }
    }
  }
};
var warnedAboutCssPropForGlobal = false;
var Global = withEmotionCache(function(props52, cache2) {
  if (!warnedAboutCssPropForGlobal && // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // I don't really want to add it to the type since it shouldn't be used
  (props52.className || props52.css)) {
    console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
    warnedAboutCssPropForGlobal = true;
  }
  var styles = props52.styles;
  var serialized = serializeStyles([styles], void 0, React3.useContext(ThemeContext));
  var sheetRef = React3.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache2.key + "-global";
    var sheet = new cache2.sheet.constructor({
      key,
      nonce: cache2.sheet.nonce,
      container: cache2.sheet.container,
      speedy: cache2.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache2.sheet.tags.length) {
      sheet.before = cache2.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache2]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache2, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache2.insert("", serialized, sheet, false);
  }, [cache2, serialized.name]);
  return null;
});
{
  Global.displayName = "EmotionGlobal";
}
var classnames = function classnames2(args) {
  var len = args.length;
  var i = 0;
  var cls = "";
  for (; i < len; i++) {
    var arg = args[i];
    if (arg == null) continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames2(arg);
        } else {
          if (arg.styles !== void 0 && arg.name !== void 0) {
            console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
          }
          toAdd = "";
          for (var k in arg) {
            if (arg[k] && k) {
              toAdd && (toAdd += " ");
              toAdd += k;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};
function merge(registered, css2, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css2(registeredStyles);
}
var Insertion3 = function Insertion4(_ref) {
  var cache2 = _ref.cache, serializedArr = _ref.serializedArr;
  useInsertionEffectAlwaysWithSyncFallback(function() {
    for (var i = 0; i < serializedArr.length; i++) {
      insertStyles(cache2, serializedArr[i], false);
    }
  });
  return null;
};
var ClassNames = withEmotionCache(function(props52, cache2) {
  var hasRendered = false;
  var serializedArr = [];
  var css2 = function css3() {
    if (hasRendered && isDevelopment3) {
      throw new Error("css can only be used during render");
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args, cache2.registered);
    serializedArr.push(serialized);
    registerStyles(cache2, serialized, false);
    return cache2.key + "-" + serialized.name;
  };
  var cx2 = function cx3() {
    if (hasRendered && isDevelopment3) {
      throw new Error("cx can only be used during render");
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return merge(cache2.registered, css2, classnames(args));
  };
  var content = {
    css: css2,
    cx: cx2,
    theme: React3.useContext(ThemeContext)
  };
  var ele = props52.children(content);
  hasRendered = true;
  return React3.createElement(React3.Fragment, null, React3.createElement(Insertion3, {
    cache: cache2,
    serializedArr
  }), ele);
});
{
  ClassNames.displayName = "EmotionClassNames";
}
{
  isBrowser3 = typeof document !== "undefined";
  isTestEnv = typeof jest !== "undefined" || typeof vi !== "undefined";
  if (isBrowser3 && !isTestEnv) {
    globalContext = // $FlowIgnore
    typeof globalThis !== "undefined" ? globalThis : isBrowser3 ? window : global;
    globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
    if (globalContext[globalKey]) {
      console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.");
    }
    globalContext[globalKey] = true;
  }
}
var isBrowser3;
var isTestEnv;
var globalContext;
var globalKey;

// node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js
var React4 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/call-all.js
function callAll(...fns) {
  return function mergedFn(...args) {
    fns.forEach((fn) => fn == null ? void 0 : fn(...args));
  };
}

// node_modules/@chakra-ui/react/dist/esm/merge-props.js
var clsx = (...args) => args.map((str) => {
  var _a7;
  return (_a7 = str == null ? void 0 : str.trim) == null ? void 0 : _a7.call(str);
}).filter(Boolean).join(" ");
var eventRegex = /^on[A-Z]/;
function mergeProps(...args) {
  let result = {};
  for (let props52 of args) {
    for (let key in result) {
      if (eventRegex.test(key) && typeof result[key] === "function" && typeof props52[key] === "function") {
        result[key] = callAll(result[key], props52[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx(result[key], props52[key]);
        continue;
      }
      if (key === "style") {
        result[key] = Object.assign({}, result[key] ?? {}, props52[key] ?? {});
        continue;
      }
      result[key] = props52[key] !== void 0 ? props52[key] : result[key];
    }
    for (let key in props52) {
      if (result[key] === void 0) {
        result[key] = props52[key];
      }
    }
  }
  return result;
}

// node_modules/@chakra-ui/react/dist/esm/merge-refs.js
function assignRef(ref36, value) {
  if (ref36 == null) return;
  if (typeof ref36 === "function") {
    ref36(value);
    return;
  }
  try {
    ref36.current = value;
  } catch (error) {
    throw new Error(`Cannot assign value '${value}' to ref '${ref36}'`);
  }
}
function mergeRefs(...refs) {
  return (node2) => {
    refs.forEach((ref36) => {
      assignRef(ref36, node2);
    });
  };
}

// node_modules/@chakra-ui/react/dist/esm/utils/compact.js
function compact(object) {
  const clone = Object.assign({}, object);
  for (let key in clone) {
    if (clone[key] === void 0) delete clone[key];
  }
  return clone;
}

// node_modules/@chakra-ui/react/dist/esm/utils/interop.js
function interopDefault(mod3) {
  return mod3.default || mod3;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/provider.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);

// node_modules/@chakra-ui/react/dist/esm/create-context.js
var import_react5 = __toESM(require_react(), 1);
function getErrorMessage2(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext3(options = {}) {
  const {
    name,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options;
  const Context = (0, import_react5.createContext)(defaultValue);
  Context.displayName = name;
  function useContext$1() {
    var _a7;
    const context = (0, import_react5.useContext)(Context);
    if (!context && strict) {
      const error = new Error(
        errorMessage ?? getErrorMessage2(hookName, providerName)
      );
      error.name = "ContextError";
      (_a7 = Error.captureStackTrace) == null ? void 0 : _a7.call(Error, error, useContext$1);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext$1, Context];
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/provider.js
var [ChakraContextProvider, useChakraContext] = createContext3({
  name: "ChakraContext",
  strict: true,
  providerName: "<ChakraProvider />"
});
function ChakraProvider(props52) {
  const { value: sys, children } = props52;
  return (0, import_jsx_runtime3.jsxs)(ChakraContextProvider, { value: sys, children: [
    !sys._config.disableLayers && (0, import_jsx_runtime3.jsx)(Global, { styles: sys.layers.atRule }),
    (0, import_jsx_runtime3.jsx)(
      Global,
      {
        styles: [sys.getPreflightCss(), sys.getGlobalCss(), sys.getTokenCss()]
      }
    ),
    children
  ] });
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-resolved-props.js
var import_react7 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/split-props.js
var splitProps = (props52, keys) => {
  const descriptors = Object.getOwnPropertyDescriptors(props52);
  const dKeys = Object.keys(descriptors);
  const split = (k) => {
    const clone = {};
    for (let i = 0; i < k.length; i++) {
      const key = k[i];
      if (descriptors[key]) {
        Object.defineProperty(clone, key, descriptors[key]);
        delete descriptors[key];
      }
    }
    return clone;
  };
  const fn = (key) => split(Array.isArray(key) ? key : dKeys.filter(key));
  return [keys].map(fn).concat(split(dKeys));
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-resolved-props.js
function useResolvedProps(inProps, cvaRecipe, shouldForwardProps) {
  const { css: css2, isValidProperty } = useChakraContext();
  const { children, ...props52 } = inProps;
  const result = (0, import_react7.useMemo)(() => {
    const [htmlProps, restProps_A] = splitProps(props52, [
      "htmlWidth",
      "htmlHeight",
      "htmlSize",
      "htmlTranslate"
    ]);
    const [forwardedProps, restProps_B] = splitProps(
      restProps_A,
      (key) => shouldForwardProps(key, cvaRecipe.variantKeys)
    );
    const [variantProps, restProps_C] = splitProps(
      restProps_B,
      cvaRecipe.variantKeys
    );
    const [styleProps, elementProps] = splitProps(restProps_C, isValidProperty);
    return {
      htmlProps: getHtmlProps(htmlProps),
      forwardedProps,
      variantProps,
      styleProps,
      elementProps
    };
  }, [cvaRecipe.variantKeys, shouldForwardProps, props52, isValidProperty]);
  const { css: cssStyles, ...propStyles } = result.styleProps;
  const cvaStyles = (0, import_react7.useMemo)(
    () => cvaRecipe(result.variantProps),
    [cvaRecipe, result.variantProps]
  );
  const styles = (0, import_react7.useMemo)(() => {
    return css2(cvaStyles, ...toArray(cssStyles), propStyles);
  }, [css2, cvaStyles, cssStyles, propStyles]);
  return {
    styles,
    props: {
      ...result.forwardedProps,
      ...result.elementProps,
      ...result.htmlProps,
      children
    }
  };
}
var getHtmlProps = (props52) => {
  const htmlProps = {};
  for (const key in props52) {
    if (key.startsWith("html")) {
      htmlProps[key.replace("html", "").toLowerCase()] = props52[key];
    }
  }
  return htmlProps;
};
var toArray = (val) => {
  const res = Array.isArray(val) ? val : [val];
  return res.filter(Boolean).flat();
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js
var isPropValid2 = interopDefault(isPropValid);
var testOmitPropsOnStringTag = isPropValid2;
var testOmitPropsOnComponent = (key) => key !== "theme";
var composeShouldForwardProps = (tag, options, isReal) => {
  let shouldForwardProp;
  if (options) {
    const optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? (propName) => tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName) : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp !== "function" && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }
  return shouldForwardProp;
};
var isBrowser2 = typeof document !== "undefined";
var Insertion5 = ({ cache: cache2, serialized, isStringTag }) => {
  registerStyles(cache2, serialized, isStringTag);
  const rules = useInsertionEffectAlwaysWithSyncFallback(
    () => insertStyles(cache2, serialized, isStringTag)
  );
  if (!isBrowser2 && rules !== void 0) {
    let serializedNames = serialized.name;
    let next3 = serialized.next;
    while (next3 !== void 0) {
      serializedNames = cx(serializedNames, next3.name);
      next3 = next3.next;
    }
    return (0, import_jsx_runtime4.jsx)(
      "style",
      {
        ...{
          [`data-emotion`]: cx(cache2.key, serializedNames),
          dangerouslySetInnerHTML: { __html: rules },
          nonce: cache2.sheet.nonce
        }
      }
    );
  }
  return null;
};
var createStyled = (tag, configOrCva = {}, options = {}) => {
  if (true) {
    if (tag === void 0) {
      throw new Error(
        "You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it."
      );
    }
  }
  const isReal = tag.__emotion_real === tag;
  const baseTag = isReal && tag.__emotion_base || tag;
  let identifierName;
  let targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  let styles = [];
  const Styled = withEmotionCache((inProps, cache2, ref36) => {
    const { cva, isValidProperty } = useChakraContext();
    const cvaFn = configOrCva.__cva__ ? configOrCva : cva(configOrCva);
    const cvaRecipe = mergeCva(tag.__emotion_cva, cvaFn);
    const createShouldForwardProps = (props210) => {
      return (prop, variantKeys) => {
        if (props210.includes(prop)) return true;
        return !(variantKeys == null ? void 0 : variantKeys.includes(prop)) && !isValidProperty(prop);
      };
    };
    if (!options.shouldForwardProp && options.forwardProps) {
      options.shouldForwardProp = createShouldForwardProps(options.forwardProps);
    }
    const shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
    const initShouldForwardProp = (prop, variantKeys) => {
      const emotionSfp = typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
      const chakraSfp = !(variantKeys == null ? void 0 : variantKeys.includes(prop)) && !isValidProperty(prop);
      return emotionSfp(prop) && chakraSfp;
    };
    const defaultShouldForwardProp = shouldForwardProp || initShouldForwardProp;
    const propsWithDefault = React4.useMemo(
      () => Object.assign({}, options.defaultProps, compact(inProps)),
      [inProps]
    );
    const { props: props52, styles: styleProps } = useResolvedProps(
      propsWithDefault,
      cvaRecipe,
      defaultShouldForwardProp
    );
    const shouldUseAs = !defaultShouldForwardProp("as");
    let FinalTag = shouldUseAs && props52.as || baseTag;
    let className = "";
    let classInterpolations = [styleProps];
    let mergedProps = props52;
    if (props52.theme == null) {
      mergedProps = {};
      for (let key in props52) {
        mergedProps[key] = props52[key];
      }
      mergedProps.theme = React4.useContext(ThemeContext);
    }
    if (typeof props52.className === "string") {
      className = getRegisteredStyles(
        cache2.registered,
        classInterpolations,
        props52.className
      );
    } else if (props52.className != null) {
      className = cx(className, props52.className);
    }
    const serialized = serializeStyles(
      styles.concat(classInterpolations),
      cache2.registered,
      mergedProps
    );
    className = cx(className, `${cache2.key}-${serialized.name}`);
    if (targetClassName !== void 0) {
      className = cx(className, targetClassName);
    }
    const finalShouldForwardProp = shouldUseAs && shouldForwardProp === void 0 ? initShouldForwardProp : defaultShouldForwardProp;
    let newProps = {};
    for (let key in props52) {
      if (shouldUseAs && key === "as") continue;
      if (finalShouldForwardProp(key)) {
        newProps[key] = props52[key];
      }
    }
    newProps.className = className.trim();
    newProps.ref = ref36;
    if (props52.asChild && !options.forwardAsChild) {
      const child = React4.Children.only(props52.children);
      FinalTag = child.type;
      newProps.children = null;
      newProps = mergeProps(newProps, child.props);
      newProps.ref = mergeRefs(ref36, child.ref);
    }
    return (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
      (0, import_jsx_runtime4.jsx)(
        Insertion5,
        {
          cache: cache2,
          serialized,
          isStringTag: typeof FinalTag === "string"
        }
      ),
      (0, import_jsx_runtime4.jsx)(FinalTag, { ...newProps })
    ] });
  });
  Styled.displayName = identifierName !== void 0 ? identifierName : `Styled(${typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component"})`;
  Styled.__emotion_real = Styled;
  Styled.__emotion_base = baseTag;
  Styled.__emotion_forwardProp = options.shouldForwardProp;
  Styled.__emotion_cva = configOrCva;
  Object.defineProperty(Styled, "toString", {
    value() {
      if (targetClassName === void 0 && true) {
        return "NO_COMPONENT_SELECTOR";
      }
      return `.${targetClassName}`;
    }
  });
  return Styled;
};
var styledFn = createStyled.bind();
var cache = /* @__PURE__ */ new Map();
var chakraImpl = new Proxy(styledFn, {
  apply(_, __, args) {
    return styledFn(...args);
  },
  get(_, el) {
    if (!cache.has(el)) {
      cache.set(el, styledFn(el));
    }
    return cache.get(el);
  }
});
var chakra = chakraImpl;
var mergeCva = (cvaA, cvaB) => {
  if (cvaA && !cvaB) return cvaA;
  if (!cvaA && cvaB) return cvaB;
  return cvaA.merge(cvaB);
};

// node_modules/@chakra-ui/react/dist/esm/components/theme.js
var Theme = (0, import_react9.forwardRef)(
  function Theme2(props52, ref36) {
    const {
      appearance,
      style,
      className,
      hasBackground = true,
      ...rest
    } = props52;
    return (0, import_jsx_runtime5.jsx)(
      chakra.div,
      {
        color: "fg",
        bg: hasBackground ? "bg" : void 0,
        colorPalette: "gray",
        ...rest,
        className: cx("chakra-theme", appearance, className),
        style: { ...style, colorScheme: appearance },
        ref: ref36
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/hooks/use-callback-ref.js
var import_react10 = __toESM(require_react(), 1);
function useCallbackRef(callback, deps = []) {
  const callbackRef = (0, import_react10.useRef)(() => {
    throw new Error("Cannot call an event handler while rendering.");
  });
  (0, import_react10.useInsertionEffect)(() => {
    callbackRef.current = callback;
  });
  return (0, import_react10.useCallback)((...args) => {
    var _a7;
    return (_a7 = callbackRef.current) == null ? void 0 : _a7.call(callbackRef, ...args);
  }, deps);
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-controllable-state.js
var import_react11 = __toESM(require_react(), 1);
function useControllableProp(prop, state2) {
  const controlled = typeof prop !== "undefined";
  const value = controlled ? prop : state2;
  return (0, import_react11.useMemo)(() => [controlled, value], [controlled, value]);
}
function useControllableState(props52) {
  const {
    value: valueProp,
    defaultValue,
    onChange,
    shouldUpdate = (prev3, next3) => prev3 !== next3
  } = props52;
  const onChangeProp = useCallbackRef(onChange);
  const shouldUpdateProp = useCallbackRef(shouldUpdate);
  const [uncontrolledState, setUncontrolledState] = (0, import_react11.useState)(defaultValue);
  const controlled = valueProp !== void 0;
  const value = controlled ? valueProp : uncontrolledState;
  const setValue = useCallbackRef(
    (next3) => {
      const setter = next3;
      const nextValue = typeof next3 === "function" ? setter(value) : next3;
      if (!shouldUpdateProp(value, nextValue)) {
        return;
      }
      if (!controlled) {
        setUncontrolledState(nextValue);
      }
      onChangeProp(nextValue);
    },
    [controlled, onChangeProp, value, shouldUpdateProp]
  );
  return [value, setValue];
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-disclosure.js
var import_react12 = __toESM(require_react(), 1);
function useDisclosure(props52 = {}) {
  const { onClose: onCloseProp, onOpen: onOpenProp, open: openProp } = props52;
  const handleOpen = useCallbackRef(onOpenProp);
  const handleClose = useCallbackRef(onCloseProp);
  const [openState, setopen] = (0, import_react12.useState)(props52.defaultOpen || false);
  const open = openProp !== void 0 ? openProp : openState;
  const isControlled = openProp !== void 0;
  const onClose = (0, import_react12.useCallback)(() => {
    if (!isControlled) {
      setopen(false);
    }
    handleClose == null ? void 0 : handleClose();
  }, [isControlled, handleClose]);
  const onOpen = (0, import_react12.useCallback)(() => {
    if (!isControlled) {
      setopen(true);
    }
    handleOpen == null ? void 0 : handleOpen();
  }, [isControlled, handleOpen]);
  const onToggle = (0, import_react12.useCallback)(() => {
    if (open) {
      onClose();
    } else {
      onOpen();
    }
  }, [open, onOpen, onClose]);
  return {
    open,
    onOpen,
    onClose,
    onToggle
  };
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-media-query.js
var import_react13 = __toESM(require_react(), 1);
function listen(query9, callback) {
  try {
    query9.addEventListener("change", callback);
    return () => query9.removeEventListener("change", callback);
  } catch (e) {
    query9.addListener(callback);
    return () => query9.removeListener(callback);
  }
}
function useMediaQuery(query9, options) {
  const { fallback: _fallback, ssr = true, getWindow: getWindow12 } = options;
  const getWin = useCallbackRef(getWindow12);
  const queries = Array.isArray(query9) ? query9 : [query9];
  const fallback5 = _fallback == null ? void 0 : _fallback.filter((v) => v != null);
  const [value, setValue] = (0, import_react13.useState)(() => {
    return queries.map((query22, index) => {
      var _a7, _b6, _c5;
      return {
        media: query22,
        matches: !ssr ? (_c5 = (_b6 = (_a7 = getWin() ?? window).matchMedia) == null ? void 0 : _b6.call(_a7, query22)) == null ? void 0 : _c5.matches : !!fallback5[index]
      };
    });
  });
  (0, import_react13.useEffect)(() => {
    const win = getWin() ?? window;
    setValue((prev3) => {
      const current = queries.map((query22) => ({
        media: query22,
        matches: win.matchMedia(query22).matches
      }));
      return prev3.every(
        (v, i) => v.matches === current[i].matches && v.media === current[i].media
      ) ? prev3 : current;
    });
    const mql = queries.map((query22) => win.matchMedia(query22));
    const handler = (evt) => {
      setValue((prev3) => {
        return prev3.slice().map((item) => {
          if (item.media === evt.media) return { ...item, matches: evt.matches };
          return item;
        });
      });
    };
    const cleanups2 = mql.map((v) => listen(v, handler));
    return () => cleanups2.forEach((fn) => fn());
  }, [getWin]);
  return value.map((item) => item.matches);
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-breakpoint.js
function useBreakpoint(options = {}) {
  var _a7;
  options.fallback || (options.fallback = "base");
  const sys = useChakraContext();
  let fallbackPassed = false;
  const allBreakpoints = sys.breakpoints.values;
  const breakpoints2 = allBreakpoints.map(({ min: min4, name: breakpoint }) => {
    const item = {
      breakpoint,
      query: `(min-width: ${min4})`,
      fallback: !fallbackPassed
    };
    if (breakpoint === options.fallback) {
      fallbackPassed = true;
    }
    return item;
  }).filter(({ breakpoint }) => {
    var _a8;
    return !!((_a8 = options.breakpoints) == null ? void 0 : _a8.includes(breakpoint));
  });
  const fallback5 = breakpoints2.map(({ fallback: fallback22 }) => fallback22);
  const values = useMediaQuery(
    breakpoints2.map((bp) => bp.query),
    { fallback: fallback5, ssr: options.ssr }
  );
  const index = values.lastIndexOf(true);
  return ((_a7 = breakpoints2[index]) == null ? void 0 : _a7.breakpoint) ?? options.fallback;
}
function useBreakpointValue(value, opts) {
  const sys = useChakraContext();
  const normalized = sys.normalizeValue(value);
  const breakpoint = useBreakpoint({
    breakpoints: Object.keys(normalized),
    ...opts
  });
  return normalized[breakpoint];
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/color-mix.js
var colorMix = (value, token2) => {
  var _a7;
  if (!value || typeof value !== "string") {
    return { invalid: true, value };
  }
  const [rawColor, rawOpacity] = value.split("/");
  if (!rawColor || !rawOpacity || rawColor === "currentBg") {
    return { invalid: true, value: rawColor };
  }
  const colorToken = token2(`colors.${rawColor}`);
  const opacityToken = (_a7 = token2.raw(`opacity.${rawOpacity}`)) == null ? void 0 : _a7.value;
  if (!opacityToken && isNaN(Number(rawOpacity))) {
    return { invalid: true, value: rawColor };
  }
  const percent = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
  const color = colorToken ?? rawColor;
  return {
    invalid: false,
    color,
    value: `color-mix(in srgb, ${color} ${percent}, transparent)`
  };
};
var createColorMixTransform = (prop) => (value, args) => {
  const mix = args.utils.colorMix(value);
  if (mix.invalid) return { [prop]: value };
  const cssVar2 = "--mix-" + prop;
  return {
    [cssVar2]: mix.value,
    [prop]: `var(${cssVar2}, ${mix.color})`
  };
};

// node_modules/@chakra-ui/react/dist/esm/utils/is.js
function isObject2(value) {
  const type = typeof value;
  return value != null && (type === "object" || type === "function") && !Array.isArray(value);
}
function isCssVar(value) {
  return /^var\(--.+\)$/.test(value);
}
function isString(value) {
  return Object.prototype.toString.call(value) === "[object String]";
}
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/@chakra-ui/react/dist/esm/utils/merge.js
function merge2(target, source) {
  if (source == null) return target;
  for (const key of Object.keys(source)) {
    if (source[key] === void 0 || key === "__proto__") continue;
    if (!isObject2(target[key]) && isObject2(source[key])) {
      Object.assign(target, { [key]: source[key] });
    } else if (target[key] && isObject2(source[key])) {
      merge2(target[key], source[key]);
    } else if (Array.isArray(source[key]) && Array.isArray(target[key])) {
      let i = 0;
      for (; i < source[key].length; i++) {
        if (isObject2(target[key][i]) && isObject2(source[key][i])) {
          merge2(target[key][i], source[key][i]);
        } else {
          target[key][i] = source[key][i];
        }
      }
    } else {
      Object.assign(target, { [key]: source[key] });
    }
  }
  return target;
}
function mergeWith(target, ...sources) {
  for (const source of sources) {
    merge2(target, source);
  }
  return target;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/config.js
var defineConditions = (v) => v;
var defineRecipe = (v) => v;
var defineSlotRecipe = (v) => v;
var defineKeyframes = (v) => v;
var defineGlobalStyles = (v) => v;
var defineStyle = (v) => v;
var defineTextStyles = (v) => v;
var defineAnimationStyles = (v) => v;
var defineLayerStyles = (v) => v;
function createProxy() {
  const identity = (v) => v;
  return new Proxy(identity, {
    get() {
      return identity;
    }
  });
}
var defineTokens = createProxy();
var defineSemanticTokens = createProxy();
var defineConfig = (v) => v;
var mergeConfigs = (...configs) => {
  return mergeWith({}, ...configs);
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/css-var.js
var escRegex = /[^a-zA-Z0-9_\u0081-\uffff-]/g;
function esc(string) {
  return `${string}`.replace(escRegex, (s) => `\\${s}`);
}
var dashCaseRegex = /[A-Z]/g;
function dashCase(string) {
  return string.replace(dashCaseRegex, (match50) => `-${match50.toLowerCase()}`);
}
function cssVar(name, options = {}) {
  const { fallback: fallback5 = "", prefix: prefix3 = "" } = options;
  const variable = dashCase(["-", prefix3, esc(name)].filter(Boolean).join("-"));
  return {
    var: variable,
    ref: `var(${variable}${fallback5 ? `, ${fallback5}` : ""})`
  };
}

// node_modules/@chakra-ui/react/dist/esm/preset-base.js
var isCssVar2 = (v) => /^var\(--.+\)$/.test(v);
var wrap2 = (str, v) => v != null ? `${str}(${v})` : v;
var deg = (v) => {
  if (isCssVar2(v) || v == null) return v;
  const unitless = typeof v === "string" && !v.endsWith("deg");
  return typeof v === "number" || unitless ? `${v}deg` : v;
};
var createFocusRing = (selector) => {
  return {
    values: ["outside", "inside", "mixed", "none"],
    transform(value, { token: token2 }) {
      const focusRingColor = token2("colors.colorPalette.focusRing");
      const styles = {
        inside: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineOffset: "0px",
            outlineWidth: "var(--focus-ring-width, 1px)",
            outlineColor: "var(--focus-ring-color)",
            outlineStyle: "var(--focus-ring-style, solid)",
            borderColor: "var(--focus-ring-color)"
          }
        },
        outside: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineWidth: "var(--focus-ring-width, 2px)",
            outlineOffset: "2px",
            outlineStyle: "var(--focus-ring-style, solid)",
            outlineColor: "var(--focus-ring-color)"
          }
        },
        mixed: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineWidth: "var(--focus-ring-width, 3px)",
            outlineStyle: "var(--focus-ring-style, solid)",
            outlineColor: "color-mix(in srgb, var(--focus-ring-color), transparent 60%)",
            borderColor: "var(--focus-ring-color)"
          }
        },
        none: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outline: "none"
          }
        }
      };
      return styles[value] ?? {};
    }
  };
};
var divideColor = createColorMixTransform("borderColor");
var createTransition = (value) => {
  return {
    transition: value,
    transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
    transitionDuration: "150ms"
  };
};
var defaultConditions = defineConditions({
  hover: [
    "@media (hover: hover)",
    "&:is(:hover, [data-hover]):not(:disabled, [data-disabled])"
  ],
  active: "&:is(:active, [data-active]):not(:disabled, [data-disabled], [data-state=open])",
  focus: "&:is(:focus, [data-focus])",
  focusWithin: "&:is(:focus-within, [data-focus-within])",
  focusVisible: "&:is(:focus-visible, [data-focus-visible])",
  disabled: "&:is(:disabled, [disabled], [data-disabled], [aria-disabled=true])",
  visited: "&:visited",
  target: "&:target",
  readOnly: "&:is([data-readonly], [aria-readonly=true], [readonly])",
  readWrite: "&:read-write",
  empty: "&:is(:empty, [data-empty])",
  checked: "&:is(:checked, [data-checked], [aria-checked=true], [data-state=checked])",
  enabled: "&:enabled",
  expanded: "&:is([aria-expanded=true], [data-expanded], [data-state=expanded])",
  highlighted: "&[data-highlighted]",
  complete: "&[data-complete]",
  incomplete: "&[data-incomplete]",
  dragging: "&[data-dragging]",
  before: "&::before",
  after: "&::after",
  firstLetter: "&::first-letter",
  firstLine: "&::first-line",
  marker: "&::marker",
  selection: "&::selection",
  file: "&::file-selector-button",
  backdrop: "&::backdrop",
  first: "&:first-of-type",
  last: "&:last-of-type",
  notFirst: "&:not(:first-of-type)",
  notLast: "&:not(:last-of-type)",
  only: "&:only-child",
  even: "&:nth-of-type(even)",
  odd: "&:nth-of-type(odd)",
  peerFocus: ".peer:is(:focus, [data-focus]) ~ &",
  peerHover: ".peer:is(:hover, [data-hover]):not(:disabled, [data-disabled]) ~ &",
  peerActive: ".peer:is(:active, [data-active]):not(:disabled, [data-disabled]) ~ &",
  peerFocusWithin: ".peer:focus-within ~ &",
  peerFocusVisible: ".peer:is(:focus-visible, [data-focus-visible]) ~ &",
  peerDisabled: ".peer:is(:disabled, [disabled], [data-disabled]) ~ &",
  peerChecked: ".peer:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) ~ &",
  peerInvalid: ".peer:is(:invalid, [data-invalid], [aria-invalid=true]) ~ &",
  peerExpanded: ".peer:is([aria-expanded=true], [data-expanded], [data-state=expanded]) ~ &",
  peerPlaceholderShown: ".peer:placeholder-shown ~ &",
  groupFocus: ".group:is(:focus, [data-focus]) &",
  groupHover: ".group:is(:hover, [data-hover]):not(:disabled, [data-disabled]) &",
  groupActive: ".group:is(:active, [data-active]):not(:disabled, [data-disabled]) &",
  groupFocusWithin: ".group:focus-within &",
  groupFocusVisible: ".group:is(:focus-visible, [data-focus-visible]) &",
  groupDisabled: ".group:is(:disabled, [disabled], [data-disabled]) &",
  groupChecked: ".group:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) &",
  groupExpanded: ".group:is([aria-expanded=true], [data-expanded], [data-state=expanded]) &",
  groupInvalid: ".group:invalid &",
  indeterminate: "&:is(:indeterminate, [data-indeterminate], [aria-checked=mixed], [data-state=indeterminate])",
  required: "&:is([data-required], [aria-required=true])",
  valid: "&:is([data-valid], [data-state=valid])",
  invalid: "&:is([data-invalid], [aria-invalid=true], [data-state=invalid])",
  autofill: "&:autofill",
  inRange: "&:is(:in-range, [data-in-range])",
  outOfRange: "&:is(:out-of-range, [data-outside-range])",
  placeholder: "&::placeholder, &[data-placeholder]",
  placeholderShown: "&:is(:placeholder-shown, [data-placeholder-shown])",
  pressed: "&:is([aria-pressed=true], [data-pressed])",
  selected: "&:is([aria-selected=true], [data-selected])",
  grabbed: "&:is([aria-grabbed=true], [data-grabbed])",
  underValue: "&[data-state=under-value]",
  overValue: "&[data-state=over-value]",
  atValue: "&[data-state=at-value]",
  default: "&:default",
  optional: "&:optional",
  open: "&:is([open], [data-open], [data-state=open])",
  closed: "&:is([closed], [data-closed], [data-state=closed])",
  fullscreen: "&is(:fullscreen, [data-fullscreen])",
  loading: "&:is([data-loading], [aria-busy=true])",
  hidden: "&:is([hidden], [data-hidden])",
  current: "&[data-current]",
  currentPage: "&[aria-current=page]",
  currentStep: "&[aria-current=step]",
  today: "&[data-today]",
  unavailable: "&[data-unavailable]",
  rangeStart: "&[data-range-start]",
  rangeEnd: "&[data-range-end]",
  now: "&[data-now]",
  topmost: "&[data-topmost]",
  motionReduce: "@media (prefers-reduced-motion: reduce)",
  motionSafe: "@media (prefers-reduced-motion: no-preference)",
  print: "@media print",
  landscape: "@media (orientation: landscape)",
  portrait: "@media (orientation: portrait)",
  dark: ".dark &, .dark .chakra-theme:not(.light) &",
  light: ":root &, .light &",
  osDark: "@media (prefers-color-scheme: dark)",
  osLight: "@media (prefers-color-scheme: light)",
  highContrast: "@media (forced-colors: active)",
  lessContrast: "@media (prefers-contrast: less)",
  moreContrast: "@media (prefers-contrast: more)",
  ltr: "[dir=ltr] &",
  rtl: "[dir=rtl] &",
  scrollbar: "&::-webkit-scrollbar",
  scrollbarThumb: "&::-webkit-scrollbar-thumb",
  scrollbarTrack: "&::-webkit-scrollbar-track",
  horizontal: "&[data-orientation=horizontal]",
  vertical: "&[data-orientation=vertical]",
  icon: "& :where(svg)",
  starting: "@starting-style"
});
var currentBgVar = cssVar("bg-currentcolor");
var isCurrentBgVar = (value) => value === currentBgVar.ref || value === "currentBg";
var colorValues = (theme) => ({
  ...theme("colors"),
  currentBg: currentBgVar
});
var defaultBaseConfig = defineConfig({
  conditions: defaultConditions,
  utilities: {
    // background
    background: {
      values: colorValues,
      shorthand: ["bg"],
      transform(value, args) {
        if (isCurrentBgVar(args.raw)) return { background: currentBgVar.ref };
        const styleObj = createColorMixTransform("background")(value, args);
        return { ...styleObj, [currentBgVar.var]: styleObj == null ? void 0 : styleObj.background };
      }
    },
    backgroundColor: {
      values: colorValues,
      shorthand: ["bgColor"],
      transform(value, args) {
        if (isCurrentBgVar(args.raw))
          return { backgroundColor: currentBgVar.ref };
        const styleObj = createColorMixTransform("backgroundColor")(value, args);
        return {
          ...styleObj,
          [currentBgVar.var]: styleObj == null ? void 0 : styleObj.backgroundColor
        };
      }
    },
    backgroundSize: { shorthand: ["bgSize"] },
    backgroundPosition: { shorthand: ["bgPos"] },
    backgroundRepeat: { shorthand: ["bgRepeat"] },
    backgroundAttachment: { shorthand: ["bgAttachment"] },
    backgroundClip: {
      shorthand: ["bgClip"],
      values: ["text"],
      transform(value) {
        return value === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: value };
      }
    },
    backgroundGradient: {
      shorthand: ["bgGradient"],
      values(theme) {
        return {
          ...theme("gradients"),
          "to-t": "linear-gradient(to top, var(--gradient))",
          "to-tr": "linear-gradient(to top right, var(--gradient))",
          "to-r": "linear-gradient(to right, var(--gradient))",
          "to-br": "linear-gradient(to bottom right, var(--gradient))",
          "to-b": "linear-gradient(to bottom, var(--gradient))",
          "to-bl": "linear-gradient(to bottom left, var(--gradient))",
          "to-l": "linear-gradient(to left, var(--gradient))",
          "to-tl": "linear-gradient(to top left, var(--gradient))"
        };
      },
      transform(value) {
        return {
          "--gradient-stops": "var(--gradient-from), var(--gradient-to)",
          "--gradient": "var(--gradient-via-stops, var(--gradient-stops))",
          backgroundImage: value
        };
      }
    },
    gradientFrom: {
      values: colorValues,
      transform: createColorMixTransform("--gradient-from")
    },
    gradientTo: {
      values: colorValues,
      transform: createColorMixTransform("--gradient-to")
    },
    gradientVia: {
      values: colorValues,
      transform(value, args) {
        const styles = createColorMixTransform("--gradient-via")(value, args);
        return {
          ...styles,
          "--gradient-via-stops": "var(--gradient-from), var(--gradient-via), var(--gradient-to)"
        };
      }
    },
    backgroundImage: { values: "gradients", shorthand: ["bgImg", "bgImage"] },
    // border
    border: { values: "borders" },
    borderTop: { values: "borders" },
    borderLeft: { values: "borders" },
    borderBlockStart: { values: "borders" },
    borderRight: { values: "borders" },
    borderInlineEnd: { values: "borders" },
    borderBottom: { values: "borders" },
    borderBlockEnd: { values: "borders" },
    borderInlineStart: { values: "borders", shorthand: ["borderStart"] },
    borderInline: { values: "borders", shorthand: ["borderX"] },
    borderBlock: { values: "borders", shorthand: ["borderY"] },
    // border colors
    borderColor: {
      values: colorValues,
      transform: createColorMixTransform("borderColor")
    },
    borderTopColor: {
      values: colorValues,
      transform: createColorMixTransform("borderTopColor")
    },
    borderBlockStartColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBlockStartColor")
    },
    borderBottomColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBottomColor")
    },
    borderBlockEndColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBlockEndColor")
    },
    borderLeftColor: {
      values: colorValues,
      transform: createColorMixTransform("borderLeftColor")
    },
    borderInlineStartColor: {
      values: colorValues,
      shorthand: ["borderStartColor"],
      transform: createColorMixTransform("borderInlineStartColor")
    },
    borderRightColor: {
      values: colorValues,
      transform: createColorMixTransform("borderRightColor")
    },
    borderInlineEndColor: {
      values: colorValues,
      shorthand: ["borderEndColor"],
      transform: createColorMixTransform("borderInlineEndColor")
    },
    // border styles
    borderStyle: { values: "borderStyles" },
    borderTopStyle: { values: "borderStyles" },
    borderBlockStartStyle: { values: "borderStyles" },
    borderBottomStyle: { values: "borderStyles" },
    borderBlockEndStyle: {
      values: "borderStyles"
    },
    borderInlineStartStyle: {
      values: "borderStyles",
      shorthand: ["borderStartStyle"]
    },
    borderInlineEndStyle: {
      values: "borderStyles",
      shorthand: ["borderEndStyle"]
    },
    borderLeftStyle: { values: "borderStyles" },
    borderRightStyle: { values: "borderStyles" },
    // border radius
    borderRadius: { values: "radii", shorthand: ["rounded"] },
    borderTopLeftRadius: { values: "radii", shorthand: ["roundedTopLeft"] },
    borderStartStartRadius: {
      values: "radii",
      shorthand: ["roundedStartStart", "borderTopStartRadius"]
    },
    borderEndStartRadius: {
      values: "radii",
      shorthand: ["roundedEndStart", "borderBottomStartRadius"]
    },
    borderTopRightRadius: {
      values: "radii",
      shorthand: ["roundedTopRight"]
    },
    borderStartEndRadius: {
      values: "radii",
      shorthand: ["roundedStartEnd", "borderTopEndRadius"]
    },
    borderEndEndRadius: {
      values: "radii",
      shorthand: ["roundedEndEnd", "borderBottomEndRadius"]
    },
    borderBottomLeftRadius: {
      values: "radii",
      shorthand: ["roundedBottomLeft"]
    },
    borderBottomRightRadius: {
      values: "radii",
      shorthand: ["roundedBottomRight"]
    },
    borderInlineStartRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedStart", "borderStartRadius"],
      transform: (value) => ({
        borderStartStartRadius: value,
        borderEndStartRadius: value
      })
    },
    borderInlineEndRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedEnd", "borderEndRadius"],
      transform: (value) => ({
        borderStartEndRadius: value,
        borderEndEndRadius: value
      })
    },
    borderTopRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedTop"],
      transform: (value) => ({
        borderTopLeftRadius: value,
        borderTopRightRadius: value
      })
    },
    borderBottomRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedBottom"],
      transform: (value) => ({
        borderBottomLeftRadius: value,
        borderBottomRightRadius: value
      })
    },
    borderLeftRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedLeft"],
      transform: (value) => ({
        borderTopLeftRadius: value,
        borderBottomLeftRadius: value
      })
    },
    borderRightRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedRight"],
      transform: (value) => ({
        borderTopRightRadius: value,
        borderBottomRightRadius: value
      })
    },
    borderWidth: { values: "borderWidths" },
    borderBlockStartWidth: { values: "borderWidths" },
    borderTopWidth: { values: "borderWidths" },
    borderBottomWidth: { values: "borderWidths" },
    borderBlockEndWidth: { values: "borderWidths" },
    borderRightWidth: { values: "borderWidths" },
    borderInlineWidth: {
      values: "borderWidths",
      shorthand: ["borderXWidth"]
    },
    borderInlineStartWidth: {
      values: "borderWidths",
      shorthand: ["borderStartWidth"]
    },
    borderInlineEndWidth: {
      values: "borderWidths",
      shorthand: ["borderEndWidth"]
    },
    borderLeftWidth: { values: "borderWidths" },
    borderBlockWidth: {
      values: "borderWidths",
      shorthand: ["borderYWidth"]
    },
    // colors
    color: {
      values: colorValues,
      transform: createColorMixTransform("color")
    },
    fill: {
      values: colorValues,
      transform: createColorMixTransform("fill")
    },
    stroke: {
      values: colorValues,
      transform: createColorMixTransform("stroke")
    },
    accentColor: {
      values: colorValues,
      transform: createColorMixTransform("accentColor")
    },
    // divide
    divideX: {
      values: { type: "string" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderInlineStartWidth: value,
            borderInlineEndWidth: "0px"
          }
        };
      }
    },
    divideY: {
      values: { type: "string" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderTopWidth: value,
            borderBottomWidth: "0px"
          }
        };
      }
    },
    divideColor: {
      values: colorValues,
      transform(value, args) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": divideColor(
            value,
            args
          )
        };
      }
    },
    divideStyle: {
      property: "borderStyle",
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderStyle: value
          }
        };
      }
    },
    // effects
    boxShadow: { values: "shadows", shorthand: ["shadow"] },
    boxShadowColor: {
      values: colorValues,
      transform: createColorMixTransform("--shadow-color"),
      shorthand: ["shadowColor"]
    },
    mixBlendMode: { shorthand: ["blendMode"] },
    backgroundBlendMode: { shorthand: ["bgBlendMode"] },
    opacity: { values: "opacity" },
    // filters
    filter: {
      transform(v) {
        if (v !== "auto") {
          return { filter: v };
        }
        return {
          filter: `var(--blur) var(--brightness) var(--contrast) var(--grayscale) var(--hue-rotate) var(--invert) var(--saturate) var(--sepia) var(--drop-shadow)`
        };
      }
    },
    blur: {
      values: "blurs",
      transform: (v) => ({ "--blur": wrap2("blur", v) })
    },
    brightness: {
      transform: (v) => ({ "--brightness": wrap2("brightness", v) })
    },
    contrast: {
      transform: (v) => ({ "--contrast": wrap2("contrast", v) })
    },
    grayscale: {
      transform: (v) => ({ "--grayscale": wrap2("grayscale", v) })
    },
    hueRotate: {
      transform: (v) => ({ "--hue-rotate": wrap2("hue-rotate", deg(v)) })
    },
    invert: { transform: (v) => ({ "--invert": wrap2("invert", v) }) },
    saturate: {
      transform: (v) => ({ "--saturate": wrap2("saturate", v) })
    },
    sepia: { transform: (v) => ({ "--sepia": wrap2("sepia", v) }) },
    dropShadow: {
      transform: (v) => ({ "--drop-shadow": wrap2("drop-shadow", v) })
    },
    // backdrop filters
    backdropFilter: {
      transform(v) {
        if (v !== "auto") {
          return { backdropFilter: v };
        }
        return {
          backdropFilter: `var(--backdrop-blur) var(--backdrop-brightness) var(--backdrop-contrast) var(--backdrop-grayscale) var(--backdrop-hue-rotate) var(--backdrop-invert) var(--backdrop-opacity) var(--backdrop-saturate) var(--backdrop-sepia)`
        };
      }
    },
    backdropBlur: {
      values: "blurs",
      transform: (v) => ({ "--backdrop-blur": wrap2("blur", v) })
    },
    backdropBrightness: {
      transform: (v) => ({
        "--backdrop-brightness": wrap2("brightness", v)
      })
    },
    backdropContrast: {
      transform: (v) => ({ "--backdrop-contrast": wrap2("contrast", v) })
    },
    backdropGrayscale: {
      transform: (v) => ({
        "--backdrop-grayscale": wrap2("grayscale", v)
      })
    },
    backdropHueRotate: {
      transform: (v) => ({
        "--backdrop-hue-rotate": wrap2("hue-rotate", deg(v))
      })
    },
    backdropInvert: {
      transform: (v) => ({ "--backdrop-invert": wrap2("invert", v) })
    },
    backdropOpacity: {
      transform: (v) => ({ "--backdrop-opacity": wrap2("opacity", v) })
    },
    backdropSaturate: {
      transform: (v) => ({ "--backdrop-saturate": wrap2("saturate", v) })
    },
    backdropSepia: {
      transform: (v) => ({ "--backdrop-sepia": wrap2("sepia", v) })
    },
    // flexbox
    flexBasis: { values: "sizes" },
    gap: { values: "spacing" },
    rowGap: { values: "spacing", shorthand: ["gapY"] },
    columnGap: { values: "spacing", shorthand: ["gapX"] },
    flexDirection: { shorthand: ["flexDir"] },
    // grid
    gridGap: { values: "spacing" },
    gridColumnGap: { values: "spacing" },
    gridRowGap: { values: "spacing" },
    // interactivity
    outlineColor: {
      values: colorValues,
      transform: createColorMixTransform("outlineColor")
    },
    focusRing: createFocusRing("&:is(:focus, [data-focus])"),
    focusVisibleRing: createFocusRing(
      "&:is(:focus-visible, [data-focus-visible])"
    ),
    focusRingColor: {
      values: colorValues,
      transform: createColorMixTransform("--focus-ring-color")
    },
    focusRingWidth: {
      values: "borderWidths",
      property: "outlineWidth",
      transform: (v) => ({ "--focus-ring-width": v })
    },
    focusRingStyle: {
      values: "borderStyles",
      property: "outlineStyle",
      transform: (v) => ({ "--focus-ring-style": v })
    },
    // layout
    aspectRatio: { values: "aspectRatios" },
    width: { values: "sizes", shorthand: ["w"] },
    inlineSize: { values: "sizes" },
    height: { values: "sizes", shorthand: ["h"] },
    blockSize: { values: "sizes" },
    boxSize: {
      values: "sizes",
      property: "width",
      transform: (v) => ({ width: v, height: v })
    },
    minWidth: { values: "sizes", shorthand: ["minW"] },
    minInlineSize: { values: "sizes" },
    minHeight: { values: "sizes", shorthand: ["minH"] },
    minBlockSize: { values: "sizes" },
    maxWidth: { values: "sizes", shorthand: ["maxW"] },
    maxInlineSize: { values: "sizes" },
    maxHeight: { values: "sizes", shorthand: ["maxH"] },
    maxBlockSize: { values: "sizes" },
    hideFrom: {
      values: "breakpoints",
      //@ts-ignore
      transform: (value, { raw, token: token2 }) => {
        const bp = token2.raw(`breakpoints.${raw}`);
        const media = bp ? `@breakpoint ${raw}` : `@media screen and (min-width: ${value})`;
        return {
          [media]: { display: "none" }
        };
      }
    },
    hideBelow: {
      values: "breakpoints",
      //@ts-ignore
      transform(value, { raw, token: token2 }) {
        const bp = token2.raw(`breakpoints.${raw}`);
        const media = bp ? `@breakpoint ${raw}Down` : `@media screen and (max-width: ${value})`;
        return {
          [media]: {
            display: "none"
          }
        };
      }
    },
    // scroll
    overscrollBehavior: { shorthand: ["overscroll"] },
    overscrollBehaviorX: { shorthand: ["overscrollX"] },
    overscrollBehaviorY: { shorthand: ["overscrollY"] },
    scrollbar: {
      values: ["visible", "hidden"],
      transform(v) {
        switch (v) {
          case "visible":
            return {
              msOverflowStyle: "auto",
              scrollbarWidth: "auto",
              "&::-webkit-scrollbar": { display: "block" }
            };
          case "hidden":
            return {
              msOverflowStyle: "none",
              scrollbarWidth: "none",
              "&::-webkit-scrollbar": { display: "none" }
            };
          default:
            return {};
        }
      }
    },
    scrollbarColor: {
      values: colorValues,
      transform: createColorMixTransform("scrollbarColor")
    },
    scrollbarGutter: { values: "spacing" },
    scrollbarWidth: { values: "sizes" },
    // scroll margin
    scrollMargin: { values: "spacing" },
    scrollMarginTop: { values: "spacing" },
    scrollMarginBottom: { values: "spacing" },
    scrollMarginLeft: { values: "spacing" },
    scrollMarginRight: { values: "spacing" },
    scrollMarginX: {
      values: "spacing",
      transform: (v) => ({ scrollMarginLeft: v, scrollMarginRight: v })
    },
    scrollMarginY: {
      values: "spacing",
      transform: (v) => ({ scrollMarginTop: v, scrollMarginBottom: v })
    },
    // scroll padding
    scrollPadding: { values: "spacing" },
    scrollPaddingTop: { values: "spacing" },
    scrollPaddingBottom: { values: "spacing" },
    scrollPaddingLeft: { values: "spacing" },
    scrollPaddingRight: { values: "spacing" },
    scrollPaddingInline: { values: "spacing", shorthand: ["scrollPaddingX"] },
    scrollPaddingBlock: { values: "spacing", shorthand: ["scrollPaddingY"] },
    // scroll snap
    scrollSnapType: {
      values: {
        none: "none",
        x: "x var(--scroll-snap-strictness)",
        y: "y var(--scroll-snap-strictness)",
        both: "both var(--scroll-snap-strictness)"
      }
    },
    scrollSnapStrictness: {
      values: ["mandatory", "proximity"],
      transform: (v) => ({ "--scroll-snap-strictness": v })
    },
    scrollSnapMargin: { values: "spacing" },
    scrollSnapMarginTop: { values: "spacing" },
    scrollSnapMarginBottom: { values: "spacing" },
    scrollSnapMarginLeft: { values: "spacing" },
    scrollSnapMarginRight: { values: "spacing" },
    // list
    listStylePosition: { shorthand: ["listStylePos"] },
    listStyleImage: { shorthand: ["listStyleImg"] },
    // position
    position: { shorthand: ["pos"] },
    zIndex: { values: "zIndex" },
    inset: { values: "spacing" },
    insetInline: { values: "spacing", shorthand: ["insetX"] },
    insetBlock: { values: "spacing", shorthand: ["insetY"] },
    top: { values: "spacing" },
    insetBlockStart: { values: "spacing" },
    bottom: { values: "spacing" },
    insetBlockEnd: { values: "spacing" },
    left: { values: "spacing" },
    right: { values: "spacing" },
    insetInlineStart: {
      values: "spacing",
      shorthand: ["insetStart"]
    },
    insetInlineEnd: {
      values: "spacing",
      shorthand: ["insetEnd"]
    },
    // shadow / ring
    ring: {
      transform(value) {
        return {
          "--ring-offset-shadow": `var(--ring-inset) 0 0 0 var(--ring-offset-width) var(--ring-offset-color)`,
          "--ring-shadow": `var(--ring-inset) 0 0 0 calc(var(--ring-width) + var(--ring-offset-width)) var(--ring-color)`,
          "--ring-width": value,
          boxShadow: "var(--ring-offset-shadow), var(--ring-shadow), var(--shadow, 0 0 #0000)"
        };
      }
    },
    ringColor: {
      values: colorValues,
      transform: createColorMixTransform("--ring-color")
    },
    ringOffset: {
      transform: (value) => ({ "--ring-offset-width": value })
    },
    ringOffsetColor: {
      values: colorValues,
      transform: createColorMixTransform("--ring-offset-color")
    },
    ringInset: {
      transform: (v) => ({ "--ring-inset": v })
    },
    // margin
    margin: { values: "spacing", shorthand: ["m"] },
    marginTop: { values: "spacing", shorthand: ["mt"] },
    marginBlockStart: { values: "spacing", shorthand: ["mt"] },
    marginRight: { values: "spacing", shorthand: ["mr"] },
    marginBottom: { values: "spacing", shorthand: ["mb"] },
    marginBlockEnd: { values: "spacing" },
    marginLeft: { values: "spacing", shorthand: ["ml"] },
    marginInlineStart: { values: "spacing", shorthand: ["ms", "marginStart"] },
    marginInlineEnd: { values: "spacing", shorthand: ["me", "marginEnd"] },
    marginInline: { values: "spacing", shorthand: ["mx", "marginX"] },
    marginBlock: { values: "spacing", shorthand: ["my", "marginY"] },
    // padding
    padding: { values: "spacing", shorthand: ["p"] },
    paddingTop: { values: "spacing", shorthand: ["pt"] },
    paddingRight: { values: "spacing", shorthand: ["pr"] },
    paddingBottom: { values: "spacing", shorthand: ["pb"] },
    paddingBlockStart: { values: "spacing" },
    paddingBlockEnd: { values: "spacing" },
    paddingLeft: { values: "spacing", shorthand: ["pl"] },
    paddingInlineStart: {
      values: "spacing",
      shorthand: ["ps", "paddingStart"]
    },
    paddingInlineEnd: { values: "spacing", shorthand: ["pe", "paddingEnd"] },
    paddingInline: { values: "spacing", shorthand: ["px", "paddingX"] },
    paddingBlock: { values: "spacing", shorthand: ["py", "paddingY"] },
    // text decoration
    textDecoration: { shorthand: ["textDecor"] },
    textDecorationColor: {
      values: colorValues,
      transform: createColorMixTransform("textDecorationColor")
    },
    textShadow: { values: "shadows" },
    // transform
    transform: {
      transform: (value) => {
        let v = value;
        if (value === "auto") {
          v = `translateX(var(--translate-x, 0)) translateY(var(--translate-y, 0)) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
        }
        if (value === "auto-gpu") {
          v = `translate3d(var(--translate-x, 0), var(--translate-y, 0), 0) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
        }
        return { transform: v };
      }
    },
    skewX: { transform: (v) => ({ "--skew-x": deg(v) }) },
    skewY: { transform: (v) => ({ "--skew-y": deg(v) }) },
    scaleX: { transform: (v) => ({ "--scale-x": v }) },
    scaleY: { transform: (v) => ({ "--scale-y": v }) },
    scale: {
      transform(value) {
        if (value !== "auto") return { scale: value };
        return {
          scale: `var(--scale-x, 1) var(--scale-y, 1)`
        };
      }
    },
    spaceXReverse: {
      values: { type: "boolean" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-x-reverse": value ? "1" : void 0
          }
        };
      }
    },
    spaceX: {
      property: "marginInlineStart",
      values: "spacing",
      transform: (v) => ({
        "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
          "--space-x-reverse": "0",
          marginInlineStart: `calc(${v} * calc(1 - var(--space-x-reverse)))`,
          marginInlineEnd: `calc(${v} * var(--space-x-reverse))`
        }
      })
    },
    spaceYReverse: {
      values: { type: "boolean" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-y-reverse": value ? "1" : void 0
          }
        };
      }
    },
    spaceY: {
      property: "marginTop",
      values: "spacing",
      transform: (v) => ({
        "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
          "--space-y-reverse": "0",
          marginTop: `calc(${v} * calc(1 - var(--space-y-reverse)))`,
          marginBottom: `calc(${v} * var(--space-y-reverse))`
        }
      })
    },
    rotate: {
      transform(value) {
        if (value !== "auto") return { rotate: deg(value) };
        return {
          rotate: `var(--rotate-x, 0) var(--rotate-y, 0) var(--rotate-z, 0)`
        };
      }
    },
    rotateX: {
      transform(value) {
        return { "--rotate-x": deg(value) };
      }
    },
    rotateY: {
      transform(value) {
        return { "--rotate-y": deg(value) };
      }
    },
    // transform / translate
    translate: {
      transform(value) {
        if (value !== "auto") return { translate: value };
        return {
          translate: `var(--translate-x) var(--translate-y)`
        };
      }
    },
    translateX: {
      values: "spacing",
      transform: (v) => ({ "--translate-x": v })
    },
    translateY: {
      values: "spacing",
      transform: (v) => ({ "--translate-y": v })
    },
    // transition
    transition: {
      values: [
        "all",
        "common",
        "colors",
        "opacity",
        "position",
        "backgrounds",
        "size",
        "shadow",
        "transform"
      ],
      transform(value) {
        switch (value) {
          case "all":
            return createTransition("all");
          case "position":
            return createTransition(
              "left, right, top, bottom, inset-inline, inset-block"
            );
          case "colors":
            return createTransition(
              "color, background-color, border-color, text-decoration-color, fill, stroke"
            );
          case "opacity":
            return createTransition("opacity");
          case "shadow":
            return createTransition("box-shadow");
          case "transform":
            return createTransition("transform");
          case "size":
            return createTransition("width, height");
          case "backgrounds":
            return createTransition(
              "background, background-color, background-image, background-position"
            );
          case "common":
            return createTransition(
              "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter"
            );
          default:
            return { transition: value };
        }
      }
    },
    transitionDuration: { values: "durations" },
    transitionProperty: {
      values: {
        common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, translate, transform",
        colors: "background-color, border-color, color, fill, stroke",
        size: "width, height",
        position: "left, right, top, bottom, inset-inline, inset-block",
        background: "background, background-color, background-image, background-position"
      }
    },
    transitionTimingFunction: { values: "easings" },
    // animation
    animation: { values: "animations" },
    animationDuration: { values: "durations" },
    animationDelay: { values: "durations" },
    animationTimingFunction: { values: "easings" },
    // typography
    fontFamily: { values: "fonts" },
    fontSize: { values: "fontSizes" },
    fontWeight: { values: "fontWeights" },
    lineHeight: { values: "lineHeights" },
    letterSpacing: { values: "letterSpacings" },
    textIndent: { values: "spacing" },
    truncate: {
      values: { type: "boolean" },
      transform(value) {
        if (value === true) {
          return {
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          };
        }
        return {};
      }
    },
    lineClamp: {
      transform(value) {
        if (value === "none") {
          return {
            WebkitLineClamp: "unset"
          };
        }
        return {
          overflow: "hidden",
          display: "-webkit-box",
          WebkitLineClamp: value,
          WebkitBoxOrient: "vertical",
          textWrap: "wrap"
        };
      }
    },
    // helpers
    srOnly: {
      values: { type: "boolean" },
      transform(value) {
        return srMapping[value] || {};
      }
    },
    debug: {
      values: { type: "boolean" },
      transform(value) {
        if (!value) return {};
        return {
          outline: "1px solid blue !important",
          "& > *": {
            outline: "1px solid red !important"
          }
        };
      }
    },
    caretColor: {
      values: colorValues,
      transform: createColorMixTransform("caretColor")
    },
    cursor: { values: "cursor" }
  }
});
var srMapping = {
  true: {
    position: "absolute",
    width: "1px",
    height: "1px",
    padding: "0",
    margin: "-1px",
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    borderWidth: "0"
  },
  false: {
    position: "static",
    width: "auto",
    height: "auto",
    padding: "0",
    margin: "0",
    overflow: "visible",
    clip: "auto",
    whiteSpace: "normal"
  }
};

// node_modules/@pandacss/is-valid-prop/dist/index.mjs
var userGeneratedStr = "";
var userGenerated = userGeneratedStr.split(",");
var cssPropertiesStr = "WebkitAppearance,WebkitBorderBefore,WebkitBorderBeforeColor,WebkitBorderBeforeStyle,WebkitBorderBeforeWidth,WebkitBoxReflect,WebkitLineClamp,WebkitMask,WebkitMaskAttachment,WebkitMaskClip,WebkitMaskComposite,WebkitMaskImage,WebkitMaskOrigin,WebkitMaskPosition,WebkitMaskPositionX,WebkitMaskPositionY,WebkitMaskRepeat,WebkitMaskRepeatX,WebkitMaskRepeatY,WebkitMaskSize,WebkitOverflowScrolling,WebkitTapHighlightColor,WebkitTextFillColor,WebkitTextStroke,WebkitTextStrokeColor,WebkitTextStrokeWidth,WebkitTouchCallout,WebkitUserModify,accentColor,alignContent,alignItems,alignSelf,alignTracks,all,animation,animationComposition,animationDelay,animationDirection,animationDuration,animationFillMode,animationIterationCount,animationName,animationPlayState,animationRange,animationRangeEnd,animationRangeStart,animationTimingFunction,animationTimeline,appearance,aspectRatio,azimuth,backdropFilter,backfaceVisibility,background,backgroundAttachment,backgroundBlendMode,backgroundClip,backgroundColor,backgroundImage,backgroundOrigin,backgroundPosition,backgroundPositionX,backgroundPositionY,backgroundRepeat,backgroundSize,blockSize,border,borderBlock,borderBlockColor,borderBlockStyle,borderBlockWidth,borderBlockEnd,borderBlockEndColor,borderBlockEndStyle,borderBlockEndWidth,borderBlockStart,borderBlockStartColor,borderBlockStartStyle,borderBlockStartWidth,borderBottom,borderBottomColor,borderBottomLeftRadius,borderBottomRightRadius,borderBottomStyle,borderBottomWidth,borderCollapse,borderColor,borderEndEndRadius,borderEndStartRadius,borderImage,borderImageOutset,borderImageRepeat,borderImageSlice,borderImageSource,borderImageWidth,borderInline,borderInlineEnd,borderInlineColor,borderInlineStyle,borderInlineWidth,borderInlineEndColor,borderInlineEndStyle,borderInlineEndWidth,borderInlineStart,borderInlineStartColor,borderInlineStartStyle,borderInlineStartWidth,borderLeft,borderLeftColor,borderLeftStyle,borderLeftWidth,borderRadius,borderRight,borderRightColor,borderRightStyle,borderRightWidth,borderSpacing,borderStartEndRadius,borderStartStartRadius,borderStyle,borderTop,borderTopColor,borderTopLeftRadius,borderTopRightRadius,borderTopStyle,borderTopWidth,borderWidth,bottom,boxAlign,boxDecorationBreak,boxDirection,boxFlex,boxFlexGroup,boxLines,boxOrdinalGroup,boxOrient,boxPack,boxShadow,boxSizing,breakAfter,breakBefore,breakInside,captionSide,caret,caretColor,caretShape,clear,clip,clipPath,color,colorScheme,columnCount,columnFill,columnGap,columnRule,columnRuleColor,columnRuleStyle,columnRuleWidth,columnSpan,columnWidth,columns,contain,containIntrinsicSize,containIntrinsicBlockSize,containIntrinsicHeight,containIntrinsicInlineSize,containIntrinsicWidth,container,containerName,containerType,content,contentVisibility,counterIncrement,counterReset,counterSet,cursor,direction,display,emptyCells,filter,flex,flexBasis,flexDirection,flexFlow,flexGrow,flexShrink,flexWrap,float,font,fontFamily,fontFeatureSettings,fontKerning,fontLanguageOverride,fontOpticalSizing,fontPalette,fontVariationSettings,fontSize,fontSizeAdjust,fontSmooth,fontStretch,fontStyle,fontSynthesis,fontSynthesisPosition,fontSynthesisSmallCaps,fontSynthesisStyle,fontSynthesisWeight,fontVariant,fontVariantAlternates,fontVariantCaps,fontVariantEastAsian,fontVariantEmoji,fontVariantLigatures,fontVariantNumeric,fontVariantPosition,fontWeight,forcedColorAdjust,gap,grid,gridArea,gridAutoColumns,gridAutoFlow,gridAutoRows,gridColumn,gridColumnEnd,gridColumnGap,gridColumnStart,gridGap,gridRow,gridRowEnd,gridRowGap,gridRowStart,gridTemplate,gridTemplateAreas,gridTemplateColumns,gridTemplateRows,hangingPunctuation,height,hyphenateCharacter,hyphenateLimitChars,hyphens,imageOrientation,imageRendering,imageResolution,imeMode,initialLetter,initialLetterAlign,inlineSize,inputSecurity,inset,insetBlock,insetBlockEnd,insetBlockStart,insetInline,insetInlineEnd,insetInlineStart,isolation,justifyContent,justifyItems,justifySelf,justifyTracks,left,letterSpacing,lineBreak,lineClamp,lineHeight,lineHeightStep,listStyle,listStyleImage,listStylePosition,listStyleType,margin,marginBlock,marginBlockEnd,marginBlockStart,marginBottom,marginInline,marginInlineEnd,marginInlineStart,marginLeft,marginRight,marginTop,marginTrim,mask,maskBorder,maskBorderMode,maskBorderOutset,maskBorderRepeat,maskBorderSlice,maskBorderSource,maskBorderWidth,maskClip,maskComposite,maskImage,maskMode,maskOrigin,maskPosition,maskRepeat,maskSize,maskType,masonryAutoFlow,mathDepth,mathShift,mathStyle,maxBlockSize,maxHeight,maxInlineSize,maxLines,maxWidth,minBlockSize,minHeight,minInlineSize,minWidth,mixBlendMode,objectFit,objectPosition,offset,offsetAnchor,offsetDistance,offsetPath,offsetPosition,offsetRotate,opacity,order,orphans,outline,outlineColor,outlineOffset,outlineStyle,outlineWidth,overflow,overflowAnchor,overflowBlock,overflowClipBox,overflowClipMargin,overflowInline,overflowWrap,overflowX,overflowY,overlay,overscrollBehavior,overscrollBehaviorBlock,overscrollBehaviorInline,overscrollBehaviorX,overscrollBehaviorY,padding,paddingBlock,paddingBlockEnd,paddingBlockStart,paddingBottom,paddingInline,paddingInlineEnd,paddingInlineStart,paddingLeft,paddingRight,paddingTop,page,pageBreakAfter,pageBreakBefore,pageBreakInside,paintOrder,perspective,perspectiveOrigin,placeContent,placeItems,placeSelf,pointerEvents,position,printColorAdjust,quotes,resize,right,rotate,rowGap,rubyAlign,rubyMerge,rubyPosition,scale,scrollbarColor,scrollbarGutter,scrollbarWidth,scrollBehavior,scrollMargin,scrollMarginBlock,scrollMarginBlockStart,scrollMarginBlockEnd,scrollMarginBottom,scrollMarginInline,scrollMarginInlineStart,scrollMarginInlineEnd,scrollMarginLeft,scrollMarginRight,scrollMarginTop,scrollPadding,scrollPaddingBlock,scrollPaddingBlockStart,scrollPaddingBlockEnd,scrollPaddingBottom,scrollPaddingInline,scrollPaddingInlineStart,scrollPaddingInlineEnd,scrollPaddingLeft,scrollPaddingRight,scrollPaddingTop,scrollSnapAlign,scrollSnapCoordinate,scrollSnapDestination,scrollSnapPointsX,scrollSnapPointsY,scrollSnapStop,scrollSnapType,scrollSnapTypeX,scrollSnapTypeY,scrollTimeline,scrollTimelineAxis,scrollTimelineName,shapeImageThreshold,shapeMargin,shapeOutside,tabSize,tableLayout,textAlign,textAlignLast,textCombineUpright,textDecoration,textDecorationColor,textDecorationLine,textDecorationSkip,textDecorationSkipInk,textDecorationStyle,textDecorationThickness,textEmphasis,textEmphasisColor,textEmphasisPosition,textEmphasisStyle,textIndent,textJustify,textOrientation,textOverflow,textRendering,textShadow,textSizeAdjust,textTransform,textUnderlineOffset,textUnderlinePosition,textWrap,timelineScope,top,touchAction,transform,transformBox,transformOrigin,transformStyle,transition,transitionBehavior,transitionDelay,transitionDuration,transitionProperty,transitionTimingFunction,translate,unicodeBidi,userSelect,verticalAlign,viewTimeline,viewTimelineAxis,viewTimelineInset,viewTimelineName,viewTransitionName,visibility,whiteSpace,whiteSpaceCollapse,widows,width,willChange,wordBreak,wordSpacing,wordWrap,writingMode,zIndex,zoom,alignmentBaseline,baselineShift,clipRule,colorInterpolation,colorRendering,dominantBaseline,fill,fillOpacity,fillRule,floodColor,floodOpacity,glyphOrientationVertical,lightingColor,marker,markerEnd,markerMid,markerStart,shapeRendering,stopColor,stopOpacity,stroke,strokeDasharray,strokeDashoffset,strokeLinecap,strokeLinejoin,strokeMiterlimit,strokeOpacity,strokeWidth,textAnchor,vectorEffect";
var allCssProperties = cssPropertiesStr.split(",").concat(userGenerated);
var properties = new Map(allCssProperties.map((prop) => [prop, true]));
function memo(fn) {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (arg) => {
    if (cache2[arg] === void 0)
      cache2[arg] = fn(arg);
    return cache2[arg];
  };
}
var cssPropertySelectorRegex = /&|@/;
var isCssProperty = memo((prop) => {
  return properties.has(prop) || prop.startsWith("--") || cssPropertySelectorRegex.test(prop);
});

// node_modules/@chakra-ui/react/dist/esm/utils/walk-object.js
var isNotNullish = (element) => element != null;
function walkObject(target, predicate, options = {}) {
  const { stop, getKey } = options;
  function inner(value, path = []) {
    if (isObject2(value) || Array.isArray(value)) {
      const result = {};
      for (const [prop, child] of Object.entries(value)) {
        const key = (getKey == null ? void 0 : getKey(prop, child)) ?? prop;
        const childPath = [...path, key];
        if (stop == null ? void 0 : stop(value, childPath)) {
          return predicate(value, path);
        }
        const next3 = inner(child, childPath);
        if (isNotNullish(next3)) {
          result[key] = next3;
        }
      }
      return result;
    }
    return predicate(value, path);
  }
  return inner(target);
}
function mapObject(obj, fn) {
  if (Array.isArray(obj)) return obj.map((value) => fn(value));
  if (!isObject2(obj)) {
    if (obj !== null && obj !== void 0) return fn(obj);
    else return obj;
  }
  return walkObject(obj, (value) => fn(value));
}

// node_modules/@chakra-ui/react/dist/esm/utils/flatten.js
function flatten(values, stop) {
  const result = {};
  walkObject(
    values,
    (token2, paths) => {
      if (token2) {
        result[paths.join(".")] = token2.value;
      }
    },
    { stop }
  );
  return result;
}

// node_modules/@chakra-ui/react/dist/esm/utils/memo.js
var memo2 = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  function get(...args) {
    const key = JSON.stringify(args);
    if (cache2[key] === void 0) cache2[key] = fn(...args);
    return cache2[key];
  }
  return get;
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/unit-conversion.js
var BASE_FONT_SIZE = 16;
var UNIT_PX = "px";
var UNIT_EM = "em";
var UNIT_REM = "rem";
function getUnit(value = "") {
  const DIGIT_REGEX = new RegExp(String.raw`-?\d+(?:\.\d+|\d*)`);
  const UNIT_REGEX = new RegExp(`${UNIT_PX}|${UNIT_EM}|${UNIT_REM}`);
  const unit = value.match(
    new RegExp(`${DIGIT_REGEX.source}(${UNIT_REGEX.source})`)
  );
  return unit == null ? void 0 : unit[1];
}
function toPx(value = "") {
  if (typeof value === "number") {
    return `${value}px`;
  }
  const unit = getUnit(value);
  if (!unit) return value;
  if (unit === UNIT_PX) {
    return value;
  }
  if (unit === UNIT_EM || unit === UNIT_REM) {
    return `${parseFloat(value) * BASE_FONT_SIZE}${UNIT_PX}`;
  }
}
function toRem(value = "") {
  const unit = getUnit(value);
  if (!unit) return value;
  if (unit === UNIT_REM) {
    return value;
  }
  if (unit === UNIT_EM) {
    return `${parseFloat(value)}${UNIT_REM}`;
  }
  if (unit === UNIT_PX) {
    return `${parseFloat(value) / BASE_FONT_SIZE}${UNIT_REM}`;
  }
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/breakpoints.js
var capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function createBreakpoints(breakpoints2) {
  const sorted = sort(breakpoints2);
  const values = Object.fromEntries(sorted);
  function get(name) {
    return values[name];
  }
  function only(name) {
    return build(get(name));
  }
  function getRanges() {
    const breakpoints22 = Object.keys(values);
    const permuations = getPermutations(breakpoints22);
    const results = breakpoints22.flatMap((name) => {
      const value = get(name);
      const down2 = [
        `${name}Down`,
        build({ max: adjust(value.min) })
      ];
      const up2 = [name, build({ min: value.min })];
      const _only = [`${name}Only`, only(name)];
      return [up2, _only, down2];
    }).filter(([, value]) => value !== "").concat(
      permuations.map(([min4, max4]) => {
        const minValue = get(min4);
        const maxValue2 = get(max4);
        return [
          `${min4}To${capitalize(max4)}`,
          build({ min: minValue.min, max: adjust(maxValue2.min) })
        ];
      })
    );
    return Object.fromEntries(results);
  }
  function toConditions() {
    const ranges = getRanges();
    return Object.fromEntries(Object.entries(ranges));
  }
  const conditions = toConditions();
  const getCondition = (key) => {
    return conditions[key];
  };
  function keys() {
    return ["base", ...Object.keys(values)];
  }
  function up(name) {
    return build({ min: get(name).min });
  }
  function down(name) {
    return build({ max: adjust(get(name).min) });
  }
  return {
    values: Object.values(values),
    only,
    keys,
    conditions,
    getCondition,
    up,
    down
  };
}
function adjust(value) {
  const computedMax = parseFloat(toPx(value) ?? "") - 0.04;
  return toRem(`${computedMax}px`);
}
function sort(breakpoints2) {
  const entries = Object.entries(breakpoints2).sort(([, minA], [, minB]) => {
    return parseInt(minA, 10) < parseInt(minB, 10) ? -1 : 1;
  });
  return entries.map(([name, min4], index, entries2) => {
    var _a7;
    let max4 = null;
    if (index <= entries2.length - 1) {
      max4 = (_a7 = entries2[index + 1]) == null ? void 0 : _a7[1];
    }
    if (max4 != null) {
      max4 = adjust(max4);
    }
    return [name, { name, min: toRem(min4), max: max4 }];
  });
}
function getPermutations(values) {
  const result = [];
  values.forEach((current, index) => {
    let idx = index;
    idx++;
    let next3 = values[idx];
    while (next3) {
      result.push([current, next3]);
      idx++;
      next3 = values[idx];
    }
  });
  return result;
}
function build({ min: min4, max: max4 }) {
  if (min4 == null && max4 == null) return "";
  return [
    "@media screen",
    min4 && `(min-width: ${min4})`,
    max4 && `(max-width: ${max4})`
  ].filter(Boolean).join(" and ");
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/conditions.js
var mapEntries = (obj, fn) => {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => fn(key, value))
  );
};
var createConditions = (options) => {
  const { breakpoints: breakpoints2, conditions: conds = {} } = options;
  const conditions = mapEntries(conds, (key, value) => [`_${key}`, value]);
  const values = Object.assign({}, conditions, breakpoints2.conditions);
  function keys() {
    return Object.keys(values);
  }
  function has2(key) {
    return keys().includes(key) || /^@|&|&$/.test(key) || key.startsWith("_");
  }
  function sort2(paths) {
    return paths.filter((v) => v !== "base").sort((a, b) => {
      const aa = has2(a);
      const bb = has2(b);
      if (aa && !bb) return 1;
      if (!aa && bb) return -1;
      return 0;
    });
  }
  function expandAtRule(key) {
    if (!key.startsWith("@breakpoint")) return key;
    return breakpoints2.getCondition(key.replace("@breakpoint ", ""));
  }
  function resolve(key) {
    return Reflect.get(values, key) || key;
  }
  return {
    keys,
    sort: sort2,
    has: has2,
    resolve,
    breakpoints: breakpoints2.keys(),
    expandAtRule
  };
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/sort-at-params.js
var createMediaQueryRegex = (dimension) => ({
  minMax: new RegExp(
    `(!?\\(\\s*min(-device-)?-${dimension})(.|
)+\\(\\s*max(-device)?-${dimension}`,
    "i"
  ),
  min: new RegExp(`\\(\\s*min(-device)?-${dimension}`, "i"),
  maxMin: new RegExp(
    `(!?\\(\\s*max(-device)?-${dimension})(.|
)+\\(\\s*min(-device)?-${dimension}`,
    "i"
  ),
  max: new RegExp(`\\(\\s*max(-device)?-${dimension}`, "i")
});
var widthRegex = createMediaQueryRegex("width");
var heightRegex = createMediaQueryRegex("height");
var createQueryTester = (regexSet) => ({
  isMin: _testQuery(regexSet.minMax, regexSet.maxMin, regexSet.min),
  isMax: _testQuery(regexSet.maxMin, regexSet.minMax, regexSet.max)
});
var { isMin: isMinWidth, isMax: isMaxWidth } = createQueryTester(widthRegex);
var { isMin: isMinHeight, isMax: isMaxHeight } = createQueryTester(heightRegex);
var isPrint = /print/i;
var isPrintOnly = /^print$/i;
var isLength = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/;
var lengthExec = /(\d)/;
var maxValue = Number.MAX_VALUE;
var multipliers = { ch: 8.8984375, em: 16, rem: 16, ex: 8.296875, px: 1 };
function getQueryLength(query9) {
  const length2 = isLength.exec(query9) || (isMinWidth(query9) || isMinHeight(query9) ? lengthExec.exec(query9) : null);
  if (!length2) return maxValue;
  if (length2[0] === "0") return 0;
  const number = parseFloat(length2[1]);
  const unit = length2[2];
  return number * (multipliers[unit] || 1);
}
function _testQuery(doubleTestTrue, doubleTestFalse, singleTest) {
  return (query9) => doubleTestTrue.test(query9) || !doubleTestFalse.test(query9) && singleTest.test(query9);
}
function _testIsPrint(a, b) {
  const isPrintA = isPrint.test(a), isPrintOnlyA = isPrintOnly.test(a);
  const isPrintB = isPrint.test(b), isPrintOnlyB = isPrintOnly.test(b);
  if (isPrintA && isPrintB) {
    if (!isPrintOnlyA && isPrintOnlyB) return 1;
    if (isPrintOnlyA && !isPrintOnlyB) return -1;
    return a.localeCompare(b);
  }
  return isPrintA ? 1 : isPrintB ? -1 : null;
}
var sortAtParams = memo2((a, b) => {
  const testIsPrint = _testIsPrint(a, b);
  if (testIsPrint !== null) return testIsPrint;
  const minA = isMinWidth(a) || isMinHeight(a), maxA = isMaxWidth(a) || isMaxHeight(a);
  const minB = isMinWidth(b) || isMinHeight(b), maxB = isMaxWidth(b) || isMaxHeight(b);
  if (minA && maxB) return -1;
  if (maxA && minB) return 1;
  const lengthA = getQueryLength(a), lengthB = getQueryLength(b);
  if (lengthA === maxValue && lengthB === maxValue) return a.localeCompare(b);
  if (lengthA === maxValue) return 1;
  if (lengthB === maxValue) return -1;
  if (lengthA !== lengthB) {
    return lengthA > lengthB ? maxA ? -1 : 1 : maxA ? 1 : -1;
  }
  return a.localeCompare(b);
});

// node_modules/@chakra-ui/react/dist/esm/styled-system/sort-at-rules.js
function sortQueries(queries) {
  return queries.sort(([a], [b]) => sortAtParams(a, b));
}
function sortAtRules(obj) {
  const mediaQueries = [];
  const containerQueries = [];
  const rest = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key.startsWith("@media")) {
      mediaQueries.push([key, value]);
    } else if (key.startsWith("@container")) {
      containerQueries.push([key, value]);
    } else if (isObject2(value)) {
      rest[key] = sortAtRules(value);
    } else {
      rest[key] = value;
    }
  }
  const sortedMediaQueries = sortQueries(mediaQueries);
  const sortedContainerQueries = sortQueries(containerQueries);
  return {
    ...rest,
    ...Object.fromEntries(sortedMediaQueries),
    ...Object.fromEntries(sortedContainerQueries)
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/css.js
var importantRegex = /\s*!(important)?/i;
var isImportant = (v) => isString(v) ? importantRegex.test(v) : false;
var withoutImportant = (v) => isString(v) ? v.replace(importantRegex, "").trim() : v;
function createCssFn(context) {
  const { transform: transform2, conditions, normalize: normalize2 } = context;
  const mergeFn = mergeCss(context);
  return memo2((...styleArgs) => {
    const styles = mergeFn(...styleArgs);
    const normalized = normalize2(styles);
    const result = /* @__PURE__ */ Object.create(null);
    walkObject(normalized, (value, paths) => {
      const important = isImportant(value);
      if (value == null) return;
      const [prop, ...selectors] = conditions.sort(paths).map(conditions.resolve);
      if (important) {
        value = withoutImportant(value);
      }
      let transformed = transform2(prop, value) ?? /* @__PURE__ */ Object.create(null);
      transformed = walkObject(
        transformed,
        (v) => isString(v) && important ? `${v} !important` : v,
        { getKey: (prop2) => conditions.expandAtRule(prop2) }
      );
      mergeByPath(result, selectors.flat(), transformed);
    });
    return sortAtRules(result);
  });
}
function mergeByPath(target, paths, value) {
  let acc = target;
  for (const path of paths) {
    if (!path) continue;
    if (!acc[path]) acc[path] = /* @__PURE__ */ Object.create(null);
    acc = acc[path];
  }
  mergeWith(acc, value);
}
function compactFn(...styles) {
  return styles.filter(
    (style) => isObject2(style) && Object.keys(compact(style)).length > 0
  );
}
function mergeCss(ctx) {
  function resolve(styles) {
    const comp = compactFn(...styles);
    if (comp.length === 1) return comp;
    return comp.map((style) => ctx.normalize(style));
  }
  return memo2((...styles) => {
    return mergeWith({}, ...resolve(styles));
  });
}

// node_modules/@chakra-ui/react/dist/esm/utils/omit.js
function omit(object, keysToOmit = []) {
  const clone = Object.assign({}, object);
  for (const key of keysToOmit) {
    if (key in clone) {
      delete clone[key];
    }
  }
  return clone;
}

// node_modules/@chakra-ui/react/dist/esm/utils/uniq.js
var uniq = (...items) => {
  const _items = items.filter(Boolean);
  return Array.from(new Set(_items));
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/cva.js
var defaults = (conf) => ({
  base: {},
  variants: {},
  defaultVariants: {},
  compoundVariants: [],
  ...conf
});
function createRecipeFn(options) {
  const { css: css2, conditions, normalize: normalize2, layers } = options;
  function cva(config = {}) {
    const { base, variants: variants3, defaultVariants: defaultVariants3, compoundVariants } = defaults(config);
    const getVariantCss = createCssFn({
      conditions,
      normalize: normalize2,
      transform(prop, value) {
        var _a7;
        return (_a7 = variants3[prop]) == null ? void 0 : _a7[value];
      }
    });
    const resolve = (props52 = {}) => {
      const variantSelections = normalize2({
        ...defaultVariants3,
        ...compact(props52)
      });
      let variantCss = { ...base };
      mergeWith(variantCss, getVariantCss(variantSelections));
      const compoundVariantCss = getCompoundVariantCss(
        compoundVariants,
        variantSelections
      );
      return layers.wrap("recipes", css2(variantCss, compoundVariantCss));
    };
    const variantKeys = Object.keys(variants3);
    const splitVariantProps = (props52) => {
      const restProps = omit(props52, ["recipe"]);
      const [recipeProps, localProps] = splitProps(restProps, variantKeys);
      if (!variantKeys.includes("colorPalette")) {
        recipeProps.colorPalette = props52.colorPalette || defaultVariants3.colorPalette;
      }
      if (variantKeys.includes("orientation")) {
        localProps.orientation = props52.orientation;
      }
      return [recipeProps, localProps];
    };
    const variantMap = Object.fromEntries(
      Object.entries(variants3).map(([key, value]) => [
        key,
        Object.keys(value)
      ])
    );
    const cvaFn = (props52) => css2(resolve(props52));
    return Object.assign(cvaFn, {
      className: config.className,
      __cva__: true,
      variantMap,
      variantKeys,
      raw: resolve,
      config,
      splitVariantProps,
      merge(other) {
        return cva(mergeCva2(options)(this, other));
      }
    });
  }
  function getCompoundVariantCss(cvs, vm) {
    let result = {};
    cvs.forEach((cv) => {
      const isMatching = Object.entries(cv).every(([key, value]) => {
        if (key === "css") return true;
        const values = Array.isArray(value) ? value : [value];
        return values.some((value2) => vm[key] === value2);
      });
      if (isMatching) {
        result = css2(result, cv.css);
      }
    });
    return result;
  }
  return cva;
}
function mergeCva2(opts) {
  const { css: css2 } = opts;
  return function mergeCva22(cvaA, cvaB) {
    const override = defaults(cvaB.config);
    const variantKeys = uniq(cvaA.variantKeys, Object.keys(cvaB.variants));
    const base = css2(cvaA.base, override.base);
    const variants3 = Object.fromEntries(
      variantKeys.map((key) => [
        key,
        css2(cvaA.config.variants[key], override.variants[key])
      ])
    );
    const defaultVariants3 = mergeWith(
      cvaA.config.defaultVariants,
      override.defaultVariants
    );
    const compoundVariants = [
      ...cvaA.compoundVariants,
      ...override.compoundVariants
    ];
    const className = cx(cvaA.className, cvaB.className);
    return {
      className,
      base,
      variants: variants3,
      defaultVariants: defaultVariants3,
      compoundVariants
    };
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/layers.js
var defaultLayers = {
  reset: "reset",
  base: "base",
  tokens: "tokens",
  recipes: "recipes"
};
var layerOrder = {
  reset: 0,
  base: 1,
  tokens: 2,
  recipes: 3
};
function createLayers(config) {
  const layers = config.layers ?? defaultLayers;
  const values = Object.values(layers);
  const names = values.sort((a, b) => layerOrder[a] - layerOrder[b]);
  return {
    names,
    atRule: `@layer ${names.join(", ")};`,
    wrap(layer, styles) {
      if (config.disableLayers) return styles;
      const params = layers[layer];
      return { [`@layer ${params}`]: styles };
    }
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/normalize.js
function createNormalizeFn(context) {
  const { utility, normalize: normalize2 } = context;
  const { hasShorthand, resolveShorthand } = utility;
  return function(styles) {
    return walkObject(styles, normalize2, {
      stop: (value) => Array.isArray(value),
      getKey: hasShorthand ? resolveShorthand : void 0
    });
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/preflight.js
function createPreflight(options) {
  const { preflight } = options;
  if (!preflight) return {};
  const { scope = "", level = "parent" } = isObject2(preflight) ? preflight : {};
  let selector = "";
  if (scope && level === "parent") {
    selector = `${scope} `;
  } else if (scope && level === "element") {
    selector = `&${scope}`;
  }
  const scoped = {
    "*": {
      margin: "0px",
      padding: "0px",
      font: "inherit",
      wordWrap: "break-word",
      WebkitTapHighlightColor: "transparent"
    },
    "*, *::before, *::after, *::backdrop": {
      boxSizing: "border-box",
      borderWidth: "0px",
      borderStyle: "solid",
      borderColor: "var(--global-color-border, currentColor)"
    },
    hr: {
      height: "0px",
      color: "inherit",
      borderTopWidth: "1px"
    },
    body: {
      minHeight: "100dvh",
      position: "relative"
    },
    img: {
      borderStyle: "none"
    },
    "img, svg, video, canvas, audio, iframe, embed, object": {
      display: "block",
      verticalAlign: "middle"
    },
    iframe: { border: "none" },
    "img, video": { maxWidth: "100%", height: "auto" },
    "p, h1, h2, h3, h4, h5, h6": { overflowWrap: "break-word" },
    "ol, ul": { listStyle: "none" },
    "code, kbd, pre, samp": { fontSize: "1em" },
    "button, [type='button'], [type='reset'], [type='submit']": {
      WebkitAppearance: "button",
      backgroundColor: "transparent",
      backgroundImage: "none"
    },
    "button, input, optgroup, select, textarea": { color: "inherit" },
    "button, select": { textTransform: "none" },
    table: {
      textIndent: "0px",
      borderColor: "inherit",
      borderCollapse: "collapse"
    },
    "*::placeholder": {
      opacity: "unset",
      color: "#9ca3af",
      userSelect: "none"
    },
    textarea: {
      resize: "vertical"
    },
    summary: {
      display: "list-item"
    },
    small: {
      fontSize: "80%"
    },
    "sub, sup": {
      fontSize: "75%",
      lineHeight: 0,
      position: "relative",
      verticalAlign: "baseline"
    },
    sub: {
      bottom: "-0.25em"
    },
    sup: {
      top: "-0.5em"
    },
    dialog: {
      padding: "0px"
    },
    a: {
      color: "inherit",
      textDecoration: "inherit"
    },
    "abbr:where([title])": {
      textDecoration: "underline dotted"
    },
    "b, strong": {
      fontWeight: "bolder"
    },
    "code, kbd, samp, pre": {
      fontSize: "1em",
      "--font-mono-fallback": "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New'",
      fontFamily: "var(--global-font-mono, var(--font-mono-fallback))"
    },
    'input[type="text"], input[type="email"], input[type="search"], input[type="password"]': {
      WebkitAppearance: "none",
      MozAppearance: "none"
    },
    "input[type='search']": {
      WebkitAppearance: "textfield",
      outlineOffset: "-2px"
    },
    "::-webkit-search-decoration, ::-webkit-search-cancel-button": {
      WebkitAppearance: "none"
    },
    "::-webkit-file-upload-button": {
      WebkitAppearance: "button",
      font: "inherit"
    },
    'input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button': {
      height: "auto"
    },
    "input[type='number']": {
      MozAppearance: "textfield"
    },
    ":-moz-ui-invalid": {
      boxShadow: "none"
    },
    ":-moz-focusring": {
      outline: "auto"
    },
    "[hidden]:where(:not([hidden='until-found']))": {
      display: "none !important"
    }
  };
  const preflightCss = {
    [scope || "html"]: {
      lineHeight: 1.5,
      "--font-fallback": "ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'",
      WebkitTextSizeAdjust: "100%",
      WebkitFontSmoothing: "antialiased",
      MozOsxFontSmoothing: "grayscale",
      textRendering: "optimizeLegibility",
      touchAction: "manipulation",
      MozTabSize: "4",
      tabSize: "4",
      fontFamily: "var(--global-font-body, var(--font-fallback))"
    }
  };
  if (level === "element") {
    const modified = Object.entries(scoped).reduce((acc, [k, v]) => {
      acc[k] = { [selector]: v };
      return acc;
    }, {});
    Object.assign(preflightCss, modified);
  } else if (selector) {
    preflightCss[selector] = scoped;
  } else {
    Object.assign(preflightCss, scoped);
  }
  return preflightCss;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/serialize.js
function createSerializeFn(options) {
  const { conditions, isValidProperty } = options;
  return function serialize3(styles) {
    return walkObject(styles, (value) => value, {
      getKey: (prop, value) => {
        if (!isObject2(value)) return prop;
        if (!conditions.has(prop) && !isValidProperty(prop)) {
          return parseSelectors(prop).map((s) => "&" + s).join(", ");
        }
        return prop;
      }
    });
  };
}
function parseSelectors(selector) {
  const result = [];
  let parenCount = 0;
  let currentSelector = "";
  let inEscape = false;
  for (let i = 0; i < selector.length; i++) {
    const char2 = selector[i];
    if (char2 === "\\" && !inEscape) {
      inEscape = true;
      currentSelector += char2;
      continue;
    }
    if (inEscape) {
      inEscape = false;
      currentSelector += char2;
      continue;
    }
    if (char2 === "(") {
      parenCount++;
    } else if (char2 === ")") {
      parenCount--;
    }
    if (char2 === "," && parenCount === 0) {
      result.push(currentSelector.trim());
      currentSelector = "";
    } else {
      currentSelector += char2;
    }
  }
  if (currentSelector) {
    result.push(currentSelector.trim());
  }
  return result;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/sva.js
var getSlotRecipes = (config = {}) => {
  const init = (slot) => {
    var _a7;
    return {
      base: ((_a7 = config.base) == null ? void 0 : _a7[slot]) ?? {},
      variants: {},
      defaultVariants: config.defaultVariants ?? {},
      compoundVariants: config.compoundVariants ? getSlotCompoundVariant(config.compoundVariants, slot) : []
    };
  };
  const slots = config.slots ?? [];
  const entries = slots.map((slot) => [slot, init(slot)]);
  for (const [variantsKey, variantsSpec] of Object.entries(
    config.variants ?? {}
  )) {
    for (const [variantKey, variantSpec] of Object.entries(
      variantsSpec
    )) {
      entries.forEach(([slot, slotRecipe]) => {
        var _a7;
        (_a7 = slotRecipe.variants)[variantsKey] ?? (_a7[variantsKey] = {});
        slotRecipe.variants[variantsKey][variantKey] = variantSpec[slot] ?? {};
      });
    }
  }
  return Object.fromEntries(entries);
};
var getSlotCompoundVariant = (compoundVariants, slotName) => compoundVariants.filter((compoundVariant) => compoundVariant.css[slotName]).map((compoundVariant) => ({
  ...compoundVariant,
  css: compoundVariant.css[slotName]
}));
function createSlotRecipeFn(options) {
  const { cva } = options;
  return function sva(config = {}) {
    const slots = Object.entries(getSlotRecipes(config)).map(
      ([slot, slotCva]) => [slot, cva(slotCva)]
    );
    function svaFn(props52) {
      const result = slots.map(([slot, cvaFn]) => [slot, cvaFn(props52)]);
      return Object.fromEntries(result);
    }
    const variants3 = config.variants ?? {};
    const variantKeys = Object.keys(variants3);
    function splitVariantProps(props52) {
      var _a7;
      const restProps = omit(props52, ["recipe"]);
      const [recipeProps, localProps] = splitProps(restProps, variantKeys);
      if (!variantKeys.includes("colorPalette")) {
        recipeProps.colorPalette = props52.colorPalette || ((_a7 = config.defaultVariants) == null ? void 0 : _a7.colorPalette);
      }
      if (variantKeys.includes("orientation")) {
        localProps.orientation = props52.orientation;
      }
      return [recipeProps, localProps];
    }
    const variantMap = Object.fromEntries(
      Object.entries(variants3).map(([key, value]) => [key, Object.keys(value)])
    );
    let classNameMap = {};
    if (config.className) {
      classNameMap = Object.fromEntries(
        config.slots.map((slot) => [
          slot,
          `${config.className}__${slot}`
        ])
      );
    }
    return Object.assign(svaFn, {
      variantMap,
      variantKeys,
      splitVariantProps,
      classNameMap
    });
  };
}

// node_modules/@chakra-ui/react/dist/esm/utils/create-props.js
var createProps = () => (props52) => Array.from(new Set(props52));

// node_modules/@chakra-ui/react/dist/esm/styled-system/esc.js
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|^-|[^\x80-\uFFFF\w-]/g;
var fcssescape = function(ch, asCodePoint) {
  if (!asCodePoint) return "\\" + ch;
  if (ch === "\0") return "�";
  if (ch === "-" && ch.length === 1) return "\\-";
  return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16);
};
var esc2 = (sel) => {
  return (sel + "").replace(rcssescape, fcssescape);
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/expand-reference.js
var expandTokenReferences = (str, resolve) => {
  let expanded = "";
  let index = 0;
  let state2 = "char";
  let tokenPath = "";
  let fallback5 = "";
  const currentStates = [];
  while (index < str.length) {
    const char2 = str[index];
    if (char2 === "{") {
      const endIndex = str.indexOf("}", index);
      if (endIndex === -1) {
        break;
      }
      const path = str.slice(index + 1, endIndex);
      const resolved = resolve(path);
      expanded += resolved ?? path;
      index = endIndex + 1;
      continue;
    }
    if (state2 === "token") {
      if (char2 === ",") {
        if (str[index] === "") {
          index++;
        }
        state2 = "fallback";
        currentStates.push(state2);
        const resolved = resolve(tokenPath);
        if (resolved == null ? void 0 : resolved.endsWith(")")) {
          expanded += resolved.slice(0, -1);
        }
        tokenPath = "";
        fallback5 = "";
        continue;
      }
    }
    if (state2 === "fallback") {
      const nextFallback = fallback5 + char2;
      if (nextFallback === ", var(") {
        const innerEndIndex = cssVarParser(str.slice(index + 1));
        const endIndex = innerEndIndex + index + 1;
        const cssVar2 = str.slice(index + 1, endIndex);
        if (endIndex === -1) {
          break;
        }
        expanded += ", var(" + cssVar2 + ")";
        index = endIndex + 1;
        state2 = currentStates.pop() ?? state2;
        fallback5 = "";
        continue;
      }
    }
    if (state2 === "token" || state2 === "fallback") {
      index++;
      if (char2 === ")") {
        state2 = currentStates.pop() ?? state2 ?? "char";
        fallback5 += char2;
        const resolved = tokenPath ? resolve(tokenPath) ?? esc2(tokenPath) : tokenPath;
        if (fallback5) {
          fallback5 = fallback5.slice(1).trim();
          if (!fallback5.startsWith("token(") && fallback5.endsWith(")")) {
            fallback5 = fallback5.slice(0, -1);
          }
          if (fallback5.includes("token(")) {
            const parsed = expandTokenReferences(fallback5, resolve);
            if (parsed) {
              fallback5 = parsed.slice(0, -1);
            }
          } else if (fallback5) {
            const resolvedFallback = resolve(fallback5);
            if (resolvedFallback) {
              fallback5 = resolvedFallback;
            }
          }
        }
        const lastChar = expanded.at(-1);
        if (fallback5) {
          if (lastChar == null ? void 0 : lastChar.trim()) {
            expanded += resolved.slice(0, -1) + (", " + fallback5 + ")");
          } else {
            expanded += fallback5;
          }
        } else {
          expanded += resolved || ")";
        }
        tokenPath = "";
        fallback5 = "";
        state2 = "char";
        continue;
      }
      if (state2 === "token") {
        tokenPath += char2;
      }
      if (state2 === "fallback") {
        fallback5 += char2;
      }
      continue;
    }
    const tokenIndex = str.indexOf("token(", index);
    if (tokenIndex !== -1) {
      const innerTokenIndex = tokenIndex + "token(".length;
      expanded += str.slice(index, tokenIndex);
      index = innerTokenIndex;
      state2 = "token";
      currentStates.push(state2);
      continue;
    }
    expanded += char2;
    index++;
  }
  return expanded;
};
var cssVarParser = (str) => {
  let index = 0;
  const openedParenthesises = ["("];
  while (index < str.length) {
    const char2 = str[index];
    if (char2 === "(") {
      openedParenthesises.push(char2);
    } else if (char2 === ")") {
      openedParenthesises.pop();
      if (openedParenthesises.length === 0) {
        return index;
      }
    }
    index++;
  }
  return index;
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/map-to-json.js
function mapToJson(map) {
  const obj = {};
  map.forEach((value, key) => {
    if (value instanceof Map) {
      obj[key] = Object.fromEntries(value);
    } else {
      obj[key] = value;
    }
  });
  return obj;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/references.js
var REFERENCE_REGEX = /({([^}]*)})/g;
var CURLY_REGEX = /[{}]/g;
var TOKEN_PATH_REGEX = /\w+\.\w+/;
var getReferences = (value) => {
  if (!isString(value)) return [];
  const matches2 = value.match(REFERENCE_REGEX);
  if (!matches2) return [];
  return matches2.map((match50) => match50.replace(CURLY_REGEX, "")).map((value2) => value2.trim());
};
var hasReference = (value) => REFERENCE_REGEX.test(value);
function expandReferences(token2) {
  var _a7, _b6, _c5;
  if (!((_a7 = token2.extensions) == null ? void 0 : _a7.references)) {
    return ((_c5 = (_b6 = token2.extensions) == null ? void 0 : _b6.cssVar) == null ? void 0 : _c5.ref) ?? token2.value;
  }
  const references = token2.extensions.references ?? {};
  token2.value = Object.keys(references).reduce((valueStr, key) => {
    const referenceToken = references[key];
    if (referenceToken.extensions.conditions) {
      return valueStr;
    }
    const value = expandReferences(referenceToken);
    return valueStr.replace(`{${key}}`, value);
  }, token2.value);
  delete token2.extensions.references;
  return token2.value;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/calc.js
function resolveReference(operand) {
  if (isObject2(operand) && operand.reference) {
    return operand.reference;
  }
  return String(operand);
}
var toExpression = (operator, ...operands) => operands.map(resolveReference).join(` ${operator} `).replace(/calc/g, "");
var add = (...operands) => `calc(${toExpression("+", ...operands)})`;
var subtract = (...operands) => `calc(${toExpression("-", ...operands)})`;
var multiply = (...operands) => `calc(${toExpression("*", ...operands)})`;
var divide = (...operands) => `calc(${toExpression("/", ...operands)})`;
var negate = (x) => {
  const value = resolveReference(x);
  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  }
  return multiply(value, -1);
};
var calc = Object.assign(
  (x) => ({
    add: (...operands) => calc(add(x, ...operands)),
    subtract: (...operands) => calc(subtract(x, ...operands)),
    multiply: (...operands) => calc(multiply(x, ...operands)),
    divide: (...operands) => calc(divide(x, ...operands)),
    negate: () => calc(negate(x)),
    toString: () => x.toString()
  }),
  {
    add,
    subtract,
    multiply,
    divide,
    negate
  }
);

// node_modules/@chakra-ui/react/dist/esm/styled-system/token-middleware.js
var addNegativeTokens = {
  enforce: "pre",
  transform(dictionary) {
    const { prefix: prefix3, allTokens, formatCssVar, formatTokenName, registerToken } = dictionary;
    const tokens = allTokens.filter(
      ({ extensions }) => extensions.category === "spacing"
    );
    tokens.forEach((token2) => {
      const originalPath = token2.path.slice();
      const originalVar = formatCssVar(originalPath, prefix3);
      if (isString(token2.value) && token2.value === "0rem") {
        return;
      }
      const nextToken = structuredClone(token2);
      Object.assign(nextToken.extensions, {
        negative: true,
        prop: `-${token2.extensions.prop}`,
        originalPath
      });
      nextToken.value = calc.negate(originalVar.ref);
      const lastPath = nextToken.path[nextToken.path.length - 1];
      if (lastPath != null) {
        nextToken.path[nextToken.path.length - 1] = `-${lastPath}`;
      }
      if (nextToken.path) {
        nextToken.name = formatTokenName(nextToken.path);
      }
      registerToken(nextToken);
    });
  }
};
var units = /* @__PURE__ */ new Set([
  "spacing",
  "sizes",
  "borderWidths",
  "fontSizes",
  "radii"
]);
var addPixelUnit = {
  enforce: "post",
  transform(dictionary) {
    const tokens = dictionary.allTokens.filter((token2) => {
      return units.has(token2.extensions.category) && !token2.extensions.negative;
    });
    tokens.forEach((token2) => {
      Object.assign(token2.extensions, {
        pixelValue: toPx(token2.value)
      });
    });
  }
};
var addVirtualPalette = {
  enforce: "post",
  transform(dictionary) {
    const { allTokens, registerToken, formatTokenName } = dictionary;
    const tokens = allTokens.filter(
      ({ extensions }) => extensions.category === "colors"
    );
    const keys = /* @__PURE__ */ new Map();
    const colorPalettes = /* @__PURE__ */ new Map();
    tokens.forEach((token2) => {
      const { colorPalette } = token2.extensions;
      if (!colorPalette) return;
      colorPalette.keys.forEach((keyPath) => {
        keys.set(formatTokenName(keyPath), keyPath);
      });
      colorPalette.roots.forEach((colorPaletteRoot) => {
        var _a7;
        const name = formatTokenName(colorPaletteRoot);
        const colorPaletteList = colorPalettes.get(name) || [];
        colorPaletteList.push(token2);
        colorPalettes.set(name, colorPaletteList);
        if (token2.extensions.default && colorPaletteRoot.length === 1) {
          const keyPath = (_a7 = colorPalette.keys[0]) == null ? void 0 : _a7.filter(Boolean);
          if (!keyPath.length) return;
          const path = colorPaletteRoot.concat(keyPath);
          keys.set(formatTokenName(path), []);
        }
      });
    });
    keys.forEach((segments) => {
      const path = ["colors", "colorPalette", ...segments].filter(Boolean);
      const name = formatTokenName(path);
      const prop = formatTokenName(path.slice(1));
      const token2 = {
        name,
        value: name,
        originalValue: name,
        path,
        extensions: {
          condition: "base",
          originalPath: path,
          category: "colors",
          prop,
          virtual: true
        }
      };
      registerToken(token2, "pre");
    });
  }
};
var removeEmptyTokens = {
  enforce: "post",
  transform(dictionary) {
    dictionary.allTokens = dictionary.allTokens.filter(
      (token2) => token2.value !== ""
    );
  }
};
var tokenMiddlewares = [
  addNegativeTokens,
  addVirtualPalette,
  addPixelUnit,
  removeEmptyTokens
];

// node_modules/@chakra-ui/react/dist/esm/styled-system/token-transforms.js
var addCssVariables = {
  type: "extensions",
  enforce: "pre",
  name: "tokens/css-var",
  transform(token2, dictionary) {
    const { prefix: prefix3, formatCssVar } = dictionary;
    const { negative, originalPath } = token2.extensions;
    const path = negative ? originalPath : token2.path;
    return {
      cssVar: formatCssVar(path.filter(Boolean), prefix3)
    };
  }
};
var addConditionalCssVariables = {
  enforce: "post",
  type: "value",
  name: "tokens/conditionals",
  transform(token2, dictionary) {
    const { prefix: prefix3, formatCssVar } = dictionary;
    const refs = getReferences(token2.value);
    if (!refs.length) return token2.value;
    refs.forEach((ref36) => {
      const variable = formatCssVar(ref36.split("."), prefix3);
      token2.value = token2.value.replace(`{${variable.ref}}`, variable);
    });
    return token2.value;
  }
};
var addColorPalette = {
  type: "extensions",
  enforce: "pre",
  name: "tokens/colors/colorPalette",
  match(token2) {
    return token2.extensions.category === "colors" && !token2.extensions.virtual;
  },
  transform(token2, dict) {
    let path = token2.path.slice();
    path.pop();
    path.shift();
    if (path.length === 0) {
      const newPath = [...token2.path];
      newPath.shift();
      path = newPath;
    }
    if (path.length === 0) {
      return {};
    }
    const roots = path.reduce((acc, _, i, arr) => {
      const next3 = arr.slice(0, i + 1);
      acc.push(next3);
      return acc;
    }, []);
    const root = path[0];
    const value = dict.formatTokenName(path);
    const keys = token2.path.slice(token2.path.indexOf(root) + 1).reduce((acc, _, i, arr) => {
      acc.push(arr.slice(i));
      return acc;
    }, []);
    if (keys.length === 0) {
      keys.push([""]);
    }
    return {
      colorPalette: { value, roots, keys }
    };
  }
};
var tokenTransforms = [
  addCssVariables,
  addConditionalCssVariables,
  addColorPalette
];

// node_modules/@chakra-ui/react/dist/esm/styled-system/token-dictionary.js
var isToken = (value) => {
  return isObject2(value) && Object.prototype.hasOwnProperty.call(value, "value");
};
function expandBreakpoints(breakpoints2) {
  if (!breakpoints2) return { breakpoints: {}, sizes: {} };
  return {
    breakpoints: mapObject(breakpoints2, (value) => ({ value })),
    sizes: Object.fromEntries(
      Object.entries(breakpoints2).map(([key, value]) => [
        `breakpoint-${key}`,
        { value }
      ])
    )
  };
}
function createTokenDictionary(options) {
  const {
    prefix: prefix3 = "",
    tokens = {},
    semanticTokens = {},
    breakpoints: breakpoints2 = {}
  } = options;
  const formatTokenName = (path) => path.join(".");
  const formatCssVar = (path, prefix22) => cssVar(path.join("-"), { prefix: prefix22 });
  const allTokens = [];
  const tokenNameMap = /* @__PURE__ */ new Map();
  const conditionMap = /* @__PURE__ */ new Map();
  const cssVarMap = /* @__PURE__ */ new Map();
  const colorPaletteMap = /* @__PURE__ */ new Map();
  const flatMap = /* @__PURE__ */ new Map();
  const byCategory = /* @__PURE__ */ new Map();
  const categoryMap = /* @__PURE__ */ new Map();
  const transforms = /* @__PURE__ */ new Map();
  const middlewares = [];
  function registerToken(token2, phase) {
    allTokens.push(token2);
    tokenNameMap.set(token2.name, token2);
    if (phase) {
      transforms.forEach((fn) => {
        if (fn.enforce === phase) transformToken(fn, token2);
      });
    }
  }
  const breakpointTokens = expandBreakpoints(breakpoints2);
  const computedTokens = compact({
    ...tokens,
    breakpoints: breakpointTokens.breakpoints,
    sizes: {
      ...tokens.sizes,
      ...breakpointTokens.sizes
    }
  });
  function registerTokens() {
    walkObject(
      computedTokens,
      (entry, path) => {
        const isDefault = path.includes("DEFAULT");
        path = filterDefault(path);
        const category = path[0];
        const name = formatTokenName(path);
        const t = isString(entry) ? { value: entry } : entry;
        const token2 = {
          value: t.value,
          originalValue: t.value,
          name,
          path,
          extensions: {
            condition: "base",
            originalPath: path,
            category,
            prop: formatTokenName(path.slice(1))
          }
        };
        if (isDefault) {
          token2.extensions.default = true;
        }
        registerToken(token2);
      },
      { stop: isToken }
    );
    walkObject(
      semanticTokens,
      (entry, path) => {
        const isDefault = path.includes("DEFAULT");
        path = filterBaseCondition(filterDefault(path));
        const category = path[0];
        const name = formatTokenName(path);
        const t = isString(entry.value) ? { value: { base: entry.value } } : entry;
        const token2 = {
          value: t.value.base || "",
          originalValue: t.value.base || "",
          name,
          path,
          extensions: {
            originalPath: path,
            category,
            conditions: t.value,
            condition: "base",
            prop: formatTokenName(path.slice(1))
          }
        };
        if (isDefault) {
          token2.extensions.default = true;
        }
        registerToken(token2);
      },
      { stop: isToken }
    );
  }
  function getByName(name) {
    return tokenNameMap.get(name);
  }
  function buildConditionMap(token2) {
    const { condition } = token2.extensions;
    if (!condition) return;
    if (!conditionMap.has(condition)) {
      conditionMap.set(condition, /* @__PURE__ */ new Set());
    }
    conditionMap.get(condition).add(token2);
  }
  function buildCategoryMap(token2) {
    const { category, prop } = token2.extensions;
    if (!category) return;
    if (!categoryMap.has(category)) {
      categoryMap.set(category, /* @__PURE__ */ new Map());
    }
    categoryMap.get(category).set(prop, token2);
  }
  function buildCssVars(token2) {
    const { condition, negative, virtual, cssVar: cssVar2 } = token2.extensions;
    if (negative || virtual || !condition || !cssVar2) return;
    if (!cssVarMap.has(condition)) {
      cssVarMap.set(condition, /* @__PURE__ */ new Map());
    }
    cssVarMap.get(condition).set(cssVar2.var, token2.value);
  }
  function buildFlatMap(token2) {
    const { category, prop, cssVar: cssVar2, negative } = token2.extensions;
    if (!category) return;
    if (!byCategory.has(category)) {
      byCategory.set(category, /* @__PURE__ */ new Map());
    }
    const value = negative ? token2.extensions.conditions ? token2.originalValue : token2.value : cssVar2.ref;
    byCategory.get(category).set(prop, value);
    flatMap.set([category, prop].join("."), value);
  }
  function buildColorPalette(token2) {
    const { colorPalette, virtual, default: isDefault } = token2.extensions;
    if (!colorPalette || virtual) return;
    colorPalette.roots.forEach((root) => {
      var _a7;
      const name = formatTokenName(root);
      if (!colorPaletteMap.has(name)) {
        colorPaletteMap.set(name, /* @__PURE__ */ new Map());
      }
      const virtualPath = replaceRootWithColorPalette(
        [...token2.path],
        [...root]
      );
      const virtualName = formatTokenName(virtualPath);
      const virtualToken = getByName(virtualName);
      if (!virtualToken || !virtualToken.extensions.cssVar) return;
      const { var: virtualVar } = virtualToken.extensions.cssVar;
      colorPaletteMap.get(name).set(virtualVar, token2.extensions.cssVar.ref);
      if (isDefault && root.length === 1) {
        const colorPaletteName = formatTokenName(["colors", "colorPalette"]);
        const colorPaletteToken = getByName(colorPaletteName);
        if (!colorPaletteToken) return;
        const name2 = formatTokenName(token2.path);
        const virtualToken2 = getByName(name2);
        if (!virtualToken2) return;
        const keyPath = (_a7 = colorPalette.keys[0]) == null ? void 0 : _a7.filter(Boolean);
        if (!keyPath.length) return;
        const computedName = formatTokenName(root.concat(keyPath));
        if (!colorPaletteMap.has(computedName)) {
          colorPaletteMap.set(computedName, /* @__PURE__ */ new Map());
        }
        colorPaletteMap.get(computedName).set(
          colorPaletteToken.extensions.cssVar.var,
          virtualToken2.extensions.cssVar.ref
        );
      }
    });
  }
  let byCategoryJson = {};
  function setupViews() {
    allTokens.forEach((token2) => {
      buildConditionMap(token2);
      buildCategoryMap(token2);
      buildCssVars(token2);
      buildFlatMap(token2);
      buildColorPalette(token2);
    });
    byCategoryJson = mapToJson(byCategory);
  }
  const colorMix2 = (value, tokenFn) => {
    var _a7;
    if (!value || typeof value !== "string") return { invalid: true, value };
    const [colorPath, rawOpacity] = value.split("/");
    if (!colorPath || !rawOpacity) {
      return { invalid: true, value: colorPath };
    }
    const colorToken = tokenFn(colorPath);
    const opacityToken = (_a7 = getByName(`opacity.${rawOpacity}`)) == null ? void 0 : _a7.value;
    if (!opacityToken && isNaN(Number(rawOpacity))) {
      return { invalid: true, value: colorPath };
    }
    const percent = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
    const color = colorToken ?? colorPath;
    return {
      invalid: false,
      color,
      value: `color-mix(in srgb, ${color} ${percent}, transparent)`
    };
  };
  const getVar = memo2((value, fallback5) => {
    return flatMap.get(value) ?? fallback5;
  });
  const getCategoryValues = memo2((category) => {
    return byCategoryJson[category] || null;
  });
  const expandReferenceInValue = memo2((value) => {
    return expandTokenReferences(value, (path) => {
      if (!path) return;
      if (path.includes("/")) {
        const mix = colorMix2(path, (v) => getVar(v));
        if (mix.invalid) {
          throw new Error("Invalid color mix at " + path + ": " + mix.value);
        }
        return mix.value;
      }
      const resolved = getVar(path);
      if (resolved) return resolved;
      return TOKEN_PATH_REGEX.test(path) ? esc2(path) : path;
    });
  });
  const dictionary = {
    prefix: prefix3,
    allTokens,
    tokenMap: tokenNameMap,
    registerToken,
    getByName,
    formatTokenName,
    formatCssVar,
    flatMap,
    cssVarMap,
    categoryMap,
    colorPaletteMap,
    getVar,
    getCategoryValues,
    expandReferenceInValue
  };
  function registerTransform(...fns) {
    fns.forEach((fn) => {
      transforms.set(fn.name, fn);
    });
  }
  function registerMiddleware(...fns) {
    middlewares.push(...fns);
  }
  function transformToken(transform2, token2) {
    if (token2.extensions.references) return;
    if (isFunction(transform2.match) && !transform2.match(token2)) return;
    const fn = (v) => transform2.transform(v, dictionary);
    const transformed = fn(token2);
    switch (true) {
      case transform2.type === "extensions":
        Object.assign(token2.extensions, transformed);
        break;
      case transform2.type === "value":
        token2.value = transformed;
        break;
      default:
        token2[transform2.type] = transformed;
        break;
    }
  }
  function applyMiddlewares(enforce) {
    middlewares.forEach((middleware2) => {
      if (middleware2.enforce === enforce) {
        middleware2.transform(dictionary);
      }
    });
  }
  function applyTransforms(enforce) {
    transforms.forEach((transform2) => {
      if (transform2.enforce === enforce) {
        allTokens.forEach((token2) => {
          transformToken(transform2, token2);
        });
      }
    });
  }
  function addConditionalTokens() {
    allTokens.forEach((token2) => {
      const tokens2 = getConditionalTokens(token2);
      if (!tokens2 || tokens2.length === 0) return;
      tokens2.forEach((token22) => {
        registerToken(token22);
      });
    });
  }
  function getTokenReferences(value) {
    const refs = getReferences(value);
    return refs.map((ref36) => getByName(ref36)).filter(Boolean);
  }
  function addReferences() {
    allTokens.forEach((token2) => {
      if (!hasReference(token2.value)) return;
      const references = getTokenReferences(token2.value);
      token2.extensions.references = references.reduce((acc, ref36) => {
        acc[ref36.name] = ref36;
        return acc;
      }, {});
    });
  }
  function expandTokenReferences$1() {
    allTokens.forEach((token2) => {
      expandReferences(token2);
    });
  }
  function build2() {
    applyMiddlewares("pre");
    applyTransforms("pre");
    addConditionalTokens();
    addReferences();
    expandTokenReferences$1();
    applyMiddlewares("post");
    applyTransforms("post");
    setupViews();
  }
  registerTokens();
  registerTransform(...tokenTransforms);
  registerMiddleware(...tokenMiddlewares);
  build2();
  return dictionary;
}
function filterDefault(path) {
  if (path[0] === "DEFAULT") return path;
  return path.filter((item) => item !== "DEFAULT");
}
function filterBaseCondition(path) {
  return path.filter((item) => item !== "base");
}
function getConditionalTokens(token2) {
  if (!token2.extensions.conditions) return;
  const { conditions } = token2.extensions;
  const tokens = [];
  walkObject(conditions, (value, path) => {
    const nextPath = filterBaseCondition(path);
    if (!nextPath.length) return;
    const nextToken = structuredClone(token2);
    nextToken.value = value;
    nextToken.extensions.condition = nextPath.join(":");
    tokens.push(nextToken);
  });
  return tokens;
}
function replaceRootWithColorPalette(path, roots) {
  const startIndex = path.findIndex(
    (_, index) => roots.every(
      (rootElement, rootIndex) => path[index + rootIndex] === rootElement
    )
  );
  if (startIndex === -1) {
    return path;
  }
  path.splice(startIndex, roots.length);
  path.splice(startIndex, 0, "colorPalette");
  return path;
}
var tokenCategories = createProps()([
  "aspectRatios",
  "zIndex",
  "opacity",
  "colors",
  "fonts",
  "fontSizes",
  "fontWeights",
  "lineHeights",
  "letterSpacings",
  "sizes",
  "shadows",
  "spacing",
  "radii",
  "cursor",
  "borders",
  "borderWidths",
  "borderStyles",
  "durations",
  "easings",
  "animations",
  "blurs",
  "gradients",
  "breakpoints",
  "assets"
]);

// node_modules/@chakra-ui/react/dist/esm/styled-system/utility.js
function normalize(config) {
  return config;
}
function normalizeConfig(config) {
  return Object.fromEntries(
    Object.entries(config).map(([property, propertyConfig]) => {
      return [property, normalize(propertyConfig)];
    })
  );
}
function createUtility(options) {
  const configs = normalizeConfig(options.config);
  const tokens = options.tokens;
  const shorthands = /* @__PURE__ */ new Map();
  const propValues = /* @__PURE__ */ new Map();
  function register(property, config) {
    configs[property] = normalize(config);
    assignProperty(property, config);
  }
  const assignProperty = (property, config) => {
    const values = getPropertyValues(config);
    if (!values) return;
    propValues.set(property, values);
    assignPropertyType(property, config);
  };
  const assignProperties = () => {
    for (const [prop, config] of Object.entries(configs)) {
      if (!config) continue;
      assignProperty(prop, config);
    }
  };
  const assignShorthands = () => {
    for (const [property, config] of Object.entries(configs)) {
      const { shorthand } = config ?? {};
      if (!shorthand) continue;
      const values = Array.isArray(shorthand) ? shorthand : [shorthand];
      values.forEach((name) => shorthands.set(name, property));
    }
  };
  const assignColorPaletteProperty = () => {
    const values = mapToJson(tokens.colorPaletteMap);
    register("colorPalette", {
      values: Object.keys(values),
      transform: memo2((value) => values[value])
    });
  };
  const propTypes = /* @__PURE__ */ new Map();
  const assignPropertyType = (property, config) => {
    if (!config) return;
    const values = getPropertyValues(config, (key) => `type:Tokens["${key}"]`);
    if (typeof values === "object" && values.type) {
      propTypes.set(property, /* @__PURE__ */ new Set([`type:${values.type}`]));
      return;
    }
    if (values) {
      const keys2 = new Set(Object.keys(values));
      propTypes.set(property, keys2);
    }
    const set18 = propTypes.get(property) ?? /* @__PURE__ */ new Set();
    if (config.property) {
      propTypes.set(property, set18.add(`CssProperties["${config.property}"]`));
    }
  };
  const assignPropertyTypes = () => {
    for (const [property, propertyConfig] of Object.entries(configs)) {
      if (!propertyConfig) continue;
      assignPropertyType(property, propertyConfig);
    }
  };
  const addPropertyType = (property, type) => {
    const set18 = propTypes.get(property) ?? /* @__PURE__ */ new Set();
    propTypes.set(property, /* @__PURE__ */ new Set([...set18, ...type]));
  };
  const getTypes = () => {
    const map = /* @__PURE__ */ new Map();
    for (const [prop, values] of propTypes.entries()) {
      if (values.size === 0) {
        map.set(prop, ["string"]);
        continue;
      }
      const typeValues = Array.from(values).map((key) => {
        if (key.startsWith("CssProperties")) return key;
        if (key.startsWith("type:")) return key.replace("type:", "");
        return JSON.stringify(key);
      });
      map.set(prop, typeValues);
    }
    return map;
  };
  const getPropertyValues = (config, resolveFn) => {
    const { values } = config;
    const fn = (key) => {
      const value = resolveFn == null ? void 0 : resolveFn(key);
      return value ? { [value]: value } : void 0;
    };
    if (isString(values)) {
      return (fn == null ? void 0 : fn(values)) ?? tokens.getCategoryValues(values) ?? {};
    }
    if (Array.isArray(values)) {
      return values.reduce((result, value) => {
        result[value] = value;
        return result;
      }, {});
    }
    if (isFunction(values)) {
      return values(resolveFn ? fn : tokens.getCategoryValues);
    }
    return values;
  };
  const defaultTransform = memo2((prop, value) => {
    return {
      [prop]: prop.startsWith("--") ? tokens.getVar(value, value) : value
    };
  });
  const tokenFn = Object.assign(tokens.getVar, {
    raw: (path) => tokens.getByName(path)
  });
  const transform2 = memo2((prop, raw) => {
    var _a7;
    const key = resolveShorthand(prop);
    if (isString(raw)) {
      raw = tokens.expandReferenceInValue(raw);
    }
    const config = configs[key];
    if (!config) {
      return defaultTransform(key, raw);
    }
    const value = (_a7 = propValues.get(key)) == null ? void 0 : _a7[raw];
    if (!config.transform) {
      return defaultTransform(prop, value ?? raw);
    }
    const _colorMix = (value2) => colorMix(value2, tokenFn);
    return config.transform(value ?? raw, {
      raw,
      token: tokenFn,
      utils: { colorMix: _colorMix }
    });
  });
  function build2() {
    assignShorthands();
    assignColorPaletteProperty();
    assignProperties();
    assignPropertyTypes();
  }
  build2();
  const hasShorthand = shorthands.size > 0;
  const resolveShorthand = memo2((prop) => {
    return shorthands.get(prop) ?? prop;
  });
  const keys = () => {
    return [...Array.from(shorthands.keys()), ...Object.keys(configs)];
  };
  const instance = {
    keys,
    hasShorthand,
    transform: transform2,
    shorthands,
    resolveShorthand,
    register,
    getTypes,
    addPropertyType
  };
  return instance;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/system.js
function createSystem(...configs) {
  const config = mergeConfigs(...configs);
  const {
    theme = {},
    utilities = {},
    globalCss: globalCss2 = {},
    cssVarsRoot = ":where(:root, :host)",
    cssVarsPrefix = "chakra",
    preflight
  } = config;
  const layers = createLayers(config);
  const tokens = createTokenDictionary({
    breakpoints: theme.breakpoints,
    tokens: theme.tokens,
    semanticTokens: theme.semanticTokens,
    prefix: cssVarsPrefix
  });
  const breakpoints2 = createBreakpoints(theme.breakpoints ?? {});
  const conditions = createConditions({
    conditions: config.conditions ?? {},
    breakpoints: breakpoints2
  });
  const utility = createUtility({
    config: utilities,
    tokens
  });
  function assignComposition() {
    const { textStyles: textStyles2, layerStyles: layerStyles2, animationStyles: animationStyles2 } = theme;
    const compositions = compact({
      textStyle: textStyles2,
      layerStyle: layerStyles2,
      animationStyle: animationStyles2
    });
    for (const [key, values] of Object.entries(compositions)) {
      const flatValues = flatten(
        values ?? {},
        (v) => isObject2(v) && "value" in v
      );
      utility.register(key, {
        values: Object.keys(flatValues),
        transform(value) {
          return css2(flatValues[value]);
        }
      });
    }
  }
  assignComposition();
  utility.addPropertyType("animationName", Object.keys(theme.keyframes ?? {}));
  const properties2 = /* @__PURE__ */ new Set(["css", ...utility.keys(), ...conditions.keys()]);
  const isValidProperty = memo2(
    (prop) => properties2.has(prop) || isCssProperty(prop)
  );
  const normalizeValue = (value) => {
    if (Array.isArray(value)) {
      return value.reduce((acc, current, index) => {
        const key = conditions.breakpoints[index];
        if (current != null) acc[key] = current;
        return acc;
      }, {});
    }
    return value;
  };
  const normalizeFn = createNormalizeFn({
    utility,
    normalize: normalizeValue
  });
  const serialize3 = createSerializeFn({
    conditions,
    isValidProperty
  });
  const css2 = createCssFn({
    transform: utility.transform,
    conditions,
    normalize: normalizeFn
  });
  const cva = createRecipeFn({
    css: css2,
    conditions,
    normalize: normalizeFn,
    layers
  });
  const sva = createSlotRecipeFn({ cva });
  function getTokenCss() {
    const result = {};
    for (const [key, values] of tokens.cssVarMap.entries()) {
      const varsObj = Object.fromEntries(values);
      if (Object.keys(varsObj).length === 0) continue;
      if (key === "base") {
        const cssObj = css2(serialize3({ [cssVarsRoot]: varsObj }));
        mergeWith(result, cssObj);
      } else {
        const cssObject = css2(serialize3({ [key]: varsObj }));
        mergeWith(result, cssObject);
      }
    }
    return layers.wrap("tokens", result);
  }
  function getGlobalCss() {
    const keyframes2 = Object.fromEntries(
      Object.entries(theme.keyframes ?? {}).map(([key, value]) => [
        `@keyframes ${key}`,
        value
      ])
    );
    const result = Object.assign({}, keyframes2, css2(serialize3(globalCss2)));
    return layers.wrap("base", result);
  }
  function splitCssProps(props52) {
    return splitProps(props52, isValidProperty);
  }
  function getPreflightCss() {
    const result = createPreflight({ preflight });
    return layers.wrap("reset", result);
  }
  const tokenMap = getTokenMap(tokens);
  const tokenFn = (path, fallback5) => {
    var _a7;
    return ((_a7 = tokenMap.get(path)) == null ? void 0 : _a7.value) || fallback5;
  };
  tokenFn.var = (path, fallback5) => {
    var _a7;
    return ((_a7 = tokenMap.get(path)) == null ? void 0 : _a7.variable) || fallback5;
  };
  function getRecipe(key, fallback5) {
    var _a7;
    return ((_a7 = theme.recipes) == null ? void 0 : _a7[key]) ?? fallback5;
  }
  function getSlotRecipe(key, fallback5) {
    var _a7;
    return ((_a7 = theme.slotRecipes) == null ? void 0 : _a7[key]) ?? fallback5;
  }
  function isRecipe(key) {
    return Object.hasOwnProperty.call(theme.recipes ?? {}, key);
  }
  function isSlotRecipe(key) {
    return Object.hasOwnProperty.call(theme.slotRecipes ?? {}, key);
  }
  function hasRecipe(key) {
    return isRecipe(key) || isSlotRecipe(key);
  }
  return {
    $$chakra: true,
    _config: config,
    breakpoints: breakpoints2,
    tokens,
    conditions,
    utility,
    token: tokenFn,
    properties: properties2,
    layers,
    isValidProperty,
    splitCssProps,
    normalizeValue,
    getTokenCss,
    getGlobalCss,
    getPreflightCss,
    css: css2,
    cva,
    sva,
    getRecipe,
    getSlotRecipe,
    hasRecipe,
    isRecipe,
    isSlotRecipe
  };
}
function getTokenMap(tokens) {
  const map = /* @__PURE__ */ new Map();
  tokens.allTokens.forEach((token2) => {
    const { cssVar: cssVar2, virtual, conditions } = token2.extensions;
    const value = !!conditions || virtual ? cssVar2.ref : token2.value;
    map.set(token2.name, { value, variable: cssVar2.ref });
  });
  return map;
}
var isValidSystem = (mod3) => {
  return isObject2(mod3) && !!Reflect.get(mod3, "$$chakra");
};

// node_modules/@chakra-ui/react/dist/esm/theme/breakpoints.js
var breakpoints = {
  sm: "480px",
  md: "768px",
  lg: "1024px",
  xl: "1280px",
  "2xl": "1536px"
};

// node_modules/@chakra-ui/react/dist/esm/theme/global-css.js
var empty = "var(--chakra-empty,/*!*/ /*!*/)";
var globalCss = defineGlobalStyles({
  "*": {
    fontFeatureSettings: '"cv11"',
    "--ring-inset": empty,
    "--ring-offset-width": "0px",
    "--ring-offset-color": "#fff",
    "--ring-color": "rgba(66, 153, 225, 0.6)",
    "--ring-offset-shadow": "0 0 #0000",
    "--ring-shadow": "0 0 #0000",
    ...Object.fromEntries(
      [
        "brightness",
        "contrast",
        "grayscale",
        "hue-rotate",
        "invert",
        "saturate",
        "sepia",
        "drop-shadow"
      ].map((prop) => [`--${prop}`, empty])
    ),
    ...Object.fromEntries(
      [
        "blur",
        "brightness",
        "contrast",
        "grayscale",
        "hue-rotate",
        "invert",
        "opacity",
        "saturate",
        "sepia"
      ].map((prop) => [`--backdrop-${prop}`, empty])
    ),
    "--global-font-mono": "fonts.mono",
    "--global-font-body": "fonts.body",
    "--global-color-border": "colors.border"
  },
  html: {
    color: "fg",
    bg: "bg",
    lineHeight: "1.5",
    colorPalette: "gray"
  },
  "*::placeholder": {
    color: "fg.muted"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/layer-styles.js
var layerStyles = defineLayerStyles({
  // fill: some background color + color combination
  "fill.muted": {
    value: {
      background: "colorPalette.muted",
      color: "colorPalette.fg"
    }
  },
  "fill.subtle": {
    value: {
      background: "colorPalette.subtle",
      color: "colorPalette.fg"
    }
  },
  "fill.surface": {
    value: {
      background: "colorPalette.muted",
      color: "colorPalette.fg",
      boxShadow: "inset 0 0 0px 1px var(--shadow-color)",
      boxShadowColor: "colorPalette.subtle"
    }
  },
  "fill.solid": {
    value: {
      background: "colorPalette.solid",
      color: "colorPalette.contrast"
    }
  },
  // outline: some border color + color combination
  "outline.subtle": {
    value: {
      color: "colorPalette.fg",
      boxShadow: "inset 0 0 0px 1px var(--shadow-color)",
      boxShadowColor: "colorPalette.subtle"
    }
  },
  "outline.solid": {
    value: {
      borderWidth: "1px",
      borderColor: "colorPalette.solid",
      color: "colorPalette.fg"
    }
  },
  // indicator: floating border color or left/bottom border
  "indicator.bottom": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        bottom: "var(--indicator-offset-y, 0)",
        insetInline: "var(--indicator-offset-x, 0)",
        height: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.top": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        top: "var(--indicator-offset-y, 0)",
        insetInline: "var(--indicator-offset-x, 0)",
        height: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.start": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        insetInlineStart: "var(--indicator-offset-x, 0)",
        insetBlock: "var(--indicator-offset-y, 0)",
        width: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.end": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        insetInlineEnd: "var(--indicator-offset-x, 0)",
        insetBlock: "var(--indicator-offset-y, 0)",
        width: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  disabled: {
    value: {
      opacity: "0.5",
      cursor: "not-allowed"
    }
  },
  none: {
    value: {}
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/motion-styles.js
var animationStyles = defineAnimationStyles({
  "slide-fade-in": {
    value: {
      transformOrigin: "var(--transform-origin)",
      "&[data-placement^=top]": {
        animationName: "slide-from-bottom, fade-in"
      },
      "&[data-placement^=bottom]": {
        animationName: "slide-from-top, fade-in"
      },
      "&[data-placement^=left]": {
        animationName: "slide-from-right, fade-in"
      },
      "&[data-placement^=right]": {
        animationName: "slide-from-left, fade-in"
      }
    }
  },
  "slide-fade-out": {
    value: {
      transformOrigin: "var(--transform-origin)",
      "&[data-placement^=top]": {
        animationName: "slide-to-bottom, fade-out"
      },
      "&[data-placement^=bottom]": {
        animationName: "slide-to-top, fade-out"
      },
      "&[data-placement^=left]": {
        animationName: "slide-to-right, fade-out"
      },
      "&[data-placement^=right]": {
        animationName: "slide-to-left, fade-out"
      }
    }
  },
  "scale-fade-in": {
    value: {
      transformOrigin: "var(--transform-origin)",
      animationName: "scale-in, fade-in"
    }
  },
  "scale-fade-out": {
    value: {
      transformOrigin: "var(--transform-origin)",
      animationName: "scale-out, fade-out"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/badge.js
var badgeRecipe = defineRecipe({
  className: "chakra-badge",
  base: {
    display: "inline-flex",
    alignItems: "center",
    borderRadius: "l2",
    gap: "1",
    fontWeight: "medium",
    fontVariantNumeric: "tabular-nums",
    whiteSpace: "nowrap",
    userSelect: "none"
  },
  variants: {
    variant: {
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast"
      },
      subtle: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg"
      },
      outline: {
        color: "colorPalette.fg",
        shadow: "inset 0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted"
      },
      surface: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        shadow: "inset 0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted"
      },
      plain: {
        color: "colorPalette.fg"
      }
    },
    size: {
      xs: {
        textStyle: "2xs",
        px: "1",
        minH: "4"
      },
      sm: {
        textStyle: "xs",
        px: "1.5",
        minH: "5"
      },
      md: {
        textStyle: "sm",
        px: "2",
        minH: "6"
      },
      lg: {
        textStyle: "sm",
        px: "2.5",
        minH: "7"
      }
    }
  },
  defaultVariants: {
    variant: "subtle",
    size: "sm"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/button.js
var buttonRecipe = defineRecipe({
  className: "chakra-button",
  base: {
    display: "inline-flex",
    appearance: "none",
    alignItems: "center",
    justifyContent: "center",
    userSelect: "none",
    position: "relative",
    borderRadius: "l2",
    whiteSpace: "nowrap",
    verticalAlign: "middle",
    cursor: "button",
    flexShrink: "0",
    outline: "0",
    lineHeight: "1.2",
    isolation: "isolate",
    fontWeight: "medium",
    transitionProperty: "common",
    transitionDuration: "moderate",
    focusVisibleRing: "outside",
    _disabled: {
      layerStyle: "disabled"
    },
    _icon: {
      flexShrink: "0"
    }
  },
  variants: {
    size: {
      "2xs": {
        h: "6",
        minW: "6",
        textStyle: "xs",
        px: "2",
        gap: "1",
        _icon: {
          width: "3.5",
          height: "3.5"
        }
      },
      xs: {
        h: "8",
        minW: "8",
        textStyle: "xs",
        px: "2",
        gap: "1",
        _icon: {
          width: "4",
          height: "4"
        }
      },
      sm: {
        h: "9",
        minW: "9",
        px: "3.5",
        textStyle: "sm",
        gap: "2",
        _icon: {
          width: "4",
          height: "4"
        }
      },
      md: {
        h: "10",
        minW: "10",
        textStyle: "sm",
        px: "4",
        gap: "2",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      lg: {
        h: "11",
        minW: "11",
        textStyle: "md",
        px: "5",
        gap: "3",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      xl: {
        h: "12",
        minW: "12",
        textStyle: "md",
        px: "5",
        gap: "2.5",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      "2xl": {
        h: "16",
        minW: "16",
        textStyle: "lg",
        px: "7",
        gap: "3",
        _icon: {
          width: "6",
          height: "6"
        }
      }
    },
    variant: {
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast",
        _hover: {
          bg: "colorPalette.solid/90"
        },
        _expanded: {
          bg: "colorPalette.solid/90"
        }
      },
      subtle: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.muted"
        },
        _expanded: {
          bg: "colorPalette.muted"
        }
      },
      surface: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        shadow: "inset 0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted",
        _hover: {
          bg: "colorPalette.muted"
        },
        _expanded: {
          bg: "colorPalette.muted"
        }
      },
      outline: {
        borderWidth: "1px",
        borderColor: "colorPalette.muted",
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.subtle"
        },
        _expanded: {
          bg: "colorPalette.subtle"
        }
      },
      ghost: {
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.subtle"
        },
        _expanded: {
          bg: "colorPalette.subtle"
        }
      },
      plain: {
        color: "colorPalette.fg"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkmark.js
var checkmarkRecipe = defineRecipe({
  className: "chakra-checkmark",
  base: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: "0",
    color: "white",
    borderWidth: "1px",
    borderColor: "transparent",
    borderRadius: "l1",
    focusVisibleRing: "outside",
    _invalid: {
      colorPalette: "red",
      borderColor: "border.error"
    },
    _disabled: {
      opacity: "0.5"
    }
  },
  variants: {
    size: {
      xs: {
        boxSize: "3"
      },
      sm: {
        boxSize: "4"
      },
      md: {
        boxSize: "5",
        p: "0.5"
      },
      lg: {
        boxSize: "6",
        p: "0.5"
      }
    },
    variant: {
      solid: {
        borderColor: "border",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast",
          borderColor: "colorPalette.solid"
        }
      },
      outline: {
        borderColor: "border",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg",
          borderColor: "colorPalette.solid"
        }
      },
      subtle: {
        bg: "colorPalette.muted",
        borderColor: "colorPalette.muted",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg"
        }
      },
      plain: {
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg"
        }
      },
      inverted: {
        borderColor: "border",
        color: "colorPalette.fg",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          borderColor: "colorPalette.solid"
        }
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/code.js
var { variants, defaultVariants } = badgeRecipe;
var codeRecipe = defineRecipe({
  className: "chakra-code",
  base: {
    fontFamily: "mono",
    alignItems: "center",
    display: "inline-flex",
    borderRadius: "l2"
  },
  variants,
  defaultVariants
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/container.js
var containerRecipe = defineRecipe({
  className: "chakra-container",
  base: {
    position: "relative",
    maxWidth: "8xl",
    w: "100%",
    mx: "auto",
    px: { base: "4", md: "6", lg: "8" }
  },
  variants: {
    centerContent: {
      true: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center"
      }
    },
    fluid: {
      true: {
        maxWidth: "full"
      }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/heading.js
var headingRecipe = defineRecipe({
  className: "chakra-heading",
  base: {
    fontFamily: "heading",
    fontWeight: "semibold"
  },
  variants: {
    size: {
      xs: { textStyle: "xs" },
      sm: { textStyle: "sm" },
      md: { textStyle: "md" },
      lg: { textStyle: "lg" },
      xl: { textStyle: "xl" },
      "2xl": { textStyle: "2xl" },
      "3xl": { textStyle: "3xl" },
      "4xl": { textStyle: "4xl" },
      "5xl": { textStyle: "5xl" },
      "6xl": { textStyle: "6xl" },
      "7xl": { textStyle: "7xl" }
    }
  },
  defaultVariants: {
    size: "xl"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/icon.js
var iconRecipe = defineRecipe({
  className: "chakra-icon",
  base: {
    display: "inline-block",
    lineHeight: "1em",
    flexShrink: "0",
    color: "currentcolor",
    verticalAlign: "middle",
    width: "var(--icon-size)",
    height: "var(--icon-size)"
  },
  variants: {
    size: {
      inherit: { "--icon-size": "1em" },
      xs: { "--icon-size": "sizes.3" },
      sm: { "--icon-size": "sizes.4" },
      md: { "--icon-size": "sizes.5" },
      lg: { "--icon-size": "sizes.6" },
      xl: { "--icon-size": "sizes.7" },
      "2xl": { "--icon-size": "sizes.8" }
    }
  },
  defaultVariants: {
    size: "inherit"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/input.js
var inputRecipe = defineRecipe({
  className: "chakra-input",
  base: {
    width: "100%",
    minWidth: "0",
    outline: "0",
    position: "relative",
    appearance: "none",
    textAlign: "start",
    borderRadius: "l2",
    _disabled: {
      layerStyle: "disabled"
    },
    height: "var(--input-height)",
    minW: "var(--input-height)",
    "--focus-color": "colors.colorPalette.focusRing",
    "--error-color": "colors.border.error",
    _invalid: {
      focusRingColor: "var(--error-color)",
      borderColor: "var(--error-color)"
    }
  },
  variants: {
    size: {
      "2xs": {
        textStyle: "xs",
        px: "2",
        "--input-height": "sizes.7"
      },
      xs: {
        textStyle: "xs",
        px: "2",
        "--input-height": "sizes.8"
      },
      sm: {
        textStyle: "sm",
        px: "2.5",
        "--input-height": "sizes.9"
      },
      md: {
        textStyle: "sm",
        px: "3",
        "--input-height": "sizes.10"
      },
      lg: {
        textStyle: "md",
        px: "4",
        "--input-height": "sizes.11"
      },
      xl: {
        textStyle: "md",
        px: "4.5",
        "--input-height": "sizes.12"
      },
      "2xl": {
        textStyle: "lg",
        px: "5",
        "--input-height": "sizes.16"
      }
    },
    variant: {
      outline: {
        bg: "transparent",
        borderWidth: "1px",
        borderColor: "border",
        focusVisibleRing: "inside"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.muted",
        focusVisibleRing: "inside"
      },
      flushed: {
        bg: "transparent",
        borderBottomWidth: "1px",
        borderBottomColor: "border",
        borderRadius: "0",
        px: "0",
        _focusVisible: {
          borderColor: "var(--focus-color)",
          boxShadow: "0px 1px 0px 0px var(--focus-color)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/input-addon.js
var inputAddonRecipe = defineRecipe({
  className: "chakra-input-addon",
  base: {
    flex: "0 0 auto",
    width: "auto",
    display: "flex",
    alignItems: "center",
    whiteSpace: "nowrap"
  },
  variants: {
    size: inputRecipe.variants.size,
    variant: {
      outline: {
        border: "1px solid",
        borderColor: { _light: "border", _dark: "whiteAlpha.50" },
        bg: "bg.muted"
      },
      subtle: {
        border: "2px solid",
        borderColor: "transparent",
        bg: { _light: "gray.100", _dark: "whiteAlpha.50" }
      },
      flushed: {
        borderBottom: "1px solid",
        borderColor: "inherit",
        borderRadius: "0",
        px: "0",
        bg: "transparent"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/kbd.js
var kbdRecipe = defineRecipe({
  className: "chakra-kbd",
  base: {
    display: "inline-flex",
    alignItems: "center",
    fontWeight: "medium",
    fontFamily: "mono",
    flexShrink: "0",
    whiteSpace: "nowrap",
    wordSpacing: "-0.5em",
    userSelect: "none",
    px: "1",
    borderRadius: "l2"
  },
  variants: {
    variant: {
      raised: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        borderWidth: "1px",
        borderBottomWidth: "2px",
        borderColor: "colorPalette.muted"
      },
      outline: {
        borderWidth: "1px",
        color: "colorPalette.fg"
      },
      subtle: {
        bg: "colorPalette.muted",
        color: "colorPalette.fg"
      },
      plain: {
        color: "colorPalette.fg"
      }
    },
    size: {
      sm: {
        textStyle: "xs",
        height: "4.5"
      },
      md: {
        textStyle: "sm",
        height: "5"
      },
      lg: {
        textStyle: "md",
        height: "6"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "raised"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/link.js
var linkRecipe = defineRecipe({
  className: "chakra-link",
  base: {
    display: "inline-flex",
    alignItems: "center",
    outline: "none",
    gap: "1.5",
    cursor: "pointer",
    borderRadius: "l1",
    focusRing: "outside"
  },
  variants: {
    variant: {
      underline: {
        color: "colorPalette.fg",
        textDecoration: "underline",
        textUnderlineOffset: "3px",
        textDecorationColor: "currentColor/20"
      },
      plain: {
        color: "colorPalette.fg",
        _hover: {
          textDecoration: "underline",
          textUnderlineOffset: "3px",
          textDecorationColor: "currentColor/20"
        }
      }
    }
  },
  defaultVariants: {
    variant: "plain"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/mark.js
var markRecipe = defineRecipe({
  className: "chakra-mark",
  base: {
    bg: "transparent",
    color: "inherit",
    whiteSpace: "nowrap"
  },
  variants: {
    variant: {
      subtle: {
        bg: "colorPalette.subtle",
        color: "inherit"
      },
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast"
      },
      text: {
        fontWeight: "medium"
      },
      plain: {}
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/radiomark.js
var radiomarkRecipe = defineRecipe({
  className: "chakra-radiomark",
  base: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    verticalAlign: "top",
    color: "white",
    borderWidth: "1px",
    borderColor: "transparent",
    borderRadius: "full",
    cursor: "radio",
    _focusVisible: {
      outline: "2px solid",
      outlineColor: "colorPalette.focusRing",
      outlineOffset: "2px"
    },
    _invalid: {
      colorPalette: "red",
      borderColor: "red.500"
    },
    _disabled: {
      opacity: "0.5",
      cursor: "disabled"
    },
    "& .dot": {
      height: "100%",
      width: "100%",
      borderRadius: "full",
      bg: "currentColor",
      scale: "0.4"
    }
  },
  variants: {
    variant: {
      solid: {
        borderWidth: "1px",
        borderColor: "border",
        _checked: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast",
          borderColor: "colorPalette.solid"
        }
      },
      subtle: {
        borderWidth: "1px",
        bg: "colorPalette.muted",
        borderColor: "colorPalette.muted",
        color: "transparent",
        _checked: {
          color: "colorPalette.fg"
        }
      },
      outline: {
        borderWidth: "1px",
        borderColor: "inherit",
        _checked: {
          color: "colorPalette.fg",
          borderColor: "colorPalette.solid"
        },
        "& .dot": {
          scale: "0.6"
        }
      },
      inverted: {
        bg: "bg",
        borderWidth: "1px",
        borderColor: "inherit",
        _checked: {
          color: "colorPalette.solid",
          borderColor: "currentcolor"
        }
      }
    },
    size: {
      xs: {
        boxSize: "3"
      },
      sm: {
        boxSize: "4"
      },
      md: {
        boxSize: "5"
      },
      lg: {
        boxSize: "6"
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/separator.js
var separatorRecipe = defineRecipe({
  className: "chakra-separator",
  base: {
    display: "block",
    borderColor: "border"
  },
  variants: {
    variant: {
      solid: {
        borderStyle: "solid"
      },
      dashed: {
        borderStyle: "dashed"
      },
      dotted: {
        borderStyle: "dotted"
      }
    },
    orientation: {
      vertical: {
        height: "100%",
        borderInlineStartWidth: "var(--separator-thickness)"
      },
      horizontal: {
        width: "100%",
        borderTopWidth: "var(--separator-thickness)"
      }
    },
    size: {
      xs: {
        "--separator-thickness": "0.5px"
      },
      sm: {
        "--separator-thickness": "1px"
      },
      md: {
        "--separator-thickness": "2px"
      },
      lg: {
        "--separator-thickness": "3px"
      }
    }
  },
  defaultVariants: {
    size: "sm",
    variant: "solid",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/skeleton.js
var skeletonRecipe = defineRecipe({
  className: "chakra-skeleton",
  base: {},
  variants: {
    loading: {
      true: {
        borderRadius: "l2",
        boxShadow: "none",
        backgroundClip: "padding-box",
        cursor: "default",
        color: "transparent",
        pointerEvents: "none",
        userSelect: "none",
        flexShrink: "0",
        "&::before, &::after, *": {
          visibility: "hidden"
        }
      },
      false: {
        background: "unset",
        animation: "fade-in var(--fade-duration, 0.1s) ease-out !important"
      }
    },
    variant: {
      pulse: {
        background: "bg.emphasized",
        animation: "pulse",
        animationDuration: "var(--duration, 1.2s)"
      },
      shine: {
        "--animate-from": "200%",
        "--animate-to": "-200%",
        "--start-color": "colors.bg.muted",
        "--end-color": "colors.bg.emphasized",
        backgroundImage: "linear-gradient(270deg,var(--start-color),var(--end-color),var(--end-color),var(--start-color))",
        backgroundSize: "400% 100%",
        animation: "bg-position var(--duration, 5s) ease-in-out infinite"
      },
      none: {
        animation: "none"
      }
    }
  },
  defaultVariants: {
    variant: "pulse",
    loading: true
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/skip-nav-link.js
var skipNavLinkRecipe = defineRecipe({
  className: "chakra-skip-nav",
  base: {
    display: "inline-flex",
    bg: "bg.panel",
    padding: "2.5",
    borderRadius: "l2",
    fontWeight: "semibold",
    focusVisibleRing: "outside",
    textStyle: "sm",
    // visually hidden
    userSelect: "none",
    border: "0",
    height: "1px",
    width: "1px",
    margin: "-1px",
    outline: "0",
    overflow: "hidden",
    position: "absolute",
    clip: "rect(0 0 0 0)",
    _focusVisible: {
      clip: "auto",
      width: "auto",
      height: "auto",
      position: "fixed",
      top: "6",
      insetStart: "6"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/spinner.js
var spinnerRecipe = defineRecipe({
  className: "chakra-spinner",
  base: {
    display: "inline-block",
    borderColor: "currentColor",
    borderStyle: "solid",
    borderWidth: "2px",
    borderRadius: "full",
    width: "var(--spinner-size)",
    height: "var(--spinner-size)",
    animation: "spin",
    animationDuration: "slowest",
    "--spinner-track-color": "transparent",
    borderBottomColor: "var(--spinner-track-color)",
    borderInlineStartColor: "var(--spinner-track-color)"
  },
  variants: {
    size: {
      inherit: { "--spinner-size": "1em" },
      xs: { "--spinner-size": "sizes.3" },
      sm: { "--spinner-size": "sizes.4" },
      md: { "--spinner-size": "sizes.5" },
      lg: { "--spinner-size": "sizes.8" },
      xl: { "--spinner-size": "sizes.10" }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/textarea.js
var textareaRecipe = defineRecipe({
  className: "chakra-textarea",
  base: {
    width: "100%",
    minWidth: "0",
    outline: "0",
    position: "relative",
    appearance: "none",
    textAlign: "start",
    borderRadius: "l2",
    _disabled: {
      layerStyle: "disabled"
    },
    "--focus-color": "colors.colorPalette.focusRing",
    "--error-color": "colors.border.error",
    _invalid: {
      focusRingColor: "var(--error-color)",
      borderColor: "var(--error-color)"
    }
  },
  variants: {
    size: {
      xs: {
        textStyle: "xs",
        px: "2",
        py: "1.5",
        scrollPaddingBottom: "1.5"
      },
      sm: {
        textStyle: "sm",
        px: "2.5",
        py: "2",
        scrollPaddingBottom: "2"
      },
      md: {
        textStyle: "sm",
        px: "3",
        py: "2",
        scrollPaddingBottom: "2"
      },
      lg: {
        textStyle: "md",
        px: "4",
        py: "3",
        scrollPaddingBottom: "3"
      },
      xl: {
        textStyle: "md",
        px: "4.5",
        py: "3.5",
        scrollPaddingBottom: "3.5"
      }
    },
    variant: {
      outline: {
        bg: "transparent",
        borderWidth: "1px",
        borderColor: "border",
        focusVisibleRing: "inside"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.muted",
        focusVisibleRing: "inside"
      },
      flushed: {
        bg: "transparent",
        borderBottomWidth: "1px",
        borderBottomColor: "border",
        borderRadius: "0",
        px: "0",
        _focusVisible: {
          borderColor: "var(--focus-color)",
          boxShadow: "0px 1px 0px 0px var(--focus-color)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes.js
var recipes = {
  badge: badgeRecipe,
  button: buttonRecipe,
  code: codeRecipe,
  container: containerRecipe,
  heading: headingRecipe,
  input: inputRecipe,
  inputAddon: inputAddonRecipe,
  kbd: kbdRecipe,
  link: linkRecipe,
  mark: markRecipe,
  separator: separatorRecipe,
  skeleton: skeletonRecipe,
  skipNavLink: skipNavLinkRecipe,
  spinner: spinnerRecipe,
  textarea: textareaRecipe,
  icon: iconRecipe,
  checkmark: checkmarkRecipe,
  radiomark: radiomarkRecipe
};

// node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/colors.js
var semanticColors = defineSemanticTokens.colors({
  bg: {
    DEFAULT: {
      value: { _light: "{colors.white}", _dark: "{colors.black}" }
    },
    subtle: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
    },
    muted: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    inverted: {
      value: { _light: "{colors.black}", _dark: "{colors.white}" }
    },
    panel: {
      value: { _light: "{colors.white}", _dark: "{colors.gray.950}" }
    },
    error: {
      value: { _light: "{colors.red.50}", _dark: "{colors.red.950}" }
    },
    warning: {
      value: { _light: "{colors.orange.50}", _dark: "{colors.orange.950}" }
    },
    success: {
      value: { _light: "{colors.green.50}", _dark: "{colors.green.950}" }
    },
    info: {
      value: { _light: "{colors.blue.50}", _dark: "{colors.blue.950}" }
    }
  },
  fg: {
    DEFAULT: {
      value: { _light: "{colors.black}", _dark: "{colors.gray.50}" }
    },
    muted: {
      value: { _light: "{colors.gray.600}", _dark: "{colors.gray.400}" }
    },
    subtle: {
      value: { _light: "{colors.gray.400}", _dark: "{colors.gray.500}" }
    },
    inverted: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.black}" }
    },
    error: {
      value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
    },
    warning: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.300}" }
    },
    success: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.300}" }
    },
    info: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.300}" }
    }
  },
  border: {
    DEFAULT: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    muted: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    subtle: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
    },
    inverted: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    },
    error: {
      value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
    },
    warning: {
      value: { _light: "{colors.orange.500}", _dark: "{colors.orange.400}" }
    },
    success: {
      value: { _light: "{colors.green.500}", _dark: "{colors.green.400}" }
    },
    info: {
      value: { _light: "{colors.blue.500}", _dark: "{colors.blue.400}" }
    }
  },
  gray: {
    contrast: {
      value: { _light: "{colors.white}", _dark: "{colors.black}" }
    },
    fg: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    },
    subtle: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    muted: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
    },
    solid: {
      value: { _light: "{colors.gray.900}", _dark: "{colors.white}" }
    },
    focusRing: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    }
  },
  red: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.red.700}", _dark: "{colors.red.300}" }
    },
    subtle: {
      value: { _light: "{colors.red.100}", _dark: "{colors.red.900}" }
    },
    muted: {
      value: { _light: "{colors.red.200}", _dark: "{colors.red.800}" }
    },
    emphasized: {
      value: { _light: "{colors.red.300}", _dark: "{colors.red.700}" }
    },
    solid: {
      value: { _light: "{colors.red.600}", _dark: "{colors.red.600}" }
    },
    focusRing: {
      value: { _light: "{colors.red.600}", _dark: "{colors.red.600}" }
    }
  },
  orange: {
    contrast: {
      value: { _light: "white", _dark: "black" }
    },
    fg: {
      value: { _light: "{colors.orange.700}", _dark: "{colors.orange.300}" }
    },
    subtle: {
      value: { _light: "{colors.orange.100}", _dark: "{colors.orange.900}" }
    },
    muted: {
      value: { _light: "{colors.orange.200}", _dark: "{colors.orange.800}" }
    },
    emphasized: {
      value: { _light: "{colors.orange.300}", _dark: "{colors.orange.700}" }
    },
    solid: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.500}" }
    },
    focusRing: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.500}" }
    }
  },
  green: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.green.700}", _dark: "{colors.green.300}" }
    },
    subtle: {
      value: { _light: "{colors.green.100}", _dark: "{colors.green.900}" }
    },
    muted: {
      value: { _light: "{colors.green.200}", _dark: "{colors.green.800}" }
    },
    emphasized: {
      value: { _light: "{colors.green.300}", _dark: "{colors.green.700}" }
    },
    solid: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.600}" }
    },
    focusRing: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.600}" }
    }
  },
  blue: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.blue.700}", _dark: "{colors.blue.300}" }
    },
    subtle: {
      value: { _light: "{colors.blue.100}", _dark: "{colors.blue.900}" }
    },
    muted: {
      value: { _light: "{colors.blue.200}", _dark: "{colors.blue.800}" }
    },
    emphasized: {
      value: { _light: "{colors.blue.300}", _dark: "{colors.blue.700}" }
    },
    solid: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.600}" }
    },
    focusRing: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.600}" }
    }
  },
  yellow: {
    contrast: {
      value: { _light: "black", _dark: "black" }
    },
    fg: {
      value: { _light: "{colors.yellow.800}", _dark: "{colors.yellow.300}" }
    },
    subtle: {
      value: { _light: "{colors.yellow.100}", _dark: "{colors.yellow.900}" }
    },
    muted: {
      value: { _light: "{colors.yellow.200}", _dark: "{colors.yellow.800}" }
    },
    emphasized: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.700}" }
    },
    solid: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.300}" }
    },
    focusRing: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.300}" }
    }
  },
  teal: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.teal.700}", _dark: "{colors.teal.300}" }
    },
    subtle: {
      value: { _light: "{colors.teal.100}", _dark: "{colors.teal.900}" }
    },
    muted: {
      value: { _light: "{colors.teal.200}", _dark: "{colors.teal.800}" }
    },
    emphasized: {
      value: { _light: "{colors.teal.300}", _dark: "{colors.teal.700}" }
    },
    solid: {
      value: { _light: "{colors.teal.600}", _dark: "{colors.teal.600}" }
    },
    focusRing: {
      value: { _light: "{colors.teal.600}", _dark: "{colors.teal.600}" }
    }
  },
  purple: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.purple.700}", _dark: "{colors.purple.300}" }
    },
    subtle: {
      value: { _light: "{colors.purple.100}", _dark: "{colors.purple.900}" }
    },
    muted: {
      value: { _light: "{colors.purple.200}", _dark: "{colors.purple.800}" }
    },
    emphasized: {
      value: { _light: "{colors.purple.300}", _dark: "{colors.purple.700}" }
    },
    solid: {
      value: { _light: "{colors.purple.600}", _dark: "{colors.purple.600}" }
    },
    focusRing: {
      value: { _light: "{colors.purple.600}", _dark: "{colors.purple.600}" }
    }
  },
  pink: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.pink.700}", _dark: "{colors.pink.300}" }
    },
    subtle: {
      value: { _light: "{colors.pink.100}", _dark: "{colors.pink.900}" }
    },
    muted: {
      value: { _light: "{colors.pink.200}", _dark: "{colors.pink.800}" }
    },
    emphasized: {
      value: { _light: "{colors.pink.300}", _dark: "{colors.pink.700}" }
    },
    solid: {
      value: { _light: "{colors.pink.600}", _dark: "{colors.pink.600}" }
    },
    focusRing: {
      value: { _light: "{colors.pink.600}", _dark: "{colors.pink.600}" }
    }
  },
  cyan: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.cyan.700}", _dark: "{colors.cyan.300}" }
    },
    subtle: {
      value: { _light: "{colors.cyan.100}", _dark: "{colors.cyan.900}" }
    },
    muted: {
      value: { _light: "{colors.cyan.200}", _dark: "{colors.cyan.800}" }
    },
    emphasized: {
      value: { _light: "{colors.cyan.300}", _dark: "{colors.cyan.700}" }
    },
    solid: {
      value: { _light: "{colors.cyan.600}", _dark: "{colors.cyan.600}" }
    },
    focusRing: {
      value: { _light: "{colors.cyan.600}", _dark: "{colors.cyan.600}" }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/radii.js
var semanticRadii = defineSemanticTokens.radii({
  l1: { value: "{radii.xs}" },
  l2: { value: "{radii.sm}" },
  l3: { value: "{radii.md}" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/shadows.js
var semanticShadows = defineSemanticTokens.shadows({
  xs: {
    value: {
      _light: "0px 1px 2px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/20}",
      _dark: "0px 1px 1px {black/64}, 0px 0px 1px inset {colors.gray.300/20}"
    }
  },
  sm: {
    value: {
      _light: "0px 2px 4px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 2px 4px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  md: {
    value: {
      _light: "0px 4px 8px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 4px 8px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  lg: {
    value: {
      _light: "0px 8px 16px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 8px 16px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  xl: {
    value: {
      _light: "0px 16px 24px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 16px 24px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  "2xl": {
    value: {
      _light: "0px 24px 40px {colors.gray.900/16}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 24px 40px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  inner: {
    value: {
      _light: "inset 0 2px 4px 0 {black/5}",
      _dark: "inset 0 2px 4px 0 black"
    }
  },
  inset: {
    value: {
      _light: "inset 0 0 0 1px {black/5}",
      _dark: "inset 0 0 0 1px {colors.gray.300/5}"
    }
  }
});

// node_modules/@zag-js/anatomy/dist/index.mjs
var createAnatomy = (name, parts64 = []) => ({
  parts: (...values) => {
    if (isEmpty(parts64)) {
      return createAnatomy(name, values);
    }
    throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
  },
  extendWith: (...values) => createAnatomy(name, [...parts64, ...values]),
  rename: (newName) => createAnatomy(newName, parts64),
  keys: () => parts64,
  build: () => [...new Set(parts64)].reduce(
    (prev3, part) => Object.assign(prev3, {
      [part]: {
        selector: [
          `&[data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`,
          `& [data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`
        ].join(", "),
        attrs: { "data-scope": toKebabCase(name), "data-part": toKebabCase(part) }
      }
    }),
    {}
  )
});
var toKebabCase = (value) => value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty = (v) => v.length === 0;

// node_modules/@zag-js/dom-event/node_modules/@zag-js/dom-query/dist/index.mjs
var defaultItemToId2 = (v) => v.id;
function itemById2(v, id, itemToId = defaultItemToId2) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId2(v, id, itemToId = defaultItemToId2) {
  const item = itemById2(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize2 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText2 = (item) => sanitize2(item.dataset.valuetext ?? item.textContent ?? "");
var match3 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap3 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText2(v, text, currentId, itemToId = defaultItemToId2) {
  const index = currentId ? indexOfId2(v, currentId, itemToId) : -1;
  let items = currentId ? wrap3(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match3(getValueText2(item), text));
}
function getByTypeaheadImpl2(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText2(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead2 = Object.assign(getByTypeaheadImpl2, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent2
});
function isValidTypeaheadEvent2(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var fps2 = 1e3 / 60;

// node_modules/@zag-js/text-selection/node_modules/@zag-js/dom-query/dist/index.mjs
var defaultItemToId3 = (v) => v.id;
function itemById3(v, id, itemToId = defaultItemToId3) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId3(v, id, itemToId = defaultItemToId3) {
  const item = itemById3(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize3 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText3 = (item) => sanitize3(item.dataset.valuetext ?? item.textContent ?? "");
var match4 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap4 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText3(v, text, currentId, itemToId = defaultItemToId3) {
  const index = currentId ? indexOfId3(v, currentId, itemToId) : -1;
  let items = currentId ? wrap4(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match4(getValueText3(item), text));
}
function getByTypeaheadImpl3(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText3(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead3 = Object.assign(getByTypeaheadImpl3, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent3
});
function isValidTypeaheadEvent3(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var fps3 = 1e3 / 60;

// node_modules/@zag-js/dom-event/dist/index.mjs
function clamp(value) {
  return Math.max(0, Math.min(1, value));
}
function getRelativePoint(point, element) {
  const { left, top, width, height } = element.getBoundingClientRect();
  const offset4 = { x: point.x - left, y: point.y - top };
  const percent = { x: clamp(offset4.x / width), y: clamp(offset4.y / height) };
  function getPercentValue3(options = {}) {
    const { dir = "ltr", orientation = "horizontal", inverted } = options;
    const invertX = typeof inverted === "object" ? inverted.x : inverted;
    const invertY = typeof inverted === "object" ? inverted.y : inverted;
    if (orientation === "horizontal") {
      return dir === "rtl" || invertX ? 1 - percent.x : percent.x;
    }
    return invertY ? 1 - percent.y : percent.y;
  }
  return { offset: offset4, percent, getPercentValue: getPercentValue3 };
}

// node_modules/@zag-js/accordion/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument2 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow2 = (el) => el != null && el === el.window;
function getDocument3(el) {
  if (isDocument2(el)) return el;
  if (isWindow2(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId4 = (v) => v.id;
function itemById4(v, id, itemToId = defaultItemToId4) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId4(v, id, itemToId = defaultItemToId4) {
  const item = itemById4(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
function nextById2(v, id, loop = true) {
  let idx = indexOfId4(v, id);
  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
  return v[idx];
}
function prevById2(v, id, loop = true) {
  let idx = indexOfId4(v, id);
  if (idx === -1) return loop ? v[v.length - 1] : null;
  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
  return v[idx];
}
var sanitize4 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText4 = (item) => sanitize4(item.dataset.valuetext ?? item.textContent ?? "");
var match5 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap5 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText4(v, text, currentId, itemToId = defaultItemToId4) {
  const index = currentId ? indexOfId4(v, currentId, itemToId) : -1;
  let items = currentId ? wrap5(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match5(getValueText4(item), text));
}
function getByTypeaheadImpl4(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText4(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead4 = Object.assign(getByTypeaheadImpl4, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent4
});
function isValidTypeaheadEvent4(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function queryAll2(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function createScope2(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument3(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps4 = 1e3 / 60;

// node_modules/@zag-js/utils/dist/index.mjs
var first = (v) => v[0];
var last = (v) => v[v.length - 1];
var isArrayLike = (value) => (value == null ? void 0 : value.constructor.name) === "Array";
var isArrayEqual = (a, b) => {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (!isEqual(a[i], b[i])) return false;
  }
  return true;
};
var isEqual = (a, b) => {
  if (Object.is(a, b)) return true;
  if (a == null && b != null || a != null && b == null) return false;
  if (typeof (a == null ? void 0 : a.isEqual) === "function" && typeof (b == null ? void 0 : b.isEqual) === "function") {
    return a.isEqual(b);
  }
  if (typeof a === "function" && typeof b === "function") {
    return a.toString() === b.toString();
  }
  if (isArrayLike(a) && isArrayLike(b)) {
    return isArrayEqual(Array.from(a), Array.from(b));
  }
  if (!(typeof a === "object") || !(typeof b === "object")) return false;
  const keys = Object.keys(b ?? /* @__PURE__ */ Object.create(null));
  const length2 = keys.length;
  for (let i = 0; i < length2; i++) {
    const hasKey = Reflect.has(a, keys[i]);
    if (!hasKey) return false;
  }
  for (let i = 0; i < length2; i++) {
    const key = keys[i];
    if (!isEqual(a[key], b[key])) return false;
  }
  return true;
};
var isArray = (v) => Array.isArray(v);
var isObject3 = (v) => !(v == null || typeof v !== "object" || isArray(v));
var hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
function splitProps2(props52, keys) {
  const rest = {};
  const result = {};
  const keySet = new Set(keys);
  for (const key in props52) {
    if (keySet.has(key)) {
      result[key] = props52[key];
    } else {
      rest[key] = props52[key];
    }
  }
  return [result, rest];
}
var createSplitProps = (keys) => {
  return function split(props52) {
    return splitProps2(props52, keys);
  };
};

// node_modules/proxy-compare/dist/index.js
var TRACK_MEMO_SYMBOL = Symbol();
var GET_ORIGINAL_SYMBOL = Symbol();
var AFFECTED_PROPERTY = "a";
var IS_TARGET_COPIED_PROPERTY = "f";
var PROXY_PROPERTY = "p";
var PROXY_CACHE_PROPERTY = "c";
var TARGET_CACHE_PROPERTY = "t";
var NEXT_OBJECT_PROPERTY = "n";
var CHANGED_PROPERTY = "g";
var HAS_KEY_PROPERTY = "h";
var ALL_OWN_KEYS_PROPERTY = "w";
var HAS_OWN_KEY_PROPERTY = "o";
var KEYS_PROPERTY = "k";
var newProxy = (target, handler) => new Proxy(target, handler);
var getProto = Object.getPrototypeOf;
var objectsToTrack = /* @__PURE__ */ new WeakMap();
var isObjectToTrack = (obj) => obj && (objectsToTrack.has(obj) ? objectsToTrack.get(obj) : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);
var isObject4 = (x) => typeof x === "object" && x !== null;
var needsToCopyTargetObject = (obj) => Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor) => !descriptor.configurable && !descriptor.writable);
var copyTargetObject = (obj) => {
  if (Array.isArray(obj)) {
    return Array.from(obj);
  }
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  Object.values(descriptors).forEach((desc) => {
    desc.configurable = true;
  });
  return Object.create(getProto(obj), descriptors);
};
var createProxyHandler = (origObj, isTargetCopied) => {
  const state2 = {
    [IS_TARGET_COPIED_PROPERTY]: isTargetCopied
  };
  let trackObject = false;
  const recordUsage = (type, key) => {
    if (!trackObject) {
      let used = state2[AFFECTED_PROPERTY].get(origObj);
      if (!used) {
        used = {};
        state2[AFFECTED_PROPERTY].set(origObj, used);
      }
      if (type === ALL_OWN_KEYS_PROPERTY) {
        used[ALL_OWN_KEYS_PROPERTY] = true;
      } else {
        let set18 = used[type];
        if (!set18) {
          set18 = /* @__PURE__ */ new Set();
          used[type] = set18;
        }
        set18.add(key);
      }
    }
  };
  const recordObjectAsUsed = () => {
    trackObject = true;
    state2[AFFECTED_PROPERTY].delete(origObj);
  };
  const handler = {
    get(target, key) {
      if (key === GET_ORIGINAL_SYMBOL) {
        return origObj;
      }
      recordUsage(KEYS_PROPERTY, key);
      return createProxy2(Reflect.get(target, key), state2[AFFECTED_PROPERTY], state2[PROXY_CACHE_PROPERTY], state2[TARGET_CACHE_PROPERTY]);
    },
    has(target, key) {
      if (key === TRACK_MEMO_SYMBOL) {
        recordObjectAsUsed();
        return true;
      }
      recordUsage(HAS_KEY_PROPERTY, key);
      return Reflect.has(target, key);
    },
    getOwnPropertyDescriptor(target, key) {
      recordUsage(HAS_OWN_KEY_PROPERTY, key);
      return Reflect.getOwnPropertyDescriptor(target, key);
    },
    ownKeys(target) {
      recordUsage(ALL_OWN_KEYS_PROPERTY);
      return Reflect.ownKeys(target);
    }
  };
  if (isTargetCopied) {
    handler.set = handler.deleteProperty = () => false;
  }
  return [handler, state2];
};
var getOriginalObject = (obj) => (
  // unwrap proxy
  obj[GET_ORIGINAL_SYMBOL] || // otherwise
  obj
);
var createProxy2 = (obj, affected, proxyCache, targetCache2) => {
  if (!isObjectToTrack(obj))
    return obj;
  let targetAndCopied = targetCache2 && targetCache2.get(obj);
  if (!targetAndCopied) {
    const target2 = getOriginalObject(obj);
    if (needsToCopyTargetObject(target2)) {
      targetAndCopied = [target2, copyTargetObject(target2)];
    } else {
      targetAndCopied = [target2];
    }
    targetCache2 === null || targetCache2 === void 0 ? void 0 : targetCache2.set(obj, targetAndCopied);
  }
  const [target, copiedTarget] = targetAndCopied;
  let handlerAndState = proxyCache && proxyCache.get(target);
  if (!handlerAndState || handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {
    handlerAndState = createProxyHandler(target, !!copiedTarget);
    handlerAndState[1][PROXY_PROPERTY] = newProxy(copiedTarget || target, handlerAndState[0]);
    if (proxyCache) {
      proxyCache.set(target, handlerAndState);
    }
  }
  handlerAndState[1][AFFECTED_PROPERTY] = affected;
  handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache;
  handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache2;
  return handlerAndState[1][PROXY_PROPERTY];
};
var isAllOwnKeysChanged = (prevObj, nextObj) => {
  const prevKeys = Reflect.ownKeys(prevObj);
  const nextKeys = Reflect.ownKeys(nextObj);
  return prevKeys.length !== nextKeys.length || prevKeys.some((k, i) => k !== nextKeys[i]);
};
var isChanged = (prevObj, nextObj, affected, cache2, isEqual6 = Object.is) => {
  if (isEqual6(prevObj, nextObj)) {
    return false;
  }
  if (!isObject4(prevObj) || !isObject4(nextObj))
    return true;
  const used = affected.get(getOriginalObject(prevObj));
  if (!used)
    return true;
  if (cache2) {
    const hit = cache2.get(prevObj);
    if (hit && hit[NEXT_OBJECT_PROPERTY] === nextObj) {
      return hit[CHANGED_PROPERTY];
    }
    cache2.set(prevObj, {
      [NEXT_OBJECT_PROPERTY]: nextObj,
      [CHANGED_PROPERTY]: false
    });
  }
  let changed = null;
  try {
    for (const key of used[HAS_KEY_PROPERTY] || []) {
      changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);
      if (changed)
        return changed;
    }
    if (used[ALL_OWN_KEYS_PROPERTY] === true) {
      changed = isAllOwnKeysChanged(prevObj, nextObj);
      if (changed)
        return changed;
    } else {
      for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {
        const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);
        const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);
        changed = hasPrev !== hasNext;
        if (changed)
          return changed;
      }
    }
    for (const key of used[KEYS_PROPERTY] || []) {
      changed = isChanged(prevObj[key], nextObj[key], affected, cache2, isEqual6);
      if (changed)
        return changed;
    }
    if (changed === null)
      changed = true;
    return changed;
  } finally {
    if (cache2) {
      cache2.set(prevObj, {
        [NEXT_OBJECT_PROPERTY]: nextObj,
        [CHANGED_PROPERTY]: changed
      });
    }
  }
};
var getUntracked = (obj) => {
  if (isObjectToTrack(obj)) {
    return obj[GET_ORIGINAL_SYMBOL] || null;
  }
  return null;
};
var markToTrack = (obj, mark = true) => {
  objectsToTrack.set(obj, mark);
};

// node_modules/@zag-js/accordion/node_modules/@zag-js/store/dist/index.mjs
function getGlobal() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal(key, value) {
  const g = getGlobal();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev = () => true;
var isObject5 = (x) => typeof x === "object" && x !== null;
var proxyStateMap = makeGlobal("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet = makeGlobal("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject5(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap.has(value)) {
      snap[key] = snapshot(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject5(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject5(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxy(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return proxyFunction(initialObject);
}
function snapshot(proxyObject, handlePromise) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (isDev() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/klona/full/index.mjs
function set2(obj, key, val) {
  if (typeof val.value === "object") val.value = klona(val.value);
  if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === "__proto__") {
    Object.defineProperty(obj, key, val);
  } else obj[key] = val.value;
}
function klona(x) {
  if (typeof x !== "object") return x;
  var i = 0, k, list, tmp, str = Object.prototype.toString.call(x);
  if (str === "[object Object]") {
    tmp = Object.create(x.__proto__ || null);
  } else if (str === "[object Array]") {
    tmp = Array(x.length);
  } else if (str === "[object Set]") {
    tmp = /* @__PURE__ */ new Set();
    x.forEach(function(val) {
      tmp.add(klona(val));
    });
  } else if (str === "[object Map]") {
    tmp = /* @__PURE__ */ new Map();
    x.forEach(function(val, key) {
      tmp.set(klona(key), klona(val));
    });
  } else if (str === "[object Date]") {
    tmp = /* @__PURE__ */ new Date(+x);
  } else if (str === "[object RegExp]") {
    tmp = new RegExp(x.source, x.flags);
  } else if (str === "[object DataView]") {
    tmp = new x.constructor(klona(x.buffer));
  } else if (str === "[object ArrayBuffer]") {
    tmp = x.slice(0);
  } else if (str.slice(-6) === "Array]") {
    tmp = new x.constructor(x);
  }
  if (tmp) {
    for (list = Object.getOwnPropertySymbols(x); i < list.length; i++) {
      set2(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));
    }
    for (i = 0, list = Object.getOwnPropertyNames(x); i < list.length; i++) {
      if (Object.hasOwnProperty.call(tmp, k = list[i]) && tmp[k] === x[k]) continue;
      set2(tmp, k, Object.getOwnPropertyDescriptor(x, k));
    }
  }
  return tmp || x;
}

// node_modules/@zag-js/accordion/node_modules/@zag-js/core/dist/index.mjs
var isString2 = (v) => typeof v === "string";
var isFunction2 = (v) => typeof v === "function";
function exec(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString2(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction2(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards = { or, and, not, stateIn };

// node_modules/@zag-js/accordion/node_modules/@zag-js/types/dist/index.mjs
var createProps2 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/accordion/dist/index.mjs
var anatomy = createAnatomy("accordion").parts("root", "item", "itemTrigger", "itemContent", "itemIndicator");
var parts = anatomy.build();
var dom = createScope2({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `accordion:${ctx.id}`;
  },
  getItemId: (ctx, value) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.item) == null ? void 0 : _b6.call(_a7, value)) ?? `accordion:${ctx.id}:item:${value}`;
  },
  getItemContentId: (ctx, value) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemContent) == null ? void 0 : _b6.call(_a7, value)) ?? `accordion:${ctx.id}:content:${value}`;
  },
  getItemTriggerId: (ctx, value) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemTrigger) == null ? void 0 : _b6.call(_a7, value)) ?? `accordion:${ctx.id}:trigger:${value}`;
  },
  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),
  getTriggerEls: (ctx) => {
    const ownerId = CSS.escape(dom.getRootId(ctx));
    const selector = `[aria-controls][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll2(dom.getRootEl(ctx), selector);
  },
  getFirstTriggerEl: (ctx) => first(dom.getTriggerEls(ctx)),
  getLastTriggerEl: (ctx) => last(dom.getTriggerEls(ctx)),
  getNextTriggerEl: (ctx, id) => nextById2(dom.getTriggerEls(ctx), dom.getItemTriggerId(ctx, id)),
  getPrevTriggerEl: (ctx, id) => prevById2(dom.getTriggerEls(ctx), dom.getItemTriggerId(ctx, id))
});
var { and: and2, not: not2 } = guards;
var props = createProps2()([
  "collapsible",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "multiple",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "value"
]);
var splitProps3 = createSplitProps(props);
var itemProps = createProps2()(["value", "disabled"]);
var splitItemProps = createSplitProps(itemProps);

// node_modules/@zag-js/avatar/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument3 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow3 = (el) => el != null && el === el.window;
function getDocument4(el) {
  if (isDocument3(el)) return el;
  if (isWindow3(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId5 = (v) => v.id;
function itemById5(v, id, itemToId = defaultItemToId5) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId5(v, id, itemToId = defaultItemToId5) {
  const item = itemById5(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize5 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText5 = (item) => sanitize5(item.dataset.valuetext ?? item.textContent ?? "");
var match6 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap6 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText5(v, text, currentId, itemToId = defaultItemToId5) {
  const index = currentId ? indexOfId5(v, currentId, itemToId) : -1;
  let items = currentId ? wrap6(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match6(getValueText5(item), text));
}
function getByTypeaheadImpl5(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText5(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead5 = Object.assign(getByTypeaheadImpl5, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent5
});
function isValidTypeaheadEvent5(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function createScope3(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument4(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps5 = 1e3 / 60;

// node_modules/@zag-js/avatar/node_modules/@zag-js/store/dist/index.mjs
function getGlobal2() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal2(key, value) {
  const g = getGlobal2();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev2 = () => true;
var isObject6 = (x) => typeof x === "object" && x !== null;
var proxyStateMap2 = makeGlobal2("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet2 = makeGlobal2("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction2 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject6(x) && !refSet2.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet2.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap2.has(value)) {
      snap[key] = snapshot2(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject6(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev2() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev2() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject6(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap2.has(value) && canProxy(value)) {
          nextValue = proxy2(value);
        }
        const childProxyState = !refSet2.has(nextValue) && proxyStateMap2.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap2.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap2,
  refSet2,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction2] = buildProxyFunction2();
function proxy2(initialObject = {}) {
  return proxyFunction2(initialObject);
}
function snapshot2(proxyObject, handlePromise) {
  const proxyState = proxyStateMap2.get(proxyObject);
  if (isDev2() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/avatar/node_modules/@zag-js/types/dist/index.mjs
var createProps3 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/avatar/dist/index.mjs
var anatomy2 = createAnatomy("avatar").parts("root", "image", "fallback");
var parts2 = anatomy2.build();
var dom2 = createScope3({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `avatar:${ctx.id}`;
  },
  getImageId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.image) ?? `avatar:${ctx.id}:image`;
  },
  getFallbackId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.fallback) ?? `avatar:${ctx.id}:fallback`;
  },
  getRootEl: (ctx) => dom2.getById(ctx, dom2.getRootId(ctx)),
  getImageEl: (ctx) => dom2.getById(ctx, dom2.getImageId(ctx))
});
var props2 = createProps3()(["dir", "id", "ids", "onStatusChange", "getRootNode"]);
var splitProps4 = createSplitProps(props2);

// node_modules/@zag-js/carousel/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument4 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow4 = (el) => el != null && el === el.window;
function getDocument5(el) {
  if (isDocument4(el)) return el;
  if (isWindow4(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId6 = (v) => v.id;
function itemById6(v, id, itemToId = defaultItemToId6) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId6(v, id, itemToId = defaultItemToId6) {
  const item = itemById6(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize6 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText6 = (item) => sanitize6(item.dataset.valuetext ?? item.textContent ?? "");
var match7 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap7 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText6(v, text, currentId, itemToId = defaultItemToId6) {
  const index = currentId ? indexOfId6(v, currentId, itemToId) : -1;
  let items = currentId ? wrap7(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match7(getValueText6(item), text));
}
function getByTypeaheadImpl6(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText6(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead6 = Object.assign(getByTypeaheadImpl6, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent6
});
function isValidTypeaheadEvent6(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function queryAll3(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function createScope4(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument5(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps6 = 1e3 / 60;

// node_modules/@zag-js/carousel/node_modules/@zag-js/store/dist/index.mjs
function getGlobal3() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal3(key, value) {
  const g = getGlobal3();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev3 = () => true;
var isObject7 = (x) => typeof x === "object" && x !== null;
var proxyStateMap3 = makeGlobal3("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet3 = makeGlobal3("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction3 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject7(x) && !refSet3.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet3.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap3.has(value)) {
      snap[key] = snapshot3(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject7(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev3() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev3() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject7(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap3.has(value) && canProxy(value)) {
          nextValue = proxy3(value);
        }
        const childProxyState = !refSet3.has(nextValue) && proxyStateMap3.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap3.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap3,
  refSet3,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction3] = buildProxyFunction3();
function proxy3(initialObject = {}) {
  return proxyFunction3(initialObject);
}
function snapshot3(proxyObject, handlePromise) {
  const proxyState = proxyStateMap3.get(proxyObject);
  if (isDev3() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/carousel/node_modules/@zag-js/types/dist/index.mjs
var createProps4 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/carousel/dist/index.mjs
var anatomy3 = createAnatomy("carousel").parts(
  "root",
  "viewport",
  "itemGroup",
  "item",
  "nextTrigger",
  "prevTrigger",
  "indicatorGroup",
  "indicator"
);
var parts3 = anatomy3.build();
var dom3 = createScope4({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `carousel:${ctx.id}`;
  },
  getViewportId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.viewport) ?? `carousel:${ctx.id}:viewport`;
  },
  getItemId: (ctx, index) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.item) == null ? void 0 : _b6.call(_a7, index)) ?? `carousel:${ctx.id}:item:${index}`;
  },
  getItemGroupId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.itemGroup) ?? `carousel:${ctx.id}:item-group`;
  },
  getNextTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.nextTrigger) ?? `carousel:${ctx.id}:next-trigger`;
  },
  getPrevTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.prevTrigger) ?? `carousel:${ctx.id}:prev-trigger`;
  },
  getIndicatorGroupId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.indicatorGroup) ?? `carousel:${ctx.id}:indicator-group`;
  },
  getIndicatorId: (ctx, index) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.indicator) == null ? void 0 : _b6.call(_a7, index)) ?? `carousel:${ctx.id}:indicator:${index}`;
  },
  getRootEl: (ctx) => dom3.getById(ctx, dom3.getRootId(ctx)),
  getViewportEl: (ctx) => dom3.getById(ctx, dom3.getViewportId(ctx)),
  getSlideGroupEl: (ctx) => dom3.getById(ctx, dom3.getItemGroupId(ctx)),
  getSlideEls: (ctx) => queryAll3(dom3.getSlideGroupEl(ctx), `[data-part=item]`)
});
var props3 = createProps4()([
  "align",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "index",
  "loop",
  "onIndexChange",
  "orientation",
  "slidesPerView",
  "spacing"
]);
var splitProps5 = createSplitProps(props3);
var indicatorProps = createProps4()(["index", "readOnly"]);
var splitIndicatorProps = createSplitProps(indicatorProps);

// node_modules/@ark-ui/anatomy/dist/carousel/index.js
var anatomy4 = anatomy3.extendWith("control");

// node_modules/@zag-js/checkbox/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument5 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow5 = (el) => el != null && el === el.window;
function getDocument6(el) {
  if (isDocument5(el)) return el;
  if (isWindow5(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId7 = (v) => v.id;
function itemById7(v, id, itemToId = defaultItemToId7) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId7(v, id, itemToId = defaultItemToId7) {
  const item = itemById7(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize7 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText7 = (item) => sanitize7(item.dataset.valuetext ?? item.textContent ?? "");
var match8 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap8 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText7(v, text, currentId, itemToId = defaultItemToId7) {
  const index = currentId ? indexOfId7(v, currentId, itemToId) : -1;
  let items = currentId ? wrap8(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match8(getValueText7(item), text));
}
function getByTypeaheadImpl7(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText7(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead7 = Object.assign(getByTypeaheadImpl7, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent7
});
function isValidTypeaheadEvent7(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function createScope5(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument6(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps7 = 1e3 / 60;

// node_modules/@zag-js/checkbox/node_modules/@zag-js/store/dist/index.mjs
function getGlobal4() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal4(key, value) {
  const g = getGlobal4();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev4 = () => true;
var isObject8 = (x) => typeof x === "object" && x !== null;
var proxyStateMap4 = makeGlobal4("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet4 = makeGlobal4("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction4 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject8(x) && !refSet4.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet4.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap4.has(value)) {
      snap[key] = snapshot4(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject8(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev4() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev4() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject8(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap4.has(value) && canProxy(value)) {
          nextValue = proxy4(value);
        }
        const childProxyState = !refSet4.has(nextValue) && proxyStateMap4.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap4.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap4,
  refSet4,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction4] = buildProxyFunction4();
function proxy4(initialObject = {}) {
  return proxyFunction4(initialObject);
}
function snapshot4(proxyObject, handlePromise) {
  const proxyState = proxyStateMap4.get(proxyObject);
  if (isDev4() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/checkbox/node_modules/@zag-js/core/dist/index.mjs
var isString3 = (v) => typeof v === "string";
var isFunction3 = (v) => typeof v === "function";
function exec2(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString3(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction3(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or2(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec2(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and3(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec2(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not3(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec2(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn2(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards2 = { or: or2, and: and3, not: not3, stateIn: stateIn2 };

// node_modules/@zag-js/form-utils/dist/index.mjs
var getWindow3 = (el) => el.ownerDocument.defaultView || window;
function getDescriptor(el, options) {
  const { type = "HTMLInputElement", property = "value" } = options;
  const proto = getWindow3(el)[type].prototype;
  return Object.getOwnPropertyDescriptor(proto, property) ?? {};
}
function setElementValue(el, value, option = {}) {
  var _a7;
  const descriptor = getDescriptor(el, option);
  (_a7 = descriptor.set) == null ? void 0 : _a7.call(el, value);
  el.setAttribute("value", value);
}
function dispatchInputValueEvent(el, options) {
  const { value, bubbles = true } = options;
  if (!el) return;
  const win = getWindow3(el);
  if (!(el instanceof win.HTMLInputElement)) return;
  setElementValue(el, `${value}`);
  el.dispatchEvent(new win.Event("input", { bubbles }));
}

// node_modules/@zag-js/checkbox/node_modules/@zag-js/types/dist/index.mjs
var createProps5 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/checkbox/dist/index.mjs
var anatomy5 = createAnatomy("checkbox").parts("root", "label", "control", "indicator");
var parts4 = anatomy5.build();
var dom4 = createScope5({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `checkbox:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `checkbox:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `checkbox:${ctx.id}:control`;
  },
  getHiddenInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.hiddenInput) ?? `checkbox:${ctx.id}:input`;
  },
  getRootEl: (ctx) => dom4.getById(ctx, dom4.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom4.getById(ctx, dom4.getHiddenInputId(ctx))
});
var { not: not4 } = guards2;
var props4 = createProps5()([
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
var splitProps6 = createSplitProps(props4);

// node_modules/@ark-ui/anatomy/dist/checkbox/index.js
var anatomy6 = anatomy5.extendWith("group");

// node_modules/@zag-js/clipboard/node_modules/@zag-js/dom-query/dist/index.mjs
var isHTMLElement3 = (v) => typeof v === "object" && (v == null ? void 0 : v.nodeType) === Node.ELEMENT_NODE && typeof (v == null ? void 0 : v.nodeName) === "string";
var isDocument6 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow6 = (el) => el != null && el === el.window;
var isNode2 = (el) => el.nodeType !== void 0;
var isShadowRoot2 = (el) => el && isNode2(el) && el.nodeType === Node.DOCUMENT_FRAGMENT_NODE && "host" in el;
function getDocument7(el) {
  if (isDocument6(el)) return el;
  if (isWindow6(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
function getWindow4(el) {
  var _a7;
  if (isShadowRoot2(el)) return getWindow4(el.host);
  if (isDocument6(el)) return el.defaultView ?? window;
  if (isHTMLElement3(el)) return ((_a7 = el.ownerDocument) == null ? void 0 : _a7.defaultView) ?? window;
  return window;
}
var defaultItemToId8 = (v) => v.id;
function itemById8(v, id, itemToId = defaultItemToId8) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId8(v, id, itemToId = defaultItemToId8) {
  const item = itemById8(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize8 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText8 = (item) => sanitize8(item.dataset.valuetext ?? item.textContent ?? "");
var match9 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap9 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText8(v, text, currentId, itemToId = defaultItemToId8) {
  const index = currentId ? indexOfId8(v, currentId, itemToId) : -1;
  let items = currentId ? wrap9(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match9(getValueText8(item), text));
}
function getByTypeaheadImpl8(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText8(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead8 = Object.assign(getByTypeaheadImpl8, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent8
});
function isValidTypeaheadEvent8(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function createScope6(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument7(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps8 = 1e3 / 60;

// node_modules/@zag-js/clipboard/node_modules/@zag-js/store/dist/index.mjs
function getGlobal5() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal5(key, value) {
  const g = getGlobal5();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev5 = () => true;
var isObject9 = (x) => typeof x === "object" && x !== null;
var proxyStateMap5 = makeGlobal5("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet5 = makeGlobal5("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction5 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject9(x) && !refSet5.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet5.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap5.has(value)) {
      snap[key] = snapshot5(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject9(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev5() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev5() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject9(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap5.has(value) && canProxy(value)) {
          nextValue = proxy5(value);
        }
        const childProxyState = !refSet5.has(nextValue) && proxyStateMap5.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap5.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap5,
  refSet5,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction5] = buildProxyFunction5();
function proxy5(initialObject = {}) {
  return proxyFunction5(initialObject);
}
function snapshot5(proxyObject, handlePromise) {
  const proxyState = proxyStateMap5.get(proxyObject);
  if (isDev5() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/clipboard/node_modules/@zag-js/types/dist/index.mjs
var createProps6 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/clipboard/dist/index.mjs
var anatomy7 = createAnatomy("clipboard").parts("root", "control", "trigger", "indicator", "input", "label");
var parts5 = anatomy7.build();
var dom5 = createScope6({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `clip:${ctx.id}`;
  },
  getInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.input) ?? `clip:${ctx.id}:input`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `clip:${ctx.id}:label`;
  },
  getInputEl: (ctx) => dom5.getById(ctx, dom5.getInputId(ctx)),
  writeToClipboard: (ctx) => copyText(dom5.getDoc(ctx), ctx.value)
});
function createNode(doc, text) {
  const node2 = doc.createElement("pre");
  Object.assign(node2.style, {
    width: "1px",
    height: "1px",
    position: "fixed",
    top: "5px"
  });
  node2.textContent = text;
  return node2;
}
function copyNode(node2) {
  const win = getWindow4(node2);
  const selection = win.getSelection();
  if (selection == null) {
    return Promise.reject(new Error());
  }
  selection.removeAllRanges();
  const doc = node2.ownerDocument;
  const range2 = doc.createRange();
  range2.selectNodeContents(node2);
  selection.addRange(range2);
  doc.execCommand("copy");
  selection.removeAllRanges();
  return Promise.resolve();
}
function copyText(doc, text) {
  var _a7;
  const win = doc.defaultView || window;
  if (((_a7 = win.navigator.clipboard) == null ? void 0 : _a7.writeText) !== void 0) {
    return win.navigator.clipboard.writeText(text);
  }
  if (!doc.body) {
    return Promise.reject(new Error());
  }
  const node2 = createNode(doc, text);
  doc.body.appendChild(node2);
  copyNode(node2);
  doc.body.removeChild(node2);
  return Promise.resolve();
}
var props5 = createProps6()([
  "getRootNode",
  "id",
  "ids",
  "value",
  "timeout",
  "onStatusChange"
]);
var contextProps = createSplitProps(props5);
var indicatorProps2 = createProps6()(["copied"]);
var splitIndicatorProps2 = createSplitProps(indicatorProps2);

// node_modules/@zag-js/collapsible/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument7 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow7 = (el) => el != null && el === el.window;
function getDocument8(el) {
  if (isDocument7(el)) return el;
  if (isWindow7(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId9 = (v) => v.id;
function itemById9(v, id, itemToId = defaultItemToId9) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId9(v, id, itemToId = defaultItemToId9) {
  const item = itemById9(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize9 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText9 = (item) => sanitize9(item.dataset.valuetext ?? item.textContent ?? "");
var match10 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap10 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText9(v, text, currentId, itemToId = defaultItemToId9) {
  const index = currentId ? indexOfId9(v, currentId, itemToId) : -1;
  let items = currentId ? wrap10(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match10(getValueText9(item), text));
}
function getByTypeaheadImpl9(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText9(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead9 = Object.assign(getByTypeaheadImpl9, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent9
});
function isValidTypeaheadEvent9(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function createScope7(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument8(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps9 = 1e3 / 60;

// node_modules/@zag-js/collapsible/node_modules/@zag-js/store/dist/index.mjs
function getGlobal6() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal6(key, value) {
  const g = getGlobal6();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev6 = () => true;
var isObject10 = (x) => typeof x === "object" && x !== null;
var proxyStateMap6 = makeGlobal6("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet6 = makeGlobal6("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction6 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject10(x) && !refSet6.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet6.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap6.has(value)) {
      snap[key] = snapshot6(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject10(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev6() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev6() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject10(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap6.has(value) && canProxy(value)) {
          nextValue = proxy6(value);
        }
        const childProxyState = !refSet6.has(nextValue) && proxyStateMap6.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap6.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap6,
  refSet6,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction6] = buildProxyFunction6();
function proxy6(initialObject = {}) {
  return proxyFunction6(initialObject);
}
function snapshot6(proxyObject, handlePromise) {
  const proxyState = proxyStateMap6.get(proxyObject);
  if (isDev6() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/collapsible/node_modules/@zag-js/types/dist/index.mjs
var createProps7 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/collapsible/dist/index.mjs
var anatomy8 = createAnatomy("collapsible").parts("root", "trigger", "content");
var parts6 = anatomy8.build();
var dom6 = createScope7({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `collapsible:${ctx.id}`;
  },
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `collapsible:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `collapsible:${ctx.id}:trigger`;
  },
  getRootEl: (ctx) => dom6.getById(ctx, dom6.getRootId(ctx)),
  getContentEl: (ctx) => dom6.getById(ctx, dom6.getContentId(ctx)),
  getTriggerEl: (ctx) => dom6.getById(ctx, dom6.getTriggerId(ctx))
});
var props6 = createProps7()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "onExitComplete",
  "onOpenChange",
  "open.controlled",
  "open"
]);
var splitProps7 = createSplitProps(props6);

// node_modules/@zag-js/numeric-range/dist/index.mjs
function getRoundedValue(value, minValue, step) {
  return Math.round((value - minValue) / step) * step + minValue;
}
function clampValue(value, minValue, maxValue2) {
  return Math.min(Math.max(value, minValue), maxValue2);
}
function getValuePercent(value, minValue, maxValue2) {
  return (value - minValue) / (maxValue2 - minValue);
}
function getPercentValue(percent, minValue, maxValue2, step) {
  const value = percent * (maxValue2 - minValue) + minValue;
  const roundedValue = getRoundedValue(value, minValue, step);
  return clampValue(roundedValue, minValue, maxValue2);
}
function roundToStepPrecision(value, step) {
  let roundedValue = value;
  let stepString = step.toString();
  let pointIndex = stepString.indexOf(".");
  let precision = pointIndex >= 0 ? stepString.length - pointIndex : 0;
  if (precision > 0) {
    let pow = Math.pow(10, precision);
    roundedValue = Math.round(roundedValue * pow) / pow;
  }
  return roundedValue;
}
function snapValueToStep(value, min4, max4, step) {
  min4 = Number(min4);
  max4 = Number(max4);
  let remainder = (value - (isNaN(min4) ? 0 : min4)) % step;
  let snappedValue = roundToStepPrecision(
    Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder,
    step
  );
  if (!isNaN(min4)) {
    if (snappedValue < min4) {
      snappedValue = min4;
    } else if (!isNaN(max4) && snappedValue > max4) {
      snappedValue = min4 + Math.floor(roundToStepPrecision((max4 - min4) / step, step)) * step;
    }
  } else if (!isNaN(max4) && snappedValue > max4) {
    snappedValue = Math.floor(roundToStepPrecision(max4 / step, step)) * step;
  }
  snappedValue = roundToStepPrecision(snappedValue, step);
  return snappedValue;
}
function getValueTransformer(valueA, valueB) {
  const input = { min: valueA[0], max: valueA[1] };
  const output = { min: valueB[0], max: valueB[1] };
  return function getValue(value) {
    if (input.min === input.max || output.min === output.max) return output.min;
    const ratio = (output.max - output.min) / (input.max - input.min);
    return output.min + ratio * (value - input.min);
  };
}
function toFixedNumber(value, digits = 0, base = 10) {
  const pow = Math.pow(base, digits);
  return Math.round(value * pow) / pow;
}
function mod(value, modulo) {
  return (value % modulo + modulo) % modulo;
}

// node_modules/@zag-js/color-utils/dist/index.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var isEqualObject = (a, b) => {
  if (Object.keys(a).length !== Object.keys(b).length) return false;
  for (let key in a) if (a[key] !== b[key]) return false;
  return true;
};
var Color = class {
  toHexInt() {
    return this.toFormat("rgba").toHexInt();
  }
  getChannelValue(channel) {
    if (channel in this) return this[channel];
    throw new Error("Unsupported color channel: " + channel);
  }
  getChannelValuePercent(channel, valueToCheck) {
    const value = valueToCheck ?? this.getChannelValue(channel);
    const { minValue, maxValue: maxValue2 } = this.getChannelRange(channel);
    return getValuePercent(value, minValue, maxValue2);
  }
  getChannelPercentValue(channel, percentToCheck) {
    const { minValue, maxValue: maxValue2, step } = this.getChannelRange(channel);
    const percentValue = getPercentValue(percentToCheck, minValue, maxValue2, step);
    return snapValueToStep(percentValue, minValue, maxValue2, step);
  }
  withChannelValue(channel, value) {
    const { minValue, maxValue: maxValue2 } = this.getChannelRange(channel);
    if (channel in this) {
      let clone = this.clone();
      clone[channel] = clampValue(value, minValue, maxValue2);
      return clone;
    }
    throw new Error("Unsupported color channel: " + channel);
  }
  getColorAxes(xyChannels) {
    let { xChannel, yChannel } = xyChannels;
    let xCh = xChannel || this.getChannels().find((c) => c !== yChannel);
    let yCh = yChannel || this.getChannels().find((c) => c !== xCh);
    let zCh = this.getChannels().find((c) => c !== xCh && c !== yCh);
    return { xChannel: xCh, yChannel: yCh, zChannel: zCh };
  }
  incrementChannel(channel, stepSize) {
    const { minValue, maxValue: maxValue2, step } = this.getChannelRange(channel);
    const value = snapValueToStep(
      clampValue(this.getChannelValue(channel) + stepSize, minValue, maxValue2),
      minValue,
      maxValue2,
      step
    );
    return this.withChannelValue(channel, value);
  }
  decrementChannel(channel, stepSize) {
    return this.incrementChannel(channel, -stepSize);
  }
  isEqual(color) {
    const isSame = isEqualObject(this.toJSON(), color.toJSON());
    return isSame && this.getChannelValue("alpha") === color.getChannelValue("alpha");
  }
};
var _RGBColor = class _RGBColor2 extends Color {
  constructor(red, green, blue, alpha) {
    super();
    this.red = red;
    this.green = green;
    this.blue = blue;
    this.alpha = alpha;
  }
  static parse(value) {
    let colors2 = [];
    if (/^#[\da-f]+$/i.test(value) && [4, 5, 7, 9].includes(value.length)) {
      const values = (value.length < 6 ? value.replace(/[^#]/gi, "$&$&") : value).slice(1).split("");
      while (values.length > 0) {
        colors2.push(parseInt(values.splice(0, 2).join(""), 16));
      }
      colors2[3] = colors2[3] !== void 0 ? colors2[3] / 255 : void 0;
    }
    const match50 = value.match(/^rgba?\((.*)\)$/);
    if (match50 == null ? void 0 : match50[1]) {
      colors2 = match50[1].split(",").map((value2) => Number(value2.trim())).map((num, i) => clampValue(num, 0, i < 3 ? 255 : 1));
    }
    return colors2.length < 3 ? void 0 : new _RGBColor2(colors2[0], colors2[1], colors2[2], colors2[3] ?? 1);
  }
  toString(format) {
    switch (format) {
      case "hex":
        return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0")).toUpperCase();
      case "hexa":
        return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0") + Math.round(this.alpha * 255).toString(16).padStart(2, "0")).toUpperCase();
      case "rgb":
        return `rgb(${this.red}, ${this.green}, ${this.blue})`;
      case "css":
      case "rgba":
        return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;
      case "hsl":
        return this.toHSL().toString("hsl");
      case "hsb":
        return this.toHSB().toString("hsb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "rgba":
        return this;
      case "hsba":
        return this.toHSB();
      case "hsla":
        return this.toHSL();
      default:
        throw new Error("Unsupported color conversion: rgb -> " + format);
    }
  }
  toHexInt() {
    return this.red << 16 | this.green << 8 | this.blue;
  }
  /**
   * Converts an RGB color value to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSBColor object.
   */
  toHSB() {
    const red = this.red / 255;
    const green = this.green / 255;
    const blue = this.blue / 255;
    const min4 = Math.min(red, green, blue);
    const brightness = Math.max(red, green, blue);
    const chroma = brightness - min4;
    const saturation = brightness === 0 ? 0 : chroma / brightness;
    let hue = 0;
    if (chroma !== 0) {
      switch (brightness) {
        case red:
          hue = (green - blue) / chroma + (green < blue ? 6 : 0);
          break;
        case green:
          hue = (blue - red) / chroma + 2;
          break;
        case blue:
          hue = (red - green) / chroma + 4;
          break;
      }
      hue /= 6;
    }
    return new HSBColor(
      toFixedNumber(hue * 360, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(brightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  /**
   * Converts an RGB color value to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSLColor object.
   */
  toHSL() {
    const red = this.red / 255;
    const green = this.green / 255;
    const blue = this.blue / 255;
    const min4 = Math.min(red, green, blue);
    const max4 = Math.max(red, green, blue);
    const lightness = (max4 + min4) / 2;
    const chroma = max4 - min4;
    let hue = -1;
    let saturation = -1;
    if (chroma === 0) {
      hue = saturation = 0;
    } else {
      saturation = chroma / (lightness < 0.5 ? max4 + min4 : 2 - max4 - min4);
      switch (max4) {
        case red:
          hue = (green - blue) / chroma + (green < blue ? 6 : 0);
          break;
        case green:
          hue = (blue - red) / chroma + 2;
          break;
        case blue:
          hue = (red - green) / chroma + 4;
          break;
      }
      hue /= 6;
    }
    return new HSLColor(
      toFixedNumber(hue * 360, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(lightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  clone() {
    return new _RGBColor2(this.red, this.green, this.blue, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "red":
      case "green":
      case "blue":
        return { style: "decimal" };
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "red":
      case "green":
      case "blue":
        return { minValue: 0, maxValue: 255, step: 1, pageSize: 17 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { r: this.red, g: this.green, b: this.blue, a: this.alpha };
  }
  getFormat() {
    return "rgba";
  }
  getChannels() {
    return _RGBColor2.colorChannels;
  }
};
__publicField(_RGBColor, "colorChannels", ["red", "green", "blue"]);
var RGBColor = _RGBColor;
var HSL_REGEX = /hsl\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsla\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
var _HSLColor = class _HSLColor2 extends Color {
  constructor(hue, saturation, lightness, alpha) {
    super();
    this.hue = hue;
    this.saturation = saturation;
    this.lightness = lightness;
    this.alpha = alpha;
  }
  static parse(value) {
    let m;
    if (m = value.match(HSL_REGEX)) {
      const [h, s, l, a] = (m[1] ?? m[2]).split(",").map((n) => Number(n.trim().replace("%", "")));
      return new _HSLColor2(mod(h, 360), clampValue(s, 0, 100), clampValue(l, 0, 100), clampValue(a ?? 1, 0, 1));
    }
  }
  toString(format) {
    switch (format) {
      case "hex":
        return this.toRGB().toString("hex");
      case "hexa":
        return this.toRGB().toString("hexa");
      case "hsl":
        return `hsl(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%)`;
      case "css":
      case "hsla":
        return `hsla(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%, ${this.alpha})`;
      case "hsb":
        return this.toHSB().toString("hsb");
      case "rgb":
        return this.toRGB().toString("rgb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "hsla":
        return this;
      case "hsba":
        return this.toHSB();
      case "rgba":
        return this.toRGB();
      default:
        throw new Error("Unsupported color conversion: hsl -> " + format);
    }
  }
  /**
   * Converts a HSL color to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV.
   * @returns An HSBColor object.
   */
  toHSB() {
    let saturation = this.saturation / 100;
    let lightness = this.lightness / 100;
    let brightness = lightness + saturation * Math.min(lightness, 1 - lightness);
    saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness);
    return new HSBColor(
      toFixedNumber(this.hue, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(brightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  /**
   * Converts a HSL color to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative.
   * @returns An RGBColor object.
   */
  toRGB() {
    let hue = this.hue;
    let saturation = this.saturation / 100;
    let lightness = this.lightness / 100;
    let a = saturation * Math.min(lightness, 1 - lightness);
    let fn = (n, k = (n + hue / 30) % 12) => lightness - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return new RGBColor(
      Math.round(fn(0) * 255),
      Math.round(fn(8) * 255),
      Math.round(fn(4) * 255),
      toFixedNumber(this.alpha, 2)
    );
  }
  clone() {
    return new _HSLColor2(this.hue, this.saturation, this.lightness, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "hue":
        return { style: "unit", unit: "degree", unitDisplay: "narrow" };
      case "saturation":
      case "lightness":
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    if (channel === "saturation" || channel === "lightness") {
      value /= 100;
    }
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "hue":
        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };
      case "saturation":
      case "lightness":
        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { h: this.hue, s: this.saturation, l: this.lightness, a: this.alpha };
  }
  getFormat() {
    return "hsla";
  }
  getChannels() {
    return _HSLColor2.colorChannels;
  }
};
__publicField(_HSLColor, "colorChannels", ["hue", "saturation", "lightness"]);
var HSLColor = _HSLColor;
var HSB_REGEX = /hsb\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsba\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
var _HSBColor = class _HSBColor2 extends Color {
  constructor(hue, saturation, brightness, alpha) {
    super();
    this.hue = hue;
    this.saturation = saturation;
    this.brightness = brightness;
    this.alpha = alpha;
  }
  static parse(value) {
    let m;
    if (m = value.match(HSB_REGEX)) {
      const [h, s, b, a] = (m[1] ?? m[2]).split(",").map((n) => Number(n.trim().replace("%", "")));
      return new _HSBColor2(mod(h, 360), clampValue(s, 0, 100), clampValue(b, 0, 100), clampValue(a ?? 1, 0, 1));
    }
  }
  toString(format) {
    switch (format) {
      case "css":
        return this.toHSL().toString("css");
      case "hex":
        return this.toRGB().toString("hex");
      case "hexa":
        return this.toRGB().toString("hexa");
      case "hsb":
        return `hsb(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%)`;
      case "hsba":
        return `hsba(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%, ${this.alpha})`;
      case "hsl":
        return this.toHSL().toString("hsl");
      case "rgb":
        return this.toRGB().toString("rgb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "hsba":
        return this;
      case "hsla":
        return this.toHSL();
      case "rgba":
        return this.toRGB();
      default:
        throw new Error("Unsupported color conversion: hsb -> " + format);
    }
  }
  /**
   * Converts a HSB color to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL.
   * @returns An HSLColor object.
   */
  toHSL() {
    let saturation = this.saturation / 100;
    let brightness = this.brightness / 100;
    let lightness = brightness * (1 - saturation / 2);
    saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness);
    return new HSLColor(
      toFixedNumber(this.hue, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(lightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  /**
   * Converts a HSV color value to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative.
   * @returns An RGBColor object.
   */
  toRGB() {
    let hue = this.hue;
    let saturation = this.saturation / 100;
    let brightness = this.brightness / 100;
    let fn = (n, k = (n + hue / 60) % 6) => brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0);
    return new RGBColor(
      Math.round(fn(5) * 255),
      Math.round(fn(3) * 255),
      Math.round(fn(1) * 255),
      toFixedNumber(this.alpha, 2)
    );
  }
  clone() {
    return new _HSBColor2(this.hue, this.saturation, this.brightness, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "hue":
        return { style: "unit", unit: "degree", unitDisplay: "narrow" };
      case "saturation":
      case "brightness":
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    if (channel === "saturation" || channel === "brightness") {
      value /= 100;
    }
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "hue":
        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };
      case "saturation":
      case "brightness":
        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { h: this.hue, s: this.saturation, b: this.brightness, a: this.alpha };
  }
  getFormat() {
    return "hsba";
  }
  getChannels() {
    return _HSBColor2.colorChannels;
  }
};
__publicField(_HSBColor, "colorChannels", ["hue", "saturation", "brightness"]);
var HSBColor = _HSBColor;
var nativeColors = "aliceblue:f0f8ff,antiquewhite:faebd7,aqua:00ffff,aquamarine:7fffd4,azure:f0ffff,beige:f5f5dc,bisque:ffe4c4,black:000000,blanchedalmond:ffebcd,blue:0000ff,blueviolet:8a2be2,brown:a52a2a,burlywood:deb887,cadetblue:5f9ea0,chartreuse:7fff00,chocolate:d2691e,coral:ff7f50,cornflowerblue:6495ed,cornsilk:fff8dc,crimson:dc143c,cyan:00ffff,darkblue:00008b,darkcyan:008b8b,darkgoldenrod:b8860b,darkgray:a9a9a9,darkgreen:006400,darkkhaki:bdb76b,darkmagenta:8b008b,darkolivegreen:556b2f,darkorange:ff8c00,darkorchid:9932cc,darkred:8b0000,darksalmon:e9967a,darkseagreen:8fbc8f,darkslateblue:483d8b,darkslategray:2f4f4f,darkturquoise:00ced1,darkviolet:9400d3,deeppink:ff1493,deepskyblue:00bfff,dimgray:696969,dodgerblue:1e90ff,firebrick:b22222,floralwhite:fffaf0,forestgreen:228b22,fuchsia:ff00ff,gainsboro:dcdcdc,ghostwhite:f8f8ff,gold:ffd700,goldenrod:daa520,gray:808080,green:008000,greenyellow:adff2f,honeydew:f0fff0,hotpink:ff69b4,indianred:cd5c5c,indigo:4b0082,ivory:fffff0,khaki:f0e68c,lavender:e6e6fa,lavenderblush:fff0f5,lawngreen:7cfc00,lemonchiffon:fffacd,lightblue:add8e6,lightcoral:f08080,lightcyan:e0ffff,lightgoldenrodyellow:fafad2,lightgrey:d3d3d3,lightgreen:90ee90,lightpink:ffb6c1,lightsalmon:ffa07a,lightseagreen:20b2aa,lightskyblue:87cefa,lightslategray:778899,lightsteelblue:b0c4de,lightyellow:ffffe0,lime:00ff00,limegreen:32cd32,linen:faf0e6,magenta:ff00ff,maroon:800000,mediumaquamarine:66cdaa,mediumblue:0000cd,mediumorchid:ba55d3,mediumpurple:9370d8,mediumseagreen:3cb371,mediumslateblue:7b68ee,mediumspringgreen:00fa9a,mediumturquoise:48d1cc,mediumvioletred:c71585,midnightblue:191970,mintcream:f5fffa,mistyrose:ffe4e1,moccasin:ffe4b5,navajowhite:ffdead,navy:000080,oldlace:fdf5e6,olive:808000,olivedrab:6b8e23,orange:ffa500,orangered:ff4500,orchid:da70d6,palegoldenrod:eee8aa,palegreen:98fb98,paleturquoise:afeeee,palevioletred:d87093,papayawhip:ffefd5,peachpuff:ffdab9,peru:cd853f,pink:ffc0cb,plum:dda0dd,powderblue:b0e0e6,purple:800080,red:ff0000,rosybrown:bc8f8f,royalblue:4169e1,saddlebrown:8b4513,salmon:fa8072,sandybrown:f4a460,seagreen:2e8b57,seashell:fff5ee,sienna:a0522d,silver:c0c0c0,skyblue:87ceeb,slateblue:6a5acd,slategray:708090,snow:fffafa,springgreen:00ff7f,steelblue:4682b4,tan:d2b48c,teal:008080,thistle:d8bfd8,tomato:ff6347,turquoise:40e0d0,violet:ee82ee,wheat:f5deb3,white:ffffff,whitesmoke:f5f5f5,yellow:ffff00,yellowgreen:9acd32";
var makeMap = (str) => {
  const map = /* @__PURE__ */ new Map();
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    const [key, val] = list[i].split(":");
    map.set(key, `#${val}`);
  }
  return map;
};
var nativeColorMap = makeMap(nativeColors);

// node_modules/@zag-js/color-picker/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument8 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow8 = (el) => el != null && el === el.window;
function getDocument9(el) {
  if (isDocument8(el)) return el;
  if (isWindow8(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId10 = (v) => v.id;
function itemById10(v, id, itemToId = defaultItemToId10) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId10(v, id, itemToId = defaultItemToId10) {
  const item = itemById10(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize10 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText10 = (item) => sanitize10(item.dataset.valuetext ?? item.textContent ?? "");
var match11 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap11 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText10(v, text, currentId, itemToId = defaultItemToId10) {
  const index = currentId ? indexOfId10(v, currentId, itemToId) : -1;
  let items = currentId ? wrap11(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match11(getValueText10(item), text));
}
function getByTypeaheadImpl10(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText10(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead10 = Object.assign(getByTypeaheadImpl10, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent10
});
function isValidTypeaheadEvent10(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function queryAll4(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function createScope8(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument9(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps10 = 1e3 / 60;

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp2(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length2 = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length2] > rects.floating[length2]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware2.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state2, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state2;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state2);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state2) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state2;
    const {
      element,
      padding = 0
    } = evaluate(options, state2) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length2 = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length2] + rects.reference[axis] - coords[axis] - rects.floating[length2];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length2];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length2] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max4 = clientSize - arrowDimensions[length2] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length2] / 2 + centerToReference;
    const offset4 = clamp2(min$1, center, max4);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length2] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length2] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max4 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state2) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state2);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex2 = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex2];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex2,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state2) {
      const {
        rects
      } = state2;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state2);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state2, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state2, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state2, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state2;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state2);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state2) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state2;
      const diffCoords = await convertValueToCoords(state2, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state2) {
      const {
        x,
        y,
        placement
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min4 = mainAxisCoord + overflow[minSide];
        const max4 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp2(min4, mainAxisCoord, max4);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min4 = crossAxisCoord + overflow[minSide];
        const max4 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp2(min4, crossAxisCoord, max4);
      }
      const limitedCoords = limiter.fn({
        ...state2,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state2) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state2;
      const {
        offset: offset4 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state2);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset4, state2);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state2) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state2;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state2.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state2.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state2.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state2,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName2(node2) {
  if (isNode3(node2)) {
    return (node2.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow5(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement2(node2) {
  var _ref;
  return (_ref = (isNode3(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode3(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow5(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow5(value).Element;
}
function isHTMLElement4(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow5(value).HTMLElement;
}
function isShadowRoot3(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow5(value).ShadowRoot;
}
function isOverflowElement2(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle4(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName2(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css2 = isElement(elementOrCss) ? getComputedStyle4(elementOrCss) : elementOrCss;
  return css2.transform !== "none" || css2.perspective !== "none" || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode2(element);
  while (isHTMLElement4(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode2(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName2(node2));
}
function getComputedStyle4(element) {
  return getWindow5(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode2(node2) {
  if (getNodeName2(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot3(node2) && node2.host || // Fallback.
    getDocumentElement2(node2)
  );
  return isShadowRoot3(result) ? result.host : result;
}
function getNearestOverflowAncestor2(node2) {
  const parentNode = getParentNode2(node2);
  if (isLastTraversableNode(parentNode)) {
    return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
  }
  if (isHTMLElement4(parentNode) && isOverflowElement2(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor2(parentNode);
}
function getOverflowAncestors2(node2, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor2(node2);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow5(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement2(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors2(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors2(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
var noOffsets = createCoords(0);

// node_modules/@zag-js/popper/node_modules/@zag-js/dom-query/dist/index.mjs
var defaultItemToId11 = (v) => v.id;
function itemById11(v, id, itemToId = defaultItemToId11) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId11(v, id, itemToId = defaultItemToId11) {
  const item = itemById11(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize11 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText11 = (item) => sanitize11(item.dataset.valuetext ?? item.textContent ?? "");
var match12 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap12 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText11(v, text, currentId, itemToId = defaultItemToId11) {
  const index = currentId ? indexOfId11(v, currentId, itemToId) : -1;
  let items = currentId ? wrap12(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match12(getValueText11(item), text));
}
function getByTypeaheadImpl11(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText11(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead11 = Object.assign(getByTypeaheadImpl11, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent11
});
function isValidTypeaheadEvent11(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var fps11 = 1e3 / 60;

// node_modules/@zag-js/popper/dist/index.mjs
var toVar = (value) => ({ variable: value, reference: `var(${value})` });
var cssVars = {
  arrowSize: toVar("--arrow-size"),
  arrowSizeHalf: toVar("--arrow-size-half"),
  arrowBg: toVar("--arrow-background"),
  transformOrigin: toVar("--transform-origin"),
  arrowOffset: toVar("--arrow-offset")
};

// node_modules/@zag-js/color-picker/node_modules/@zag-js/store/dist/index.mjs
function getGlobal7() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal7(key, value) {
  const g = getGlobal7();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev7 = () => true;
var isObject11 = (x) => typeof x === "object" && x !== null;
var proxyStateMap7 = makeGlobal7("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet7 = makeGlobal7("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction7 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject11(x) && !refSet7.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet7.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap7.has(value)) {
      snap[key] = snapshot7(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject11(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev7() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev7() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject11(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap7.has(value) && canProxy(value)) {
          nextValue = proxy7(value);
        }
        const childProxyState = !refSet7.has(nextValue) && proxyStateMap7.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap7.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap7,
  refSet7,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction7] = buildProxyFunction7();
function proxy7(initialObject = {}) {
  return proxyFunction7(initialObject);
}
function snapshot7(proxyObject, handlePromise) {
  const proxyState = proxyStateMap7.get(proxyObject);
  if (isDev7() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/color-picker/node_modules/@zag-js/core/dist/index.mjs
var isString4 = (v) => typeof v === "string";
var isFunction4 = (v) => typeof v === "function";
function exec3(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString4(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction4(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or3(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec3(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and4(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec3(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not5(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec3(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn3(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards3 = { or: or3, and: and4, not: not5, stateIn: stateIn3 };

// node_modules/@zag-js/dismissable/node_modules/@zag-js/dom-query/dist/index.mjs
var defaultItemToId12 = (v) => v.id;
function itemById12(v, id, itemToId = defaultItemToId12) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId12(v, id, itemToId = defaultItemToId12) {
  const item = itemById12(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize12 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText12 = (item) => sanitize12(item.dataset.valuetext ?? item.textContent ?? "");
var match13 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap13 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText12(v, text, currentId, itemToId = defaultItemToId12) {
  const index = currentId ? indexOfId12(v, currentId, itemToId) : -1;
  let items = currentId ? wrap13(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match13(getValueText12(item), text));
}
function getByTypeaheadImpl12(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText12(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead12 = Object.assign(getByTypeaheadImpl12, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent12
});
function isValidTypeaheadEvent12(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var fps12 = 1e3 / 60;

// node_modules/@zag-js/interact-outside/node_modules/@zag-js/dom-query/dist/index.mjs
var defaultItemToId13 = (v) => v.id;
function itemById13(v, id, itemToId = defaultItemToId13) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId13(v, id, itemToId = defaultItemToId13) {
  const item = itemById13(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize13 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText13 = (item) => sanitize13(item.dataset.valuetext ?? item.textContent ?? "");
var match14 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap14 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText13(v, text, currentId, itemToId = defaultItemToId13) {
  const index = currentId ? indexOfId13(v, currentId, itemToId) : -1;
  let items = currentId ? wrap14(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match14(getValueText13(item), text));
}
function getByTypeaheadImpl13(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText13(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead13 = Object.assign(getByTypeaheadImpl13, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent13
});
function isValidTypeaheadEvent13(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var fps13 = 1e3 / 60;

// node_modules/@zag-js/color-picker/dist/index.mjs
var anatomy9 = createAnatomy("color-picker", [
  "root",
  "label",
  "control",
  "trigger",
  "positioner",
  "content",
  "area",
  "areaThumb",
  "valueText",
  "areaBackground",
  "channelSlider",
  "channelSliderLabel",
  "channelSliderTrack",
  "channelSliderThumb",
  "channelSliderValueText",
  "channelInput",
  "transparencyGrid",
  "swatchGroup",
  "swatchTrigger",
  "swatchIndicator",
  "swatch",
  "eyeDropperTrigger",
  "formatTrigger",
  "formatSelect"
]);
var parts7 = anatomy9.build();
var dom7 = createScope8({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `color-picker:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `color-picker:${ctx.id}:label`;
  },
  getHiddenInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.hiddenInput) ?? `color-picker:${ctx.id}:hidden-input`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `color-picker:${ctx.id}:control`;
  },
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `color-picker:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `color-picker:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.positioner) ?? `color-picker:${ctx.id}:positioner`;
  },
  getFormatSelectId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.formatSelect) ?? `color-picker:${ctx.id}:format-select`;
  },
  getAreaId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.area) ?? `color-picker:${ctx.id}:area`;
  },
  getAreaGradientId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.areaGradient) ?? `color-picker:${ctx.id}:area-gradient`;
  },
  getAreaThumbId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.areaThumb) ?? `color-picker:${ctx.id}:area-thumb`;
  },
  getChannelSliderTrackId: (ctx, channel) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.channelSliderTrack) == null ? void 0 : _b6.call(_a7, channel)) ?? `color-picker:${ctx.id}:slider-track:${channel}`;
  },
  getChannelSliderThumbId: (ctx, channel) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.channelSliderThumb) == null ? void 0 : _b6.call(_a7, channel)) ?? `color-picker:${ctx.id}:slider-thumb:${channel}`;
  },
  getContentEl: (ctx) => dom7.getById(ctx, dom7.getContentId(ctx)),
  getAreaThumbEl: (ctx) => dom7.getById(ctx, dom7.getAreaThumbId(ctx)),
  getChannelSliderThumbEl: (ctx, channel) => dom7.getById(ctx, dom7.getChannelSliderThumbId(ctx, channel)),
  getChannelInputEl: (ctx, channel) => {
    const selector = `input[data-channel="${channel}"]`;
    return [
      ...queryAll4(dom7.getContentEl(ctx), selector),
      ...queryAll4(dom7.getControlEl(ctx), selector)
    ];
  },
  getFormatSelectEl: (ctx) => dom7.getById(ctx, dom7.getFormatSelectId(ctx)),
  getHiddenInputEl: (ctx) => dom7.getById(ctx, dom7.getHiddenInputId(ctx)),
  getAreaEl: (ctx) => dom7.getById(ctx, dom7.getAreaId(ctx)),
  getAreaValueFromPoint(ctx, point) {
    const areaEl = dom7.getAreaEl(ctx);
    if (!areaEl) return;
    const { percent } = getRelativePoint(point, areaEl);
    return percent;
  },
  getControlEl: (ctx) => dom7.getById(ctx, dom7.getControlId(ctx)),
  getTriggerEl: (ctx) => dom7.getById(ctx, dom7.getTriggerId(ctx)),
  getPositionerEl: (ctx) => dom7.getById(ctx, dom7.getPositionerId(ctx)),
  getChannelSliderTrackEl: (ctx, channel) => {
    return dom7.getById(ctx, dom7.getChannelSliderTrackId(ctx, channel));
  },
  getChannelSliderValueFromPoint(ctx, point, channel) {
    const trackEl = dom7.getChannelSliderTrackEl(ctx, channel);
    if (!trackEl) return;
    const { percent } = getRelativePoint(point, trackEl);
    return percent;
  },
  getChannelInputEls: (ctx) => {
    return [
      ...queryAll4(dom7.getContentEl(ctx), "input[data-channel]"),
      ...queryAll4(dom7.getControlEl(ctx), "input[data-channel]")
    ];
  }
});
var formats = ["hsba", "hsla", "rgba"];
var formatRegex = new RegExp(`^(${formats.join("|")})$`);
var { and: and5 } = guards3;

// node_modules/@ark-ui/anatomy/dist/color-picker/index.js
var anatomy10 = anatomy9.extendWith("view");

// node_modules/@zag-js/combobox/node_modules/@zag-js/collection/dist/index.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
var fallback = {
  itemToValue(item) {
    if (typeof item === "string") return item;
    if (isObject3(item) && hasProp(item, "value")) return item.value;
    return "";
  },
  itemToString(item) {
    if (typeof item === "string") return item;
    if (isObject3(item) && hasProp(item, "label")) return item.label;
    return fallback.itemToValue(item);
  },
  isItemDisabled(item) {
    if (isObject3(item) && hasProp(item, "disabled")) return !!item.disabled;
    return false;
  }
};
var Collection = class {
  constructor(options) {
    this.options = options;
    __publicField2(this, "items");
    this.items = [...options.items];
  }
  isEqual(other) {
    return isEqual(this.items, other.items);
  }
  /**
   * Function to update the collection items
   */
  setItems(items) {
    this.items = Array.from(items);
  }
  /**
   * Returns all the values in the collection
   */
  getValues(items = this.items) {
    return Array.from(items).map((item) => this.getItemValue(item)).filter(Boolean);
  }
  /**
   * Get the item based on its value
   */
  find(value) {
    if (value == null) return null;
    const index = this.items.findIndex((item) => this.getItemValue(item) === value);
    return index != null ? this.items[index] : null;
  }
  /**
   * Get the items based on its values
   */
  findMany(values) {
    return Array.from(values).map((value) => this.find(value)).filter(Boolean);
  }
  /**
   * Get the item based on its index
   */
  at(index) {
    return this.items[index] ?? null;
  }
  sortFn(valueA, valueB) {
    const indexA = this.indexOf(valueA);
    const indexB = this.indexOf(valueB);
    return (indexA ?? 0) - (indexB ?? 0);
  }
  /**
   * Sort the values based on their index
   */
  sort(values) {
    return [...values].sort(this.sortFn.bind(this));
  }
  /**
   * Convert an item to a value
   */
  getItemValue(item) {
    var _a7, _b6;
    if (item == null) return null;
    return ((_b6 = (_a7 = this.options).itemToValue) == null ? void 0 : _b6.call(_a7, item)) ?? fallback.itemToValue(item);
  }
  /**
   * Whether an item is disabled
   */
  getItemDisabled(item) {
    var _a7, _b6;
    if (item == null) return false;
    return ((_b6 = (_a7 = this.options).isItemDisabled) == null ? void 0 : _b6.call(_a7, item)) ?? fallback.isItemDisabled(item);
  }
  /**
   * Convert an item to a string
   */
  stringifyItem(item) {
    var _a7, _b6;
    if (item == null) return null;
    return ((_b6 = (_a7 = this.options).itemToString) == null ? void 0 : _b6.call(_a7, item)) ?? fallback.itemToString(item);
  }
  /**
   * Convert a value to a string
   */
  stringify(value) {
    if (value == null) return null;
    return this.stringifyItem(this.find(value));
  }
  /**
   * Convert an array of items to a string
   */
  stringifyItems(items, separator = ", ") {
    return Array.from(items).map((item) => this.stringifyItem(item)).filter(Boolean).join(separator);
  }
  /**
   * Convert an array of items to a string
   */
  stringifyMany(value, separator) {
    return this.stringifyItems(this.findMany(value), separator);
  }
  /**
   * Whether the collection has a value
   */
  has(value) {
    return this.indexOf(value) !== -1;
  }
  /**
   * Whether the collection has an item
   */
  hasItem(item) {
    if (item == null) return false;
    return this.has(this.getItemValue(item));
  }
  /**
   * Returns the number of items in the collection
   */
  get size() {
    return this.items.length;
  }
  /**
   * Returns the first value in the collection
   */
  get firstValue() {
    let index = 0;
    while (this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the last value in the collection
   */
  get lastValue() {
    let index = this.size - 1;
    while (this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the next value in the collection
   */
  getNextValue(value) {
    let index = this.indexOf(value);
    if (index === -1) return null;
    index++;
    while (index <= this.size && this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the previous value in the collection
   */
  getPreviousValue(value) {
    let index = this.indexOf(value);
    if (index === -1) return null;
    index--;
    while (index >= 0 && this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  /**
   * Get the index of an item based on its key
   */
  indexOf(value) {
    if (value == null) return -1;
    return this.items.findIndex((item) => this.getItemValue(item) === value);
  }
  getByText(text, current) {
    let items = current != null ? wrap15(this.items, this.indexOf(current)) : this.items;
    const isSingleKey = text.length === 1;
    if (isSingleKey) items = items.filter((item) => this.getItemValue(item) !== current);
    return items.find((item) => match15(this.stringifyItem(item), text));
  }
  /**
   * Search for a value based on a query
   */
  search(queryString, options) {
    const { state: state2, currentValue, timeout = 350 } = options;
    const search = state2.keysSoFar + queryString;
    const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
    const query9 = isRepeated ? search[0] : search;
    const item = this.getByText(query9, currentValue);
    const value = this.getItemValue(item);
    function cleanup() {
      clearTimeout(state2.timer);
      state2.timer = -1;
    }
    function update(value2) {
      state2.keysSoFar = value2;
      cleanup();
      if (value2 !== "") {
        state2.timer = +setTimeout(() => {
          update("");
          cleanup();
        }, timeout);
      }
    }
    update(search);
    return value;
  }
  *[Symbol.iterator]() {
    yield* this.items;
  }
  insertBefore(value, item) {
    const index = this.indexOf(value);
    if (index === -1) return;
    this.items.splice(index, 0, item);
  }
  insertAfter(value, item) {
    const index = this.indexOf(value);
    if (index === -1) return;
    this.items.splice(index + 1, 0, item);
  }
  reorder(fromIndex, toIndex) {
    if (fromIndex === -1 || toIndex === -1) return;
    if (fromIndex === toIndex) return;
    const [removed] = this.items.splice(fromIndex, 1);
    this.items.splice(toIndex, 0, removed);
  }
  toJSON() {
    return {
      size: this.size,
      first: this.firstValue,
      last: this.lastValue
    };
  }
};
var match15 = (label, query9) => {
  return !!(label == null ? void 0 : label.toLowerCase().startsWith(query9.toLowerCase()));
};
var wrap15 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};

// node_modules/@zag-js/combobox/node_modules/@zag-js/store/dist/index.mjs
function getGlobal8() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal8(key, value) {
  const g = getGlobal8();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev8 = () => true;
var isObject12 = (x) => typeof x === "object" && x !== null;
var proxyStateMap8 = makeGlobal8("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet8 = makeGlobal8("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction8 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject12(x) && !refSet8.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet8.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap8.has(value)) {
      snap[key] = snapshot8(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject12(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev8() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev8() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject12(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap8.has(value) && canProxy(value)) {
          nextValue = proxy8(value);
        }
        const childProxyState = !refSet8.has(nextValue) && proxyStateMap8.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap8.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap8,
  refSet8,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction8] = buildProxyFunction8();
function proxy8(initialObject = {}) {
  return proxyFunction8(initialObject);
}
function snapshot8(proxyObject, handlePromise) {
  const proxyState = proxyStateMap8.get(proxyObject);
  if (isDev8() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}
function ref8(obj) {
  refSet8.add(obj);
  return obj;
}

// node_modules/@zag-js/combobox/node_modules/@zag-js/core/dist/index.mjs
var isString5 = (v) => typeof v === "string";
var isFunction6 = (v) => typeof v === "function";
function exec4(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString5(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction6(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or4(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec4(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and6(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec4(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not6(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec4(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn4(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards4 = { or: or4, and: and6, not: not6, stateIn: stateIn4 };

// node_modules/@zag-js/combobox/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument9 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow9 = (el) => el != null && el === el.window;
function getDocument12(el) {
  if (isDocument9(el)) return el;
  if (isWindow9(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId14 = (v) => v.id;
function itemById14(v, id, itemToId = defaultItemToId14) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId14(v, id, itemToId = defaultItemToId14) {
  const item = itemById14(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize14 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText14 = (item) => sanitize14(item.dataset.valuetext ?? item.textContent ?? "");
var match16 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap16 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText14(v, text, currentId, itemToId = defaultItemToId14) {
  const index = currentId ? indexOfId14(v, currentId, itemToId) : -1;
  let items = currentId ? wrap16(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match16(getValueText14(item), text));
}
function getByTypeaheadImpl14(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText14(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead14 = Object.assign(getByTypeaheadImpl14, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent14
});
function isValidTypeaheadEvent14(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function query3(root, selector) {
  return (root == null ? void 0 : root.querySelector(selector)) ?? null;
}
function createScope9(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument12(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps14 = 1e3 / 60;

// node_modules/@zag-js/aria-hidden/node_modules/@zag-js/dom-query/dist/index.mjs
var defaultItemToId15 = (v) => v.id;
function itemById15(v, id, itemToId = defaultItemToId15) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId15(v, id, itemToId = defaultItemToId15) {
  const item = itemById15(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize15 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText15 = (item) => sanitize15(item.dataset.valuetext ?? item.textContent ?? "");
var match17 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap17 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText15(v, text, currentId, itemToId = defaultItemToId15) {
  const index = currentId ? indexOfId15(v, currentId, itemToId) : -1;
  let items = currentId ? wrap17(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match17(getValueText15(item), text));
}
function getByTypeaheadImpl15(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText15(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead15 = Object.assign(getByTypeaheadImpl15, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent15
});
function isValidTypeaheadEvent15(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var fps15 = 1e3 / 60;

// node_modules/@zag-js/combobox/dist/index.mjs
var anatomy11 = createAnatomy("combobox").parts(
  "root",
  "clearTrigger",
  "content",
  "control",
  "input",
  "item",
  "itemGroup",
  "itemGroupLabel",
  "itemIndicator",
  "itemText",
  "label",
  "list",
  "positioner",
  "trigger"
);
var parts8 = anatomy11.build();
var collection = (options) => {
  return ref8(new Collection(options));
};
collection.empty = () => {
  return ref8(new Collection({ items: [] }));
};
var dom8 = createScope9({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `combobox:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `combobox:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `combobox:${ctx.id}:control`;
  },
  getInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.input) ?? `combobox:${ctx.id}:input`;
  },
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `combobox:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.positioner) ?? `combobox:${ctx.id}:popper`;
  },
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `combobox:${ctx.id}:toggle-btn`;
  },
  getClearTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.clearTrigger) ?? `combobox:${ctx.id}:clear-btn`;
  },
  getItemGroupId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemGroup) == null ? void 0 : _b6.call(_a7, id)) ?? `combobox:${ctx.id}:optgroup:${id}`;
  },
  getItemGroupLabelId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemGroupLabel) == null ? void 0 : _b6.call(_a7, id)) ?? `combobox:${ctx.id}:optgroup-label:${id}`;
  },
  getItemId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.item) == null ? void 0 : _b6.call(_a7, id)) ?? `combobox:${ctx.id}:option:${id}`;
  },
  getContentEl: (ctx) => dom8.getById(ctx, dom8.getContentId(ctx)),
  getInputEl: (ctx) => dom8.getById(ctx, dom8.getInputId(ctx)),
  getPositionerEl: (ctx) => dom8.getById(ctx, dom8.getPositionerId(ctx)),
  getControlEl: (ctx) => dom8.getById(ctx, dom8.getControlId(ctx)),
  getTriggerEl: (ctx) => dom8.getById(ctx, dom8.getTriggerId(ctx)),
  getClearTriggerEl: (ctx) => dom8.getById(ctx, dom8.getClearTriggerId(ctx)),
  getHighlightedItemEl: (ctx) => {
    const value = ctx.highlightedValue;
    if (value == null) return;
    const selector = `[role=option][data-value="${CSS.escape(value)}"`;
    return query3(dom8.getContentEl(ctx), selector);
  },
  focusInputEl: (ctx) => {
    const inputEl = dom8.getInputEl(ctx);
    if (dom8.isActiveElement(ctx, inputEl)) return;
    inputEl == null ? void 0 : inputEl.focus({ preventScroll: true });
  },
  focusTriggerEl: (ctx) => {
    const triggerEl = dom8.getTriggerEl(ctx);
    if (dom8.isActiveElement(ctx, triggerEl)) return;
    triggerEl == null ? void 0 : triggerEl.focus({ preventScroll: true });
  }
});
var { and: and7, not: not7 } = guards4;

// node_modules/@zag-js/date-picker/node_modules/@internationalized/date/dist/string.mjs
var $fae977aafc393c5c$var$requiredDurationTimeGroups = [
  "hours",
  "minutes",
  "seconds"
];
var $fae977aafc393c5c$var$requiredDurationGroups = [
  "years",
  "months",
  "weeks",
  "days",
  ...$fae977aafc393c5c$var$requiredDurationTimeGroups
];

// node_modules/@zag-js/date-picker/node_modules/@internationalized/date/dist/HebrewCalendar.mjs
var $7c5f6fbf42389787$var$HOUR_PARTS = 1080;
var $7c5f6fbf42389787$var$DAY_PARTS = 24 * $7c5f6fbf42389787$var$HOUR_PARTS;
var $7c5f6fbf42389787$var$MONTH_DAYS = 29;
var $7c5f6fbf42389787$var$MONTH_FRACT = 12 * $7c5f6fbf42389787$var$HOUR_PARTS + 793;
var $7c5f6fbf42389787$var$MONTH_PARTS = $7c5f6fbf42389787$var$MONTH_DAYS * $7c5f6fbf42389787$var$DAY_PARTS + $7c5f6fbf42389787$var$MONTH_FRACT;

// node_modules/@internationalized/date/dist/string.mjs
var $fae977aafc393c5c$var$requiredDurationTimeGroups2 = [
  "hours",
  "minutes",
  "seconds"
];
var $fae977aafc393c5c$var$requiredDurationGroups2 = [
  "years",
  "months",
  "weeks",
  "days",
  ...$fae977aafc393c5c$var$requiredDurationTimeGroups2
];

// node_modules/@internationalized/date/dist/HebrewCalendar.mjs
var $7c5f6fbf42389787$var$HOUR_PARTS2 = 1080;
var $7c5f6fbf42389787$var$DAY_PARTS2 = 24 * $7c5f6fbf42389787$var$HOUR_PARTS2;
var $7c5f6fbf42389787$var$MONTH_DAYS2 = 29;
var $7c5f6fbf42389787$var$MONTH_FRACT2 = 12 * $7c5f6fbf42389787$var$HOUR_PARTS2 + 793;
var $7c5f6fbf42389787$var$MONTH_PARTS2 = $7c5f6fbf42389787$var$MONTH_DAYS2 * $7c5f6fbf42389787$var$DAY_PARTS2 + $7c5f6fbf42389787$var$MONTH_FRACT2;

// node_modules/@zag-js/date-picker/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument10 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow10 = (el) => el != null && el === el.window;
function getDocument13(el) {
  if (isDocument10(el)) return el;
  if (isWindow10(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId16 = (v) => v.id;
function itemById16(v, id, itemToId = defaultItemToId16) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId16(v, id, itemToId = defaultItemToId16) {
  const item = itemById16(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize16 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText16 = (item) => sanitize16(item.dataset.valuetext ?? item.textContent ?? "");
var match19 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap18 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText16(v, text, currentId, itemToId = defaultItemToId16) {
  const index = currentId ? indexOfId16(v, currentId, itemToId) : -1;
  let items = currentId ? wrap18(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match19(getValueText16(item), text));
}
function getByTypeaheadImpl16(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText16(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead16 = Object.assign(getByTypeaheadImpl16, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent16
});
function isValidTypeaheadEvent16(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function queryAll5(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function query4(root, selector) {
  return (root == null ? void 0 : root.querySelector(selector)) ?? null;
}
function createScope10(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument13(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps16 = 1e3 / 60;

// node_modules/@zag-js/date-picker/node_modules/@zag-js/store/dist/index.mjs
function getGlobal9() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal9(key, value) {
  const g = getGlobal9();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev9 = () => true;
var isObject13 = (x) => typeof x === "object" && x !== null;
var proxyStateMap9 = makeGlobal9("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet9 = makeGlobal9("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction9 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject13(x) && !refSet9.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet9.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap9.has(value)) {
      snap[key] = snapshot9(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject13(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev9() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev9() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject13(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap9.has(value) && canProxy(value)) {
          nextValue = proxy9(value);
        }
        const childProxyState = !refSet9.has(nextValue) && proxyStateMap9.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap9.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap9,
  refSet9,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction9] = buildProxyFunction9();
function proxy9(initialObject = {}) {
  return proxyFunction9(initialObject);
}
function snapshot9(proxyObject, handlePromise) {
  const proxyState = proxyStateMap9.get(proxyObject);
  if (isDev9() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/date-picker/node_modules/@zag-js/core/dist/index.mjs
var isString6 = (v) => typeof v === "string";
var isFunction7 = (v) => typeof v === "function";
function exec5(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString6(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction7(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or5(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec5(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and8(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec5(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not8(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec5(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn5(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards5 = { or: or5, and: and8, not: not8, stateIn: stateIn5 };

// node_modules/@zag-js/date-picker/node_modules/@zag-js/types/dist/index.mjs
var createProps8 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/date-picker/dist/index.mjs
var anatomy12 = createAnatomy("date-picker").parts(
  "root",
  "label",
  "clearTrigger",
  "content",
  "control",
  "input",
  "monthSelect",
  "nextTrigger",
  "positioner",
  "prevTrigger",
  "rangeText",
  "table",
  "tableBody",
  "tableCell",
  "tableCellTrigger",
  "tableHead",
  "tableHeader",
  "tableRow",
  "trigger",
  "viewTrigger",
  "viewControl",
  "yearSelect",
  "presetTrigger"
);
var parts9 = anatomy12.build();
var dom9 = createScope10({
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `datepicker:${ctx.id}:label`;
  },
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `datepicker:${ctx.id}`;
  },
  getTableId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.table) == null ? void 0 : _b6.call(_a7, id)) ?? `datepicker:${ctx.id}:table:${id}`;
  },
  getTableHeaderId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.tableHeader) == null ? void 0 : _b6.call(_a7, id)) ?? `datepicker:${ctx.id}:thead`;
  },
  getTableBodyId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.tableBody) == null ? void 0 : _b6.call(_a7, id)) ?? `datepicker:${ctx.id}:tbody`;
  },
  getTableRowId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.tableRow) == null ? void 0 : _b6.call(_a7, id)) ?? `datepicker:${ctx.id}:tr:${id}`;
  },
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `datepicker:${ctx.id}:content`;
  },
  getCellTriggerId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.cellTrigger) == null ? void 0 : _b6.call(_a7, id)) ?? `datepicker:${ctx.id}:cell-trigger:${id}`;
  },
  getPrevTriggerId: (ctx, view) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.prevTrigger) == null ? void 0 : _b6.call(_a7, view)) ?? `datepicker:${ctx.id}:prev:${view}`;
  },
  getNextTriggerId: (ctx, view) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.nextTrigger) == null ? void 0 : _b6.call(_a7, view)) ?? `datepicker:${ctx.id}:next:${view}`;
  },
  getViewTriggerId: (ctx, view) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.viewTrigger) == null ? void 0 : _b6.call(_a7, view)) ?? `datepicker:${ctx.id}:view:${view}`;
  },
  getClearTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.clearTrigger) ?? `datepicker:${ctx.id}:clear`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `datepicker:${ctx.id}:control`;
  },
  getInputId: (ctx, index) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.input) == null ? void 0 : _b6.call(_a7, index)) ?? `datepicker:${ctx.id}:input:${index}`;
  },
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `datepicker:${ctx.id}:trigger`;
  },
  getPositionerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.positioner) ?? `datepicker:${ctx.id}:positioner`;
  },
  getMonthSelectId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.monthSelect) ?? `datepicker:${ctx.id}:month-select`;
  },
  getYearSelectId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.yearSelect) ?? `datepicker:${ctx.id}:year-select`;
  },
  getFocusedCell: (ctx, view = ctx.view) => query4(
    dom9.getContentEl(ctx),
    `[data-part=table-cell-trigger][data-view=${view}][data-focus]:not([data-outside-range])`
  ),
  getTriggerEl: (ctx) => dom9.getById(ctx, dom9.getTriggerId(ctx)),
  getContentEl: (ctx) => dom9.getById(ctx, dom9.getContentId(ctx)),
  getInputEls: (ctx) => queryAll5(dom9.getControlEl(ctx), `[data-part=input]`),
  getYearSelectEl: (ctx) => dom9.getById(ctx, dom9.getYearSelectId(ctx)),
  getMonthSelectEl: (ctx) => dom9.getById(ctx, dom9.getMonthSelectId(ctx)),
  getClearTriggerEl: (ctx) => dom9.getById(ctx, dom9.getClearTriggerId(ctx)),
  getPositionerEl: (ctx) => dom9.getById(ctx, dom9.getPositionerId(ctx)),
  getControlEl: (ctx) => dom9.getById(ctx, dom9.getControlId(ctx))
});
var { and: and9 } = guards5;
var props7 = createProps8()([
  "closeOnSelect",
  "dir",
  "disabled",
  "fixedWeeks",
  "focusedValue",
  "format",
  "getRootNode",
  "id",
  "ids",
  "isDateUnavailable",
  "isDateUnavailable",
  "locale",
  "max",
  "min",
  "modal",
  "name",
  "numOfMonths",
  "onFocusChange",
  "onOpenChange",
  "onValueChange",
  "onViewChange",
  "open",
  "open.controlled",
  "positioning",
  "readOnly",
  "selectionMode",
  "startOfWeek",
  "timeZone",
  "translations",
  "value",
  "view"
]);
var splitProps8 = createSplitProps(props7);
var inputProps = createProps8()(["index"]);
var splitInputProps = createSplitProps(inputProps);
var presetTriggerProps = createProps8()(["value"]);
var splitPresetTriggerProps = createSplitProps(presetTriggerProps);
var tableProps = createProps8()(["columns", "id", "view"]);
var splitTableProps = createSplitProps(tableProps);
var tableCellProps = createProps8()(["disabled", "value", "columns"]);
var splitTableCellProps = createSplitProps(tableCellProps);
var viewProps = createProps8()(["view"]);
var splitViewProps = createSplitProps(viewProps);

// node_modules/@ark-ui/anatomy/dist/date-picker/index.js
var anatomy13 = anatomy12.extendWith("view");

// node_modules/@zag-js/dialog/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument11 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow11 = (el) => el != null && el === el.window;
function getDocument14(el) {
  if (isDocument11(el)) return el;
  if (isWindow11(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId17 = (v) => v.id;
function itemById17(v, id, itemToId = defaultItemToId17) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId17(v, id, itemToId = defaultItemToId17) {
  const item = itemById17(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize17 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText17 = (item) => sanitize17(item.dataset.valuetext ?? item.textContent ?? "");
var match20 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap19 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText17(v, text, currentId, itemToId = defaultItemToId17) {
  const index = currentId ? indexOfId17(v, currentId, itemToId) : -1;
  let items = currentId ? wrap19(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match20(getValueText17(item), text));
}
function getByTypeaheadImpl17(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText17(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead17 = Object.assign(getByTypeaheadImpl17, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent17
});
function isValidTypeaheadEvent17(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function createScope11(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument14(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps17 = 1e3 / 60;

// node_modules/@zag-js/dialog/node_modules/@zag-js/store/dist/index.mjs
function getGlobal10() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal10(key, value) {
  const g = getGlobal10();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev10 = () => true;
var isObject14 = (x) => typeof x === "object" && x !== null;
var proxyStateMap10 = makeGlobal10("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet10 = makeGlobal10("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction10 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject14(x) && !refSet10.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet10.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap10.has(value)) {
      snap[key] = snapshot10(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject14(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev10() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev10() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject14(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap10.has(value) && canProxy(value)) {
          nextValue = proxy10(value);
        }
        const childProxyState = !refSet10.has(nextValue) && proxyStateMap10.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap10.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap10,
  refSet10,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction10] = buildProxyFunction10();
function proxy10(initialObject = {}) {
  return proxyFunction10(initialObject);
}
function snapshot10(proxyObject, handlePromise) {
  const proxyState = proxyStateMap10.get(proxyObject);
  if (isDev10() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/remove-scroll/node_modules/@zag-js/dom-query/dist/index.mjs
var defaultItemToId18 = (v) => v.id;
function itemById18(v, id, itemToId = defaultItemToId18) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId18(v, id, itemToId = defaultItemToId18) {
  const item = itemById18(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize18 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText18 = (item) => sanitize18(item.dataset.valuetext ?? item.textContent ?? "");
var match21 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap20 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText18(v, text, currentId, itemToId = defaultItemToId18) {
  const index = currentId ? indexOfId18(v, currentId, itemToId) : -1;
  let items = currentId ? wrap20(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match21(getValueText18(item), text));
}
function getByTypeaheadImpl18(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText18(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead18 = Object.assign(getByTypeaheadImpl18, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent18
});
function isValidTypeaheadEvent18(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var fps18 = 1e3 / 60;

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node2, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node2 === null || node2 === void 0 ? void 0 : (_node$getAttribute = node2.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node2, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node2 && isInert2(node2.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node2) {
  var _node$getAttribute2;
  var attValue = node2 === null || node2 === void 0 ? void 0 : (_node$getAttribute2 = node2.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node2, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node2) {
  return !isNaN(parseInt(node2.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node2) {
  if (!node2) {
    throw new Error("No node provided");
  }
  if (node2.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node2.tagName) || isContentEditable(node2)) && !hasTabIndex(node2)) {
      return 0;
    }
  }
  return node2.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node2, isScope) {
  var tabIndex = getTabIndex(node2);
  if (tabIndex < 0 && isScope && !hasTabIndex(node2)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node2) {
  return node2.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node2) {
  return isInput(node2) && node2.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node2) {
  var r = node2.tagName === "DETAILS" && Array.prototype.slice.apply(node2.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node2) {
  if (!node2.name) {
    return true;
  }
  var radioScope = node2.form || getRootNode(node2);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node2.name));
  } else {
    try {
      radioSet = queryRadios(node2.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node2.form);
  return !checked || checked === node2;
};
var isRadio = function isRadio2(node2) {
  return isInput(node2) && node2.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node2) {
  return isRadio(node2) && !isTabbableRadio(node2);
};
var isNodeAttached = function isNodeAttached2(node2) {
  var _nodeRoot;
  var nodeRoot = node2 && getRootNode(node2);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node2) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node2 !== null && node2 !== void 0 && (_node$ownerDocument = node2.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node2));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node2) {
  var _node$getBoundingClie = node2.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node2, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node2).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node2, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node2.parentElement : node2;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node2;
      while (node2) {
        var parentElement = node2.parentElement;
        var rootNode = getRootNode(node2);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node2);
        } else if (node2.assignedSlot) {
          node2 = node2.assignedSlot;
        } else if (!parentElement && rootNode !== node2.ownerDocument) {
          node2 = rootNode.host;
        } else {
          node2 = parentElement;
        }
      }
      node2 = originalNode;
    }
    if (isNodeAttached(node2)) {
      return !node2.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node2);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node2) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node2.tagName)) {
    var parentNode = node2.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node2);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node2) {
  if (node2.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node2) || isHiddenInput(node2) || isHidden(node2, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node2) || isDisabledFromFieldset(node2)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node2) {
  if (isNonTabbableRadio(node2) || getTabIndex(node2) < 0 || !isNodeMatchingSelectorFocusable(options, node2)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable2 = function isTabbable3(node2, options) {
  options = options || {};
  if (!node2) {
    throw new Error("No node provided");
  }
  if (matches.call(node2, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node2);
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");
var isFocusable3 = function isFocusable4(node2, options) {
  options = options || {};
  if (!node2) {
    throw new Error("No node provided");
  }
  if (matches.call(node2, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node2);
};

// node_modules/@zag-js/dialog/node_modules/@zag-js/types/dist/index.mjs
var createProps9 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/dialog/dist/index.mjs
var anatomy14 = createAnatomy("dialog").parts(
  "trigger",
  "backdrop",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts10 = anatomy14.build();
var dom10 = createScope11({
  getPositionerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.positioner) ?? `dialog:${ctx.id}:positioner`;
  },
  getBackdropId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.backdrop) ?? `dialog:${ctx.id}:backdrop`;
  },
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `dialog:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `dialog:${ctx.id}:trigger`;
  },
  getTitleId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.title) ?? `dialog:${ctx.id}:title`;
  },
  getDescriptionId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.description) ?? `dialog:${ctx.id}:description`;
  },
  getCloseTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.closeTrigger) ?? `dialog:${ctx.id}:close`;
  },
  getContentEl: (ctx) => dom10.getById(ctx, dom10.getContentId(ctx)),
  getPositionerEl: (ctx) => dom10.getById(ctx, dom10.getPositionerId(ctx)),
  getBackdropEl: (ctx) => dom10.getById(ctx, dom10.getBackdropId(ctx)),
  getTriggerEl: (ctx) => dom10.getById(ctx, dom10.getTriggerId(ctx)),
  getTitleEl: (ctx) => dom10.getById(ctx, dom10.getTitleId(ctx)),
  getDescriptionEl: (ctx) => dom10.getById(ctx, dom10.getDescriptionId(ctx)),
  getCloseTriggerEl: (ctx) => dom10.getById(ctx, dom10.getCloseTriggerId(ctx))
});
var props8 = createProps9()([
  "aria-label",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "finalFocusEl",
  "getRootNode",
  "getRootNode",
  "id",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "open.controlled",
  "open",
  "persistentElements",
  "preventScroll",
  "restoreFocus",
  "role",
  "trapFocus"
]);
var splitProps9 = createSplitProps(props8);

// node_modules/@zag-js/editable/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument12 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow12 = (el) => el != null && el === el.window;
function getDocument15(el) {
  if (isDocument12(el)) return el;
  if (isWindow12(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId19 = (v) => v.id;
function itemById19(v, id, itemToId = defaultItemToId19) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId19(v, id, itemToId = defaultItemToId19) {
  const item = itemById19(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize19 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText19 = (item) => sanitize19(item.dataset.valuetext ?? item.textContent ?? "");
var match22 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap21 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText19(v, text, currentId, itemToId = defaultItemToId19) {
  const index = currentId ? indexOfId19(v, currentId, itemToId) : -1;
  let items = currentId ? wrap21(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match22(getValueText19(item), text));
}
function getByTypeaheadImpl19(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText19(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead19 = Object.assign(getByTypeaheadImpl19, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent19
});
function isValidTypeaheadEvent19(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function createScope12(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument15(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps19 = 1e3 / 60;

// node_modules/@zag-js/editable/node_modules/@zag-js/store/dist/index.mjs
function getGlobal11() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal11(key, value) {
  const g = getGlobal11();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev11 = () => true;
var isObject15 = (x) => typeof x === "object" && x !== null;
var proxyStateMap11 = makeGlobal11("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet11 = makeGlobal11("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction11 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject15(x) && !refSet11.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet11.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap11.has(value)) {
      snap[key] = snapshot11(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject15(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev11() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev11() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject15(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap11.has(value) && canProxy(value)) {
          nextValue = proxy11(value);
        }
        const childProxyState = !refSet11.has(nextValue) && proxyStateMap11.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap11.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap11,
  refSet11,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction11] = buildProxyFunction11();
function proxy11(initialObject = {}) {
  return proxyFunction11(initialObject);
}
function snapshot11(proxyObject, handlePromise) {
  const proxyState = proxyStateMap11.get(proxyObject);
  if (isDev11() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/editable/node_modules/@zag-js/types/dist/index.mjs
var createProps10 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/editable/dist/index.mjs
var anatomy15 = createAnatomy("editable").parts(
  "root",
  "area",
  "label",
  "preview",
  "input",
  "editTrigger",
  "submitTrigger",
  "cancelTrigger",
  "control"
);
var parts11 = anatomy15.build();
var dom11 = createScope12({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `editable:${ctx.id}`;
  },
  getAreaId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.area) ?? `editable:${ctx.id}:area`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `editable:${ctx.id}:label`;
  },
  getPreviewId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.preview) ?? `editable:${ctx.id}:preview`;
  },
  getInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.input) ?? `editable:${ctx.id}:input`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `editable:${ctx.id}:control`;
  },
  getSubmitTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.submitTrigger) ?? `editable:${ctx.id}:submit`;
  },
  getCancelTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.cancelTrigger) ?? `editable:${ctx.id}:cancel`;
  },
  getEditTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.editTrigger) ?? `editable:${ctx.id}:edit`;
  },
  getInputEl: (ctx) => dom11.getById(ctx, dom11.getInputId(ctx)),
  getPreviewEl: (ctx) => dom11.getById(ctx, dom11.getPreviewId(ctx)),
  getSubmitTriggerEl: (ctx) => dom11.getById(ctx, dom11.getSubmitTriggerId(ctx)),
  getCancelTriggerEl: (ctx) => dom11.getById(ctx, dom11.getCancelTriggerId(ctx)),
  getEditTriggerEl: (ctx) => dom11.getById(ctx, dom11.getEditTriggerId(ctx))
});
var props9 = createProps10()([
  "activationMode",
  "autoResize",
  "dir",
  "disabled",
  "finalFocusEl",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "maxLength",
  "name",
  "onEdit",
  "onFocusOutside",
  "onInteractOutside",
  "onPointerDownOutside",
  "onValueChange",
  "onValueCommit",
  "onValueRevert",
  "placeholder",
  "readOnly",
  "required",
  "selectOnFocus",
  "startWithEditView",
  "submitMode",
  "translations",
  "value"
]);
var splitProps10 = createSplitProps(props9);

// node_modules/@ark-ui/anatomy/dist/field/index.js
var anatomy16 = createAnatomy("field").parts(
  "root",
  "errorText",
  "helperText",
  "input",
  "label",
  "select",
  "textarea"
);

// node_modules/@ark-ui/anatomy/dist/fieldset/index.js
var anatomy17 = createAnatomy("fieldset").parts("root", "errorText", "helperText", "legend");

// node_modules/@zag-js/file-upload/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument13 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow13 = (el) => el != null && el === el.window;
function getDocument16(el) {
  if (isDocument13(el)) return el;
  if (isWindow13(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId20 = (v) => v.id;
function itemById20(v, id, itemToId = defaultItemToId20) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId20(v, id, itemToId = defaultItemToId20) {
  const item = itemById20(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize20 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText20 = (item) => sanitize20(item.dataset.valuetext ?? item.textContent ?? "");
var match23 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap22 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText20(v, text, currentId, itemToId = defaultItemToId20) {
  const index = currentId ? indexOfId20(v, currentId, itemToId) : -1;
  let items = currentId ? wrap22(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match23(getValueText20(item), text));
}
function getByTypeaheadImpl20(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText20(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead20 = Object.assign(getByTypeaheadImpl20, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent20
});
function isValidTypeaheadEvent20(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function createScope13(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument16(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps20 = 1e3 / 60;

// node_modules/@zag-js/file-upload/node_modules/@zag-js/i18n-utils/dist/index.mjs
function i18nCache2(Ins) {
  const formatterCache = /* @__PURE__ */ new Map();
  return function create(locale, options) {
    const cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
    if (formatterCache.has(cacheKey)) {
      return formatterCache.get(cacheKey);
    }
    let formatter = new Ins(locale, options);
    formatterCache.set(cacheKey, formatter);
    return formatter;
  };
}
var getNumberFormatter2 = i18nCache2(Intl.NumberFormat);
var getListFormatter2 = i18nCache2(Intl.ListFormat);
var getRelativeTimeFormatter2 = i18nCache2(Intl.RelativeTimeFormat);
var MINUTE_TO_MS2 = 1e3 * 60;
var HOUR_TO_MS2 = 1e3 * 60 * 60;
var DAY_TO_MS2 = 1e3 * 60 * 60 * 24;
var WEEK_TO_MS2 = 1e3 * 60 * 60 * 24 * 7;
var MONTH_TO_MS2 = 1e3 * 60 * 60 * 24 * 30;
var YEAR_TO_MS2 = 1e3 * 60 * 60 * 24 * 365;

// node_modules/@zag-js/file-upload/node_modules/@zag-js/types/dist/index.mjs
var createProps11 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/file-upload/node_modules/@zag-js/store/dist/index.mjs
function getGlobal12() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal12(key, value) {
  const g = getGlobal12();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev12 = () => true;
var isObject16 = (x) => typeof x === "object" && x !== null;
var proxyStateMap12 = makeGlobal12("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet12 = makeGlobal12("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction12 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject16(x) && !refSet12.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet12.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap12.has(value)) {
      snap[key] = snapshot12(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject16(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev12() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev12() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject16(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap12.has(value) && canProxy(value)) {
          nextValue = proxy12(value);
        }
        const childProxyState = !refSet12.has(nextValue) && proxyStateMap12.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap12.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap12,
  refSet12,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction12] = buildProxyFunction12();
function proxy12(initialObject = {}) {
  return proxyFunction12(initialObject);
}
function snapshot12(proxyObject, handlePromise) {
  const proxyState = proxyStateMap12.get(proxyObject);
  if (isDev12() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/file-upload/node_modules/@zag-js/core/dist/index.mjs
var isString7 = (v) => typeof v === "string";
var isFunction8 = (v) => typeof v === "function";
function exec6(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString7(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction8(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or6(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec6(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and10(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec6(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not9(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec6(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn6(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards6 = { or: or6, and: and10, not: not9, stateIn: stateIn6 };

// node_modules/@zag-js/file-upload/dist/index.mjs
var anatomy18 = createAnatomy("file-upload").parts(
  "root",
  "dropzone",
  "item",
  "itemDeleteTrigger",
  "itemGroup",
  "itemName",
  "itemPreview",
  "itemPreviewImage",
  "itemSizeText",
  "label",
  "trigger"
);
var parts12 = anatomy18.build();
var dom12 = createScope13({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `file:${ctx.id}`;
  },
  getDropzoneId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.dropzone) ?? `file:${ctx.id}:dropzone`;
  },
  getHiddenInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.hiddenInput) ?? `file:${ctx.id}:input`;
  },
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `file:${ctx.id}:trigger`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `file:${ctx.id}:label`;
  },
  getItemId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.item) == null ? void 0 : _b6.call(_a7, id)) ?? `file:${ctx.id}:item:${id}`;
  },
  getItemNameId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemName) == null ? void 0 : _b6.call(_a7, id)) ?? `file:${ctx.id}:item-name:${id}`;
  },
  getItemSizeTextId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemSizeText) == null ? void 0 : _b6.call(_a7, id)) ?? `file:${ctx.id}:item-size:${id}`;
  },
  getItemPreviewId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemPreview) == null ? void 0 : _b6.call(_a7, id)) ?? `file:${ctx.id}:item-preview:${id}`;
  },
  getHiddenInputEl: (ctx) => dom12.getById(ctx, dom12.getHiddenInputId(ctx)),
  getDropzoneEl: (ctx) => dom12.getById(ctx, dom12.getDropzoneId(ctx))
});
var { not: not10 } = guards6;
var props10 = createProps11()([
  "accept",
  "allowDrop",
  "capture",
  "dir",
  "directory",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "locale",
  "maxFiles",
  "maxFileSize",
  "minFileSize",
  "name",
  "onFileAccept",
  "onFileReject",
  "onFileChange",
  "required",
  "translations",
  "validate"
]);
var splitProps11 = createSplitProps(props10);
var itemProps2 = createProps11()(["file"]);
var splitItemProps2 = createSplitProps(itemProps2);

// node_modules/@zag-js/hover-card/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument14 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow14 = (el) => el != null && el === el.window;
function getDocument17(el) {
  if (isDocument14(el)) return el;
  if (isWindow14(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId21 = (v) => v.id;
function itemById21(v, id, itemToId = defaultItemToId21) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId21(v, id, itemToId = defaultItemToId21) {
  const item = itemById21(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize21 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText21 = (item) => sanitize21(item.dataset.valuetext ?? item.textContent ?? "");
var match24 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap23 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText21(v, text, currentId, itemToId = defaultItemToId21) {
  const index = currentId ? indexOfId21(v, currentId, itemToId) : -1;
  let items = currentId ? wrap23(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match24(getValueText21(item), text));
}
function getByTypeaheadImpl21(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText21(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead21 = Object.assign(getByTypeaheadImpl21, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent21
});
function isValidTypeaheadEvent21(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function createScope14(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument17(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps21 = 1e3 / 60;

// node_modules/@zag-js/hover-card/node_modules/@zag-js/store/dist/index.mjs
function getGlobal13() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal13(key, value) {
  const g = getGlobal13();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev13 = () => true;
var isObject17 = (x) => typeof x === "object" && x !== null;
var proxyStateMap13 = makeGlobal13("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet13 = makeGlobal13("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction13 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject17(x) && !refSet13.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet13.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap13.has(value)) {
      snap[key] = snapshot13(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject17(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev13() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev13() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject17(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap13.has(value) && canProxy(value)) {
          nextValue = proxy13(value);
        }
        const childProxyState = !refSet13.has(nextValue) && proxyStateMap13.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap13.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap13,
  refSet13,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction13] = buildProxyFunction13();
function proxy13(initialObject = {}) {
  return proxyFunction13(initialObject);
}
function snapshot13(proxyObject, handlePromise) {
  const proxyState = proxyStateMap13.get(proxyObject);
  if (isDev13() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/hover-card/node_modules/@zag-js/core/dist/index.mjs
var isString8 = (v) => typeof v === "string";
var isFunction9 = (v) => typeof v === "function";
function exec7(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString8(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction9(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or7(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec7(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and11(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec7(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not11(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec7(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn7(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards7 = { or: or7, and: and11, not: not11, stateIn: stateIn7 };

// node_modules/@zag-js/hover-card/node_modules/@zag-js/types/dist/index.mjs
var createProps12 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/hover-card/dist/index.mjs
var anatomy19 = createAnatomy("hoverCard").parts("arrow", "arrowTip", "trigger", "positioner", "content");
var parts13 = anatomy19.build();
var dom13 = createScope14({
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `hover-card:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `hover-card:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.positioner) ?? `hover-card:${ctx.id}:popper`;
  },
  getArrowId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.arrow) ?? `hover-card:${ctx.id}:arrow`;
  },
  getTriggerEl: (ctx) => dom13.getById(ctx, dom13.getTriggerId(ctx)),
  getContentEl: (ctx) => dom13.getById(ctx, dom13.getContentId(ctx)),
  getPositionerEl: (ctx) => dom13.getById(ctx, dom13.getPositionerId(ctx))
});
var { not: not12, and: and12 } = guards7;
var props11 = createProps12()([
  "closeDelay",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onOpenChange",
  "open.controlled",
  "open",
  "openDelay",
  "positioning"
]);
var splitProps12 = createSplitProps(props11);

// node_modules/@zag-js/menu/node_modules/@zag-js/store/dist/index.mjs
function getGlobal14() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal14(key, value) {
  const g = getGlobal14();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev14 = () => true;
var isObject18 = (x) => typeof x === "object" && x !== null;
var proxyStateMap14 = makeGlobal14("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet14 = makeGlobal14("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction14 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject18(x) && !refSet14.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet14.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap14.has(value)) {
      snap[key] = snapshot14(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject18(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev14() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev14() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject18(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap14.has(value) && canProxy(value)) {
          nextValue = proxy14(value);
        }
        const childProxyState = !refSet14.has(nextValue) && proxyStateMap14.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap14.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap14,
  refSet14,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction14] = buildProxyFunction14();
function proxy14(initialObject = {}) {
  return proxyFunction14(initialObject);
}
function snapshot14(proxyObject, handlePromise) {
  const proxyState = proxyStateMap14.get(proxyObject);
  if (isDev14() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/menu/node_modules/@zag-js/core/dist/index.mjs
var isString9 = (v) => typeof v === "string";
var isFunction10 = (v) => typeof v === "function";
function exec8(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString9(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction10(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or8(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec8(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and13(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec8(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not13(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec8(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn8(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards8 = { or: or8, and: and13, not: not13, stateIn: stateIn8 };

// node_modules/@zag-js/menu/node_modules/@zag-js/dom-query/dist/index.mjs
var isHTMLElement8 = (v) => typeof v === "object" && (v == null ? void 0 : v.nodeType) === Node.ELEMENT_NODE && typeof (v == null ? void 0 : v.nodeName) === "string";
var isDocument15 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow15 = (el) => el != null && el === el.window;
function getDocument18(el) {
  if (isDocument15(el)) return el;
  if (isWindow15(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId22 = (v) => v.id;
function itemById22(v, id, itemToId = defaultItemToId22) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId22(v, id, itemToId = defaultItemToId22) {
  const item = itemById22(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
function nextById3(v, id, loop = true) {
  let idx = indexOfId22(v, id);
  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
  return v[idx];
}
function prevById3(v, id, loop = true) {
  let idx = indexOfId22(v, id);
  if (idx === -1) return loop ? v[v.length - 1] : null;
  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
  return v[idx];
}
var sanitize22 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText22 = (item) => sanitize22(item.dataset.valuetext ?? item.textContent ?? "");
var match25 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap24 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText22(v, text, currentId, itemToId = defaultItemToId22) {
  const index = currentId ? indexOfId22(v, currentId, itemToId) : -1;
  let items = currentId ? wrap24(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match25(getValueText22(item), text));
}
function getByTypeaheadImpl22(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText22(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead22 = Object.assign(getByTypeaheadImpl22, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent22
});
function isValidTypeaheadEvent22(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function queryAll6(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function createScope15(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument18(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps22 = 1e3 / 60;

// node_modules/@zag-js/rect-utils/dist/index.mjs
var { min: min2, max: max2 } = Math;
var { sign, abs: abs2, min: min22 } = Math;

// node_modules/@zag-js/menu/node_modules/@zag-js/types/dist/index.mjs
var createProps13 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/menu/dist/index.mjs
var anatomy20 = createAnatomy("menu").parts(
  "arrow",
  "arrowTip",
  "content",
  "contextTrigger",
  "indicator",
  "item",
  "itemGroup",
  "itemGroupLabel",
  "itemIndicator",
  "itemText",
  "positioner",
  "separator",
  "trigger",
  "triggerItem"
);
var parts14 = anatomy20.build();
var dom14 = createScope15({
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `menu:${ctx.id}:trigger`;
  },
  getContextTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.contextTrigger) ?? `menu:${ctx.id}:ctx-trigger`;
  },
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `menu:${ctx.id}:content`;
  },
  getArrowId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.arrow) ?? `menu:${ctx.id}:arrow`;
  },
  getPositionerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.positioner) ?? `menu:${ctx.id}:popper`;
  },
  getGroupId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.group) == null ? void 0 : _b6.call(_a7, id)) ?? `menu:${ctx.id}:group:${id}`;
  },
  getGroupLabelId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.groupLabel) == null ? void 0 : _b6.call(_a7, id)) ?? `menu:${ctx.id}:group-label:${id}`;
  },
  getContentEl: (ctx) => dom14.getById(ctx, dom14.getContentId(ctx)),
  getPositionerEl: (ctx) => dom14.getById(ctx, dom14.getPositionerId(ctx)),
  getTriggerEl: (ctx) => dom14.getById(ctx, dom14.getTriggerId(ctx)),
  getHighlightedItemEl: (ctx) => ctx.highlightedValue ? dom14.getById(ctx, ctx.highlightedValue) : null,
  getArrowEl: (ctx) => dom14.getById(ctx, dom14.getArrowId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom14.getContentId(ctx));
    const selector = `[role^="menuitem"][data-ownedby=${ownerId}]:not([data-disabled])`;
    return queryAll6(dom14.getContentEl(ctx), selector);
  },
  getFirstEl: (ctx) => first(dom14.getElements(ctx)),
  getLastEl: (ctx) => last(dom14.getElements(ctx)),
  getNextEl: (ctx, loop) => nextById3(dom14.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),
  getPrevEl: (ctx, loop) => prevById3(dom14.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),
  getElemByKey: (ctx, key) => getByTypeahead22(dom14.getElements(ctx), { state: ctx.typeaheadState, key, activeId: ctx.highlightedValue }),
  isTargetDisabled: (v) => {
    return isHTMLElement8(v) && (v.dataset.disabled === "" || v.hasAttribute("disabled"));
  },
  isTriggerItem: (el) => {
    var _a7;
    return !!((_a7 = el == null ? void 0 : el.getAttribute("role")) == null ? void 0 : _a7.startsWith("menuitem")) && !!(el == null ? void 0 : el.hasAttribute("aria-controls"));
  },
  getOptionFromItemEl(el) {
    return {
      id: el.id,
      name: el.dataset.name,
      value: el.dataset.value,
      valueText: el.dataset.valueText,
      type: el.dataset.type
    };
  }
});
var { not: not14, and: and14, or: or9 } = guards8;
var props12 = createProps13()([
  "anchorPoint",
  "aria-label",
  "closeOnSelect",
  "dir",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "loopFocus",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onEscapeKeyDown",
  "onSelect",
  "onHighlightChange",
  "open",
  "open.controlled",
  "positioning",
  "typeahead",
  "composite"
]);
var splitProps13 = createSplitProps(props12);
var itemProps3 = createProps13()(["closeOnSelect", "disabled", "value", "valueText"]);
var splitItemProps3 = createSplitProps(itemProps3);
var itemGroupLabelProps = createProps13()(["htmlFor"]);
var splitItemGroupLabelProps = createSplitProps(itemGroupLabelProps);
var itemGroupProps = createProps13()(["id"]);
var splitItemGroupProps = createSplitProps(itemGroupProps);
var optionItemProps = createProps13()([
  "disabled",
  "valueText",
  "closeOnSelect",
  "type",
  "value",
  "checked",
  "onCheckedChange"
]);
var splitOptionItemProps = createSplitProps(optionItemProps);

// node_modules/@zag-js/number-input/node_modules/@zag-js/dom-query/dist/index.mjs
var MAX_Z_INDEX2 = 2147483647;
var isDocument16 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow16 = (el) => el != null && el === el.window;
function getDocument19(el) {
  if (isDocument16(el)) return el;
  if (isWindow16(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var isDom3 = () => typeof document !== "undefined";
function getPlatform2() {
  const agent = navigator.userAgentData;
  return (agent == null ? void 0 : agent.platform) ?? navigator.platform;
}
var pt2 = (v) => isDom3() && v.test(getPlatform2());
var vn2 = (v) => isDom3() && v.test(navigator.vendor);
var isSafari3 = () => isApple2() && vn2(/apple/i);
var isApple2 = () => pt2(/mac|iphone|ipad|ipod/i);
var defaultItemToId23 = (v) => v.id;
function itemById23(v, id, itemToId = defaultItemToId23) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId23(v, id, itemToId = defaultItemToId23) {
  const item = itemById23(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize23 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText23 = (item) => sanitize23(item.dataset.valuetext ?? item.textContent ?? "");
var match26 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap25 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText23(v, text, currentId, itemToId = defaultItemToId23) {
  const index = currentId ? indexOfId23(v, currentId, itemToId) : -1;
  let items = currentId ? wrap25(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match26(getValueText23(item), text));
}
function getByTypeaheadImpl23(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText23(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead23 = Object.assign(getByTypeaheadImpl23, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent23
});
function isValidTypeaheadEvent23(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function createScope16(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument19(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps23 = 1e3 / 60;

// node_modules/@zag-js/number-utils/dist/index.mjs
function wrap26(num, max4) {
  return (num % max4 + max4) % max4;
}
function roundToDevicePixel(num) {
  if (typeof window.devicePixelRatio !== "number") return Math.round(num);
  const dp = window.devicePixelRatio;
  return Math.floor(num * dp + 0.5) / dp;
}
var nf = new Intl.NumberFormat("en-US", { style: "decimal", maximumFractionDigits: 20 });

// node_modules/@zag-js/number-input/node_modules/@zag-js/store/dist/index.mjs
function getGlobal15() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal15(key, value) {
  const g = getGlobal15();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev15 = () => true;
var isObject19 = (x) => typeof x === "object" && x !== null;
var proxyStateMap15 = makeGlobal15("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet15 = makeGlobal15("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction15 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject19(x) && !refSet15.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet15.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap15.has(value)) {
      snap[key] = snapshot15(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject19(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev15() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev15() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject19(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap15.has(value) && canProxy(value)) {
          nextValue = proxy15(value);
        }
        const childProxyState = !refSet15.has(nextValue) && proxyStateMap15.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap15.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap15,
  refSet15,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction15] = buildProxyFunction15();
function proxy15(initialObject = {}) {
  return proxyFunction15(initialObject);
}
function snapshot15(proxyObject, handlePromise) {
  const proxyState = proxyStateMap15.get(proxyObject);
  if (isDev15() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/number-input/node_modules/@zag-js/core/dist/index.mjs
var isString10 = (v) => typeof v === "string";
var isFunction11 = (v) => typeof v === "function";
function exec9(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString10(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction11(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or10(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec9(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and15(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec9(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not15(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec9(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn9(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards9 = { or: or10, and: and15, not: not15, stateIn: stateIn9 };

// node_modules/@internationalized/number/dist/NumberFormatter.mjs
var $488c6ddbf4ef74c2$var$formatterCache = /* @__PURE__ */ new Map();
var $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
try {
  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch (e) {
}
var $488c6ddbf4ef74c2$var$supportsUnit = false;
try {
  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch (e) {
}
var $488c6ddbf4ef74c2$var$UNITS = {
  degree: {
    narrow: {
      default: "°",
      "ja-JP": " 度",
      "zh-TW": "度",
      "sl-SI": " °"
    }
  }
};
var $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 = class {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(value) {
    let res = "";
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);
    else res = this.numberFormatter.format(value);
    if (this.options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
      var _UNITS_unit;
      let { unit, unitDisplay = "short", locale } = this.resolvedOptions();
      if (!unit) return res;
      let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
      res += values[locale] || values.default;
    }
    return res;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(value) {
    return this.numberFormatter.formatToParts(value);
  }
  /** Formats a number range as a string. */
  formatRange(start, end) {
    if (typeof this.numberFormatter.formatRange === "function")
      return this.numberFormatter.formatRange(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    return `${this.format(start)} – ${this.format(end)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.numberFormatter.formatRangeToParts === "function")
      return this.numberFormatter.formatRangeToParts(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    let startParts = this.numberFormatter.formatToParts(start);
    let endParts = this.numberFormatter.formatToParts(end);
    return [
      ...startParts.map((p) => ({
        ...p,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...endParts.map((p) => ({
        ...p,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let options = this.numberFormatter.resolvedOptions();
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {
      ...options,
      signDisplay: this.options.signDisplay
    };
    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === "unit") options = {
      ...options,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    };
    return options;
  }
  constructor(locale, options = {}) {
    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);
    this.options = options;
  }
};
function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {
  let { numberingSystem } = options;
  if (numberingSystem && locale.includes("-nu-")) {
    if (!locale.includes("-u-")) locale += "-u-";
    locale += `-nu-${numberingSystem}`;
  }
  if (options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
    var _UNITS_unit;
    let { unit, unitDisplay = "short" } = options;
    if (!unit) throw new Error('unit option must be provided with style: "unit"');
    if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
    options = {
      ...options,
      style: "decimal"
    };
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.NumberFormat(locale, options);
  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
  if (signDisplay === "auto") return numberFormat.format(num);
  else if (signDisplay === "never") return numberFormat.format(Math.abs(num));
  else {
    let needsPositiveSign = false;
    if (signDisplay === "always") needsPositiveSign = num > 0 || Object.is(num, 0);
    else if (signDisplay === "exceptZero") {
      if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);
      else needsPositiveSign = num > 0;
    }
    if (needsPositiveSign) {
      let negative = numberFormat.format(-num);
      let noSign = numberFormat.format(num);
      let minus = negative.replace(noSign, "").replace(/\u200e|\u061C/, "");
      if ([
        ...minus
      ].length !== 1) console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case");
      let positive = negative.replace(noSign, "!!!").replace(minus, "+").replace("!!!", noSign);
      return positive;
    } else return numberFormat.format(num);
  }
}

// node_modules/@internationalized/number/dist/NumberParser.mjs
var $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp("^.*\\(.*\\).*$");
var $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
  "latn",
  "arab",
  "hanidec"
];
var $6c7bd7858deea686$export$cd11ab140839f11d = class {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(value, minValue, maxValue2) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue2);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.options = options;
  }
};
var $6c7bd7858deea686$var$numberParserCache = /* @__PURE__ */ new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {
  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);
  if (!locale.includes("-nu-") && !defaultParser.isValidPartialNumber(value)) {
    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS) if (numberingSystem !== defaultParser.options.numberingSystem) {
      let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes("-u-") ? "-nu-" : "-u-nu-") + numberingSystem, options);
      if (parser.isValidPartialNumber(value)) return parser;
    }
  }
  return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
  if (!parser) {
    parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);
  }
  return parser;
}
var $6c7bd7858deea686$var$NumberParserImpl = class {
  parse(value) {
    let fullySanitizedValue = this.sanitize(value);
    if (this.symbols.group)
      fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, "");
    if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, ".");
    if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, "-");
    fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
    if (this.options.style === "percent") {
      let isNegative = fullySanitizedValue.indexOf("-");
      fullySanitizedValue = fullySanitizedValue.replace("-", "");
      let index = fullySanitizedValue.indexOf(".");
      if (index === -1) index = fullySanitizedValue.length;
      fullySanitizedValue = fullySanitizedValue.replace(".", "");
      if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;
      else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;
      else if (index - 2 === -2) fullySanitizedValue = "0.00";
      else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;
      if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;
    }
    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
    if (isNaN(newValue)) return NaN;
    if (this.options.style === "percent") {
      var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
      let options = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),
        maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)
      };
      return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));
    }
    if (this.options.currencySign === "accounting" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;
    return newValue;
  }
  sanitize(value) {
    value = value.replace(this.symbols.literals, "");
    if (this.symbols.minusSign) value = value.replace("-", this.symbols.minusSign);
    if (this.options.numberingSystem === "arab") {
      if (this.symbols.decimal) {
        value = value.replace(",", this.symbols.decimal);
        value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
      }
      if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, ".", this.symbols.group);
    }
    if (this.options.locale === "fr-FR") value = $6c7bd7858deea686$var$replaceAll(value, ".", String.fromCharCode(8239));
    return value;
  }
  isValidPartialNumber(value, minValue = -Infinity, maxValue2 = Infinity) {
    value = this.sanitize(value);
    if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);
    else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue2 > 0) value = value.slice(this.symbols.plusSign.length);
    if (this.symbols.group && value.startsWith(this.symbols.group)) return false;
    if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;
    if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, "");
    value = value.replace(this.symbols.numeral, "");
    if (this.symbols.decimal) value = value.replace(this.symbols.decimal, "");
    return value.length === 0;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.formatter = new Intl.NumberFormat(locale, options);
    this.options = this.formatter.resolvedOptions();
    this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);
    var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
    if (this.options.style === "percent" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
};
var $6c7bd7858deea686$var$nonLiteralParts = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]);
var $6c7bd7858deea686$var$pluralNumbers = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
  var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
  let symbolFormatter = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21
  });
  let allParts = symbolFormatter.formatToParts(-10000.111);
  let posAllParts = symbolFormatter.formatToParts(10000.111);
  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n) => symbolFormatter.formatToParts(n));
  var _allParts_find_value;
  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p) => p.type === "minusSign")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : "-";
  let plusSign = (_posAllParts_find = posAllParts.find((p) => p.type === "plusSign")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "exceptZero" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "always")) plusSign = "+";
  let decimalParts = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3);
  let decimal = (_decimalParts_find = decimalParts.find((p) => p.type === "decimal")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
  let group2 = (_allParts_find1 = allParts.find((p) => p.type === "group")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
  let allPartsLiterals = allParts.filter((p) => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p) => $6c7bd7858deea686$var$escapeRegex(p.value));
  let pluralPartsLiterals = pluralParts.flatMap((p) => p.filter((p2) => !$6c7bd7858deea686$var$nonLiteralParts.has(p2.type)).map((p2) => $6c7bd7858deea686$var$escapeRegex(p2.value)));
  let sortedLiterals = [
    .../* @__PURE__ */ new Set([
      ...allPartsLiterals,
      ...pluralPartsLiterals
    ])
  ].sort((a, b) => b.length - a.length);
  let literals = sortedLiterals.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${sortedLiterals.join("|")}|[\\p{White_Space}]`, "gu");
  let numerals = [
    ...new Intl.NumberFormat(intlOptions.locale, {
      useGrouping: false
    }).format(9876543210)
  ].reverse();
  let indexes = new Map(numerals.map((d, i) => [
    d,
    i
  ]));
  let numeral = new RegExp(`[${numerals.join("")}]`, "g");
  let index = (d) => String(indexes.get(d));
  return {
    minusSign,
    plusSign,
    decimal,
    group: group2,
    literals,
    numeral,
    index
  };
}
function $6c7bd7858deea686$var$replaceAll(str, find, replace2) {
  if (str.replaceAll)
    return str.replaceAll(find, replace2);
  return str.split(find).join(replace2);
}
function $6c7bd7858deea686$var$escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// node_modules/@zag-js/number-input/dist/index.mjs
var anatomy21 = createAnatomy("numberInput").parts(
  "root",
  "label",
  "input",
  "control",
  "valueText",
  "incrementTrigger",
  "decrementTrigger",
  "scrubber"
);
var parts15 = anatomy21.build();
var dom15 = createScope16({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `number-input:${ctx.id}`;
  },
  getInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.input) ?? `number-input:${ctx.id}:input`;
  },
  getIncrementTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.incrementTrigger) ?? `number-input:${ctx.id}:inc`;
  },
  getDecrementTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.decrementTrigger) ?? `number-input:${ctx.id}:dec`;
  },
  getScrubberId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.scrubber) ?? `number-input:${ctx.id}:scrubber`;
  },
  getCursorId: (ctx) => `number-input:${ctx.id}:cursor`,
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `number-input:${ctx.id}:label`;
  },
  getInputEl: (ctx) => dom15.getById(ctx, dom15.getInputId(ctx)),
  getIncrementTriggerEl: (ctx) => dom15.getById(ctx, dom15.getIncrementTriggerId(ctx)),
  getDecrementTriggerEl: (ctx) => dom15.getById(ctx, dom15.getDecrementTriggerId(ctx)),
  getScrubberEl: (ctx) => dom15.getById(ctx, dom15.getScrubberId(ctx)),
  getCursorEl: (ctx) => dom15.getDoc(ctx).getElementById(dom15.getCursorId(ctx)),
  getPressedTriggerEl: (ctx, hint = ctx.hint) => {
    let btnEl = null;
    if (hint === "increment") {
      btnEl = dom15.getIncrementTriggerEl(ctx);
    }
    if (hint === "decrement") {
      btnEl = dom15.getDecrementTriggerEl(ctx);
    }
    return btnEl;
  },
  setupVirtualCursor(ctx) {
    if (isSafari3()) return;
    dom15.createVirtualCursor(ctx);
    return () => {
      var _a7;
      (_a7 = dom15.getCursorEl(ctx)) == null ? void 0 : _a7.remove();
    };
  },
  preventTextSelection(ctx) {
    const doc = dom15.getDoc(ctx);
    const html = doc.documentElement;
    const body = doc.body;
    body.style.pointerEvents = "none";
    html.style.userSelect = "none";
    html.style.cursor = "ew-resize";
    return () => {
      body.style.pointerEvents = "";
      html.style.userSelect = "";
      html.style.cursor = "";
      if (!html.style.length) {
        html.removeAttribute("style");
      }
      if (!body.style.length) {
        body.removeAttribute("style");
      }
    };
  },
  getMousementValue(ctx, event) {
    const x = roundToDevicePixel(event.movementX);
    const y = roundToDevicePixel(event.movementY);
    let hint = x > 0 ? "increment" : x < 0 ? "decrement" : null;
    if (ctx.isRtl && hint === "increment") hint = "decrement";
    if (ctx.isRtl && hint === "decrement") hint = "increment";
    const point = {
      x: ctx.scrubberCursorPoint.x + x,
      y: ctx.scrubberCursorPoint.y + y
    };
    const win = dom15.getWin(ctx);
    const width = win.innerWidth;
    const half = roundToDevicePixel(7.5);
    point.x = wrap26(point.x + half, width) - half;
    return { hint, point };
  },
  createVirtualCursor(ctx) {
    const doc = dom15.getDoc(ctx);
    const el = doc.createElement("div");
    el.className = "scrubber--cursor";
    el.id = dom15.getCursorId(ctx);
    Object.assign(el.style, {
      width: "15px",
      height: "15px",
      position: "fixed",
      pointerEvents: "none",
      left: "0px",
      top: "0px",
      zIndex: MAX_Z_INDEX2,
      transform: ctx.scrubberCursorPoint ? `translate3d(${ctx.scrubberCursorPoint.x}px, ${ctx.scrubberCursorPoint.y}px, 0px)` : void 0,
      willChange: "transform"
    });
    el.innerHTML = `
        <svg width="46" height="15" style="left: -15.5px; position: absolute; top: 0; filter: drop-shadow(rgba(0, 0, 0, 0.4) 0px 1px 1.1px);">
          <g transform="translate(2 3)">
            <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z" style="stroke-width: 2px; stroke: white;"></path>
            <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z"></path>
          </g>
        </svg>`;
    doc.body.appendChild(el);
  }
});
var { not: not16, and: and16 } = guards9;

// node_modules/@zag-js/pagination/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument17 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow17 = (el) => el != null && el === el.window;
function getDocument20(el) {
  if (isDocument17(el)) return el;
  if (isWindow17(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId24 = (v) => v.id;
function itemById24(v, id, itemToId = defaultItemToId24) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId24(v, id, itemToId = defaultItemToId24) {
  const item = itemById24(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize24 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText24 = (item) => sanitize24(item.dataset.valuetext ?? item.textContent ?? "");
var match27 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap27 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText24(v, text, currentId, itemToId = defaultItemToId24) {
  const index = currentId ? indexOfId24(v, currentId, itemToId) : -1;
  let items = currentId ? wrap27(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match27(getValueText24(item), text));
}
function getByTypeaheadImpl24(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText24(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead24 = Object.assign(getByTypeaheadImpl24, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent24
});
function isValidTypeaheadEvent24(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function createScope17(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument20(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps24 = 1e3 / 60;

// node_modules/@zag-js/pagination/node_modules/@zag-js/store/dist/index.mjs
function getGlobal16() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal16(key, value) {
  const g = getGlobal16();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev16 = () => true;
var isObject20 = (x) => typeof x === "object" && x !== null;
var proxyStateMap16 = makeGlobal16("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet16 = makeGlobal16("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction16 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject20(x) && !refSet16.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet16.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap16.has(value)) {
      snap[key] = snapshot16(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject20(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev16() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev16() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject20(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap16.has(value) && canProxy(value)) {
          nextValue = proxy16(value);
        }
        const childProxyState = !refSet16.has(nextValue) && proxyStateMap16.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap16.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap16,
  refSet16,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction16] = buildProxyFunction16();
function proxy16(initialObject = {}) {
  return proxyFunction16(initialObject);
}
function snapshot16(proxyObject, handlePromise) {
  const proxyState = proxyStateMap16.get(proxyObject);
  if (isDev16() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/pagination/node_modules/@zag-js/types/dist/index.mjs
var createProps14 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/pagination/dist/index.mjs
var anatomy22 = createAnatomy("pagination").parts("root", "item", "ellipsis", "prevTrigger", "nextTrigger");
var parts16 = anatomy22.build();
var dom16 = createScope17({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `pagination:${ctx.id}`;
  },
  getPrevTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.prevTrigger) ?? `pagination:${ctx.id}:prev`;
  },
  getNextTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.nextTrigger) ?? `pagination:${ctx.id}:next`;
  },
  getEllipsisId: (ctx, index) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.ellipsis) == null ? void 0 : _b6.call(_a7, index)) ?? `pagination:${ctx.id}:ellipsis:${index}`;
  },
  getItemId: (ctx, page) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.item) == null ? void 0 : _b6.call(_a7, page)) ?? `pagination:${ctx.id}:item:${page}`;
  }
});
var props13 = createProps14()([
  "count",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onPageChange",
  "onPageSizeChange",
  "page",
  "pageSize",
  "siblingCount",
  "translations",
  "type"
]);
var splitProps14 = createSplitProps(props13);
var itemProps4 = createProps14()(["value", "type"]);
var splitItemProps4 = createSplitProps(itemProps4);
var ellipsisProps = createProps14()(["index"]);
var splitEllipsisProps = createSplitProps(ellipsisProps);

// node_modules/@zag-js/pin-input/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument18 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow18 = (el) => el != null && el === el.window;
function getDocument21(el) {
  if (isDocument18(el)) return el;
  if (isWindow18(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId25 = (v) => v.id;
function itemById25(v, id, itemToId = defaultItemToId25) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId25(v, id, itemToId = defaultItemToId25) {
  const item = itemById25(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize25 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText25 = (item) => sanitize25(item.dataset.valuetext ?? item.textContent ?? "");
var match28 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap28 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText25(v, text, currentId, itemToId = defaultItemToId25) {
  const index = currentId ? indexOfId25(v, currentId, itemToId) : -1;
  let items = currentId ? wrap28(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match28(getValueText25(item), text));
}
function getByTypeaheadImpl25(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText25(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead25 = Object.assign(getByTypeaheadImpl25, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent25
});
function isValidTypeaheadEvent25(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function queryAll7(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function createScope18(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument21(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps25 = 1e3 / 60;

// node_modules/@zag-js/pin-input/node_modules/@zag-js/store/dist/index.mjs
function getGlobal17() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal17(key, value) {
  const g = getGlobal17();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev17 = () => true;
var isObject21 = (x) => typeof x === "object" && x !== null;
var proxyStateMap17 = makeGlobal17("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet17 = makeGlobal17("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction17 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject21(x) && !refSet17.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet17.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap17.has(value)) {
      snap[key] = snapshot17(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject21(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev17() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev17() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject21(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap17.has(value) && canProxy(value)) {
          nextValue = proxy17(value);
        }
        const childProxyState = !refSet17.has(nextValue) && proxyStateMap17.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap17.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap17,
  refSet17,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction17] = buildProxyFunction17();
function proxy17(initialObject = {}) {
  return proxyFunction17(initialObject);
}
function snapshot17(proxyObject, handlePromise) {
  const proxyState = proxyStateMap17.get(proxyObject);
  if (isDev17() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/pin-input/dist/index.mjs
var anatomy23 = createAnatomy("pinInput").parts("root", "label", "input", "control");
var parts17 = anatomy23.build();
var dom17 = createScope18({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `pin-input:${ctx.id}`;
  },
  getInputId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.input) == null ? void 0 : _b6.call(_a7, id)) ?? `pin-input:${ctx.id}:${id}`;
  },
  getHiddenInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.hiddenInput) ?? `pin-input:${ctx.id}:hidden`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `pin-input:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `pin-input:${ctx.id}:control`;
  },
  getRootEl: (ctx) => dom17.getById(ctx, dom17.getRootId(ctx)),
  getInputEls: (ctx) => {
    const ownerId = CSS.escape(dom17.getRootId(ctx));
    const selector = `input[data-ownedby=${ownerId}]`;
    return queryAll7(dom17.getRootEl(ctx), selector);
  },
  getInputEl: (ctx, id) => dom17.getById(ctx, dom17.getInputId(ctx, id)),
  getFocusedInputEl: (ctx) => dom17.getInputEls(ctx)[ctx.focusedIndex],
  getFirstInputEl: (ctx) => dom17.getInputEls(ctx)[0],
  getHiddenInputEl: (ctx) => dom17.getById(ctx, dom17.getHiddenInputId(ctx))
});

// node_modules/@zag-js/popover/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument19 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow19 = (el) => el != null && el === el.window;
function getDocument22(el) {
  if (isDocument19(el)) return el;
  if (isWindow19(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId26 = (v) => v.id;
function itemById26(v, id, itemToId = defaultItemToId26) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId26(v, id, itemToId = defaultItemToId26) {
  const item = itemById26(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize26 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText26 = (item) => sanitize26(item.dataset.valuetext ?? item.textContent ?? "");
var match29 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap29 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText26(v, text, currentId, itemToId = defaultItemToId26) {
  const index = currentId ? indexOfId26(v, currentId, itemToId) : -1;
  let items = currentId ? wrap29(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match29(getValueText26(item), text));
}
function getByTypeaheadImpl26(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText26(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead26 = Object.assign(getByTypeaheadImpl26, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent26
});
function isValidTypeaheadEvent26(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var isHTMLElement22 = (element) => typeof element === "object" && element !== null && element.nodeType === 1;
var isFrame2 = (element) => isHTMLElement22(element) && element.tagName === "IFRAME";
function isVisible2(el) {
  if (!isHTMLElement22(el)) return false;
  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;
}
var focusableSelector2 = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
var getFocusables2 = (container, includeContainer = false) => {
  if (!container) return [];
  const elements = Array.from(container.querySelectorAll(focusableSelector2));
  const include = includeContainer == true || includeContainer == "if-empty" && elements.length === 0;
  if (include && isHTMLElement22(container) && isFocusable5(container)) {
    elements.unshift(container);
  }
  const focusableElements = elements.filter(isFocusable5);
  focusableElements.forEach((element, i) => {
    if (isFrame2(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      focusableElements.splice(i, 1, ...getFocusables2(frameBody));
    }
  });
  return focusableElements;
};
function isFocusable5(element) {
  if (!element || element.closest("[inert]")) return false;
  return element.matches(focusableSelector2) && isVisible2(element);
}
function createScope19(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument22(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps26 = 1e3 / 60;

// node_modules/@zag-js/popover/node_modules/@zag-js/store/dist/index.mjs
function getGlobal18() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal18(key, value) {
  const g = getGlobal18();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev18 = () => true;
var isObject22 = (x) => typeof x === "object" && x !== null;
var proxyStateMap18 = makeGlobal18("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet18 = makeGlobal18("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction18 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject22(x) && !refSet18.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet18.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap18.has(value)) {
      snap[key] = snapshot18(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject22(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev18() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev18() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject22(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap18.has(value) && canProxy(value)) {
          nextValue = proxy18(value);
        }
        const childProxyState = !refSet18.has(nextValue) && proxyStateMap18.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap18.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap18,
  refSet18,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction18] = buildProxyFunction18();
function proxy18(initialObject = {}) {
  return proxyFunction18(initialObject);
}
function snapshot18(proxyObject, handlePromise) {
  const proxyState = proxyStateMap18.get(proxyObject);
  if (isDev18() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/popover/node_modules/@zag-js/types/dist/index.mjs
var createProps15 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/popover/dist/index.mjs
var anatomy24 = createAnatomy("popover").parts(
  "arrow",
  "arrowTip",
  "anchor",
  "trigger",
  "indicator",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts18 = anatomy24.build();
var dom18 = createScope19({
  getAnchorId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.anchor) ?? `popover:${ctx.id}:anchor`;
  },
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `popover:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `popover:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.positioner) ?? `popover:${ctx.id}:popper`;
  },
  getArrowId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.arrow) ?? `popover:${ctx.id}:arrow`;
  },
  getTitleId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.title) ?? `popover:${ctx.id}:title`;
  },
  getDescriptionId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.description) ?? `popover:${ctx.id}:desc`;
  },
  getCloseTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.closeTrigger) ?? `popover:${ctx.id}:close`;
  },
  getAnchorEl: (ctx) => dom18.getById(ctx, dom18.getAnchorId(ctx)),
  getTriggerEl: (ctx) => dom18.getById(ctx, dom18.getTriggerId(ctx)),
  getContentEl: (ctx) => dom18.getById(ctx, dom18.getContentId(ctx)),
  getPositionerEl: (ctx) => dom18.getById(ctx, dom18.getPositionerId(ctx)),
  getTitleEl: (ctx) => dom18.getById(ctx, dom18.getTitleId(ctx)),
  getDescriptionEl: (ctx) => dom18.getById(ctx, dom18.getDescriptionId(ctx)),
  getFocusableEls: (ctx) => getFocusables2(dom18.getContentEl(ctx)),
  getFirstFocusableEl: (ctx) => dom18.getFocusableEls(ctx)[0]
});
var props14 = createProps15()([
  "autoFocus",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "open.controlled",
  "open",
  "persistentElements",
  "portalled",
  "positioning"
]);
var splitProps15 = createSplitProps(props14);

// node_modules/@zag-js/progress/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument20 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow20 = (el) => el != null && el === el.window;
function getDocument23(el) {
  if (isDocument20(el)) return el;
  if (isWindow20(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId27 = (v) => v.id;
function itemById27(v, id, itemToId = defaultItemToId27) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId27(v, id, itemToId = defaultItemToId27) {
  const item = itemById27(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize27 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText27 = (item) => sanitize27(item.dataset.valuetext ?? item.textContent ?? "");
var match30 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap30 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText27(v, text, currentId, itemToId = defaultItemToId27) {
  const index = currentId ? indexOfId27(v, currentId, itemToId) : -1;
  let items = currentId ? wrap30(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match30(getValueText27(item), text));
}
function getByTypeaheadImpl27(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText27(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead27 = Object.assign(getByTypeaheadImpl27, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent27
});
function isValidTypeaheadEvent27(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function createScope20(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument23(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps27 = 1e3 / 60;

// node_modules/@zag-js/progress/node_modules/@zag-js/store/dist/index.mjs
function getGlobal19() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal19(key, value) {
  const g = getGlobal19();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev19 = () => true;
var isObject23 = (x) => typeof x === "object" && x !== null;
var proxyStateMap19 = makeGlobal19("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet19 = makeGlobal19("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction19 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject23(x) && !refSet19.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet19.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap19.has(value)) {
      snap[key] = snapshot19(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject23(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev19() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev19() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject23(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap19.has(value) && canProxy(value)) {
          nextValue = proxy19(value);
        }
        const childProxyState = !refSet19.has(nextValue) && proxyStateMap19.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap19.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap19,
  refSet19,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction19] = buildProxyFunction19();
function proxy19(initialObject = {}) {
  return proxyFunction19(initialObject);
}
function snapshot19(proxyObject, handlePromise) {
  const proxyState = proxyStateMap19.get(proxyObject);
  if (isDev19() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/progress/node_modules/@zag-js/types/dist/index.mjs
var createProps16 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/progress/dist/index.mjs
var anatomy25 = createAnatomy("progress").parts(
  "root",
  "label",
  "track",
  "range",
  "valueText",
  "view",
  "circle",
  "circleTrack",
  "circleRange"
);
var parts19 = anatomy25.build();
var dom19 = createScope20({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `progress-${ctx.id}`;
  },
  getTrackId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.track) ?? `progress-${ctx.id}-track`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `progress-${ctx.id}-label`;
  },
  getCircleId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.circle) ?? `progress-${ctx.id}-circle`;
  }
});
var props15 = createProps16()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "max",
  "min",
  "orientation",
  "translations",
  "value"
]);
var splitProps16 = createSplitProps(props15);

// node_modules/@zag-js/qr-code/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument21 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow21 = (el) => el != null && el === el.window;
function getDocument24(el) {
  if (isDocument21(el)) return el;
  if (isWindow21(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId28 = (v) => v.id;
function itemById28(v, id, itemToId = defaultItemToId28) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId28(v, id, itemToId = defaultItemToId28) {
  const item = itemById28(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize28 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText28 = (item) => sanitize28(item.dataset.valuetext ?? item.textContent ?? "");
var match31 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap31 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText28(v, text, currentId, itemToId = defaultItemToId28) {
  const index = currentId ? indexOfId28(v, currentId, itemToId) : -1;
  let items = currentId ? wrap31(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match31(getValueText28(item), text));
}
function getByTypeaheadImpl28(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText28(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead28 = Object.assign(getByTypeaheadImpl28, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent28
});
function isValidTypeaheadEvent28(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function createScope21(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument24(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps28 = 1e3 / 60;

// node_modules/@zag-js/qr-code/node_modules/@zag-js/store/dist/index.mjs
function getGlobal20() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal20(key, value) {
  const g = getGlobal20();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev20 = () => true;
var isObject24 = (x) => typeof x === "object" && x !== null;
var proxyStateMap20 = makeGlobal20("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet20 = makeGlobal20("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction20 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject24(x) && !refSet20.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet20.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap20.has(value)) {
      snap[key] = snapshot20(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject24(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev20() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev20() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject24(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap20.has(value) && canProxy(value)) {
          nextValue = proxy20(value);
        }
        const childProxyState = !refSet20.has(nextValue) && proxyStateMap20.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap20.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap20,
  refSet20,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction20] = buildProxyFunction20();
function proxy20(initialObject = {}) {
  return proxyFunction20(initialObject);
}
function snapshot20(proxyObject, handlePromise) {
  const proxyState = proxyStateMap20.get(proxyObject);
  if (isDev20() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/uqr/dist/index.mjs
var QrCodeDataType = ((QrCodeDataType2) => {
  QrCodeDataType2[QrCodeDataType2["Border"] = -1] = "Border";
  QrCodeDataType2[QrCodeDataType2["Data"] = 0] = "Data";
  QrCodeDataType2[QrCodeDataType2["Function"] = 1] = "Function";
  QrCodeDataType2[QrCodeDataType2["Position"] = 2] = "Position";
  QrCodeDataType2[QrCodeDataType2["Timing"] = 3] = "Timing";
  QrCodeDataType2[QrCodeDataType2["Alignment"] = 4] = "Alignment";
  return QrCodeDataType2;
})(QrCodeDataType || {});

// node_modules/@zag-js/qr-code/node_modules/@zag-js/types/dist/index.mjs
var createProps17 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/qr-code/dist/index.mjs
var anatomy26 = createAnatomy("qr-code").parts("root", "frame", "pattern", "overlay");
var parts20 = anatomy26.build();
var dom20 = createScope21({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `qrcode:${ctx.id}:root`;
  },
  getFrameId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.frame) ?? `qrcode:${ctx.id}:frame`;
  },
  getFrameEl: (ctx) => dom20.getById(ctx, dom20.getFrameId(ctx))
});
var props16 = createProps17()(["ids", "value", "id", "encoding", "dir", "getRootNode"]);
var splitProps17 = createSplitProps(props16);

// node_modules/@zag-js/radio-group/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument22 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow22 = (el) => el != null && el === el.window;
function getDocument25(el) {
  if (isDocument22(el)) return el;
  if (isWindow22(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId29 = (v) => v.id;
function itemById29(v, id, itemToId = defaultItemToId29) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId29(v, id, itemToId = defaultItemToId29) {
  const item = itemById29(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize29 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText29 = (item) => sanitize29(item.dataset.valuetext ?? item.textContent ?? "");
var match32 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap32 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText29(v, text, currentId, itemToId = defaultItemToId29) {
  const index = currentId ? indexOfId29(v, currentId, itemToId) : -1;
  let items = currentId ? wrap32(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match32(getValueText29(item), text));
}
function getByTypeaheadImpl29(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText29(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead29 = Object.assign(getByTypeaheadImpl29, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent29
});
function isValidTypeaheadEvent29(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function queryAll8(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function createScope22(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument25(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps29 = 1e3 / 60;

// node_modules/@zag-js/radio-group/node_modules/@zag-js/store/dist/index.mjs
function getGlobal21() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal21(key, value) {
  const g = getGlobal21();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev21 = () => true;
var isObject25 = (x) => typeof x === "object" && x !== null;
var proxyStateMap21 = makeGlobal21("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet21 = makeGlobal21("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction21 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject25(x) && !refSet21.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet21.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap21.has(value)) {
      snap[key] = snapshot21(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject25(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev21() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev21() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject25(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap21.has(value) && canProxy(value)) {
          nextValue = proxy21(value);
        }
        const childProxyState = !refSet21.has(nextValue) && proxyStateMap21.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap21.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap21,
  refSet21,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction21] = buildProxyFunction21();
function proxy21(initialObject = {}) {
  return proxyFunction21(initialObject);
}
function snapshot21(proxyObject, handlePromise) {
  const proxyState = proxyStateMap21.get(proxyObject);
  if (isDev21() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/radio-group/node_modules/@zag-js/core/dist/index.mjs
var isString11 = (v) => typeof v === "string";
var isFunction12 = (v) => typeof v === "function";
function exec10(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString11(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction12(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or11(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec10(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and17(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec10(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not17(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec10(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn10(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards10 = { or: or11, and: and17, not: not17, stateIn: stateIn10 };

// node_modules/@zag-js/radio-group/node_modules/@zag-js/types/dist/index.mjs
var createProps18 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/radio-group/dist/index.mjs
var anatomy27 = createAnatomy("radio-group").parts(
  "root",
  "label",
  "item",
  "itemText",
  "itemControl",
  "indicator"
);
var parts21 = anatomy27.build();
var dom21 = createScope22({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `radio-group:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `radio-group:${ctx.id}:label`;
  },
  getItemId: (ctx, value) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.item) == null ? void 0 : _b6.call(_a7, value)) ?? `radio-group:${ctx.id}:radio:${value}`;
  },
  getItemHiddenInputId: (ctx, value) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemHiddenInput) == null ? void 0 : _b6.call(_a7, value)) ?? `radio-group:${ctx.id}:radio:input:${value}`;
  },
  getItemControlId: (ctx, value) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemControl) == null ? void 0 : _b6.call(_a7, value)) ?? `radio-group:${ctx.id}:radio:control:${value}`;
  },
  getItemLabelId: (ctx, value) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemLabel) == null ? void 0 : _b6.call(_a7, value)) ?? `radio-group:${ctx.id}:radio:label:${value}`;
  },
  getIndicatorId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.indicator) ?? `radio-group:${ctx.id}:indicator`;
  },
  getRootEl: (ctx) => dom21.getById(ctx, dom21.getRootId(ctx)),
  getItemHiddenInputEl: (ctx, value) => dom21.getById(ctx, dom21.getItemHiddenInputId(ctx, value)),
  getIndicatorEl: (ctx) => dom21.getById(ctx, dom21.getIndicatorId(ctx)),
  getFirstEnabledInputEl: (ctx) => {
    var _a7;
    return (_a7 = dom21.getRootEl(ctx)) == null ? void 0 : _a7.querySelector("input:not(:disabled)");
  },
  getFirstEnabledAndCheckedInputEl: (ctx) => {
    var _a7;
    return (_a7 = dom21.getRootEl(ctx)) == null ? void 0 : _a7.querySelector("input:not(:disabled):checked");
  },
  getInputEls: (ctx) => {
    const ownerId = CSS.escape(dom21.getRootId(ctx));
    const selector = `input[type=radio][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll8(dom21.getRootEl(ctx), selector);
  },
  getActiveRadioEl: (ctx) => {
    if (!ctx.value) return;
    return dom21.getById(ctx, dom21.getItemId(ctx, ctx.value));
  },
  getOffsetRect: (el) => ({
    left: (el == null ? void 0 : el.offsetLeft) ?? 0,
    top: (el == null ? void 0 : el.offsetTop) ?? 0,
    width: (el == null ? void 0 : el.offsetWidth) ?? 0,
    height: (el == null ? void 0 : el.offsetHeight) ?? 0
  }),
  getRectById: (ctx, id) => {
    const radioEl = dom21.getById(ctx, dom21.getItemId(ctx, id));
    if (!radioEl) return;
    return dom21.resolveRect(dom21.getOffsetRect(radioEl));
  },
  resolveRect: (rect) => ({
    width: `${rect.width}px`,
    height: `${rect.height}px`,
    left: `${rect.left}px`,
    top: `${rect.top}px`
  })
});
var { not: not18 } = guards10;
var props17 = createProps18()([
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onValueChange",
  "orientation",
  "readOnly",
  "value"
]);
var splitProps18 = createSplitProps(props17);
var itemProps5 = createProps18()(["value", "disabled", "invalid"]);
var splitItemProps5 = createSplitProps(itemProps5);

// node_modules/@zag-js/rating-group/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument23 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow23 = (el) => el != null && el === el.window;
function getDocument26(el) {
  if (isDocument23(el)) return el;
  if (isWindow23(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId30 = (v) => v.id;
function itemById30(v, id, itemToId = defaultItemToId30) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId30(v, id, itemToId = defaultItemToId30) {
  const item = itemById30(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize30 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText30 = (item) => sanitize30(item.dataset.valuetext ?? item.textContent ?? "");
var match33 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap33 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText30(v, text, currentId, itemToId = defaultItemToId30) {
  const index = currentId ? indexOfId30(v, currentId, itemToId) : -1;
  let items = currentId ? wrap33(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match33(getValueText30(item), text));
}
function getByTypeaheadImpl30(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText30(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead30 = Object.assign(getByTypeaheadImpl30, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent30
});
function isValidTypeaheadEvent30(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function query5(root, selector) {
  return (root == null ? void 0 : root.querySelector(selector)) ?? null;
}
function createScope23(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument26(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps30 = 1e3 / 60;

// node_modules/@zag-js/rating-group/node_modules/@zag-js/store/dist/index.mjs
function getGlobal22() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal22(key, value) {
  const g = getGlobal22();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev22 = () => true;
var isObject26 = (x) => typeof x === "object" && x !== null;
var proxyStateMap22 = makeGlobal22("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet22 = makeGlobal22("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction22 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject26(x) && !refSet22.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet22.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap22.has(value)) {
      snap[key] = snapshot22(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject26(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev22() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev22() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject26(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap22.has(value) && canProxy(value)) {
          nextValue = proxy22(value);
        }
        const childProxyState = !refSet22.has(nextValue) && proxyStateMap22.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap22.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap22,
  refSet22,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction22] = buildProxyFunction22();
function proxy22(initialObject = {}) {
  return proxyFunction22(initialObject);
}
function snapshot22(proxyObject, handlePromise) {
  const proxyState = proxyStateMap22.get(proxyObject);
  if (isDev22() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/rating-group/node_modules/@zag-js/types/dist/index.mjs
var createProps19 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/rating-group/dist/index.mjs
var anatomy28 = createAnatomy("rating-group").parts("root", "label", "item", "control");
var parts22 = anatomy28.build();
var dom22 = createScope23({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `rating:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `rating:${ctx.id}:label`;
  },
  getHiddenInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.hiddenInput) ?? `rating:${ctx.id}:input`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `rating:${ctx.id}:control`;
  },
  getItemId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.item) == null ? void 0 : _b6.call(_a7, id)) ?? `rating:${ctx.id}:item:${id}`;
  },
  getRootEl: (ctx) => dom22.getById(ctx, dom22.getRootId(ctx)),
  getControlEl: (ctx) => dom22.getById(ctx, dom22.getControlId(ctx)),
  getRadioEl: (ctx, value = ctx.value) => {
    const selector = `[role=radio][aria-posinset='${Math.ceil(value)}']`;
    return query5(dom22.getControlEl(ctx), selector);
  },
  getHiddenInputEl: (ctx) => dom22.getById(ctx, dom22.getHiddenInputId(ctx)),
  dispatchChangeEvent: (ctx) => {
    const inputEl = dom22.getHiddenInputEl(ctx);
    if (!inputEl) return;
    dispatchInputValueEvent(inputEl, { value: ctx.value });
  }
});
var props18 = createProps19()([
  "allowHalf",
  "autoFocus",
  "count",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onHoverChange",
  "onValueChange",
  "required",
  "readOnly",
  "translations",
  "value"
]);
var splitProps19 = createSplitProps(props18);
var itemProps6 = createProps19()(["index"]);
var splitItemProps6 = createSplitProps(itemProps6);

// node_modules/@ark-ui/anatomy/dist/segment-group/index.js
var anatomy29 = anatomy27.rename("segment-group");

// node_modules/@zag-js/select/node_modules/@zag-js/collection/dist/index.mjs
var __defProp3 = Object.defineProperty;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField3 = (obj, key, value) => __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
var fallback2 = {
  itemToValue(item) {
    if (typeof item === "string") return item;
    if (isObject3(item) && hasProp(item, "value")) return item.value;
    return "";
  },
  itemToString(item) {
    if (typeof item === "string") return item;
    if (isObject3(item) && hasProp(item, "label")) return item.label;
    return fallback2.itemToValue(item);
  },
  isItemDisabled(item) {
    if (isObject3(item) && hasProp(item, "disabled")) return !!item.disabled;
    return false;
  }
};
var Collection2 = class {
  constructor(options) {
    this.options = options;
    __publicField3(this, "items");
    this.items = [...options.items];
  }
  isEqual(other) {
    return isEqual(this.items, other.items);
  }
  /**
   * Function to update the collection items
   */
  setItems(items) {
    this.items = Array.from(items);
  }
  /**
   * Returns all the values in the collection
   */
  getValues(items = this.items) {
    return Array.from(items).map((item) => this.getItemValue(item)).filter(Boolean);
  }
  /**
   * Get the item based on its value
   */
  find(value) {
    if (value == null) return null;
    const index = this.items.findIndex((item) => this.getItemValue(item) === value);
    return index != null ? this.items[index] : null;
  }
  /**
   * Get the items based on its values
   */
  findMany(values) {
    return Array.from(values).map((value) => this.find(value)).filter(Boolean);
  }
  /**
   * Get the item based on its index
   */
  at(index) {
    return this.items[index] ?? null;
  }
  sortFn(valueA, valueB) {
    const indexA = this.indexOf(valueA);
    const indexB = this.indexOf(valueB);
    return (indexA ?? 0) - (indexB ?? 0);
  }
  /**
   * Sort the values based on their index
   */
  sort(values) {
    return [...values].sort(this.sortFn.bind(this));
  }
  /**
   * Convert an item to a value
   */
  getItemValue(item) {
    var _a7, _b6;
    if (item == null) return null;
    return ((_b6 = (_a7 = this.options).itemToValue) == null ? void 0 : _b6.call(_a7, item)) ?? fallback2.itemToValue(item);
  }
  /**
   * Whether an item is disabled
   */
  getItemDisabled(item) {
    var _a7, _b6;
    if (item == null) return false;
    return ((_b6 = (_a7 = this.options).isItemDisabled) == null ? void 0 : _b6.call(_a7, item)) ?? fallback2.isItemDisabled(item);
  }
  /**
   * Convert an item to a string
   */
  stringifyItem(item) {
    var _a7, _b6;
    if (item == null) return null;
    return ((_b6 = (_a7 = this.options).itemToString) == null ? void 0 : _b6.call(_a7, item)) ?? fallback2.itemToString(item);
  }
  /**
   * Convert a value to a string
   */
  stringify(value) {
    if (value == null) return null;
    return this.stringifyItem(this.find(value));
  }
  /**
   * Convert an array of items to a string
   */
  stringifyItems(items, separator = ", ") {
    return Array.from(items).map((item) => this.stringifyItem(item)).filter(Boolean).join(separator);
  }
  /**
   * Convert an array of items to a string
   */
  stringifyMany(value, separator) {
    return this.stringifyItems(this.findMany(value), separator);
  }
  /**
   * Whether the collection has a value
   */
  has(value) {
    return this.indexOf(value) !== -1;
  }
  /**
   * Whether the collection has an item
   */
  hasItem(item) {
    if (item == null) return false;
    return this.has(this.getItemValue(item));
  }
  /**
   * Returns the number of items in the collection
   */
  get size() {
    return this.items.length;
  }
  /**
   * Returns the first value in the collection
   */
  get firstValue() {
    let index = 0;
    while (this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the last value in the collection
   */
  get lastValue() {
    let index = this.size - 1;
    while (this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the next value in the collection
   */
  getNextValue(value) {
    let index = this.indexOf(value);
    if (index === -1) return null;
    index++;
    while (index <= this.size && this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the previous value in the collection
   */
  getPreviousValue(value) {
    let index = this.indexOf(value);
    if (index === -1) return null;
    index--;
    while (index >= 0 && this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  /**
   * Get the index of an item based on its key
   */
  indexOf(value) {
    if (value == null) return -1;
    return this.items.findIndex((item) => this.getItemValue(item) === value);
  }
  getByText(text, current) {
    let items = current != null ? wrap34(this.items, this.indexOf(current)) : this.items;
    const isSingleKey = text.length === 1;
    if (isSingleKey) items = items.filter((item) => this.getItemValue(item) !== current);
    return items.find((item) => match34(this.stringifyItem(item), text));
  }
  /**
   * Search for a value based on a query
   */
  search(queryString, options) {
    const { state: state2, currentValue, timeout = 350 } = options;
    const search = state2.keysSoFar + queryString;
    const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
    const query9 = isRepeated ? search[0] : search;
    const item = this.getByText(query9, currentValue);
    const value = this.getItemValue(item);
    function cleanup() {
      clearTimeout(state2.timer);
      state2.timer = -1;
    }
    function update(value2) {
      state2.keysSoFar = value2;
      cleanup();
      if (value2 !== "") {
        state2.timer = +setTimeout(() => {
          update("");
          cleanup();
        }, timeout);
      }
    }
    update(search);
    return value;
  }
  *[Symbol.iterator]() {
    yield* this.items;
  }
  insertBefore(value, item) {
    const index = this.indexOf(value);
    if (index === -1) return;
    this.items.splice(index, 0, item);
  }
  insertAfter(value, item) {
    const index = this.indexOf(value);
    if (index === -1) return;
    this.items.splice(index + 1, 0, item);
  }
  reorder(fromIndex, toIndex) {
    if (fromIndex === -1 || toIndex === -1) return;
    if (fromIndex === toIndex) return;
    const [removed] = this.items.splice(fromIndex, 1);
    this.items.splice(toIndex, 0, removed);
  }
  toJSON() {
    return {
      size: this.size,
      first: this.firstValue,
      last: this.lastValue
    };
  }
};
var match34 = (label, query9) => {
  return !!(label == null ? void 0 : label.toLowerCase().startsWith(query9.toLowerCase()));
};
var wrap34 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};

// node_modules/@zag-js/select/node_modules/@zag-js/store/dist/index.mjs
function getGlobal23() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal23(key, value) {
  const g = getGlobal23();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev23 = () => true;
var isObject27 = (x) => typeof x === "object" && x !== null;
var proxyStateMap23 = makeGlobal23("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet23 = makeGlobal23("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction23 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject27(x) && !refSet23.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet23.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap23.has(value)) {
      snap[key] = snapshot23(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject27(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev23() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev23() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject27(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap23.has(value) && canProxy(value)) {
          nextValue = proxy23(value);
        }
        const childProxyState = !refSet23.has(nextValue) && proxyStateMap23.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap23.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap23,
  refSet23,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction23] = buildProxyFunction23();
function proxy23(initialObject = {}) {
  return proxyFunction23(initialObject);
}
function snapshot23(proxyObject, handlePromise) {
  const proxyState = proxyStateMap23.get(proxyObject);
  if (isDev23() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}
function ref23(obj) {
  refSet23.add(obj);
  return obj;
}

// node_modules/@zag-js/select/node_modules/@zag-js/core/dist/index.mjs
var isString13 = (v) => typeof v === "string";
var isFunction13 = (v) => typeof v === "function";
function exec11(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString13(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction13(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or12(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec11(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and18(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec11(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not19(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec11(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn11(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards11 = { or: or12, and: and18, not: not19, stateIn: stateIn11 };

// node_modules/@zag-js/select/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument24 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow24 = (el) => el != null && el === el.window;
function getDocument27(el) {
  if (isDocument24(el)) return el;
  if (isWindow24(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId31 = (v) => v.id;
function itemById31(v, id, itemToId = defaultItemToId31) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId31(v, id, itemToId = defaultItemToId31) {
  const item = itemById31(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize31 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText31 = (item) => sanitize31(item.dataset.valuetext ?? item.textContent ?? "");
var match35 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap35 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText31(v, text, currentId, itemToId = defaultItemToId31) {
  const index = currentId ? indexOfId31(v, currentId, itemToId) : -1;
  let items = currentId ? wrap35(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match35(getValueText31(item), text));
}
function getByTypeaheadImpl31(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText31(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead31 = Object.assign(getByTypeaheadImpl31, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent31
});
function isValidTypeaheadEvent31(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function createScope24(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument27(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps31 = 1e3 / 60;

// node_modules/@zag-js/select/node_modules/@zag-js/types/dist/index.mjs
var createProps20 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/select/dist/index.mjs
var anatomy30 = createAnatomy("select").parts(
  "label",
  "positioner",
  "trigger",
  "indicator",
  "clearTrigger",
  "item",
  "itemText",
  "itemIndicator",
  "itemGroup",
  "itemGroupLabel",
  "list",
  "content",
  "root",
  "control",
  "valueText"
);
var parts23 = anatomy30.build();
var collection2 = (options) => {
  return ref23(new Collection2(options));
};
collection2.empty = () => {
  return ref23(new Collection2({ items: [] }));
};
var dom23 = createScope24({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `select:${ctx.id}`;
  },
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `select:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `select:${ctx.id}:trigger`;
  },
  getClearTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.clearTrigger) ?? `select:${ctx.id}:clear-trigger`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `select:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `select:${ctx.id}:control`;
  },
  getItemId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.item) == null ? void 0 : _b6.call(_a7, id)) ?? `select:${ctx.id}:option:${id}`;
  },
  getHiddenSelectId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.hiddenSelect) ?? `select:${ctx.id}:select`;
  },
  getPositionerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.positioner) ?? `select:${ctx.id}:positioner`;
  },
  getItemGroupId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemGroup) == null ? void 0 : _b6.call(_a7, id)) ?? `select:${ctx.id}:optgroup:${id}`;
  },
  getItemGroupLabelId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemGroupLabel) == null ? void 0 : _b6.call(_a7, id)) ?? `select:${ctx.id}:optgroup-label:${id}`;
  },
  getHiddenSelectEl: (ctx) => dom23.getById(ctx, dom23.getHiddenSelectId(ctx)),
  getContentEl: (ctx) => dom23.getById(ctx, dom23.getContentId(ctx)),
  getControlEl: (ctx) => dom23.getById(ctx, dom23.getControlId(ctx)),
  getTriggerEl: (ctx) => dom23.getById(ctx, dom23.getTriggerId(ctx)),
  getClearTriggerEl: (ctx) => dom23.getById(ctx, dom23.getClearTriggerId(ctx)),
  getPositionerEl: (ctx) => dom23.getById(ctx, dom23.getPositionerId(ctx)),
  getHighlightedOptionEl(ctx) {
    if (!ctx.highlightedValue) return null;
    return dom23.getById(ctx, dom23.getItemId(ctx, ctx.highlightedValue));
  }
});
var { and: and19, not: not20, or: or13 } = guards11;
var props19 = createProps20()([
  "closeOnSelect",
  "collection",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "invalid",
  "loopFocus",
  "multiple",
  "name",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onValueChange",
  "open.controlled",
  "open",
  "composite",
  "positioning",
  "required",
  "readOnly",
  "scrollToIndexFn",
  "value"
]);
var splitProps20 = createSplitProps(props19);
var itemProps7 = createProps20()(["item", "persistFocus"]);
var splitItemProps7 = createSplitProps(itemProps7);
var itemGroupProps2 = createProps20()(["id"]);
var splitItemGroupProps2 = createSplitProps(itemGroupProps2);
var itemGroupLabelProps2 = createProps20()(["htmlFor"]);
var splitItemGroupLabelProps2 = createSplitProps(itemGroupLabelProps2);

// node_modules/@zag-js/signature-pad/node_modules/@zag-js/dom-query/dist/index.mjs
var isHTMLElement9 = (v) => typeof v === "object" && (v == null ? void 0 : v.nodeType) === Node.ELEMENT_NODE && typeof (v == null ? void 0 : v.nodeName) === "string";
var isDocument25 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow25 = (el) => el != null && el === el.window;
var isNode4 = (el) => el.nodeType !== void 0;
var isShadowRoot4 = (el) => el && isNode4(el) && el.nodeType === Node.DOCUMENT_FRAGMENT_NODE && "host" in el;
function getDocument28(el) {
  if (isDocument25(el)) return el;
  if (isWindow25(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
function getWindow9(el) {
  var _a7;
  if (isShadowRoot4(el)) return getWindow9(el.host);
  if (isDocument25(el)) return el.defaultView ?? window;
  if (isHTMLElement9(el)) return ((_a7 = el.ownerDocument) == null ? void 0 : _a7.defaultView) ?? window;
  return window;
}
function getDataUrl2(svg, opts) {
  const { type, quality = 0.92 } = opts;
  if (!svg) throw new Error("[get-data-url]: could not find the svg element");
  const win = getWindow9(svg);
  const doc = win.document;
  const serializer = new win.XMLSerializer();
  const source = '<?xml version="1.0" standalone="no"?>\r\n' + serializer.serializeToString(svg);
  const svgString = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
  if (type === "image/svg+xml") {
    return Promise.resolve(svgString);
  }
  const svgBounds = svg.getBoundingClientRect();
  const dpr = win.devicePixelRatio || 1;
  const canvas = doc.createElement("canvas");
  const image = new win.Image();
  image.src = svgString;
  canvas.width = svgBounds.width * dpr;
  canvas.height = svgBounds.height * dpr;
  const context = canvas.getContext("2d");
  context.scale(dpr, dpr);
  return new Promise((resolve) => {
    image.onload = () => {
      context.drawImage(image, 0, 0);
      resolve(canvas.toDataURL(type, quality));
    };
  });
}
var defaultItemToId32 = (v) => v.id;
function itemById32(v, id, itemToId = defaultItemToId32) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId32(v, id, itemToId = defaultItemToId32) {
  const item = itemById32(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize32 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText32 = (item) => sanitize32(item.dataset.valuetext ?? item.textContent ?? "");
var match36 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap36 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText32(v, text, currentId, itemToId = defaultItemToId32) {
  const index = currentId ? indexOfId32(v, currentId, itemToId) : -1;
  let items = currentId ? wrap36(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match36(getValueText32(item), text));
}
function getByTypeaheadImpl32(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText32(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead32 = Object.assign(getByTypeaheadImpl32, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent32
});
function isValidTypeaheadEvent32(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function query6(root, selector) {
  return (root == null ? void 0 : root.querySelector(selector)) ?? null;
}
function createScope25(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument28(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps32 = 1e3 / 60;

// node_modules/@zag-js/signature-pad/node_modules/@zag-js/store/dist/index.mjs
function getGlobal24() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal24(key, value) {
  const g = getGlobal24();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev24 = () => true;
var isObject28 = (x) => typeof x === "object" && x !== null;
var proxyStateMap24 = makeGlobal24("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet24 = makeGlobal24("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction24 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject28(x) && !refSet24.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet24.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap24.has(value)) {
      snap[key] = snapshot24(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject28(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev24() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev24() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject28(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap24.has(value) && canProxy(value)) {
          nextValue = proxy24(value);
        }
        const childProxyState = !refSet24.has(nextValue) && proxyStateMap24.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap24.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap24,
  refSet24,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction24] = buildProxyFunction24();
function proxy24(initialObject = {}) {
  return proxyFunction24(initialObject);
}
function snapshot24(proxyObject, handlePromise) {
  const proxyState = proxyStateMap24.get(proxyObject);
  if (isDev24() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/perfect-freehand/dist/esm/index.mjs
var { min: C, PI: xe } = Math;
var V = xe + 1e-4;

// node_modules/@zag-js/signature-pad/node_modules/@zag-js/types/dist/index.mjs
var createProps21 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/signature-pad/dist/index.mjs
var anatomy31 = createAnatomy("signature-pad").parts(
  "root",
  "control",
  "segment",
  "segmentPath",
  "guide",
  "clearTrigger",
  "label"
);
var parts24 = anatomy31.build();
var dom24 = createScope25({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `signature-${ctx.id}`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `signature-control-${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `signature-label-${ctx.id}`;
  },
  getHiddenInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.hiddenInput) ?? `signature-input-${ctx.id}`;
  },
  getControlEl: (ctx) => dom24.getById(ctx, dom24.getControlId(ctx)),
  getSegmentEl: (ctx) => query6(dom24.getControlEl(ctx), "[data-part=segment]"),
  getHiddenInputEl: (ctx) => dom24.getById(ctx, dom24.getHiddenInputId(ctx)),
  getDataUrl: (ctx, options) => {
    if (ctx.isEmpty) return Promise.resolve("");
    return getDataUrl2(dom24.getSegmentEl(ctx), options);
  }
});
var props20 = createProps21()([
  "dir",
  "disabled",
  "drawing",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onDraw",
  "onDrawEnd",
  "readOnly",
  "required",
  "translations"
]);
var splitProps21 = createSplitProps(props20);

// node_modules/@zag-js/slider/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument26 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow26 = (el) => el != null && el === el.window;
function getDocument29(el) {
  if (isDocument26(el)) return el;
  if (isWindow26(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId33 = (v) => v.id;
function itemById33(v, id, itemToId = defaultItemToId33) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId33(v, id, itemToId = defaultItemToId33) {
  const item = itemById33(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize33 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText33 = (item) => sanitize33(item.dataset.valuetext ?? item.textContent ?? "");
var match37 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap37 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText33(v, text, currentId, itemToId = defaultItemToId33) {
  const index = currentId ? indexOfId33(v, currentId, itemToId) : -1;
  let items = currentId ? wrap37(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match37(getValueText33(item), text));
}
function getByTypeaheadImpl33(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText33(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead33 = Object.assign(getByTypeaheadImpl33, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent33
});
function isValidTypeaheadEvent33(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function queryAll9(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function createScope26(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument29(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps33 = 1e3 / 60;

// node_modules/@zag-js/slider/node_modules/@zag-js/store/dist/index.mjs
function getGlobal25() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal25(key, value) {
  const g = getGlobal25();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev25 = () => true;
var isObject29 = (x) => typeof x === "object" && x !== null;
var proxyStateMap25 = makeGlobal25("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet25 = makeGlobal25("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction25 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject29(x) && !refSet25.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet25.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap25.has(value)) {
      snap[key] = snapshot25(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject29(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev25() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev25() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject29(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap25.has(value) && canProxy(value)) {
          nextValue = proxy25(value);
        }
        const childProxyState = !refSet25.has(nextValue) && proxyStateMap25.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap25.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap25,
  refSet25,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction25] = buildProxyFunction25();
function proxy25(initialObject = {}) {
  return proxyFunction25(initialObject);
}
function snapshot25(proxyObject, handlePromise) {
  const proxyState = proxyStateMap25.get(proxyObject);
  if (isDev25() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/slider/node_modules/@zag-js/types/dist/index.mjs
var createProps22 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/slider/dist/index.mjs
var anatomy32 = createAnatomy("slider").parts(
  "root",
  "label",
  "thumb",
  "valueText",
  "track",
  "range",
  "control",
  "markerGroup",
  "marker"
);
var parts25 = anatomy32.build();
function getBounds(value) {
  const firstValue = value[0];
  const lastThumb = value[value.length - 1];
  return [firstValue, lastThumb];
}
function getRangeOffsets(ctx) {
  const [firstPercent, lastPercent] = getBounds(ctx.valuePercent);
  if (ctx.valuePercent.length === 1) {
    if (ctx.origin === "center") {
      const isNegative = ctx.valuePercent[0] < 50;
      const start = isNegative ? `${ctx.valuePercent[0]}%` : "50%";
      const end = isNegative ? "50%" : `${100 - ctx.valuePercent[0]}%`;
      return { start, end };
    }
    return { start: "0%", end: `${100 - lastPercent}%` };
  }
  return { start: `${firstPercent}%`, end: `${100 - lastPercent}%` };
}
function getRangeStyle(ctx) {
  if (ctx.isVertical) {
    return {
      position: "absolute",
      bottom: "var(--slider-range-start)",
      top: "var(--slider-range-end)"
    };
  }
  return {
    position: "absolute",
    [ctx.isRtl ? "right" : "left"]: "var(--slider-range-start)",
    [ctx.isRtl ? "left" : "right"]: "var(--slider-range-end)"
  };
}
function getVerticalThumbOffset(ctx) {
  const { height = 0 } = ctx.thumbSize ?? {};
  const getValue = getValueTransformer([ctx.min, ctx.max], [-height / 2, height / 2]);
  return parseFloat(getValue(ctx.value).toFixed(2));
}
function getHorizontalThumbOffset(ctx) {
  const { width = 0 } = ctx.thumbSize ?? {};
  if (ctx.isRtl) {
    const getValue2 = getValueTransformer([ctx.max, ctx.min], [-width / 2, width / 2]);
    return -1 * parseFloat(getValue2(ctx.value).toFixed(2));
  }
  const getValue = getValueTransformer([ctx.min, ctx.max], [-width / 2, width / 2]);
  return parseFloat(getValue(ctx.value).toFixed(2));
}
function getOffset(ctx, percent) {
  if (ctx.thumbAlignment === "center") return `${percent}%`;
  const offset4 = ctx.isVertical ? getVerticalThumbOffset(ctx) : getHorizontalThumbOffset(ctx);
  return `calc(${percent}% - ${offset4}px)`;
}
function getThumbOffset(ctx) {
  let percent = getValuePercent(ctx.value, ctx.min, ctx.max) * 100;
  return getOffset(ctx, percent);
}
function getVisibility(ctx) {
  let visibility = "visible";
  if (ctx.thumbAlignment === "contain" && !ctx.hasMeasuredThumbSize) {
    visibility = "hidden";
  }
  return visibility;
}
function getThumbStyle(ctx, index) {
  const placementProp = ctx.isVertical ? "bottom" : "insetInlineStart";
  return {
    visibility: getVisibility(ctx),
    position: "absolute",
    transform: "var(--slider-thumb-transform)",
    [placementProp]: `var(--slider-thumb-offset-${index})`
  };
}
function getControlStyle() {
  return {
    touchAction: "none",
    userSelect: "none",
    WebkitUserSelect: "none",
    position: "relative"
  };
}
function getRootStyle(ctx) {
  const range2 = getRangeOffsets(ctx);
  const offsetStyles = ctx.value.reduce((styles, value, index) => {
    const offset4 = getThumbOffset({ ...ctx, value });
    return { ...styles, [`--slider-thumb-offset-${index}`]: offset4 };
  }, {});
  return {
    ...offsetStyles,
    "--slider-thumb-transform": ctx.isVertical ? "translateY(50%)" : ctx.isRtl ? "translateX(50%)" : "translateX(-50%)",
    "--slider-range-start": range2.start,
    "--slider-range-end": range2.end
  };
}
function getMarkerStyle(ctx, value) {
  return {
    // @ts-expect-error
    visibility: getVisibility(ctx),
    position: "absolute",
    pointerEvents: "none",
    // @ts-expect-error
    [ctx.isHorizontal ? "insetInlineStart" : "bottom"]: getThumbOffset({ ...ctx, value }),
    translate: "var(--tx) var(--ty)",
    "--tx": ctx.isHorizontal ? ctx.isRtl ? "50%" : "-50%" : "0%",
    "--ty": !ctx.isHorizontal ? "50%" : "0%"
  };
}
function getMarkerGroupStyle() {
  return {
    userSelect: "none",
    WebkitUserSelect: "none",
    pointerEvents: "none",
    position: "relative"
  };
}
var styleGetterFns = {
  getRootStyle,
  getControlStyle,
  getThumbStyle,
  getRangeStyle,
  getMarkerStyle,
  getMarkerGroupStyle
};
var dom25 = createScope26({
  ...styleGetterFns,
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `slider:${ctx.id}`;
  },
  getThumbId: (ctx, index) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.thumb) == null ? void 0 : _b6.call(_a7, index)) ?? `slider:${ctx.id}:thumb:${index}`;
  },
  getHiddenInputId: (ctx, index) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.hiddenInput) == null ? void 0 : _b6.call(_a7, index)) ?? `slider:${ctx.id}:input:${index}`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `slider:${ctx.id}:control`;
  },
  getTrackId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.track) ?? `slider:${ctx.id}:track`;
  },
  getRangeId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.range) ?? `slider:${ctx.id}:range`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `slider:${ctx.id}:label`;
  },
  getValueTextId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.valueText) ?? `slider:${ctx.id}:value-text`;
  },
  getMarkerId: (ctx, value) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.marker) == null ? void 0 : _b6.call(_a7, value)) ?? `slider:${ctx.id}:marker:${value}`;
  },
  getRootEl: (ctx) => dom25.getById(ctx, dom25.getRootId(ctx)),
  getThumbEl: (ctx, index) => dom25.getById(ctx, dom25.getThumbId(ctx, index)),
  getHiddenInputEl: (ctx, index) => dom25.getById(ctx, dom25.getHiddenInputId(ctx, index)),
  getControlEl: (ctx) => dom25.getById(ctx, dom25.getControlId(ctx)),
  getElements: (ctx) => queryAll9(dom25.getControlEl(ctx), "[role=slider]"),
  getFirstEl: (ctx) => dom25.getElements(ctx)[0],
  getRangeEl: (ctx) => dom25.getById(ctx, dom25.getRangeId(ctx)),
  getValueFromPoint(ctx, point) {
    const controlEl = dom25.getControlEl(ctx);
    if (!controlEl) return;
    const relativePoint = getRelativePoint(point, controlEl);
    const percent = relativePoint.getPercentValue({
      orientation: ctx.orientation,
      dir: ctx.dir,
      inverted: { y: true }
    });
    return getPercentValue(percent, ctx.min, ctx.max, ctx.step);
  },
  dispatchChangeEvent(ctx) {
    const valueArray = Array.from(ctx.value);
    valueArray.forEach((value, index) => {
      const inputEl = dom25.getHiddenInputEl(ctx, index);
      if (!inputEl) return;
      dispatchInputValueEvent(inputEl, { value });
    });
  }
});
var props21 = createProps22()([
  "aria-label",
  "aria-labelledby",
  "dir",
  "disabled",
  "form",
  "getAriaValueText",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "max",
  "min",
  "minStepsBetweenThumbs",
  "name",
  "onFocusChange",
  "onValueChange",
  "onValueChangeEnd",
  "orientation",
  "origin",
  "readOnly",
  "step",
  "thumbAlignment",
  "thumbAlignment",
  "thumbSize",
  "value"
]);
var splitProps22 = createSplitProps(props21);
var thumbProps = createProps22()(["index", "name"]);
var splitThumbProps = createSplitProps(thumbProps);

// node_modules/@zag-js/splitter/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument27 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow27 = (el) => el != null && el === el.window;
function getDocument30(el) {
  if (isDocument27(el)) return el;
  if (isWindow27(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId34 = (v) => v.id;
function itemById34(v, id, itemToId = defaultItemToId34) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId34(v, id, itemToId = defaultItemToId34) {
  const item = itemById34(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize34 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText34 = (item) => sanitize34(item.dataset.valuetext ?? item.textContent ?? "");
var match38 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap38 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText34(v, text, currentId, itemToId = defaultItemToId34) {
  const index = currentId ? indexOfId34(v, currentId, itemToId) : -1;
  let items = currentId ? wrap38(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match38(getValueText34(item), text));
}
function getByTypeaheadImpl34(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText34(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead34 = Object.assign(getByTypeaheadImpl34, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent34
});
function isValidTypeaheadEvent34(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function queryAll10(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function createScope27(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument30(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps34 = 1e3 / 60;

// node_modules/@zag-js/splitter/node_modules/@zag-js/store/dist/index.mjs
function getGlobal26() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal26(key, value) {
  const g = getGlobal26();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev26 = () => true;
var isObject30 = (x) => typeof x === "object" && x !== null;
var proxyStateMap26 = makeGlobal26("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet26 = makeGlobal26("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction26 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject30(x) && !refSet26.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet26.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap26.has(value)) {
      snap[key] = snapshot26(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject30(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev26() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev26() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject30(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap26.has(value) && canProxy(value)) {
          nextValue = proxy26(value);
        }
        const childProxyState = !refSet26.has(nextValue) && proxyStateMap26.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap26.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap26,
  refSet26,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction26] = buildProxyFunction26();
function proxy26(initialObject = {}) {
  return proxyFunction26(initialObject);
}
function snapshot26(proxyObject, handlePromise) {
  const proxyState = proxyStateMap26.get(proxyObject);
  if (isDev26() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/splitter/node_modules/@zag-js/types/dist/index.mjs
var createProps23 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/splitter/dist/index.mjs
var anatomy33 = createAnatomy("splitter").parts("root", "panel", "resizeTrigger");
var parts26 = anatomy33.build();
var dom26 = createScope27({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `splitter:${ctx.id}`;
  },
  getResizeTriggerId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.resizeTrigger) == null ? void 0 : _b6.call(_a7, id)) ?? `splitter:${ctx.id}:splitter:${id}`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `splitter:${ctx.id}:label`;
  },
  getPanelId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.panel) == null ? void 0 : _b6.call(_a7, id)) ?? `splitter:${ctx.id}:panel:${id}`;
  },
  getGlobalCursorId: (ctx) => `splitter:${ctx.id}:global-cursor`,
  getRootEl: (ctx) => dom26.getById(ctx, dom26.getRootId(ctx)),
  getResizeTriggerEl: (ctx, id) => dom26.getById(ctx, dom26.getResizeTriggerId(ctx, id)),
  getPanelEl: (ctx, id) => dom26.getById(ctx, dom26.getPanelId(ctx, id)),
  getCursor(ctx) {
    const x = ctx.isHorizontal;
    let cursor3 = x ? "col-resize" : "row-resize";
    if (ctx.activeResizeState.isAtMin) cursor3 = x ? "e-resize" : "s-resize";
    if (ctx.activeResizeState.isAtMax) cursor3 = x ? "w-resize" : "n-resize";
    return cursor3;
  },
  getPanelStyle(ctx, id) {
    var _a7;
    const flexGrow = ((_a7 = ctx.panels.find((panel) => panel.id === id)) == null ? void 0 : _a7.size) ?? "0";
    return {
      flexBasis: 0,
      flexGrow,
      flexShrink: 1,
      overflow: "hidden"
    };
  },
  getActiveHandleEl(ctx) {
    const activeId = ctx.activeResizeId;
    if (activeId == null) return;
    return dom26.getById(ctx, dom26.getResizeTriggerId(ctx, activeId));
  },
  getResizeTriggerEls(ctx) {
    const ownerId = CSS.escape(dom26.getRootId(ctx));
    return queryAll10(dom26.getRootEl(ctx), `[role=separator][data-ownedby='${ownerId}']`);
  },
  setupGlobalCursor(ctx) {
    const styleEl = dom26.getById(ctx, dom26.getGlobalCursorId(ctx));
    const textContent = `* { cursor: ${dom26.getCursor(ctx)} !important; }`;
    if (styleEl) {
      styleEl.textContent = textContent;
    } else {
      const style = dom26.getDoc(ctx).createElement("style");
      style.id = dom26.getGlobalCursorId(ctx);
      style.textContent = textContent;
      dom26.getDoc(ctx).head.appendChild(style);
    }
  },
  removeGlobalCursor(ctx) {
    var _a7;
    (_a7 = dom26.getById(ctx, dom26.getGlobalCursorId(ctx))) == null ? void 0 : _a7.remove();
  }
});
var props22 = createProps23()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onSizeChange",
  "onSizeChangeEnd",
  "orientation",
  "size"
]);
var splitProps23 = createSplitProps(props22);
var panelProps = createProps23()(["id", "snapSize"]);
var splitPanelProps = createSplitProps(panelProps);
var resizeTriggerProps = createProps23()(["disabled", "id", "step"]);
var splitResizeTriggerProps = createSplitProps(resizeTriggerProps);

// node_modules/@zag-js/switch/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument28 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow28 = (el) => el != null && el === el.window;
function getDocument31(el) {
  if (isDocument28(el)) return el;
  if (isWindow28(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId35 = (v) => v.id;
function itemById35(v, id, itemToId = defaultItemToId35) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId35(v, id, itemToId = defaultItemToId35) {
  const item = itemById35(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize35 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText35 = (item) => sanitize35(item.dataset.valuetext ?? item.textContent ?? "");
var match39 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap39 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText35(v, text, currentId, itemToId = defaultItemToId35) {
  const index = currentId ? indexOfId35(v, currentId, itemToId) : -1;
  let items = currentId ? wrap39(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match39(getValueText35(item), text));
}
function getByTypeaheadImpl35(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText35(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead35 = Object.assign(getByTypeaheadImpl35, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent35
});
function isValidTypeaheadEvent35(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function createScope28(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument31(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps35 = 1e3 / 60;

// node_modules/@zag-js/switch/node_modules/@zag-js/store/dist/index.mjs
function getGlobal27() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal27(key, value) {
  const g = getGlobal27();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev27 = () => true;
var isObject31 = (x) => typeof x === "object" && x !== null;
var proxyStateMap27 = makeGlobal27("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet27 = makeGlobal27("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction27 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject31(x) && !refSet27.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet27.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap27.has(value)) {
      snap[key] = snapshot27(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject31(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev27() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev27() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject31(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap27.has(value) && canProxy(value)) {
          nextValue = proxy27(value);
        }
        const childProxyState = !refSet27.has(nextValue) && proxyStateMap27.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap27.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap27,
  refSet27,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction27] = buildProxyFunction27();
function proxy27(initialObject = {}) {
  return proxyFunction27(initialObject);
}
function snapshot27(proxyObject, handlePromise) {
  const proxyState = proxyStateMap27.get(proxyObject);
  if (isDev27() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/switch/node_modules/@zag-js/core/dist/index.mjs
var isString14 = (v) => typeof v === "string";
var isFunction14 = (v) => typeof v === "function";
function exec12(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString14(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction14(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or14(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec12(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and20(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec12(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not21(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec12(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn12(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards12 = { or: or14, and: and20, not: not21, stateIn: stateIn12 };

// node_modules/@zag-js/switch/node_modules/@zag-js/types/dist/index.mjs
var createProps24 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/switch/dist/index.mjs
var anatomy34 = createAnatomy("switch").parts("root", "label", "control", "thumb");
var parts27 = anatomy34.build();
var dom27 = createScope28({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `switch:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `switch:${ctx.id}:label`;
  },
  getThumbId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.thumb) ?? `switch:${ctx.id}:thumb`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `switch:${ctx.id}:control`;
  },
  getHiddenInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.hiddenInput) ?? `switch:${ctx.id}:input`;
  },
  getRootEl: (ctx) => dom27.getById(ctx, dom27.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom27.getById(ctx, dom27.getHiddenInputId(ctx))
});
var { not: not22 } = guards12;
var props23 = createProps24()([
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "label",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
var splitProps24 = createSplitProps(props23);

// node_modules/@zag-js/tabs/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument29 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow29 = (el) => el != null && el === el.window;
function getDocument32(el) {
  if (isDocument29(el)) return el;
  if (isWindow29(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId36 = (v) => v.id;
function itemById36(v, id, itemToId = defaultItemToId36) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId36(v, id, itemToId = defaultItemToId36) {
  const item = itemById36(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
function nextById4(v, id, loop = true) {
  let idx = indexOfId36(v, id);
  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
  return v[idx];
}
function prevById4(v, id, loop = true) {
  let idx = indexOfId36(v, id);
  if (idx === -1) return loop ? v[v.length - 1] : null;
  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
  return v[idx];
}
var sanitize36 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText36 = (item) => sanitize36(item.dataset.valuetext ?? item.textContent ?? "");
var match40 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap40 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText36(v, text, currentId, itemToId = defaultItemToId36) {
  const index = currentId ? indexOfId36(v, currentId, itemToId) : -1;
  let items = currentId ? wrap40(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match40(getValueText36(item), text));
}
function getByTypeaheadImpl36(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText36(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead36 = Object.assign(getByTypeaheadImpl36, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent36
});
function isValidTypeaheadEvent36(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function queryAll11(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function createScope29(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument32(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps36 = 1e3 / 60;

// node_modules/@zag-js/tabs/node_modules/@zag-js/store/dist/index.mjs
function getGlobal28() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal28(key, value) {
  const g = getGlobal28();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev28 = () => true;
var isObject32 = (x) => typeof x === "object" && x !== null;
var proxyStateMap28 = makeGlobal28("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet28 = makeGlobal28("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction28 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject32(x) && !refSet28.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet28.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap28.has(value)) {
      snap[key] = snapshot28(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject32(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev28() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev28() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject32(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap28.has(value) && canProxy(value)) {
          nextValue = proxy28(value);
        }
        const childProxyState = !refSet28.has(nextValue) && proxyStateMap28.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap28.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap28,
  refSet28,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction28] = buildProxyFunction28();
function proxy28(initialObject = {}) {
  return proxyFunction28(initialObject);
}
function snapshot28(proxyObject, handlePromise) {
  const proxyState = proxyStateMap28.get(proxyObject);
  if (isDev28() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/tabs/node_modules/@zag-js/core/dist/index.mjs
var isString15 = (v) => typeof v === "string";
var isFunction15 = (v) => typeof v === "function";
function exec13(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString15(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction15(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or15(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec13(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and21(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec13(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not23(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec13(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn13(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards13 = { or: or15, and: and21, not: not23, stateIn: stateIn13 };

// node_modules/@zag-js/tabs/node_modules/@zag-js/types/dist/index.mjs
var createProps25 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/tabs/dist/index.mjs
var anatomy35 = createAnatomy("tabs").parts("root", "list", "trigger", "content", "indicator");
var parts28 = anatomy35.build();
var dom28 = createScope29({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `tabs:${ctx.id}`;
  },
  getListId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.list) ?? `tabs:${ctx.id}:list`;
  },
  getContentId: (ctx, id) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `tabs:${ctx.id}:content-${id}`;
  },
  getTriggerId: (ctx, id) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `tabs:${ctx.id}:trigger-${id}`;
  },
  getIndicatorId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.indicator) ?? `tabs:${ctx.id}:indicator`;
  },
  getListEl: (ctx) => dom28.getById(ctx, dom28.getListId(ctx)),
  getContentEl: (ctx, id) => dom28.getById(ctx, dom28.getContentId(ctx, id)),
  getTriggerEl: (ctx, id) => dom28.getById(ctx, dom28.getTriggerId(ctx, id)),
  getIndicatorEl: (ctx) => dom28.getById(ctx, dom28.getIndicatorId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom28.getListId(ctx));
    const selector = `[role=tab][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll11(dom28.getListEl(ctx), selector);
  },
  getFirstTriggerEl: (ctx) => first(dom28.getElements(ctx)),
  getLastTriggerEl: (ctx) => last(dom28.getElements(ctx)),
  getNextTriggerEl: (ctx, id) => nextById4(dom28.getElements(ctx), dom28.getTriggerId(ctx, id), ctx.loopFocus),
  getPrevTriggerEl: (ctx, id) => prevById4(dom28.getElements(ctx), dom28.getTriggerId(ctx, id), ctx.loopFocus),
  getSelectedContentEl: (ctx) => {
    if (!ctx.value) return;
    return dom28.getContentEl(ctx, ctx.value);
  },
  getSelectedTriggerEl: (ctx) => {
    if (!ctx.value) return;
    return dom28.getTriggerEl(ctx, ctx.value);
  },
  getOffsetRect: (el) => {
    return {
      left: (el == null ? void 0 : el.offsetLeft) ?? 0,
      top: (el == null ? void 0 : el.offsetTop) ?? 0,
      width: (el == null ? void 0 : el.offsetWidth) ?? 0,
      height: (el == null ? void 0 : el.offsetHeight) ?? 0
    };
  },
  getRectById: (ctx, id) => {
    const tab = itemById36(dom28.getElements(ctx), dom28.getTriggerId(ctx, id));
    return dom28.resolveRect(dom28.getOffsetRect(tab));
  },
  resolveRect: (rect) => ({
    width: `${rect.width}px`,
    height: `${rect.height}px`,
    left: `${rect.left}px`,
    top: `${rect.top}px`
  })
});
var { not: not24 } = guards13;
var props24 = createProps25()([
  "activationMode",
  "composite",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "loopFocus",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "translations",
  "value"
]);
var splitProps25 = createSplitProps(props24);
var triggerProps = createProps25()(["disabled", "value"]);
var splitTriggerProps = createSplitProps(triggerProps);
var contentProps = createProps25()(["value"]);
var splitContentProps = createSplitProps(contentProps);

// node_modules/@zag-js/tags-input/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument30 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow30 = (el) => el != null && el === el.window;
function getDocument33(el) {
  if (isDocument30(el)) return el;
  if (isWindow30(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId37 = (v) => v.id;
function itemById37(v, id, itemToId = defaultItemToId37) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId37(v, id, itemToId = defaultItemToId37) {
  const item = itemById37(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
function nextById5(v, id, loop = true) {
  let idx = indexOfId37(v, id);
  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
  return v[idx];
}
function prevById5(v, id, loop = true) {
  let idx = indexOfId37(v, id);
  if (idx === -1) return loop ? v[v.length - 1] : null;
  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
  return v[idx];
}
var sanitize37 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText37 = (item) => sanitize37(item.dataset.valuetext ?? item.textContent ?? "");
var match41 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap41 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText37(v, text, currentId, itemToId = defaultItemToId37) {
  const index = currentId ? indexOfId37(v, currentId, itemToId) : -1;
  let items = currentId ? wrap41(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match41(getValueText37(item), text));
}
function getByTypeaheadImpl37(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText37(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead37 = Object.assign(getByTypeaheadImpl37, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent37
});
function isValidTypeaheadEvent37(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function queryAll12(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function createScope30(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument33(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps37 = 1e3 / 60;

// node_modules/@zag-js/auto-resize/node_modules/@zag-js/dom-query/dist/index.mjs
var defaultItemToId38 = (v) => v.id;
function itemById38(v, id, itemToId = defaultItemToId38) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId38(v, id, itemToId = defaultItemToId38) {
  const item = itemById38(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize38 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText38 = (item) => sanitize38(item.dataset.valuetext ?? item.textContent ?? "");
var match42 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap42 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText38(v, text, currentId, itemToId = defaultItemToId38) {
  const index = currentId ? indexOfId38(v, currentId, itemToId) : -1;
  let items = currentId ? wrap42(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match42(getValueText38(item), text));
}
function getByTypeaheadImpl38(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText38(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead38 = Object.assign(getByTypeaheadImpl38, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent38
});
function isValidTypeaheadEvent38(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var fps38 = 1e3 / 60;

// node_modules/@zag-js/tags-input/node_modules/@zag-js/store/dist/index.mjs
function getGlobal29() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal29(key, value) {
  const g = getGlobal29();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev29 = () => true;
var isObject33 = (x) => typeof x === "object" && x !== null;
var proxyStateMap29 = makeGlobal29("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet29 = makeGlobal29("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction29 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject33(x) && !refSet29.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet29.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap29.has(value)) {
      snap[key] = snapshot29(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject33(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev29() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev29() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject33(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap29.has(value) && canProxy(value)) {
          nextValue = proxy29(value);
        }
        const childProxyState = !refSet29.has(nextValue) && proxyStateMap29.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap29.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap29,
  refSet29,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction29] = buildProxyFunction29();
function proxy29(initialObject = {}) {
  return proxyFunction29(initialObject);
}
function snapshot29(proxyObject, handlePromise) {
  const proxyState = proxyStateMap29.get(proxyObject);
  if (isDev29() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/tags-input/node_modules/@zag-js/core/dist/index.mjs
var isString16 = (v) => typeof v === "string";
var isFunction16 = (v) => typeof v === "function";
function exec14(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString16(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction16(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or16(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec14(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and22(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec14(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not25(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec14(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn14(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards14 = { or: or16, and: and22, not: not25, stateIn: stateIn14 };

// node_modules/@zag-js/tags-input/node_modules/@zag-js/types/dist/index.mjs
var createProps26 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/tags-input/dist/index.mjs
var anatomy36 = createAnatomy("tagsInput").parts(
  "root",
  "label",
  "control",
  "input",
  "clearTrigger",
  "item",
  "itemPreview",
  "itemInput",
  "itemText",
  "itemDeleteTrigger"
);
var parts29 = anatomy36.build();
var dom29 = createScope30({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `tags-input:${ctx.id}`;
  },
  getInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.input) ?? `tags-input:${ctx.id}:input`;
  },
  getClearTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.clearBtn) ?? `tags-input:${ctx.id}:clear-btn`;
  },
  getHiddenInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.hiddenInput) ?? `tags-input:${ctx.id}:hidden-input`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `tags-input:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `tags-input:${ctx.id}:control`;
  },
  getItemId: (ctx, opt) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.item) == null ? void 0 : _b6.call(_a7, opt)) ?? `tags-input:${ctx.id}:tag:${opt.value}:${opt.index}`;
  },
  getItemDeleteTriggerId: (ctx, opt) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemDeleteTrigger) == null ? void 0 : _b6.call(_a7, opt)) ?? `${dom29.getItemId(ctx, opt)}:delete-btn`;
  },
  getItemInputId: (ctx, opt) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemInput) == null ? void 0 : _b6.call(_a7, opt)) ?? `${dom29.getItemId(ctx, opt)}:input`;
  },
  getEditInputId: (ctx) => `${ctx.editedTagId}:input`,
  getTagInputEl: (ctx, opt) => dom29.getById(ctx, dom29.getItemInputId(ctx, opt)),
  getRootEl: (ctx) => dom29.getById(ctx, dom29.getRootId(ctx)),
  getInputEl: (ctx) => dom29.getById(ctx, dom29.getInputId(ctx)),
  getHiddenInputEl: (ctx) => dom29.getById(ctx, dom29.getHiddenInputId(ctx)),
  getEditInputEl: (ctx) => dom29.getById(ctx, dom29.getEditInputId(ctx)),
  getTagElements: (ctx) => queryAll12(dom29.getRootEl(ctx), `[data-part=item-preview]:not([data-disabled])`),
  getFirstEl: (ctx) => dom29.getTagElements(ctx)[0],
  getLastEl: (ctx) => dom29.getTagElements(ctx)[dom29.getTagElements(ctx).length - 1],
  getPrevEl: (ctx, id) => prevById5(dom29.getTagElements(ctx), id, false),
  getNextEl: (ctx, id) => nextById5(dom29.getTagElements(ctx), id, false),
  getTagElAtIndex: (ctx, index) => dom29.getTagElements(ctx)[index],
  getIndexOfId: (ctx, id) => indexOfId37(dom29.getTagElements(ctx), id),
  isInputFocused: (ctx) => dom29.getDoc(ctx).activeElement === dom29.getInputEl(ctx),
  getHighlightedTagValue: (ctx) => {
    if (!ctx.highlightedTagId) return null;
    const tagEl = dom29.getById(ctx, ctx.highlightedTagId);
    return (tagEl == null ? void 0 : tagEl.dataset.value) ?? null;
  },
  setHoverIntent: (el) => {
    const tagEl = el.closest("[data-part=item-preview]");
    if (!tagEl) return;
    tagEl.dataset.deleteIntent = "";
  },
  clearHoverIntent: (el) => {
    const tagEl = el.closest("[data-part=item-preview]");
    if (!tagEl) return;
    delete tagEl.dataset.deleteIntent;
  },
  dispatchInputEvent(ctx) {
    const inputEl = dom29.getHiddenInputEl(ctx);
    if (!inputEl) return;
    dispatchInputValueEvent(inputEl, { value: ctx.valueAsString });
  }
});
var { and: and23, not: not26, or: or17 } = guards14;
var props25 = createProps26()([
  "addOnPaste",
  "allowOverflow",
  "autoFocus",
  "blurBehavior",
  "delimiter",
  "dir",
  "disabled",
  "editable",
  "form",
  "getRootNode",
  "id",
  "ids",
  "inputValue",
  "invalid",
  "max",
  "maxLength",
  "name",
  "onFocusOutside",
  "onHighlightChange",
  "onInputValueChange",
  "onInteractOutside",
  "onPointerDownOutside",
  "onValueChange",
  "onValueInvalid",
  "required",
  "readOnly",
  "translations",
  "validate",
  "value"
]);
var splitProps26 = createSplitProps(props25);
var itemProps8 = createProps26()(["index", "disabled", "value"]);
var splitItemProps8 = createSplitProps(itemProps8);

// node_modules/@zag-js/time-picker/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument31 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow31 = (el) => el != null && el === el.window;
function getDocument35(el) {
  if (isDocument31(el)) return el;
  if (isWindow31(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId39 = (v) => v.id;
function itemById39(v, id, itemToId = defaultItemToId39) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId39(v, id, itemToId = defaultItemToId39) {
  const item = itemById39(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize39 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText39 = (item) => sanitize39(item.dataset.valuetext ?? item.textContent ?? "");
var match43 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap43 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText39(v, text, currentId, itemToId = defaultItemToId39) {
  const index = currentId ? indexOfId39(v, currentId, itemToId) : -1;
  let items = currentId ? wrap43(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match43(getValueText39(item), text));
}
function getByTypeaheadImpl39(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText39(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead39 = Object.assign(getByTypeaheadImpl39, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent39
});
function isValidTypeaheadEvent39(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function queryAll13(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function query7(root, selector) {
  return (root == null ? void 0 : root.querySelector(selector)) ?? null;
}
function createScope31(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument35(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps39 = 1e3 / 60;

// node_modules/@zag-js/time-picker/node_modules/@internationalized/date/dist/string.mjs
var $fae977aafc393c5c$var$requiredDurationTimeGroups3 = [
  "hours",
  "minutes",
  "seconds"
];
var $fae977aafc393c5c$var$requiredDurationGroups3 = [
  "years",
  "months",
  "weeks",
  "days",
  ...$fae977aafc393c5c$var$requiredDurationTimeGroups3
];

// node_modules/@zag-js/time-picker/node_modules/@internationalized/date/dist/HebrewCalendar.mjs
var $7c5f6fbf42389787$var$HOUR_PARTS3 = 1080;
var $7c5f6fbf42389787$var$DAY_PARTS3 = 24 * $7c5f6fbf42389787$var$HOUR_PARTS3;
var $7c5f6fbf42389787$var$MONTH_DAYS3 = 29;
var $7c5f6fbf42389787$var$MONTH_FRACT3 = 12 * $7c5f6fbf42389787$var$HOUR_PARTS3 + 793;
var $7c5f6fbf42389787$var$MONTH_PARTS3 = $7c5f6fbf42389787$var$MONTH_DAYS3 * $7c5f6fbf42389787$var$DAY_PARTS3 + $7c5f6fbf42389787$var$MONTH_FRACT3;

// node_modules/@zag-js/time-picker/node_modules/@zag-js/store/dist/index.mjs
function getGlobal30() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal30(key, value) {
  const g = getGlobal30();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev30 = () => true;
var isObject34 = (x) => typeof x === "object" && x !== null;
var proxyStateMap30 = makeGlobal30("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet30 = makeGlobal30("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction30 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject34(x) && !refSet30.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet30.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap30.has(value)) {
      snap[key] = snapshot30(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject34(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev30() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev30() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject34(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap30.has(value) && canProxy(value)) {
          nextValue = proxy30(value);
        }
        const childProxyState = !refSet30.has(nextValue) && proxyStateMap30.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap30.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap30,
  refSet30,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction30] = buildProxyFunction30();
function proxy30(initialObject = {}) {
  return proxyFunction30(initialObject);
}
function snapshot30(proxyObject, handlePromise) {
  const proxyState = proxyStateMap30.get(proxyObject);
  if (isDev30() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/time-picker/node_modules/@zag-js/core/dist/index.mjs
var isString17 = (v) => typeof v === "string";
var isFunction17 = (v) => typeof v === "function";
function exec15(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString17(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction17(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or18(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec15(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and24(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec15(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not27(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec15(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn15(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards15 = { or: or18, and: and24, not: not27, stateIn: stateIn15 };

// node_modules/@zag-js/time-picker/node_modules/@zag-js/types/dist/index.mjs
var createProps27 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/time-picker/dist/index.mjs
var anatomy37 = createAnatomy("time-picker").parts(
  "cell",
  "clearTrigger",
  "column",
  "content",
  "control",
  "input",
  "label",
  "positioner",
  "root",
  "spacer",
  "trigger"
);
var parts30 = anatomy37.build();
var dom30 = createScope31({
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `time-picker:${ctx.id}:content`;
  },
  getColumnId: (ctx, unit) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.column) == null ? void 0 : _b6.call(_a7, unit)) ?? `time-picker:${ctx.id}:column:${unit}`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `time-picker:${ctx.id}:control`;
  },
  getClearTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.clearTrigger) ?? `time-picker:${ctx.id}:clear-trigger`;
  },
  getPositionerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.positioner) ?? `time-picker:${ctx.id}:positioner`;
  },
  getInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.input) ?? `time-picker:${ctx.id}:input`;
  },
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `time-picker:${ctx.id}:trigger`;
  },
  getContentEl: (ctx) => dom30.getById(ctx, dom30.getContentId(ctx)),
  getColumnEl: (ctx, unit) => query7(dom30.getContentEl(ctx), `[data-part=column][data-unit=${unit}]`),
  getColumnEls: (ctx) => queryAll13(dom30.getContentEl(ctx), `[data-part=column]:not([hidden])`),
  getColumnCellEls: (ctx, unit) => queryAll13(dom30.getColumnEl(ctx, unit), `[data-part=cell]`),
  getControlEl: (ctx) => dom30.getById(ctx, dom30.getControlId(ctx)),
  getClearTriggerEl: (ctx) => dom30.getById(ctx, dom30.getClearTriggerId(ctx)),
  getPositionerEl: (ctx) => dom30.getById(ctx, dom30.getPositionerId(ctx)),
  getInputEl: (ctx) => dom30.getById(ctx, dom30.getInputId(ctx)),
  getTriggerEl: (ctx) => dom30.getById(ctx, dom30.getTriggerId(ctx)),
  getFocusedCell: (ctx) => query7(dom30.getContentEl(ctx), `[data-part=cell][data-focus]`),
  getInitialFocusCell: (ctx, unit) => {
    const contentEl = dom30.getContentEl(ctx);
    let cellEl = query7(contentEl, `[data-part=cell][data-unit=${unit}][aria-current]`);
    cellEl || (cellEl = query7(contentEl, `[data-part=cell][data-unit=${unit}][data-now]`));
    cellEl || (cellEl = query7(contentEl, `[data-part=cell][data-unit=${unit}]`));
    return cellEl;
  },
  getColumnUnit: (el) => el.dataset.unit,
  getCellValue: (el) => {
    const value = el == null ? void 0 : el.dataset.value;
    return (el == null ? void 0 : el.dataset.unit) === "period" ? value : Number(value ?? "0");
  }
});
var { and: and25 } = guards15;
var props26 = createProps27()([
  "dir",
  "disabled",
  "disableLayer",
  "getRootNode",
  "id",
  "ids",
  "locale",
  "max",
  "min",
  "name",
  "onFocusChange",
  "onOpenChange",
  "onValueChange",
  "open.controlled",
  "open",
  "placeholder",
  "positioning",
  "readOnly",
  "steps",
  "value",
  "allowSeconds"
]);
var splitProps27 = createSplitProps(props26);

// node_modules/@zag-js/toast/node_modules/@zag-js/store/dist/index.mjs
function getGlobal31() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal31(key, value) {
  const g = getGlobal31();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev31 = () => true;
var isObject35 = (x) => typeof x === "object" && x !== null;
var proxyStateMap31 = makeGlobal31("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet31 = makeGlobal31("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction31 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject35(x) && !refSet31.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet31.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap31.has(value)) {
      snap[key] = snapshot31(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject35(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev31() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev31() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject35(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap31.has(value) && canProxy(value)) {
          nextValue = proxy31(value);
        }
        const childProxyState = !refSet31.has(nextValue) && proxyStateMap31.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap31.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap31,
  refSet31,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction31] = buildProxyFunction31();
function proxy31(initialObject = {}) {
  return proxyFunction31(initialObject);
}
function snapshot31(proxyObject, handlePromise) {
  const proxyState = proxyStateMap31.get(proxyObject);
  if (isDev31() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/toast/node_modules/@zag-js/core/dist/index.mjs
var isString18 = (v) => typeof v === "string";
var isFunction18 = (v) => typeof v === "function";
function exec16(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString18(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction18(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or19(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec16(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and26(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec16(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not28(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec16(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn16(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards16 = { or: or19, and: and26, not: not28, stateIn: stateIn16 };

// node_modules/@zag-js/toast/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument32 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow32 = (el) => el != null && el === el.window;
function getDocument36(el) {
  if (isDocument32(el)) return el;
  if (isWindow32(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId40 = (v) => v.id;
function itemById40(v, id, itemToId = defaultItemToId40) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId40(v, id, itemToId = defaultItemToId40) {
  const item = itemById40(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize40 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText40 = (item) => sanitize40(item.dataset.valuetext ?? item.textContent ?? "");
var match44 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap44 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText40(v, text, currentId, itemToId = defaultItemToId40) {
  const index = currentId ? indexOfId40(v, currentId, itemToId) : -1;
  let items = currentId ? wrap44(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match44(getValueText40(item), text));
}
function getByTypeaheadImpl40(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText40(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead40 = Object.assign(getByTypeaheadImpl40, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent40
});
function isValidTypeaheadEvent40(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function createScope32(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument36(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps40 = 1e3 / 60;

// node_modules/@zag-js/toast/dist/index.mjs
var anatomy38 = createAnatomy("toast").parts(
  "group",
  "root",
  "title",
  "description",
  "actionTrigger",
  "closeTrigger"
);
var parts31 = anatomy38.build();
var dom31 = createScope32({
  getRegionId: (placement) => `toast-group:${placement}`,
  getRegionEl: (ctx, placement) => dom31.getById(ctx, `toast-group:${placement}`),
  getRootId: (ctx) => `toast:${ctx.id}`,
  getRootEl: (ctx) => dom31.getById(ctx, dom31.getRootId(ctx)),
  getTitleId: (ctx) => `toast:${ctx.id}:title`,
  getDescriptionId: (ctx) => `toast:${ctx.id}:description`,
  getCloseTriggerId: (ctx) => `toast${ctx.id}:close`
});
var { not: not29, and: and27, or: or20 } = guards16;

// node_modules/@zag-js/toggle-group/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument33 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow33 = (el) => el != null && el === el.window;
function getDocument37(el) {
  if (isDocument33(el)) return el;
  if (isWindow33(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId41 = (v) => v.id;
function itemById41(v, id, itemToId = defaultItemToId41) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId41(v, id, itemToId = defaultItemToId41) {
  const item = itemById41(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
function nextById6(v, id, loop = true) {
  let idx = indexOfId41(v, id);
  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
  return v[idx];
}
function prevById6(v, id, loop = true) {
  let idx = indexOfId41(v, id);
  if (idx === -1) return loop ? v[v.length - 1] : null;
  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
  return v[idx];
}
var sanitize41 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText41 = (item) => sanitize41(item.dataset.valuetext ?? item.textContent ?? "");
var match45 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap45 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText41(v, text, currentId, itemToId = defaultItemToId41) {
  const index = currentId ? indexOfId41(v, currentId, itemToId) : -1;
  let items = currentId ? wrap45(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match45(getValueText41(item), text));
}
function getByTypeaheadImpl41(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText41(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead41 = Object.assign(getByTypeaheadImpl41, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent41
});
function isValidTypeaheadEvent41(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function queryAll15(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function createScope33(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument37(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps41 = 1e3 / 60;

// node_modules/@zag-js/toggle-group/node_modules/@zag-js/store/dist/index.mjs
function getGlobal32() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal32(key, value) {
  const g = getGlobal32();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev32 = () => true;
var isObject36 = (x) => typeof x === "object" && x !== null;
var proxyStateMap32 = makeGlobal32("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet32 = makeGlobal32("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction32 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject36(x) && !refSet32.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet32.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap32.has(value)) {
      snap[key] = snapshot32(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject36(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev32() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev32() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject36(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap32.has(value) && canProxy(value)) {
          nextValue = proxy32(value);
        }
        const childProxyState = !refSet32.has(nextValue) && proxyStateMap32.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap32.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap32,
  refSet32,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction32] = buildProxyFunction32();
function proxy32(initialObject = {}) {
  return proxyFunction32(initialObject);
}
function snapshot32(proxyObject, handlePromise) {
  const proxyState = proxyStateMap32.get(proxyObject);
  if (isDev32() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/toggle-group/node_modules/@zag-js/core/dist/index.mjs
var isString19 = (v) => typeof v === "string";
var isFunction19 = (v) => typeof v === "function";
function exec17(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString19(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction19(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or21(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec17(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and28(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec17(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not30(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec17(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn17(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards17 = { or: or21, and: and28, not: not30, stateIn: stateIn17 };

// node_modules/@zag-js/toggle-group/node_modules/@zag-js/types/dist/index.mjs
var createProps28 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/toggle-group/dist/index.mjs
var anatomy39 = createAnatomy("toggle-group").parts("root", "item");
var parts32 = anatomy39.build();
var dom32 = createScope33({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `toggle-group:${ctx.id}`;
  },
  getItemId: (ctx, value) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.item) == null ? void 0 : _b6.call(_a7, value)) ?? `toggle-group:${ctx.id}:${value}`;
  },
  getRootEl: (ctx) => dom32.getById(ctx, dom32.getRootId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom32.getRootId(ctx));
    const selector = `[data-ownedby='${ownerId}']:not([data-disabled])`;
    return queryAll15(dom32.getRootEl(ctx), selector);
  },
  getFirstEl: (ctx) => first(dom32.getElements(ctx)),
  getLastEl: (ctx) => last(dom32.getElements(ctx)),
  getNextEl: (ctx, id) => nextById6(dom32.getElements(ctx), id, ctx.currentLoopFocus),
  getPrevEl: (ctx, id) => prevById6(dom32.getElements(ctx), id, ctx.currentLoopFocus)
});
var { not: not31, and: and29 } = guards17;
var props27 = createProps28()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "loopFocus",
  "multiple",
  "onValueChange",
  "orientation",
  "rovingFocus",
  "value"
]);
var splitProps28 = createSplitProps(props27);
var itemProps9 = createProps28()(["value", "disabled"]);
var splitItemProps9 = createSplitProps(itemProps9);

// node_modules/@zag-js/tooltip/node_modules/@zag-js/dom-query/dist/index.mjs
var isDocument34 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow34 = (el) => el != null && el === el.window;
function getDocument38(el) {
  if (isDocument34(el)) return el;
  if (isWindow34(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId42 = (v) => v.id;
function itemById42(v, id, itemToId = defaultItemToId42) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId42(v, id, itemToId = defaultItemToId42) {
  const item = itemById42(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize42 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText42 = (item) => sanitize42(item.dataset.valuetext ?? item.textContent ?? "");
var match46 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap46 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText42(v, text, currentId, itemToId = defaultItemToId42) {
  const index = currentId ? indexOfId42(v, currentId, itemToId) : -1;
  let items = currentId ? wrap46(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match46(getValueText42(item), text));
}
function getByTypeaheadImpl42(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText42(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead42 = Object.assign(getByTypeaheadImpl42, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent42
});
function isValidTypeaheadEvent42(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function createScope34(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument38(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps42 = 1e3 / 60;

// node_modules/@zag-js/tooltip/node_modules/@zag-js/store/dist/index.mjs
function getGlobal33() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal33(key, value) {
  const g = getGlobal33();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev33 = () => true;
var isObject37 = (x) => typeof x === "object" && x !== null;
var proxyStateMap33 = makeGlobal33("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet33 = makeGlobal33("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction33 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject37(x) && !refSet33.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet33.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap33.has(value)) {
      snap[key] = snapshot33(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject37(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev33() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev33() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject37(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap33.has(value) && canProxy(value)) {
          nextValue = proxy33(value);
        }
        const childProxyState = !refSet33.has(nextValue) && proxyStateMap33.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap33.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap33,
  refSet33,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction33] = buildProxyFunction33();
function proxy33(initialObject = {}) {
  return proxyFunction33(initialObject);
}
function snapshot33(proxyObject, handlePromise) {
  const proxyState = proxyStateMap33.get(proxyObject);
  if (isDev33() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/tooltip/node_modules/@zag-js/core/dist/index.mjs
var isString20 = (v) => typeof v === "string";
var isFunction20 = (v) => typeof v === "function";
function exec18(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString20(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction20(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or22(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec18(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and30(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec18(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not32(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec18(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn18(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards18 = { or: or22, and: and30, not: not32, stateIn: stateIn18 };

// node_modules/@zag-js/tooltip/node_modules/@zag-js/types/dist/index.mjs
var createProps29 = () => (props52) => Array.from(new Set(props52));

// node_modules/@zag-js/tooltip/dist/index.mjs
var anatomy40 = createAnatomy("tooltip").parts("trigger", "arrow", "arrowTip", "positioner", "content");
var parts33 = anatomy40.build();
var dom33 = createScope34({
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `tooltip:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `tooltip:${ctx.id}:content`;
  },
  getArrowId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.arrow) ?? `tooltip:${ctx.id}:arrow`;
  },
  getPositionerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.positioner) ?? `tooltip:${ctx.id}:popper`;
  },
  getTriggerEl: (ctx) => dom33.getById(ctx, dom33.getTriggerId(ctx)),
  getContentEl: (ctx) => dom33.getById(ctx, dom33.getContentId(ctx)),
  getPositionerEl: (ctx) => dom33.getById(ctx, dom33.getPositionerId(ctx)),
  getArrowEl: (ctx) => dom33.getById(ctx, dom33.getArrowId(ctx))
});
var store = proxy33({
  id: null,
  prevId: null,
  setId(val) {
    this.prevId = this.id;
    this.id = val;
  }
});
var { and: and31, not: not33 } = guards18;
var props28 = createProps29()([
  "aria-label",
  "closeDelay",
  "closeOnEscape",
  "closeOnPointerDown",
  "closeOnScroll",
  "closeOnClick",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "interactive",
  "onOpenChange",
  "open.controlled",
  "open",
  "openDelay",
  "positioning"
]);
var splitProps29 = createSplitProps(props28);

// node_modules/@zag-js/tree-view/node_modules/@zag-js/dom-query/dist/index.mjs
var isHTMLElement10 = (v) => typeof v === "object" && (v == null ? void 0 : v.nodeType) === Node.ELEMENT_NODE && typeof (v == null ? void 0 : v.nodeName) === "string";
var isDocument35 = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow35 = (el) => el != null && el === el.window;
function getDocument39(el) {
  if (isDocument35(el)) return el;
  if (isWindow35(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
var defaultItemToId43 = (v) => v.id;
function itemById43(v, id, itemToId = defaultItemToId43) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId43(v, id, itemToId = defaultItemToId43) {
  const item = itemById43(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
var sanitize43 = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText43 = (item) => sanitize43(item.dataset.valuetext ?? item.textContent ?? "");
var match47 = (valueText, query22) => valueText.trim().toLowerCase().startsWith(query22.toLowerCase());
var wrap47 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText43(v, text, currentId, itemToId = defaultItemToId43) {
  const index = currentId ? indexOfId43(v, currentId, itemToId) : -1;
  let items = currentId ? wrap47(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match47(getValueText43(item), text));
}
function getByTypeaheadImpl43(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query22 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next3 = getByText43(items, query22, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead43 = Object.assign(getByTypeaheadImpl43, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent43
});
function isValidTypeaheadEvent43(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
function isHiddenElement(node2) {
  if (node2.parentElement && isHiddenElement(node2.parentElement)) return true;
  return node2.hidden;
}
function queryAll16(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function query8(root, selector) {
  return (root == null ? void 0 : root.querySelector(selector)) ?? null;
}
function createScope35(methods) {
  const dom61 = {
    getRootNode: (ctx) => {
      var _a7;
      return ((_a7 = ctx.getRootNode) == null ? void 0 : _a7.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument39(dom61.getRootNode(ctx)),
    getWin: (ctx) => dom61.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom61.getRootNode(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === dom61.getActiveElement(ctx),
    getById: (ctx, id) => dom61.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom61, ...methods };
}
var fps43 = 1e3 / 60;

// node_modules/@zag-js/tree-view/node_modules/@zag-js/store/dist/index.mjs
function getGlobal34() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal34(key, value) {
  const g = getGlobal34();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev34 = () => true;
var isObject38 = (x) => typeof x === "object" && x !== null;
var proxyStateMap34 = makeGlobal34("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet34 = makeGlobal34("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction34 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject38(x) && !refSet34.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet34.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap34.has(value)) {
      snap[key] = snapshot34(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject38(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev34() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev34() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject38(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap34.has(value) && canProxy(value)) {
          nextValue = proxy34(value);
        }
        const childProxyState = !refSet34.has(nextValue) && proxyStateMap34.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap34.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap34,
  refSet34,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction34] = buildProxyFunction34();
function proxy34(initialObject = {}) {
  return proxyFunction34(initialObject);
}
function snapshot34(proxyObject, handlePromise) {
  const proxyState = proxyStateMap34.get(proxyObject);
  if (isDev34() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@zag-js/tree-view/node_modules/@zag-js/core/dist/index.mjs
var isString21 = (v) => typeof v === "string";
var isFunction21 = (v) => typeof v === "function";
function exec19(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString21(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction21(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or23(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec19(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and32(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec19(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not34(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec19(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn19(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards19 = { or: or23, and: and32, not: not34, stateIn: stateIn19 };

// node_modules/@zag-js/tree-view/dist/index.mjs
var anatomy41 = createAnatomy("tree-view").parts(
  "root",
  "label",
  "tree",
  "item",
  "itemIndicator",
  "itemText",
  "branch",
  "branchControl",
  "branchTrigger",
  "branchContent",
  "branchText",
  "branchIndicator"
);
var parts34 = anatomy41.build();
var dom34 = createScope35({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `tree-root:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `tree-label:${ctx.id}`;
  },
  getTreeId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.tree) ?? `tree-tree:${ctx.id}`;
  },
  getNodeId(node2) {
    if (!isHTMLElement10(node2)) return null;
    return node2.dataset.branch ?? node2.dataset.item ?? null;
  },
  getNodeEl(ctx, id) {
    const node2 = dom34.getItemEl(ctx, id) ?? dom34.getBranchEl(ctx, id);
    if ((node2 == null ? void 0 : node2.dataset.part) === "branch") {
      return query8(node2, "[data-part=branch-control]");
    }
    return node2;
  },
  getTreeEl(ctx) {
    return dom34.getById(ctx, dom34.getTreeId(ctx));
  },
  getBranchEl(ctx, id) {
    const selector = `[role=treeitem][data-branch="${id}"]`;
    return query8(dom34.getTreeEl(ctx), selector);
  },
  getItemEl(ctx, id) {
    const selector = `[role=treeitem][data-item="${id}"]`;
    return query8(dom34.getTreeEl(ctx), selector);
  },
  getBranchControlEl(ctx, id) {
    const selector = "[data-part=branch-control]";
    return query8(dom34.getBranchEl(ctx, id), selector);
  },
  getFocusedEl(ctx) {
    if (!ctx.focusedValue) return null;
    return dom34.getById(ctx, ctx.focusedValue);
  },
  focusNode(node2, options) {
    if (isHTMLElement10(node2)) node2.focus(options);
  },
  getNodeDepth(node2) {
    return (node2 == null ? void 0 : node2.dataset.depth) ? Number(node2.dataset.depth) : -1;
  },
  getTreeWalker(ctx, opts) {
    const { skipHidden = true, root } = opts ?? {};
    const treeEl = root || dom34.getTreeEl(ctx);
    if (!treeEl) throw new Error("Tree or branch root not found");
    const doc = dom34.getDoc(ctx);
    return doc.createTreeWalker(treeEl, NodeFilter.SHOW_ELEMENT, {
      acceptNode(node2) {
        if (skipHidden && isHiddenElement(node2)) {
          return NodeFilter.FILTER_REJECT;
        }
        if (node2.role === "treeitem" && node2.dataset.part !== "branch") {
          return NodeFilter.FILTER_ACCEPT;
        }
        if (node2.role === "button" && node2.dataset.part === "branch-control") {
          return NodeFilter.FILTER_ACCEPT;
        }
        return NodeFilter.FILTER_SKIP;
      }
    });
  },
  getMatchingEl(ctx, key) {
    const walker = dom34.getTreeWalker(ctx);
    const elements = [];
    let node2 = walker.firstChild();
    while (node2) {
      if (isHTMLElement10(node2)) elements.push(node2);
      node2 = walker.nextNode();
    }
    return getByTypeahead43(elements, {
      state: ctx.typeaheadState,
      key,
      activeId: ctx.focusedValue,
      itemToId: (v) => dom34.getNodeId(v) ?? v.id
    });
  },
  getTreeNodes(ctx, options = {}) {
    const walker = dom34.getTreeWalker(ctx, options);
    const nodes = [];
    let node2 = walker.firstChild();
    while (node2) {
      if (isHTMLElement10(node2)) {
        nodes.push(node2);
      }
      node2 = walker.nextNode();
    }
    return nodes;
  },
  getBranchNodes(ctx, depth) {
    if (depth === -1) return [];
    return queryAll16(dom34.getTreeEl(ctx), `[role=treeitem][data-part=branch][data-depth="${depth}"]`);
  },
  getNodesInRange(nodes, startNode, endNode) {
    const nextSet = /* @__PURE__ */ new Set();
    nodes.forEach((node2) => {
      const nodeId = dom34.getNodeId(node2);
      if (nodeId == null) return;
      if (node2 === startNode || node2 === endNode) {
        nextSet.add(nodeId);
        return;
      }
      const startPos = node2.compareDocumentPosition(startNode);
      const endPos = node2.compareDocumentPosition(endNode);
      if (startPos & Node.DOCUMENT_POSITION_FOLLOWING && endPos & Node.DOCUMENT_POSITION_PRECEDING) {
        nextSet.add(nodeId);
        return;
      }
      if (startPos & Node.DOCUMENT_POSITION_PRECEDING && endPos & Node.DOCUMENT_POSITION_FOLLOWING) {
        nextSet.add(nodeId);
        return;
      }
    });
    return Array.from(nextSet);
  }
});
var { and: and33 } = guards19;

// node_modules/@chakra-ui/react/dist/esm/anatomy.js
var accordionAnatomy = anatomy.extendWith("itemBody");
var actionBarAnatomy = createAnatomy("action-bar").parts(
  "positioner",
  "content",
  "separator",
  "selectionTrigger",
  "closeTrigger"
);
var alertAnatomy = createAnatomy("alert").parts(
  "title",
  "description",
  "root",
  "indicator",
  "content"
);
var avatarAnatomy = anatomy2;
var breadcrumbAnatomy = createAnatomy("breadcrumb").parts(
  "link",
  "currentLink",
  "item",
  "list",
  "root",
  "ellipsis",
  "separator"
);
var blockquoteAnatomy = createAnatomy("blockquote").parts(
  "root",
  "icon",
  "content",
  "caption"
);
var cardAnatomy = createAnatomy("card").parts(
  "root",
  "header",
  "body",
  "footer",
  "title",
  "description"
);
var checkboxAnatomy = anatomy6;
var checkboxCardAnatomy = createAnatomy("checkbox-card", [
  "root",
  "control",
  "label",
  "description",
  "addon",
  "indicator",
  "content"
]);
var collapsibleAnataomy = anatomy8;
var dataListAnatomy = createAnatomy("data-list").parts(
  "root",
  "item",
  "itemLabel",
  "itemValue"
);
var dialogAnatomy = anatomy14.extendWith(
  "header",
  "body",
  "footer",
  "backdrop"
);
var drawerAnatomy = anatomy14.extendWith(
  "header",
  "body",
  "footer",
  "backdrop"
);
var editableAnatomy = anatomy15.extendWith("textarea");
var emptyStateAnatomy = createAnatomy("empty-state", [
  "root",
  "content",
  "indicator",
  "title",
  "description"
]);
var fieldAnatomy = anatomy16.extendWith("requiredIndicator");
var fileUploadAnatomy = anatomy18.extendWith(
  "itemContent",
  "dropzoneContent"
);
var hoverCardAnatomy = anatomy19;
var listAnatomy = createAnatomy("list").parts(
  "root",
  "item",
  "indicator"
);
var menuAnatomy = anatomy20.extendWith("itemCommand");
var nativeSelectAnatomy = createAnatomy("select").parts(
  "root",
  "field",
  "indicator"
);
var numberInputAnatomy = anatomy21;
var pinInputAnatomy = anatomy23;
var popoverAnatomy = anatomy24.extendWith(
  "header",
  "body",
  "footer"
);
var progressAnatomy = anatomy25;
var radioGroupAnatomy = anatomy27.extendWith(
  "itemAddon",
  "itemIndicator"
);
var radioCardAnatomy = radioGroupAnatomy.extendWith(
  "itemContent",
  "itemDescription"
);
var ratingGroupAnatomy = anatomy28.extendWith("itemIndicator");
var segmentGroupAnatomy = anatomy29;
var selectAnatomy = anatomy30.extendWith("indicatorGroup");
var sliderAnatomy = anatomy32.extendWith("markerIndicator");
var statAnatomy = createAnatomy("stat").parts(
  "root",
  "label",
  "helpText",
  "valueText",
  "valueUnit",
  "indicator"
);
var statusAnatomy = createAnatomy("status").parts("root", "indicator");
var stepsAnatomy = createAnatomy("steps", [
  "root",
  "list",
  "item",
  "trigger",
  "indicator",
  "separator",
  "content",
  "title",
  "description",
  "nextTrigger",
  "prevTrigger",
  "progress"
]);
var switchAnatomy = anatomy34.extendWith("indicator");
var tableAnatomy = createAnatomy("table").parts(
  "root",
  "header",
  "body",
  "row",
  "columnHeader",
  "cell",
  "footer",
  "caption"
);
var toastAnatomy = createAnatomy("toast").parts(
  "root",
  "title",
  "description",
  "indicator",
  "closeTrigger",
  "actionTrigger"
);
var tabsAnatomy = createAnatomy("tabs").parts(
  "root",
  "trigger",
  "list",
  "content",
  "contentGroup",
  "indicator"
);
var tagAnatomy = createAnatomy("tag").parts(
  "root",
  "label",
  "closeTrigger",
  "startElement",
  "endElement"
);
var timelineAnatomy = createAnatomy("timeline").parts(
  "root",
  "item",
  "content",
  "separator",
  "indicator",
  "connector",
  "title",
  "description"
);
var tooltipAnatomy = anatomy40;

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/accordion.js
var accordionSlotRecipe = defineSlotRecipe({
  className: "chakra-accordion",
  slots: accordionAnatomy.keys(),
  base: {
    root: {
      width: "full",
      "--accordion-radius": "radii.l2"
    },
    item: {
      overflowAnchor: "none"
    },
    itemTrigger: {
      display: "flex",
      alignItems: "center",
      width: "full",
      outline: "0",
      gap: "3",
      fontWeight: "medium",
      borderRadius: "var(--accordion-radius)",
      _focusVisible: {
        outline: "2px solid",
        outlineColor: "colorPalette.focusRing"
      },
      _disabled: {
        layerStyle: "disabled"
      }
    },
    itemBody: {
      pt: "var(--accordion-padding-y)",
      pb: "calc(var(--accordion-padding-y) * 2)"
    },
    itemContent: {
      overflow: "hidden",
      borderRadius: "var(--accordion-radius)",
      _open: {
        animationName: "expand-height, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "collapse-height, fade-out",
        animationDuration: "moderate"
      }
    },
    itemIndicator: {
      transition: "rotate 0.2s",
      transformOrigin: "center",
      color: "fg.subtle",
      _open: {
        rotate: "180deg"
      },
      _icon: {
        width: "1.2em",
        height: "1.2em"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        item: {
          borderBottomWidth: "1px"
        }
      },
      subtle: {
        itemTrigger: {
          px: "var(--accordion-padding-x)"
        },
        itemContent: {
          px: "var(--accordion-padding-x)"
        },
        item: {
          borderRadius: "var(--accordion-radius)",
          _open: {
            bg: "colorPalette.subtle"
          }
        }
      },
      enclosed: {
        root: {
          borderWidth: "1px",
          borderRadius: "var(--accordion-radius)",
          divideY: "1px",
          overflow: "hidden"
        },
        itemTrigger: {
          px: "var(--accordion-padding-x)"
        },
        itemContent: {
          px: "var(--accordion-padding-x)"
        },
        item: {
          _open: {
            bg: "bg.subtle"
          }
        }
      },
      plain: {}
    },
    size: {
      sm: {
        root: {
          "--accordion-padding-x": "spacing.3",
          "--accordion-padding-y": "spacing.2"
        },
        itemTrigger: {
          textStyle: "sm",
          py: "var(--accordion-padding-y)"
        }
      },
      md: {
        root: {
          "--accordion-padding-x": "spacing.4",
          "--accordion-padding-y": "spacing.2"
        },
        itemTrigger: {
          textStyle: "md",
          py: "var(--accordion-padding-y)"
        }
      },
      lg: {
        root: {
          "--accordion-padding-x": "spacing.4.5",
          "--accordion-padding-y": "spacing.2.5"
        },
        itemTrigger: {
          textStyle: "lg",
          py: "var(--accordion-padding-y)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/action-bar.js
var actionBarSlotRecipe = defineSlotRecipe({
  className: "chakra-action-bar",
  slots: actionBarAnatomy.keys(),
  base: {
    positioner: {
      position: "fixed",
      display: "flex",
      justifyContent: "center",
      pointerEvents: "none",
      insetInline: "0",
      top: "unset",
      bottom: "calc(env(safe-area-inset-bottom) + 20px)"
    },
    content: {
      bg: "bg.panel",
      shadow: "md",
      display: "flex",
      alignItems: "center",
      gap: "3",
      borderRadius: "l3",
      py: "2.5",
      px: "3",
      pointerEvents: "auto",
      // Stabilize the position of the action bar when the scrollbar is hidden
      // by using the scrollbar width to offset the position.
      translate: "calc(-1 * var(--scrollbar-width) / 2) 0px",
      _open: {
        animationName: "slide-from-bottom, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "slide-to-bottom, fade-out",
        animationDuration: "faster"
      }
    },
    separator: {
      width: "1px",
      height: "5",
      bg: "border"
    },
    selectionTrigger: {
      display: "inline-flex",
      alignItems: "center",
      gap: "2",
      alignSelf: "stretch",
      textStyle: "sm",
      px: "4",
      py: "1",
      borderRadius: "l2",
      borderWidth: "1px",
      borderStyle: "dashed"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/alert.js
var alertSlotRecipe = defineSlotRecipe({
  slots: alertAnatomy.keys(),
  className: "chakra-alert",
  base: {
    root: {
      width: "full",
      display: "flex",
      alignItems: "flex-start",
      position: "relative",
      borderRadius: "l3"
    },
    title: {
      fontWeight: "medium"
    },
    description: {
      display: "inline"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0",
      width: "1em",
      height: "1em"
    },
    content: {
      display: "flex",
      flex: "1",
      gap: "1"
    }
  },
  variants: {
    status: {
      info: {
        root: { colorPalette: "blue" }
      },
      warning: {
        root: { colorPalette: "orange" }
      },
      success: {
        root: { colorPalette: "green" }
      },
      error: {
        root: { colorPalette: "red" }
      },
      neutral: {
        root: { colorPalette: "gray" }
      }
    },
    inline: {
      true: {
        content: {
          display: "inline-flex",
          flexDirection: "row",
          alignItems: "center"
        }
      },
      false: {
        content: {
          display: "flex",
          flexDirection: "column"
        }
      }
    },
    variant: {
      subtle: {
        root: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg"
        }
      },
      surface: {
        root: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted"
        },
        indicator: {
          color: "colorPalette.fg"
        }
      },
      outline: {
        root: {
          color: "colorPalette.fg",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted"
        },
        indicator: {
          color: "colorPalette.fg"
        }
      },
      solid: {
        root: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        },
        indicator: {
          color: "colorPalette.contrast"
        }
      }
    },
    size: {
      sm: {
        root: {
          gap: "2",
          px: "3",
          py: "3",
          textStyle: "xs"
        },
        indicator: {
          textStyle: "lg"
        }
      },
      md: {
        root: {
          gap: "3",
          px: "4",
          py: "4",
          textStyle: "sm"
        },
        indicator: {
          textStyle: "xl"
        }
      },
      lg: {
        root: {
          gap: "3",
          px: "4",
          py: "4",
          textStyle: "md"
        },
        indicator: {
          textStyle: "2xl"
        }
      }
    }
  },
  defaultVariants: {
    status: "info",
    variant: "subtle",
    size: "md",
    inline: false
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/avatar.js
var avatarSlotRecipe = defineSlotRecipe({
  slots: avatarAnatomy.keys(),
  className: "chakra-avatar",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      fontWeight: "medium",
      position: "relative",
      verticalAlign: "top",
      flexShrink: "0",
      userSelect: "none",
      width: "var(--avatar-size)",
      height: "var(--avatar-size)",
      fontSize: "var(--avatar-font-size)",
      borderRadius: "var(--avatar-radius)",
      "&[data-group-item]": {
        borderWidth: "2px",
        borderColor: "bg"
      }
    },
    image: {
      width: "100%",
      height: "100%",
      objectFit: "cover",
      borderRadius: "var(--avatar-radius)"
    },
    fallback: {
      lineHeight: "1",
      textTransform: "uppercase",
      fontWeight: "medium",
      fontSize: "var(--avatar-font-size)",
      borderRadius: "var(--avatar-radius)"
    }
  },
  variants: {
    size: {
      full: {
        root: {
          "--avatar-size": "100%",
          "--avatar-font-size": "100%"
        }
      },
      "2xs": {
        root: {
          "--avatar-font-size": "fontSizes.2xs",
          "--avatar-size": "sizes.6"
        }
      },
      xs: {
        root: {
          "--avatar-font-size": "fontSizes.xs",
          "--avatar-size": "sizes.8"
        }
      },
      sm: {
        root: {
          "--avatar-font-size": "fontSizes.sm",
          "--avatar-size": "sizes.9"
        }
      },
      md: {
        root: {
          "--avatar-font-size": "fontSizes.md",
          "--avatar-size": "sizes.10"
        }
      },
      lg: {
        root: {
          "--avatar-font-size": "fontSizes.md",
          "--avatar-size": "sizes.11"
        }
      },
      xl: {
        root: {
          "--avatar-font-size": "fontSizes.lg",
          "--avatar-size": "sizes.12"
        }
      },
      "2xl": {
        root: {
          "--avatar-font-size": "fontSizes.xl",
          "--avatar-size": "sizes.16"
        }
      }
    },
    variant: {
      solid: {
        root: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        }
      },
      subtle: {
        root: {
          bg: "colorPalette.muted",
          color: "colorPalette.fg"
        }
      },
      outline: {
        root: {
          color: "colorPalette.fg",
          borderWidth: "1px",
          borderColor: "colorPalette.muted"
        }
      }
    },
    shape: {
      square: {},
      rounded: {
        root: { "--avatar-radius": "radii.l3" }
      },
      full: {
        root: { "--avatar-radius": "radii.full" }
      }
    },
    borderless: {
      true: {
        root: {
          "&[data-group-item]": {
            borderWidth: "0px"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    shape: "full",
    variant: "subtle"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/blockquote.js
var blockquoteSlotRecipe = defineSlotRecipe({
  className: "chakra-blockquote",
  slots: blockquoteAnatomy.keys(),
  base: {
    root: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      gap: "2"
    },
    caption: {
      textStyle: "sm",
      color: "fg.muted"
    },
    icon: {
      boxSize: "5"
    }
  },
  variants: {
    justify: {
      start: {
        root: {
          alignItems: "flex-start",
          textAlign: "start"
        }
      },
      center: {
        root: {
          alignItems: "center",
          textAlign: "center"
        }
      },
      end: {
        root: {
          alignItems: "flex-end",
          textAlign: "end"
        }
      }
    },
    variant: {
      subtle: {
        root: {
          paddingX: "5",
          borderStartWidth: "4px",
          borderStartColor: "colorPalette.muted"
        },
        icon: {
          color: "colorPalette.fg"
        }
      },
      solid: {
        root: {
          paddingX: "5",
          borderStartWidth: "4px",
          borderStartColor: "colorPalette.solid"
        },
        icon: {
          color: "colorPalette.solid"
        }
      },
      plain: {
        root: {
          paddingX: "5"
        },
        icon: {
          color: "colorPalette.solid"
        }
      }
    }
  },
  defaultVariants: {
    variant: "subtle",
    justify: "start"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/breadcrumb.js
var breadcrumbSlotRecipe = defineSlotRecipe({
  className: "chakra-breadcrumb",
  slots: breadcrumbAnatomy.keys(),
  base: {
    list: {
      display: "flex",
      alignItems: "center",
      wordBreak: "break-word",
      color: "fg.muted"
    },
    link: {
      outline: "0",
      textDecoration: "none",
      borderRadius: "l1",
      focusRing: "outside",
      display: "inline-flex",
      alignItems: "center",
      gap: "2"
    },
    item: {
      display: "inline-flex",
      alignItems: "center"
    },
    separator: {
      color: "fg.muted",
      opacity: "0.8",
      _icon: {
        boxSize: "1em"
      }
    },
    ellipsis: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      _icon: {
        boxSize: "1em"
      }
    }
  },
  variants: {
    variant: {
      underline: {
        link: {
          color: "colorPalette.fg",
          textDecoration: "underline",
          textUnderlineOffset: "0.2em",
          textDecorationColor: "colorPalette.muted"
        },
        currentLink: {
          color: "colorPalette.fg"
        }
      },
      plain: {
        link: {
          color: "fg.muted",
          _hover: { color: "fg" }
        },
        currentLink: {
          color: "fg"
        }
      }
    },
    size: {
      sm: {
        list: {
          gap: "1",
          textStyle: "xs"
        }
      },
      md: {
        list: {
          gap: "1.5",
          textStyle: "sm"
        }
      },
      lg: {
        list: {
          gap: "2",
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    variant: "plain",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/card.js
var cardSlotRecipe = defineSlotRecipe({
  className: "chakra-card",
  slots: cardAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      minWidth: "0",
      wordWrap: "break-word",
      borderRadius: "l3",
      color: "fg",
      textAlign: "start"
    },
    title: {
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted",
      fontSize: "sm"
    },
    header: {
      paddingInline: "var(--card-padding)",
      paddingTop: "var(--card-padding)",
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    },
    body: {
      padding: "var(--card-padding)",
      flex: "1",
      display: "flex",
      flexDirection: "column"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      gap: "2",
      paddingInline: "var(--card-padding)",
      paddingBottom: "var(--card-padding)"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          "--card-padding": "spacing.4"
        },
        title: {
          textStyle: "md"
        }
      },
      md: {
        root: {
          "--card-padding": "spacing.6"
        },
        title: {
          textStyle: "lg"
        }
      },
      lg: {
        root: {
          "--card-padding": "spacing.7"
        },
        title: {
          textStyle: "xl"
        }
      }
    },
    variant: {
      elevated: {
        root: {
          bg: "bg.panel",
          boxShadow: "md"
        }
      },
      outline: {
        root: {
          bg: "bg.panel",
          borderWidth: "1px",
          borderColor: "border"
        }
      },
      subtle: {
        root: {
          bg: "bg.muted"
        }
      }
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkbox.js
var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n;
var checkboxSlotRecipe = defineSlotRecipe({
  slots: checkboxAnatomy.keys(),
  className: "chakra-checkbox",
  base: {
    root: {
      display: "inline-flex",
      gap: "2",
      alignItems: "center",
      verticalAlign: "top",
      position: "relative"
    },
    control: checkmarkRecipe.base,
    label: {
      fontWeight: "medium",
      userSelect: "none",
      _disabled: {
        opacity: "0.5"
      }
    }
  },
  variants: {
    size: {
      xs: {
        root: { gap: "1.5" },
        label: { textStyle: "xs" },
        control: (_b = (_a = checkmarkRecipe.variants) == null ? void 0 : _a.size) == null ? void 0 : _b.xs
      },
      sm: {
        root: { gap: "2" },
        label: { textStyle: "sm" },
        control: (_d = (_c = checkmarkRecipe.variants) == null ? void 0 : _c.size) == null ? void 0 : _d.sm
      },
      md: {
        root: { gap: "2.5" },
        label: { textStyle: "sm" },
        control: (_f = (_e2 = checkmarkRecipe.variants) == null ? void 0 : _e2.size) == null ? void 0 : _f.md
      },
      lg: {
        root: { gap: "3" },
        label: { textStyle: "md" },
        control: (_h = (_g = checkmarkRecipe.variants) == null ? void 0 : _g.size) == null ? void 0 : _h.lg
      }
    },
    variant: {
      outline: {
        control: (_j = (_i = checkmarkRecipe.variants) == null ? void 0 : _i.variant) == null ? void 0 : _j.outline
      },
      solid: {
        control: (_l = (_k = checkmarkRecipe.variants) == null ? void 0 : _k.variant) == null ? void 0 : _l.solid
      },
      subtle: {
        control: (_n = (_m = checkmarkRecipe.variants) == null ? void 0 : _m.variant) == null ? void 0 : _n.subtle
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkbox-card.js
var _a2, _b2, _c2, _d2, _e3, _f2, _g2;
var checkboxCardSlotRecipe = defineSlotRecipe({
  slots: checkboxCardAnatomy.keys(),
  className: "chakra-checkbox-card",
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      userSelect: "none",
      position: "relative",
      borderRadius: "l2",
      flex: "1",
      focusVisibleRing: "outside",
      _disabled: {
        opacity: "0.8",
        borderColor: "border.subtle"
      },
      _invalid: {
        outline: "2px solid",
        outlineColor: "border.error"
      }
    },
    control: {
      display: "inline-flex",
      flex: "1",
      position: "relative",
      borderRadius: "inherit",
      justifyContent: "var(--checkbox-card-justify)",
      alignItems: "var(--checkbox-card-align)"
    },
    label: {
      fontWeight: "medium",
      display: "flex",
      alignItems: "center",
      gap: "2",
      _disabled: {
        opacity: "0.5"
      }
    },
    description: {
      opacity: "0.64",
      textStyle: "sm"
    },
    addon: {
      _disabled: {
        opacity: "0.5"
      }
    },
    indicator: checkmarkRecipe.base,
    content: {
      display: "flex",
      flexDirection: "column",
      flex: "1",
      gap: "1",
      justifyContent: "var(--checkbox-card-justify)",
      alignItems: "var(--checkbox-card-align)"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        control: {
          padding: "3",
          gap: "1.5"
        },
        addon: {
          px: "3",
          py: "1.5",
          borderTopWidth: "1px"
        },
        indicator: (_a2 = checkmarkRecipe.variants) == null ? void 0 : _a2.size.sm
      },
      md: {
        root: {
          textStyle: "sm"
        },
        control: {
          padding: "4",
          gap: "2.5"
        },
        addon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        indicator: (_b2 = checkmarkRecipe.variants) == null ? void 0 : _b2.size.md
      },
      lg: {
        root: {
          textStyle: "md"
        },
        control: {
          padding: "4",
          gap: "3.5"
        },
        addon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        indicator: (_c2 = checkmarkRecipe.variants) == null ? void 0 : _c2.size.lg
      }
    },
    variant: {
      surface: {
        root: {
          borderWidth: "1px",
          borderColor: "border",
          _checked: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg",
            borderColor: "colorPalette.muted"
          },
          _disabled: {
            bg: "bg.muted"
          }
        },
        indicator: (_d2 = checkmarkRecipe.variants) == null ? void 0 : _d2.variant.solid
      },
      subtle: {
        root: {
          bg: "bg.muted"
        },
        control: {
          _checked: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          }
        },
        indicator: (_e3 = checkmarkRecipe.variants) == null ? void 0 : _e3.variant.plain
      },
      outline: {
        root: {
          borderWidth: "1px",
          borderColor: "border",
          _checked: {
            boxShadow: "0 0 0 1px var(--shadow-color)",
            boxShadowColor: "colorPalette.solid",
            borderColor: "colorPalette.solid"
          }
        },
        indicator: (_f2 = checkmarkRecipe.variants) == null ? void 0 : _f2.variant.solid
      },
      solid: {
        root: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        indicator: (_g2 = checkmarkRecipe.variants) == null ? void 0 : _g2.variant.inverted
      }
    },
    justify: {
      start: {
        root: { "--checkbox-card-justify": "flex-start" }
      },
      end: {
        root: { "--checkbox-card-justify": "flex-end" }
      },
      center: {
        root: { "--checkbox-card-justify": "center" }
      }
    },
    align: {
      start: {
        root: { "--checkbox-card-align": "flex-start" },
        content: { textAlign: "start" }
      },
      end: {
        root: { "--checkbox-card-align": "flex-end" },
        content: { textAlign: "end" }
      },
      center: {
        root: { "--checkbox-card-align": "center" },
        content: { textAlign: "center" }
      }
    },
    orientation: {
      vertical: {
        control: { flexDirection: "column" }
      },
      horizontal: {
        control: { flexDirection: "row" }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    align: "start",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/collapsible.js
var collapsibleSlotRecipe = defineSlotRecipe({
  slots: collapsibleAnataomy.keys(),
  className: "chakra-collapsible",
  base: {
    content: {
      overflow: "hidden",
      _open: {
        animationName: "expand-height, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "collapse-height, fade-out",
        animationDuration: "moderate"
      }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/data-list.js
var dataListSlotRecipe = defineSlotRecipe({
  slots: dataListAnatomy.keys(),
  className: "chakra-data-list",
  base: {
    itemLabel: {
      color: "fg.muted",
      display: "flex",
      alignItems: "center",
      gap: "1"
    },
    itemValue: {
      display: "flex",
      minWidth: "0",
      flex: "1"
    }
  },
  variants: {
    orientation: {
      horizontal: {
        root: {
          display: "flex",
          flexDirection: "column"
        },
        item: {
          display: "inline-flex",
          alignItems: "center",
          gap: "4"
        },
        itemLabel: {
          minWidth: "120px"
        }
      },
      vertical: {
        root: {
          display: "flex",
          flexDirection: "column"
        },
        item: {
          display: "flex",
          flexDirection: "column",
          gap: "1"
        }
      }
    },
    size: {
      sm: {
        root: {
          gap: "3"
        },
        item: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          gap: "4"
        },
        item: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          gap: "5"
        },
        item: {
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    orientation: "vertical"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/dialog.js
var dialogSlotRecipe = defineSlotRecipe({
  slots: dialogAnatomy.keys(),
  className: "chakra-dialog",
  base: {
    backdrop: {
      bg: "blackAlpha.500",
      pos: "fixed",
      left: 0,
      top: 0,
      w: "100vw",
      h: "100dvh",
      zIndex: "modal",
      _open: {
        animationName: "fade-in",
        animationDuration: "slow"
      },
      _closed: {
        animationName: "fade-out",
        animationDuration: "moderate"
      }
    },
    positioner: {
      display: "flex",
      width: "100vw",
      height: "100dvh",
      position: "fixed",
      left: 0,
      top: 0,
      "--dialog-z-index": "zIndex.modal",
      zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
      justifyContent: "center",
      overscrollBehaviorY: "none"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      borderRadius: "l3",
      textStyle: "sm",
      my: "var(--dialog-margin, var(--dialog-base-margin))",
      "--dialog-z-index": "zIndex.modal",
      zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
      bg: "bg.panel",
      boxShadow: "lg",
      _open: {
        animationDuration: "moderate"
      },
      _closed: {
        animationDuration: "faster"
      }
    },
    header: {
      flex: 0,
      px: "6",
      pt: "6",
      pb: "4"
    },
    body: {
      flex: "1",
      px: "6",
      pt: "2",
      pb: "6"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      gap: "3",
      px: "6",
      pt: "2",
      pb: "4"
    },
    title: {
      textStyle: "lg",
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted"
    }
  },
  variants: {
    placement: {
      center: {
        positioner: {
          alignItems: "center"
        },
        content: {
          "--dialog-base-margin": "auto",
          mx: "auto"
        }
      },
      top: {
        positioner: {
          alignItems: "flex-start"
        },
        content: {
          "--dialog-base-margin": "spacing.16",
          mx: "auto"
        }
      },
      bottom: {
        positioner: {
          alignItems: "flex-end"
        },
        content: {
          "--dialog-base-margin": "spacing.16",
          mx: "auto"
        }
      }
    },
    scrollBehavior: {
      inside: {
        positioner: {
          overflow: "hidden"
        },
        content: {
          maxH: "calc(100% - 7.5rem)"
        },
        body: {
          overflow: "auto"
        }
      },
      outside: {
        positioner: {
          overflow: "auto"
        }
      }
    },
    size: {
      xs: {
        content: {
          maxW: "sm"
        }
      },
      sm: {
        content: {
          maxW: "md"
        }
      },
      md: {
        content: {
          maxW: "lg"
        }
      },
      lg: {
        content: {
          maxW: "2xl"
        }
      },
      xl: {
        content: {
          maxW: "4xl"
        }
      },
      cover: {
        positioner: {
          padding: "10"
        },
        content: {
          width: "100%",
          height: "100%",
          "--dialog-margin": "0"
        }
      },
      full: {
        content: {
          maxW: "100vw",
          minH: "100vh",
          "--dialog-margin": "0",
          borderRadius: "0"
        }
      }
    },
    motionPreset: {
      scale: {
        content: {
          _open: { animationName: "scale-in, fade-in" },
          _closed: { animationName: "scale-out, fade-out" }
        }
      },
      "slide-in-bottom": {
        content: {
          _open: { animationName: "slide-from-bottom, fade-in" },
          _closed: { animationName: "slide-to-bottom, fade-out" }
        }
      },
      "slide-in-top": {
        content: {
          _open: { animationName: "slide-from-top, fade-in" },
          _closed: { animationName: "slide-to-top, fade-out" }
        }
      },
      "slide-in-left": {
        content: {
          _open: { animationName: "slide-from-left, fade-in" },
          _closed: { animationName: "slide-to-left, fade-out" }
        }
      },
      "slide-in-right": {
        content: {
          _open: { animationName: "slide-from-right, fade-in" },
          _closed: { animationName: "slide-to-right, fade-out" }
        }
      },
      none: {}
    }
  },
  defaultVariants: {
    size: "md",
    scrollBehavior: "outside",
    placement: "top",
    motionPreset: "scale"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/drawer.js
var drawerSlotRecipe = defineSlotRecipe({
  slots: drawerAnatomy.keys(),
  className: "chakra-drawer",
  base: {
    backdrop: {
      bg: "blackAlpha.500",
      pos: "fixed",
      insetInlineStart: 0,
      top: 0,
      w: "100vw",
      h: "100dvh",
      zIndex: "modal",
      _open: {
        animationName: "fade-in",
        animationDuration: "slow"
      },
      _closed: {
        animationName: "fade-out",
        animationDuration: "moderate"
      }
    },
    positioner: {
      display: "flex",
      width: "100vw",
      height: "100dvh",
      position: "fixed",
      insetInlineStart: 0,
      top: 0,
      zIndex: "modal",
      overscrollBehaviorY: "none"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      zIndex: "modal",
      textStyle: "sm",
      maxH: "100dvh",
      color: "inherit",
      bg: "bg.panel",
      boxShadow: "lg",
      _open: {
        animationDuration: "slowest",
        animationTimingFunction: "ease-in-smooth"
      },
      _closed: {
        animationDuration: "slower",
        animationTimingFunction: "ease-in-smooth"
      }
    },
    header: {
      flex: 0,
      px: "6",
      pt: "6",
      pb: "4"
    },
    body: {
      px: "6",
      py: "2",
      flex: "1",
      overflow: "auto"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      gap: "3",
      px: "6",
      pt: "2",
      pb: "4"
    },
    title: {
      textStyle: "lg",
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          maxW: "xs"
        }
      },
      sm: {
        content: {
          maxW: "md"
        }
      },
      md: {
        content: {
          maxW: "lg"
        }
      },
      lg: {
        content: {
          maxW: "2xl"
        }
      },
      xl: {
        content: {
          maxW: "4xl"
        }
      },
      full: {
        content: {
          maxW: "100vw",
          h: "100dvh"
        }
      }
    },
    placement: {
      start: {
        positioner: {
          justifyContent: "flex-start"
        },
        content: {
          _open: {
            animationName: {
              base: "slide-from-left-full, fade-in",
              _rtl: "slide-from-right-full, fade-in"
            }
          },
          _closed: {
            animationName: {
              base: "slide-to-left-full, fade-out",
              _rtl: "slide-to-right-full, fade-out"
            }
          }
        }
      },
      end: {
        positioner: {
          justifyContent: "flex-end"
        },
        content: {
          _open: {
            animationName: {
              base: "slide-from-right-full, fade-in",
              _rtl: "slide-from-left-full, fade-in"
            }
          },
          _closed: {
            animationName: {
              base: "slide-to-right-full, fade-out",
              _rtl: "slide-to-right-full, fade-out"
            }
          }
        }
      },
      top: {
        positioner: {
          alignItems: "flex-start"
        },
        content: {
          maxW: "100%",
          _open: { animationName: "slide-from-top-full, fade-in" },
          _closed: { animationName: "slide-to-top-full, fade-out" }
        }
      },
      bottom: {
        positioner: {
          alignItems: "flex-end"
        },
        content: {
          maxW: "100%",
          _open: { animationName: "slide-from-bottom-full, fade-in" },
          _closed: { animationName: "slide-to-bottom-full, fade-out" }
        }
      }
    },
    contained: {
      true: {
        positioner: {
          padding: "4"
        },
        content: {
          borderRadius: "l3"
        }
      }
    }
  },
  defaultVariants: {
    size: "xs",
    placement: "end"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/editable.js
var sharedStyles = defineStyle({
  fontSize: "inherit",
  fontWeight: "inherit",
  textAlign: "inherit",
  bg: "transparent",
  borderRadius: "l2"
});
var editableSlotRecipe = defineSlotRecipe({
  slots: editableAnatomy.keys(),
  className: "chakra-editable",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      gap: "1.5",
      width: "full"
    },
    preview: {
      ...sharedStyles,
      py: "1",
      px: "1",
      display: "inline-flex",
      alignItems: "center",
      transitionProperty: "common",
      transitionDuration: "normal",
      cursor: "text",
      _hover: {
        bg: "bg.muted"
      },
      _disabled: {
        userSelect: "none"
      }
    },
    input: {
      ...sharedStyles,
      outline: "0",
      py: "1",
      px: "1",
      transitionProperty: "common",
      transitionDuration: "normal",
      width: "full",
      focusVisibleRing: "inside",
      focusRingWidth: "2px",
      _placeholder: { opacity: 0.6 }
    },
    control: {
      display: "inline-flex",
      alignItems: "center",
      gap: "1.5"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        preview: { minH: "8" },
        input: { minH: "8" }
      },
      md: {
        root: {
          textStyle: "sm"
        },
        preview: { minH: "9" },
        input: { minH: "9" }
      },
      lg: {
        root: {
          textStyle: "md"
        },
        preview: { minH: "10" },
        input: { minH: "10" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/empty-state.js
var emptyStateSlotRecipe = defineSlotRecipe({
  slots: emptyStateAnatomy.keys(),
  className: "chakra-empty-state",
  base: {
    root: {
      width: "full"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center"
    },
    indicator: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: "fg.subtle",
      _icon: {
        boxSize: "1em"
      }
    },
    title: {
      fontWeight: "semibold"
    },
    description: {
      textStyle: "sm",
      color: "fg.muted"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          px: "4",
          py: "6"
        },
        title: {
          textStyle: "md"
        },
        content: {
          gap: "4"
        },
        indicator: {
          textStyle: "2xl"
        }
      },
      md: {
        root: {
          px: "8",
          py: "12"
        },
        title: {
          textStyle: "lg"
        },
        content: {
          gap: "6"
        },
        indicator: {
          textStyle: "4xl"
        }
      },
      lg: {
        root: {
          px: "12",
          py: "16"
        },
        title: {
          textStyle: "xl"
        },
        content: {
          gap: "8"
        },
        indicator: {
          textStyle: "6xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/field.js
var fieldSlotRecipe = defineSlotRecipe({
  className: "chakra-field",
  slots: fieldAnatomy.keys(),
  base: {
    requiredIndicator: {
      color: "fg.error",
      lineHeight: "1"
    },
    root: {
      display: "flex",
      width: "100%",
      position: "relative",
      gap: "1.5"
    },
    label: {
      display: "flex",
      alignItems: "center",
      textAlign: "start",
      textStyle: "sm",
      fontWeight: "medium",
      gap: "1",
      userSelect: "none",
      _disabled: {
        opacity: "0.5"
      }
    },
    errorText: {
      display: "inline-flex",
      alignItems: "center",
      fontWeight: "medium",
      gap: "1",
      color: "fg.error",
      textStyle: "xs"
    },
    helperText: {
      color: "fg.muted",
      textStyle: "xs"
    }
  },
  variants: {
    orientation: {
      vertical: {
        root: {
          flexDirection: "column",
          alignItems: "flex-start"
        }
      },
      horizontal: {
        root: {
          flexDirection: "row",
          alignItems: "center",
          justifyContent: "space-between"
        },
        label: {
          flex: "0 0 var(--field-label-width, 80px)"
        }
      }
    }
  },
  defaultVariants: {
    orientation: "vertical"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/fieldset.js
var fieldsetSlotRecipe = defineSlotRecipe({
  className: "fieldset",
  slots: [...anatomy17.keys(), "content"],
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      width: "full"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      width: "full"
    },
    legend: {
      color: "fg",
      fontWeight: "medium",
      _disabled: {
        opacity: "0.5"
      }
    },
    helperText: {
      color: "fg.muted",
      textStyle: "sm"
    },
    errorText: {
      display: "inline-flex",
      alignItems: "center",
      color: "fg.error",
      gap: "2",
      fontWeight: "medium",
      textStyle: "sm"
    }
  },
  variants: {
    size: {
      sm: {
        root: { spaceY: "2" },
        content: { gap: "1.5" },
        legend: { textStyle: "sm" }
      },
      md: {
        root: { spaceY: "4" },
        content: { gap: "4" },
        legend: { textStyle: "sm" }
      },
      lg: {
        root: { spaceY: "6" },
        content: { gap: "4" },
        legend: { textStyle: "md" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/file-upload.js
var fileUploadSlotRecipe = defineSlotRecipe({
  className: "chakra-file-upload",
  slots: fileUploadAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "4",
      width: "100%",
      alignItems: "flex-start"
    },
    label: {
      fontWeight: "medium",
      textStyle: "sm"
    },
    dropzone: {
      background: "bg",
      borderRadius: "l3",
      borderWidth: "2px",
      borderStyle: "dashed",
      display: "flex",
      alignItems: "center",
      flexDirection: "column",
      gap: "4",
      justifyContent: "center",
      minHeight: "2xs",
      px: "3",
      py: "2",
      transition: "backgrounds",
      focusVisibleRing: "outside",
      _hover: {
        bg: "bg.subtle"
      },
      _dragging: {
        bg: "colorPalette.subtle",
        borderStyle: "solid",
        borderColor: "colorPalette.solid"
      }
    },
    dropzoneContent: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      textAlign: "center",
      gap: "1",
      textStyle: "sm"
    },
    item: {
      textStyle: "sm",
      animationName: "fade-in",
      animationDuration: "moderate",
      background: "bg",
      borderRadius: "l2",
      borderWidth: "1px",
      width: "100%",
      display: "flex",
      alignItems: "center",
      gap: "3",
      p: "4"
    },
    itemGroup: {
      width: "100%",
      display: "flex",
      flexDirection: "column",
      gap: "3"
    },
    itemName: {
      color: "fg",
      fontWeight: "medium",
      lineClamp: "1"
    },
    itemContent: {
      display: "flex",
      flexDirection: "column",
      gap: "0.5",
      flex: "1"
    },
    itemSizeText: {
      color: "fg.muted",
      textStyle: "xs"
    },
    itemDeleteTrigger: {
      alignSelf: "flex-start"
    },
    itemPreviewImage: {
      width: "10",
      height: "10",
      objectFit: "scale-down"
    }
  },
  defaultVariants: {}
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/hover-card.js
var hoverCardSlotRecipe = defineSlotRecipe({
  className: "chakra-hover-card",
  slots: hoverCardAnatomy.keys(),
  base: {
    content: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      textStyle: "sm",
      "--hovercard-bg": "colors.bg.panel",
      bg: "var(--hovercard-bg)",
      boxShadow: "lg",
      maxWidth: "80",
      borderRadius: "l3",
      zIndex: "popover",
      transformOrigin: "var(--transform-origin)",
      outline: "0",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    arrow: {
      "--arrow-size": "sizes.3",
      "--arrow-background": "var(--hovercard-bg)"
    },
    arrowTip: {
      borderTopWidth: "0.5px",
      borderInlineStartWidth: "0.5px"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          padding: "3"
        }
      },
      sm: {
        content: {
          padding: "4"
        }
      },
      md: {
        content: {
          padding: "5"
        }
      },
      lg: {
        content: {
          padding: "6"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/list.js
var listSlotRecipe = defineSlotRecipe({
  className: "chakra-list",
  slots: listAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "var(--list-gap)",
      "& :where(ul, ol)": {
        marginTop: "var(--list-gap)"
      }
    },
    item: {
      whiteSpace: "normal",
      display: "list-item"
    },
    indicator: {
      marginEnd: "2",
      minHeight: "1lh",
      flexShrink: 0,
      display: "inline-block",
      verticalAlign: "middle"
    }
  },
  variants: {
    variant: {
      marker: {
        root: {
          listStyle: "revert",
          listStylePosition: "inside"
        },
        item: {
          _marker: {
            color: "fg.subtle"
          }
        }
      },
      plain: {
        item: {
          alignItems: "flex-start",
          display: "inline-flex"
        }
      }
    },
    align: {
      center: {
        item: { alignItems: "center" }
      },
      start: {
        item: { alignItems: "flex-start" }
      },
      end: {
        item: { alignItems: "flex-end" }
      }
    }
  },
  defaultVariants: {
    variant: "marker"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/menu.js
var menuSlotRecipe = defineSlotRecipe({
  className: "chakra-menu",
  slots: menuAnatomy.keys(),
  base: {
    content: {
      outline: 0,
      bg: "bg.panel",
      boxShadow: "lg",
      color: "fg",
      "--menu-z-index": "zIndex.dropdown",
      zIndex: "calc(var(--menu-z-index) + var(--layer-index, 0))",
      borderRadius: "l2",
      overflow: "hidden",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    item: {
      textDecoration: "none",
      color: "fg",
      userSelect: "none",
      borderRadius: "l1",
      width: "100%",
      display: "flex",
      cursor: "menuitem",
      alignItems: "center",
      textAlign: "start",
      position: "relative",
      flex: "0 0 auto",
      outline: 0,
      _disabled: {
        layerStyle: "disabled"
      }
    },
    itemText: {
      flex: "1"
    },
    itemGroupLabel: {
      px: "2",
      py: "1.5",
      fontWeight: "semibold",
      textStyle: "sm"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0"
    },
    itemCommand: {
      opacity: "0.6",
      textStyle: "xs",
      ms: "auto",
      ps: "4",
      letterSpacing: "widest"
    },
    separator: {
      height: "1px",
      bg: "bg.muted",
      my: "1",
      mx: "-1"
    }
  },
  variants: {
    variant: {
      subtle: {
        item: {
          _highlighted: {
            bg: { _light: "bg.muted", _dark: "bg.emphasized" }
          }
        }
      },
      solid: {
        item: {
          _highlighted: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        }
      }
    },
    size: {
      sm: {
        content: {
          minW: "8rem",
          padding: "1"
        },
        item: {
          gap: "1",
          textStyle: "xs",
          py: "1",
          px: "1.5"
        }
      },
      md: {
        content: {
          minW: "8rem",
          padding: "1.5"
        },
        item: {
          gap: "2",
          textStyle: "sm",
          py: "1.5",
          px: "2"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "subtle"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/select.js
var selectSlotRecipe = defineSlotRecipe({
  className: "chakra-select",
  slots: selectAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5",
      width: "full"
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      width: "full",
      minH: "var(--select-trigger-height)",
      px: "var(--select-trigger-padding-x)",
      borderRadius: "l2",
      userSelect: "none",
      textAlign: "start",
      focusVisibleRing: "inside",
      _placeholderShown: {
        color: "fg.muted"
      },
      _disabled: {
        layerStyle: "disabled"
      },
      _invalid: {
        borderColor: "border.error"
      }
    },
    indicatorGroup: {
      display: "flex",
      alignItems: "center",
      gap: "1",
      pos: "absolute",
      right: "0",
      top: "0",
      bottom: "0",
      px: "var(--select-trigger-padding-x)",
      pointerEvents: "none"
    },
    indicator: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: { base: "fg.muted", _disabled: "fg.subtle", _invalid: "fg.error" }
    },
    content: {
      background: "bg.panel",
      display: "flex",
      flexDirection: "column",
      zIndex: "dropdown",
      borderRadius: "l2",
      outline: 0,
      maxH: "96",
      overflowY: "auto",
      boxShadow: "md",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "fastest"
      }
    },
    item: {
      position: "relative",
      userSelect: "none",
      display: "flex",
      alignItems: "center",
      gap: "2",
      cursor: "option",
      justifyContent: "space-between",
      flex: "1",
      textAlign: "start",
      borderRadius: "l1",
      _highlighted: {
        bg: { _light: "bg.muted", _dark: "bg.emphasized" }
      },
      _disabled: {
        pointerEvents: "none",
        opacity: "0.5"
      },
      _icon: {
        width: "4",
        height: "4"
      }
    },
    control: {
      pos: "relative"
    },
    itemText: {
      flex: "1"
    },
    itemGroup: {
      _first: { mt: "0" }
    },
    itemGroupLabel: {
      py: "1",
      fontWeight: "medium"
    },
    label: {
      fontWeight: "medium",
      userSelect: "none",
      textStyle: "sm",
      _disabled: {
        layerStyle: "disabled"
      }
    },
    valueText: {
      lineClamp: "1",
      maxW: "80%"
    }
  },
  variants: {
    variant: {
      outline: {
        trigger: {
          bg: "transparent",
          borderWidth: "1px",
          borderColor: "border",
          _expanded: {
            borderColor: "border.emphasized"
          }
        }
      },
      subtle: {
        trigger: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.muted"
        }
      }
    },
    size: {
      xs: {
        root: {
          "--select-trigger-height": "sizes.8",
          "--select-trigger-padding-x": "spacing.2"
        },
        content: {
          p: "1",
          gap: "1",
          textStyle: "xs"
        },
        trigger: {
          textStyle: "xs",
          gap: "1"
        },
        item: {
          py: "1",
          px: "2"
        },
        itemGroupLabel: {
          py: "1",
          px: "2"
        },
        indicator: {
          _icon: {
            width: "3.5",
            height: "3.5"
          }
        }
      },
      sm: {
        root: {
          "--select-trigger-height": "sizes.9",
          "--select-trigger-padding-x": "spacing.2.5"
        },
        content: {
          p: "1",
          textStyle: "sm"
        },
        trigger: {
          textStyle: "sm",
          gap: "1"
        },
        indicator: {
          _icon: {
            width: "4",
            height: "4"
          }
        },
        item: {
          py: "1",
          px: "1.5"
        },
        itemGroup: {
          mt: "1"
        },
        itemGroupLabel: {
          py: "1",
          px: "1.5"
        }
      },
      md: {
        root: {
          "--select-trigger-height": "sizes.10",
          "--select-trigger-padding-x": "spacing.3"
        },
        content: {
          p: "1",
          textStyle: "sm"
        },
        itemGroup: {
          mt: "1.5"
        },
        item: {
          py: "1.5",
          px: "2"
        },
        itemIndicator: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center"
        },
        itemGroupLabel: {
          py: "1.5",
          px: "2"
        },
        trigger: {
          textStyle: "sm",
          gap: "2"
        },
        indicator: {
          _icon: {
            width: "4",
            height: "4"
          }
        }
      },
      lg: {
        root: {
          "--select-trigger-height": "sizes.12",
          "--select-trigger-padding-x": "spacing.4"
        },
        content: {
          p: "1.5",
          textStyle: "md"
        },
        itemGroup: {
          mt: "2"
        },
        item: {
          py: "2",
          px: "3"
        },
        itemGroupLabel: {
          py: "2",
          px: "3"
        },
        trigger: {
          textStyle: "md",
          py: "3",
          gap: "2"
        },
        indicator: {
          _icon: {
            width: "5",
            height: "5"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/native-select.js
var _a3, _b3;
var nativeSelectSlotRecipe = defineSlotRecipe({
  className: "chakra-native-select",
  slots: nativeSelectAnatomy.keys(),
  base: {
    root: {
      height: "fit-content",
      display: "flex",
      width: "100%",
      position: "relative"
    },
    field: {
      width: "100%",
      minWidth: "0",
      outline: "0",
      appearance: "none",
      borderRadius: "l2",
      _disabled: {
        layerStyle: "disabled"
      },
      _invalid: {
        borderColor: "border.error"
      },
      focusVisibleRing: "inside",
      lineHeight: "normal",
      "& > option, & > optgroup": {
        bg: "inherit"
      }
    },
    indicator: {
      position: "absolute",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      pointerEvents: "none",
      top: "50%",
      transform: "translateY(-50%)",
      height: "100%",
      color: "fg.muted",
      _disabled: {
        opacity: "0.5"
      },
      _invalid: {
        color: "fg.error"
      },
      _icon: {
        width: "1em",
        height: "1em"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        field: (_a3 = selectSlotRecipe.variants) == null ? void 0 : _a3.variant.outline.trigger
      },
      subtle: {
        field: (_b3 = selectSlotRecipe.variants) == null ? void 0 : _b3.variant.subtle.trigger
      },
      plain: {
        field: {
          bg: "transparent",
          color: "fg",
          focusRingWidth: "2px"
        }
      }
    },
    size: {
      xs: {
        field: {
          textStyle: "xs",
          ps: "2",
          pe: "6",
          height: "6"
        },
        indicator: {
          textStyle: "sm",
          insetEnd: "1.5"
        }
      },
      sm: {
        field: {
          textStyle: "sm",
          ps: "2.5",
          pe: "8",
          height: "8"
        },
        indicator: {
          textStyle: "md",
          insetEnd: "2"
        }
      },
      md: {
        field: {
          textStyle: "sm",
          ps: "3",
          pe: "8",
          height: "10"
        },
        indicator: {
          textStyle: "lg",
          insetEnd: "2"
        }
      },
      lg: {
        field: {
          textStyle: "md",
          ps: "4",
          pe: "8",
          height: "11"
        },
        indicator: {
          textStyle: "xl",
          insetEnd: "3"
        }
      },
      xl: {
        field: {
          textStyle: "md",
          ps: "4.5",
          pe: "10",
          height: "12"
        },
        indicator: {
          textStyle: "xl",
          insetEnd: "3"
        }
      }
    }
  },
  defaultVariants: selectSlotRecipe.defaultVariants
});

// node_modules/@chakra-ui/react/dist/esm/utils/entries.js
function mapEntries2(obj, f) {
  const result = {};
  for (const key in obj) {
    const kv = f(key, obj[key]);
    result[kv[0]] = kv[1];
  }
  return result;
}

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/number-input.js
var triggerStyle = defineStyle({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  flex: "1",
  userSelect: "none",
  cursor: "button",
  lineHeight: "1",
  color: "fg.muted",
  "--stepper-base-radius": "radii.xs",
  "--stepper-radius": "calc(var(--stepper-base-radius) + 1px)",
  _icon: {
    boxSize: "1em"
  },
  _disabled: {
    opacity: "0.5"
  },
  _hover: {
    bg: "bg.muted"
  },
  _active: {
    bg: "bg.emphasized"
  }
});
var numberInputSlotRecipe = defineSlotRecipe({
  className: "chakra-number-input",
  slots: numberInputAnatomy.keys(),
  base: {
    root: {
      position: "relative",
      zIndex: "0",
      isolation: "isolate"
    },
    input: {
      ...inputRecipe.base,
      verticalAlign: "top",
      pe: "calc(var(--stepper-width) + 0.5rem)"
    },
    control: {
      display: "flex",
      flexDirection: "column",
      position: "absolute",
      top: "0",
      insetEnd: "0px",
      margin: "1px",
      width: "var(--stepper-width)",
      height: "calc(100% - 2px)",
      zIndex: "1",
      borderStartWidth: "1px",
      divideY: "1px"
    },
    incrementTrigger: {
      ...triggerStyle,
      borderTopEndRadius: "var(--stepper-radius)"
    },
    decrementTrigger: {
      ...triggerStyle,
      borderBottomEndRadius: "var(--stepper-radius)"
    },
    valueText: {
      fontWeight: "medium",
      fontFeatureSettings: "pnum",
      fontVariantNumeric: "proportional-nums"
    }
  },
  variants: {
    size: {
      xs: {
        input: inputRecipe.variants.size.xs,
        control: {
          fontSize: "2xs",
          "--stepper-width": "sizes.4"
        }
      },
      sm: {
        input: inputRecipe.variants.size.sm,
        control: {
          fontSize: "xs",
          "--stepper-width": "sizes.5"
        }
      },
      md: {
        input: inputRecipe.variants.size.md,
        control: {
          fontSize: "sm",
          "--stepper-width": "sizes.6"
        }
      },
      lg: {
        input: inputRecipe.variants.size.lg,
        control: {
          fontSize: "sm",
          "--stepper-width": "sizes.6"
        }
      }
    },
    variant: mapEntries2(inputRecipe.variants.variant, (key, variantStyles) => [
      key,
      { input: variantStyles }
    ])
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/pin-input.js
var { variants: variants2, defaultVariants: defaultVariants2 } = inputRecipe;
var pinInputSlotRecipe = defineSlotRecipe({
  className: "chakra-pin-input",
  slots: pinInputAnatomy.keys(),
  base: {
    input: {
      ...inputRecipe.base,
      textAlign: "center",
      width: "var(--input-height)"
    }
  },
  variants: {
    size: mapEntries2(variants2.size, (key, value) => [key, { input: value }]),
    variant: mapEntries2(variants2.variant, (key, value) => [
      key,
      { input: value }
    ])
  },
  defaultVariants: defaultVariants2
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/popover.js
var popoverSlotRecipe = defineSlotRecipe({
  className: "chakra-popover",
  slots: popoverAnatomy.keys(),
  base: {
    content: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      textStyle: "sm",
      "--popover-bg": "colors.bg.panel",
      bg: "var(--popover-bg)",
      boxShadow: "lg",
      "--popover-size": "sizes.xs",
      "--popover-mobile-size": "calc(100dvw - 1rem)",
      width: {
        base: "min(var(--popover-mobile-size), var(--popover-size))",
        sm: "var(--popover-size)"
      },
      borderRadius: "l3",
      "--popover-z-index": "zIndex.popover",
      zIndex: "calc(var(--popover-z-index) + var(--layer-index, 0))",
      outline: "0",
      transformOrigin: "var(--transform-origin)",
      _open: {
        animationStyle: "scale-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "scale-fade-out",
        animationDuration: "faster"
      }
    },
    header: {
      paddingInline: "var(--popover-padding)",
      paddingTop: "var(--popover-padding)"
    },
    body: {
      padding: "var(--popover-padding)",
      flex: "1"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      paddingInline: "var(--popover-padding)",
      paddingBottom: "var(--popover-padding)"
    },
    arrow: {
      "--arrow-size": "sizes.3",
      "--arrow-background": "var(--popover-bg)"
    },
    arrowTip: {
      borderTopWidth: "1px",
      borderInlineStartWidth: "1px"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          "--popover-padding": "spacing.3"
        }
      },
      sm: {
        content: {
          "--popover-padding": "spacing.4"
        }
      },
      md: {
        content: {
          "--popover-padding": "spacing.5"
        }
      },
      lg: {
        content: {
          "--popover-padding": "spacing.6"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/progress.js
var progressSlotRecipe = defineSlotRecipe({
  slots: progressAnatomy.keys(),
  className: "chakra-progress",
  base: {
    root: {
      textStyle: "sm",
      position: "relative"
    },
    track: {
      overflow: "hidden",
      position: "relative"
    },
    range: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transitionProperty: "width, height",
      transitionDuration: "slow",
      height: "100%",
      bgColor: "var(--track-color)",
      _indeterminate: {
        "--animate-from-x": "-40%",
        "--animate-to-x": "100%",
        position: "absolute",
        willChange: "left",
        minWidth: "50%",
        animation: "position 1s ease infinite normal none running",
        backgroundImage: `linear-gradient(to right, transparent 0%, var(--track-color) 50%, transparent 100%)`
      }
    },
    label: {
      display: "inline-flex",
      fontWeight: "medium"
    },
    valueText: {
      textStyle: "xs",
      lineHeight: "1",
      fontWeight: "medium"
    }
  },
  variants: {
    variant: {
      outline: {
        track: {
          shadow: "inset",
          bgColor: "bg.muted"
        },
        range: {
          bgColor: "colorPalette.solid"
        }
      },
      subtle: {
        track: {
          bgColor: "colorPalette.muted"
        },
        range: {
          bgColor: "colorPalette.solid/72"
        }
      }
    },
    shape: {
      square: {},
      rounded: {
        track: {
          borderRadius: "l1"
        }
      },
      full: {
        track: {
          borderRadius: "full"
        }
      }
    },
    striped: {
      true: {
        range: {
          backgroundImage: `linear-gradient(45deg, var(--stripe-color) 25%, transparent 25%, transparent 50%, var(--stripe-color) 50%, var(--stripe-color) 75%, transparent 75%, transparent)`,
          backgroundSize: `var(--stripe-size) var(--stripe-size)`,
          "--stripe-size": "1rem",
          "--stripe-color": {
            _light: "rgba(255, 255, 255, 0.3)",
            _dark: "rgba(0, 0, 0, 0.3)"
          }
        }
      }
    },
    animated: {
      true: {
        range: {
          "--animate-from": "var(--stripe-size)",
          animation: "bg-position 1s linear infinite"
        }
      }
    },
    size: {
      xs: {
        track: { h: "1.5" }
      },
      sm: {
        track: { h: "2" }
      },
      md: {
        track: { h: "2.5" }
      },
      lg: {
        track: { h: "3" }
      },
      xl: {
        track: { h: "4" }
      }
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md",
    shape: "rounded"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/progress-circle.js
var progressCircleSlotRecipe = defineSlotRecipe({
  className: "chakra-progress-circle",
  slots: progressAnatomy.keys(),
  base: {
    root: {
      display: "inline-flex",
      textStyle: "sm",
      position: "relative"
    },
    circle: {
      _indeterminate: {
        animation: "spin 2s linear infinite"
      }
    },
    circleTrack: {
      "--track-color": "colors.colorPalette.muted",
      stroke: "var(--track-color)"
    },
    circleRange: {
      stroke: "colorPalette.solid",
      transitionProperty: "stroke-dasharray",
      transitionDuration: "0.6s",
      _indeterminate: {
        animation: "circular-progress 1.5s linear infinite"
      }
    },
    label: {
      display: "inline-flex"
    },
    valueText: {
      lineHeight: "1",
      fontWeight: "medium",
      letterSpacing: "tight",
      fontVariantNumeric: "tabular-nums"
    }
  },
  variants: {
    size: {
      xs: {
        circle: {
          "--size": "24px",
          "--thickness": "4px"
        },
        valueText: {
          textStyle: "2xs"
        }
      },
      sm: {
        circle: {
          "--size": "32px",
          "--thickness": "5px"
        },
        valueText: {
          textStyle: "2xs"
        }
      },
      md: {
        circle: {
          "--size": "40px",
          "--thickness": "6px"
        },
        valueText: {
          textStyle: "xs"
        }
      },
      lg: {
        circle: {
          "--size": "48px",
          "--thickness": "7px"
        },
        valueText: {
          textStyle: "sm"
        }
      },
      xl: {
        circle: {
          "--size": "64px",
          "--thickness": "8px"
        },
        valueText: {
          textStyle: "sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/radio-card.js
var _a4, _b4, _c3, _d3, _e4, _f3, _g3;
var radioCardSlotRecipe = defineSlotRecipe({
  className: "chakra-radio-card",
  slots: radioCardAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5",
      isolation: "isolate"
    },
    item: {
      flex: "1",
      display: "flex",
      flexDirection: "column",
      userSelect: "none",
      position: "relative",
      borderRadius: "l2",
      _focus: {
        bg: "colorPalette.muted/20"
      },
      _disabled: {
        opacity: "0.8",
        borderColor: "border.disabled"
      },
      _checked: {
        zIndex: "1"
      }
    },
    label: {
      display: "inline-flex",
      fontWeight: "medium",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    },
    itemText: {
      fontWeight: "medium"
    },
    itemDescription: {
      opacity: "0.64",
      textStyle: "sm"
    },
    itemControl: {
      display: "inline-flex",
      flex: "1",
      pos: "relative",
      rounded: "inherit",
      justifyContent: "var(--radio-card-justify)",
      alignItems: "var(--radio-card-align)",
      _disabled: {
        bg: "bg.muted"
      }
    },
    itemIndicator: radiomarkRecipe.base,
    itemAddon: {
      roundedBottom: "inherit",
      _disabled: {
        color: "fg.muted"
      }
    },
    itemContent: {
      display: "flex",
      flexDirection: "column",
      flex: "1",
      gap: "1",
      justifyContent: "var(--radio-card-justify)",
      alignItems: "var(--radio-card-align)"
    }
  },
  variants: {
    size: {
      sm: {
        item: {
          textStyle: "sm"
        },
        itemControl: {
          padding: "3",
          gap: "1.5"
        },
        itemAddon: {
          px: "3",
          py: "1.5",
          borderTopWidth: "1px"
        },
        itemIndicator: (_a4 = radiomarkRecipe.variants) == null ? void 0 : _a4.size.sm
      },
      md: {
        item: {
          textStyle: "sm"
        },
        itemControl: {
          padding: "4",
          gap: "2.5"
        },
        itemAddon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        itemIndicator: (_b4 = radiomarkRecipe.variants) == null ? void 0 : _b4.size.md
      },
      lg: {
        item: {
          textStyle: "md"
        },
        itemControl: {
          padding: "4",
          gap: "3.5"
        },
        itemAddon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        itemIndicator: (_c3 = radiomarkRecipe.variants) == null ? void 0 : _c3.size.lg
      }
    },
    variant: {
      surface: {
        item: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg",
            borderColor: "colorPalette.muted"
          }
        },
        itemIndicator: (_d3 = radiomarkRecipe.variants) == null ? void 0 : _d3.variant.solid
      },
      subtle: {
        item: {
          bg: "bg.muted"
        },
        itemControl: {
          _checked: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          }
        },
        itemIndicator: (_e4 = radiomarkRecipe.variants) == null ? void 0 : _e4.variant.outline
      },
      outline: {
        item: {
          borderWidth: "1px",
          _checked: {
            boxShadow: "0 0 0 1px var(--shadow-color)",
            boxShadowColor: "colorPalette.solid",
            borderColor: "colorPalette.solid"
          }
        },
        itemIndicator: (_f3 = radiomarkRecipe.variants) == null ? void 0 : _f3.variant.solid
      },
      solid: {
        item: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        itemIndicator: (_g3 = radiomarkRecipe.variants) == null ? void 0 : _g3.variant.inverted
      }
    },
    justify: {
      start: {
        item: { "--radio-card-justify": "flex-start" }
      },
      end: {
        item: { "--radio-card-justify": "flex-end" }
      },
      center: {
        item: { "--radio-card-justify": "center" }
      }
    },
    align: {
      start: {
        item: { "--radio-card-align": "flex-start" },
        itemControl: { textAlign: "start" }
      },
      end: {
        item: { "--radio-card-align": "flex-end" },
        itemControl: { textAlign: "end" }
      },
      center: {
        item: { "--radio-card-align": "center" },
        itemControl: { textAlign: "center" }
      }
    },
    orientation: {
      vertical: {
        itemControl: { flexDirection: "column" }
      },
      horizontal: {
        itemControl: { flexDirection: "row" }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    align: "start",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/radio-group.js
var _a5, _b5, _c4, _d4, _e5, _f4, _g4, _h2, _i2, _j2, _k2, _l2, _m2, _n2;
var radioGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-radio-group",
  slots: radioGroupAnatomy.keys(),
  base: {
    item: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      fontWeight: "medium",
      _disabled: {
        cursor: "disabled"
      }
    },
    itemControl: radiomarkRecipe.base,
    label: {
      userSelect: "none",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        itemControl: (_b5 = (_a5 = radiomarkRecipe.variants) == null ? void 0 : _a5.variant) == null ? void 0 : _b5.outline
      },
      subtle: {
        itemControl: (_d4 = (_c4 = radiomarkRecipe.variants) == null ? void 0 : _c4.variant) == null ? void 0 : _d4.subtle
      },
      solid: {
        itemControl: (_f4 = (_e5 = radiomarkRecipe.variants) == null ? void 0 : _e5.variant) == null ? void 0 : _f4.solid
      }
    },
    size: {
      xs: {
        item: { textStyle: "xs", gap: "1.5" },
        itemControl: (_h2 = (_g4 = radiomarkRecipe.variants) == null ? void 0 : _g4.size) == null ? void 0 : _h2.xs
      },
      sm: {
        item: { textStyle: "sm", gap: "2" },
        itemControl: (_j2 = (_i2 = radiomarkRecipe.variants) == null ? void 0 : _i2.size) == null ? void 0 : _j2.sm
      },
      md: {
        item: { textStyle: "sm", gap: "2.5" },
        itemControl: (_l2 = (_k2 = radiomarkRecipe.variants) == null ? void 0 : _k2.size) == null ? void 0 : _l2.md
      },
      lg: {
        item: { textStyle: "md", gap: "3" },
        itemControl: (_n2 = (_m2 = radiomarkRecipe.variants) == null ? void 0 : _m2.size) == null ? void 0 : _n2.lg
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/rating-group.js
var ratingGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-rating-group",
  slots: ratingGroupAnatomy.keys(),
  base: {
    root: {
      display: "inline-flex"
    },
    control: {
      display: "inline-flex",
      alignItems: "center"
    },
    item: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none"
    },
    itemIndicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      width: "1em",
      height: "1em",
      position: "relative",
      _icon: {
        stroke: "currentColor",
        width: "100%",
        height: "100%",
        display: "inline-block",
        flexShrink: 0,
        position: "absolute",
        left: 0,
        top: 0
      },
      "& [data-bg]": {
        color: "bg.emphasized"
      },
      "& [data-fg]": {
        color: "transparent"
      },
      "&[data-highlighted]:not([data-half])": {
        "& [data-fg]": {
          color: "colorPalette.solid"
        }
      },
      "&[data-half]": {
        "& [data-fg]": {
          color: "colorPalette.solid",
          clipPath: "inset(0 50% 0 0)"
        }
      }
    }
  },
  variants: {
    size: {
      xs: {
        item: {
          textStyle: "sm"
        }
      },
      sm: {
        item: {
          textStyle: "md"
        }
      },
      md: {
        item: {
          textStyle: "xl"
        }
      },
      lg: {
        item: {
          textStyle: "2xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/segment-group.js
var segmentGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-segment-group",
  slots: segmentGroupAnatomy.keys(),
  base: {
    root: {
      "--segment-radius": "radii.l2",
      borderRadius: "l2",
      display: "inline-flex",
      boxShadow: "inset",
      minW: "max-content",
      textAlign: "center",
      position: "relative",
      isolation: "isolate",
      bg: "bg.muted"
    },
    item: {
      display: "flex",
      alignItems: "center",
      userSelect: "none",
      fontSize: "sm",
      position: "relative",
      color: "fg",
      borderRadius: "var(--segment-radius)",
      _disabled: {
        opacity: "0.5"
      },
      "&:has(input:focus-visible)": {
        focusRing: "outside"
      },
      _before: {
        content: '""',
        position: "absolute",
        insetInlineStart: 0,
        insetBlock: "1.5",
        bg: "border",
        width: "1px",
        transition: "opacity 0.2s"
      },
      "& + &[data-state=checked], &[data-state=checked] + &, &:first-of-type": {
        _before: {
          opacity: "0"
        }
      },
      "&[data-state=checked][data-ssr]": {
        shadow: "sm",
        bg: "bg",
        borderRadius: "var(--segment-radius)"
      }
    },
    indicator: {
      shadow: "sm",
      pos: "absolute",
      bg: { _light: "bg", _dark: "bg.emphasized" },
      width: "var(--width)",
      height: "var(--height)",
      top: "var(--top)",
      left: "var(--left)",
      zIndex: -1,
      borderRadius: "var(--segment-radius)"
    }
  },
  variants: {
    size: {
      xs: {
        root: {
          height: "6"
        },
        item: {
          textStyle: "xs",
          px: "3",
          gap: "1"
        }
      },
      sm: {
        root: {
          height: "8"
        },
        item: {
          textStyle: "sm",
          px: "4",
          gap: "2"
        }
      },
      md: {
        root: {
          height: "10"
        },
        item: {
          textStyle: "sm",
          px: "4",
          gap: "2"
        }
      },
      lg: {
        root: {
          height: "10"
        },
        item: {
          textStyle: "md",
          px: "5",
          gap: "3"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/slider.js
var sliderSlotRecipe = defineSlotRecipe({
  className: "chakra-slider",
  slots: sliderAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1",
      fontSize: "sm",
      position: "relative",
      isolation: "isolate",
      touchAction: "none"
    },
    control: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative"
    },
    track: {
      overflow: "hidden",
      borderRadius: "full",
      flex: "1"
    },
    range: {
      width: "inherit",
      height: "inherit",
      _disabled: { bg: "border.emphasized!" }
    },
    markerGroup: {
      position: "absolute!",
      top: "var(--slider-marker-top)",
      insetInline: "var(--slider-marker-inset)",
      zIndex: "1"
    },
    marker: {
      "--marker-bg": { base: "white", _underValue: "colors.bg" },
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "1.5",
      color: "fg.muted",
      fontSize: "xs"
    },
    markerIndicator: {
      width: "var(--slider-marker-size)",
      height: "var(--slider-marker-size)",
      borderRadius: "full",
      bg: "var(--marker-bg)"
    },
    thumb: {
      width: "var(--slider-thumb-size)",
      height: "var(--slider-thumb-size)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: 0,
      zIndex: "2",
      borderRadius: "full",
      _focusVisible: {
        ring: "2px",
        ringColor: "colorPalette.focusRing",
        ringOffset: "2px",
        ringOffsetColor: "bg"
      }
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          "--slider-thumb-size": "sizes.4",
          "--slider-track-size": "sizes.1.5",
          "--slider-marker-top": "6px",
          "--slider-marker-size": "sizes.1",
          "--slider-marker-inset": "3px"
        }
      },
      md: {
        root: {
          "--slider-thumb-size": "sizes.5",
          "--slider-track-size": "sizes.2",
          "--slider-marker-top": "8px",
          "--slider-marker-size": "sizes.1",
          "--slider-marker-inset": "4px"
        }
      },
      lg: {
        root: {
          "--slider-thumb-size": "sizes.6",
          "--slider-track-size": "sizes.2.5",
          "--slider-marker-top": "9px",
          "--slider-marker-size": "sizes.1.5",
          "--slider-marker-inset": "5px"
        }
      }
    },
    variant: {
      outline: {
        track: {
          shadow: "inset",
          bg: "bg.emphasized/72"
        },
        range: {
          bg: "colorPalette.solid"
        },
        thumb: {
          borderWidth: "2px",
          borderColor: "colorPalette.solid",
          bg: "bg",
          _disabled: {
            bg: "border.emphasized",
            borderColor: "border.emphasized"
          }
        }
      },
      solid: {
        track: {
          bg: "colorPalette.subtle",
          _disabled: {
            bg: "bg.muted"
          }
        },
        range: {
          bg: "colorPalette.solid"
        },
        thumb: {
          bg: "colorPalette.solid",
          _disabled: {
            bg: "border.emphasized"
          }
        }
      }
    },
    orientation: {
      vertical: {
        root: {
          display: "inline-flex"
        },
        control: {
          flexDirection: "column",
          height: "100%",
          minWidth: "var(--slider-thumb-size)"
        },
        track: {
          width: "var(--slider-track-size)"
        },
        thumb: {
          left: "50%",
          translate: "-50% 0"
        }
      },
      horizontal: {
        control: {
          flexDirection: "row",
          width: "100%",
          minHeight: "var(--slider-thumb-size)"
        },
        track: {
          height: "var(--slider-track-size)"
        },
        thumb: {
          top: "50%",
          translate: "0 -50%"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/stat.js
var statSlotRecipe = defineSlotRecipe({
  className: "chakra-stat",
  slots: statAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1",
      position: "relative",
      flex: "1"
    },
    label: {
      color: "fg.muted",
      textStyle: "sm"
    },
    helpText: {
      color: "fg.muted",
      textStyle: "xs"
    },
    valueUnit: {
      color: "fg.muted",
      textStyle: "xs",
      fontWeight: "initial",
      letterSpacing: "initial"
    },
    valueText: {
      verticalAlign: "baseline",
      fontWeight: "semibold",
      letterSpacing: "tight",
      fontFeatureSettings: "pnum",
      fontVariantNumeric: "proportional-nums",
      display: "inline-flex",
      gap: "1"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      marginEnd: 1,
      "& :where(svg)": {
        w: "1em",
        h: "1em"
      },
      "&[data-type=up]": {
        color: "fg.success"
      },
      "&[data-type=down]": {
        color: "fg.error"
      }
    }
  },
  variants: {
    size: {
      sm: {
        valueText: {
          textStyle: "xl"
        }
      },
      md: {
        valueText: {
          textStyle: "2xl"
        }
      },
      lg: {
        valueText: {
          textStyle: "3xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/status.js
var statusSlotRecipe = defineSlotRecipe({
  className: "chakra-status",
  slots: statusAnatomy.keys(),
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      gap: "2"
    },
    indicator: {
      width: "0.64em",
      height: "0.64em",
      flexShrink: 0,
      borderRadius: "full",
      forcedColorAdjust: "none",
      bg: "colorPalette.solid"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/steps.js
var stepsSlotRecipe = defineSlotRecipe({
  className: "chakra-steps",
  slots: stepsAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      width: "full"
    },
    list: {
      display: "flex",
      justifyContent: "space-between",
      "--steps-gutter": "spacing.3",
      "--steps-thickness": "2px"
    },
    title: {
      fontWeight: "medium",
      color: "fg"
    },
    description: {
      color: "fg.muted"
    },
    separator: {
      bg: "border",
      flex: "1"
    },
    indicator: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      flexShrink: "0",
      borderRadius: "full",
      fontWeight: "medium",
      width: "var(--steps-size)",
      height: "var(--steps-size)",
      _icon: {
        flexShrink: "0",
        width: "var(--steps-icon-size)",
        height: "var(--steps-icon-size)"
      }
    },
    item: {
      position: "relative",
      display: "flex",
      flex: "1 0 0",
      "&:last-of-type": {
        flex: "initial",
        "& [data-part=separator]": {
          display: "none"
        }
      }
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      gap: "3",
      textAlign: "start",
      focusVisibleRing: "outside",
      borderRadius: "l2"
    },
    content: {
      focusVisibleRing: "outside"
    }
  },
  variants: {
    orientation: {
      vertical: {
        root: {
          flexDirection: "row",
          height: "100%"
        },
        list: {
          flexDirection: "column",
          alignItems: "flex-start"
        },
        separator: {
          position: "absolute",
          width: "var(--steps-thickness)",
          height: "100%",
          maxHeight: "calc(100% - var(--steps-size) - var(--steps-gutter) * 2)",
          top: "calc(var(--steps-size) + var(--steps-gutter))",
          insetStart: "calc(var(--steps-size) / 2 - 1px)"
        },
        item: {
          alignItems: "flex-start"
        }
      },
      horizontal: {
        root: {
          flexDirection: "column",
          width: "100%"
        },
        list: {
          flexDirection: "row",
          alignItems: "center"
        },
        separator: {
          width: "100%",
          height: "var(--steps-thickness)",
          marginX: "var(--steps-gutter)"
        },
        item: {
          alignItems: "center"
        }
      }
    },
    variant: {
      solid: {
        indicator: {
          _incomplete: {
            borderWidth: "var(--steps-thickness)"
          },
          _current: {
            bg: "colorPalette.muted",
            borderWidth: "var(--steps-thickness)",
            borderColor: "colorPalette.solid",
            color: "colorPalette.fg"
          },
          _complete: {
            bg: "colorPalette.solid",
            borderColor: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        },
        separator: {
          _complete: {
            bg: "colorPalette.solid"
          }
        }
      },
      subtle: {
        indicator: {
          _incomplete: {
            bg: "bg.muted"
          },
          _current: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          },
          _complete: {
            bg: "colorPalette.emphasized",
            color: "colorPalette.fg"
          }
        },
        separator: {
          _complete: {
            bg: "colorPalette.emphasized"
          }
        }
      }
    },
    size: {
      xs: {
        root: {
          gap: "2.5"
        },
        list: {
          "--steps-size": "sizes.6",
          "--steps-icon-size": "sizes.3.5",
          textStyle: "xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      sm: {
        root: {
          gap: "3"
        },
        list: {
          "--steps-size": "sizes.8",
          "--steps-icon-size": "sizes.4",
          textStyle: "xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      md: {
        root: {
          gap: "4"
        },
        list: {
          "--steps-size": "sizes.10",
          "--steps-icon-size": "sizes.4",
          textStyle: "sm"
        },
        title: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          gap: "6"
        },
        list: {
          "--steps-size": "sizes.11",
          "--steps-icon-size": "sizes.5",
          textStyle: "md"
        },
        title: {
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/switch.js
var switchSlotRecipe = defineSlotRecipe({
  slots: switchAnatomy.keys(),
  className: "chakra-switch",
  base: {
    root: {
      display: "inline-flex",
      gap: "2.5",
      alignItems: "center",
      position: "relative",
      verticalAlign: "middle",
      "--switch-diff": "calc(var(--switch-width) - var(--switch-height))",
      "--switch-x": {
        base: "var(--switch-diff)",
        _rtl: "calc(var(--switch-diff) * -1)"
      }
    },
    label: {
      lineHeight: "1",
      userSelect: "none",
      fontSize: "sm",
      fontWeight: "medium",
      _disabled: {
        opacity: "0.5"
      }
    },
    indicator: {
      position: "absolute",
      height: "var(--switch-height)",
      width: "var(--switch-height)",
      fontSize: "var(--switch-indicator-font-size)",
      fontWeight: "medium",
      flexShrink: 0,
      userSelect: "none",
      display: "grid",
      placeContent: "center",
      transition: "inset-inline-start 0.12s ease",
      insetInlineStart: "calc(var(--switch-x) - 2px)",
      _checked: {
        insetInlineStart: "2px"
      }
    },
    control: {
      display: "inline-flex",
      gap: "0.5rem",
      flexShrink: 0,
      justifyContent: "flex-start",
      cursor: "switch",
      borderRadius: "full",
      position: "relative",
      width: "var(--switch-width)",
      height: "var(--switch-height)",
      _disabled: {
        opacity: "0.5",
        cursor: "not-allowed"
      },
      _invalid: {
        outline: "2px solid",
        outlineColor: "border.error",
        outlineOffset: "2px"
      }
    },
    thumb: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0,
      transitionProperty: "translate",
      transitionDuration: "fast",
      borderRadius: "inherit",
      _checked: {
        translate: "var(--switch-x) 0"
      }
    }
  },
  variants: {
    variant: {
      solid: {
        control: {
          borderRadius: "full",
          bg: "bg.emphasized",
          focusVisibleRing: "outside",
          _checked: {
            bg: "colorPalette.solid"
          }
        },
        thumb: {
          bg: "white",
          width: "var(--switch-height)",
          height: "var(--switch-height)",
          scale: "0.8",
          boxShadow: "sm",
          _checked: {
            bg: "colorPalette.contrast"
          }
        }
      },
      raised: {
        control: {
          borderRadius: "full",
          height: "calc(var(--switch-height) / 2)",
          bg: "bg.muted",
          boxShadow: "inset",
          _checked: {
            bg: "colorPalette.solid/60"
          }
        },
        thumb: {
          width: "var(--switch-height)",
          height: "var(--switch-height)",
          position: "relative",
          top: "calc(var(--switch-height) * -0.25)",
          bg: "white",
          boxShadow: "xs",
          focusVisibleRing: "outside",
          _checked: {
            bg: "colorPalette.solid"
          }
        }
      }
    },
    size: {
      xs: {
        root: {
          "--switch-width": "sizes.6",
          "--switch-height": "sizes.3",
          "--switch-indicator-font-size": "fontSizes.xs"
        }
      },
      sm: {
        root: {
          "--switch-width": "sizes.8",
          "--switch-height": "sizes.4",
          "--switch-indicator-font-size": "fontSizes.xs"
        }
      },
      md: {
        root: {
          "--switch-width": "sizes.10",
          "--switch-height": "sizes.5",
          "--switch-indicator-font-size": "fontSizes.sm"
        }
      },
      lg: {
        root: {
          "--switch-width": "sizes.12",
          "--switch-height": "sizes.6",
          "--switch-indicator-font-size": "fontSizes.md"
        }
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/table.js
var tableSlotRecipe = defineSlotRecipe({
  className: "chakra-table",
  slots: tableAnatomy.keys(),
  base: {
    root: {
      fontVariantNumeric: "lining-nums tabular-nums",
      borderCollapse: "collapse",
      width: "full",
      textAlign: "start",
      verticalAlign: "top"
    },
    row: {
      _selected: {
        bg: "colorPalette.subtle"
      }
    },
    cell: {
      textAlign: "start",
      alignItems: "center"
    },
    columnHeader: {
      fontWeight: "medium",
      textAlign: "start",
      color: "fg"
    },
    caption: {
      fontWeight: "medium",
      textStyle: "xs"
    },
    footer: {
      fontWeight: "medium"
    }
  },
  variants: {
    interactive: {
      true: {
        body: {
          "& tr": {
            _hover: {
              bg: "colorPalette.subtle"
            }
          }
        }
      }
    },
    stickyHeader: {
      true: {
        header: {
          "& :where(tr)": {
            top: "var(--table-sticky-offset, 0)",
            position: "sticky",
            zIndex: 1
          }
        }
      }
    },
    striped: {
      true: {
        row: {
          "&:nth-of-type(odd) td": {
            bg: "bg.muted"
          }
        }
      }
    },
    showColumnBorder: {
      true: {
        columnHeader: {
          "&:not(:last-of-type)": {
            borderInlineEndWidth: "1px"
          }
        },
        cell: {
          "&:not(:last-of-type)": {
            borderInlineEndWidth: "1px"
          }
        }
      }
    },
    variant: {
      line: {
        columnHeader: {
          borderBottomWidth: "1px"
        },
        cell: {
          borderBottomWidth: "1px"
        },
        row: {
          bg: "bg"
        }
      },
      outline: {
        root: {
          boxShadow: "0 0 0 1px {colors.border}",
          overflow: "hidden"
        },
        columnHeader: {
          borderBottomWidth: "1px"
        },
        header: {
          bg: "bg.muted"
        },
        row: {
          "&:not(:last-of-type)": {
            borderBottomWidth: "1px"
          }
        },
        footer: {
          borderTopWidth: "1px"
        }
      }
    },
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        columnHeader: {
          px: "2",
          py: "2"
        },
        cell: {
          px: "2",
          py: "2"
        }
      },
      md: {
        root: {
          textStyle: "sm"
        },
        columnHeader: {
          px: "3",
          py: "3"
        },
        cell: {
          px: "3",
          py: "3"
        }
      },
      lg: {
        root: {
          textStyle: "md"
        },
        columnHeader: {
          px: "4",
          py: "3"
        },
        cell: {
          px: "4",
          py: "3"
        }
      }
    }
  },
  defaultVariants: {
    variant: "line",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/tabs.js
var tabsSlotRecipe = defineSlotRecipe({
  slots: tabsAnatomy.keys(),
  className: "chakra-tabs",
  base: {
    root: {
      "--tabs-trigger-radius": "radii.l2",
      position: "relative",
      _horizontal: {
        display: "block"
      },
      _vertical: {
        display: "flex"
      }
    },
    list: {
      display: "inline-flex",
      position: "relative",
      isolation: "isolate",
      "--tabs-indicator-shadow": "shadows.xs",
      "--tabs-indicator-bg": "colors.bg",
      minH: "var(--tabs-height)",
      _horizontal: {
        flexDirection: "row"
      },
      _vertical: {
        flexDirection: "column"
      }
    },
    trigger: {
      outline: "0",
      minW: "var(--tabs-height)",
      height: "var(--tabs-height)",
      display: "flex",
      alignItems: "center",
      fontWeight: "medium",
      position: "relative",
      cursor: "button",
      gap: "2",
      _focusVisible: {
        zIndex: 1,
        outline: "2px solid",
        outlineColor: "colorPalette.focusRing"
      },
      _disabled: {
        cursor: "not-allowed",
        opacity: 0.5
      }
    },
    content: {
      focusVisibleRing: "inside",
      _horizontal: {
        width: "100%",
        pt: "var(--tabs-content-padding)"
      },
      _vertical: {
        height: "100%",
        ps: "var(--tabs-content-padding)"
      }
    },
    indicator: {
      width: "var(--width)",
      height: "var(--height)",
      borderRadius: "var(--tabs-indicator-radius)",
      bg: "var(--tabs-indicator-bg)",
      shadow: "var(--tabs-indicator-shadow)",
      zIndex: -1
    }
  },
  variants: {
    fitted: {
      true: {
        list: {
          display: "flex"
        },
        trigger: {
          flex: 1,
          textAlign: "center",
          justifyContent: "center"
        }
      }
    },
    justify: {
      start: {
        list: {
          justifyContent: "flex-start"
        }
      },
      center: {
        list: {
          justifyContent: "center"
        }
      },
      end: {
        list: {
          justifyContent: "flex-end"
        }
      }
    },
    size: {
      sm: {
        root: {
          "--tabs-height": "sizes.9",
          "--tabs-content-padding": "spacing.3"
        },
        trigger: {
          py: "1",
          px: "3",
          textStyle: "sm"
        }
      },
      md: {
        root: {
          "--tabs-height": "sizes.10",
          "--tabs-content-padding": "spacing.4"
        },
        trigger: {
          py: "2",
          px: "4",
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          "--tabs-height": "sizes.11",
          "--tabs-content-padding": "spacing.4.5"
        },
        trigger: {
          py: "2",
          px: "4.5",
          textStyle: "md"
        }
      }
    },
    variant: {
      line: {
        list: {
          display: "flex",
          borderColor: "border",
          _horizontal: {
            borderBottomWidth: "1px"
          },
          _vertical: {
            borderEndWidth: "1px"
          }
        },
        trigger: {
          color: "fg.muted",
          _disabled: {
            _active: { bg: "initial" }
          },
          _selected: {
            color: "fg",
            _horizontal: {
              layerStyle: "indicator.bottom",
              "--indicator-offset-y": "-1px",
              "--indicator-color": "colors.colorPalette.solid"
            },
            _vertical: {
              layerStyle: "indicator.end",
              "--indicator-offset-x": "-1px"
            }
          }
        }
      },
      subtle: {
        trigger: {
          borderRadius: "var(--tabs-trigger-radius)",
          color: "fg.muted",
          _selected: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg"
          }
        }
      },
      enclosed: {
        list: {
          bg: "bg.muted",
          padding: "1",
          borderRadius: "l3",
          minH: "calc(var(--tabs-height) - 4px)"
        },
        trigger: {
          justifyContent: "center",
          color: "fg.muted",
          borderRadius: "var(--tabs-trigger-radius)",
          _selected: {
            bg: "bg",
            color: "colorPalette.fg",
            shadow: "xs"
          }
        }
      },
      outline: {
        list: {
          "--line-thickness": "1px",
          "--line-offset": "calc(var(--line-thickness) * -1)",
          borderColor: "border",
          display: "flex",
          _horizontal: {
            _before: {
              content: '""',
              position: "absolute",
              bottom: "0px",
              width: "100%",
              borderBottomWidth: "var(--line-thickness)",
              borderBottomColor: "border"
            }
          },
          _vertical: {
            _before: {
              content: '""',
              position: "absolute",
              insetInline: "var(--line-offset)",
              height: "calc(100% - calc(var(--line-thickness) * 2))",
              borderEndWidth: "var(--line-thickness)",
              borderEndColor: "border"
            }
          }
        },
        trigger: {
          color: "fg.muted",
          borderWidth: "1px",
          borderColor: "transparent",
          _selected: {
            bg: "currentBg",
            color: "colorPalette.fg"
          },
          _horizontal: {
            borderTopRadius: "var(--tabs-trigger-radius)",
            marginBottom: "var(--line-offset)",
            marginEnd: { _notLast: "var(--line-offset)" },
            _selected: {
              borderColor: "border",
              borderBottomColor: "transparent"
            }
          },
          _vertical: {
            borderStartRadius: "var(--tabs-trigger-radius)",
            marginEnd: "var(--line-offset)",
            marginBottom: { _notLast: "var(--line-offset)" },
            _selected: {
              borderColor: "border",
              borderEndColor: "transparent"
            }
          }
        }
      },
      plain: {
        trigger: {
          color: "fg.muted",
          _selected: {
            color: "colorPalette.fg"
          },
          borderRadius: "var(--tabs-trigger-radius)",
          "&[data-selected][data-ssr]": {
            bg: "var(--tabs-indicator-bg)",
            shadow: "var(--tabs-indicator-shadow)",
            borderRadius: "var(--tabs-indicator-radius)"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "line"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/tag.js
var _a6;
var badgeVariant = (_a6 = badgeRecipe.variants) == null ? void 0 : _a6.variant;
var tagSlotRecipe = defineSlotRecipe({
  slots: tagAnatomy.keys(),
  className: "chakra-tag",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      verticalAlign: "top",
      maxWidth: "100%",
      userSelect: "none",
      borderRadius: "l2",
      focusVisibleRing: "outside"
    },
    label: {
      lineClamp: "1"
    },
    closeTrigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: "0",
      borderRadius: "l1",
      color: "currentColor",
      focusVisibleRing: "inside",
      focusRingWidth: "2px"
    },
    startElement: {
      flexShrink: 0,
      boxSize: "var(--tag-element-size)",
      ms: "var(--tag-element-offset)",
      "&:has([data-scope=avatar])": {
        boxSize: "var(--tag-avatar-size)",
        ms: "calc(var(--tag-element-offset) * 1.5)"
      },
      _icon: { boxSize: "100%" }
    },
    endElement: {
      flexShrink: 0,
      boxSize: "var(--tag-element-size)",
      me: "var(--tag-element-offset)",
      _icon: { boxSize: "100%" },
      "&:has(button)": {
        ms: "calc(var(--tag-element-offset) * -1)"
      }
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          px: "1.5",
          minH: "4.5",
          gap: "1",
          "--tag-avatar-size": "spacing.3",
          "--tag-element-size": "spacing.3",
          "--tag-element-offset": "-2px"
        },
        label: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          px: "1.5",
          minH: "5",
          gap: "1",
          "--tag-avatar-size": "spacing.3.5",
          "--tag-element-size": "spacing.3.5",
          "--tag-element-offset": "-2px"
        },
        label: {
          textStyle: "xs"
        }
      },
      lg: {
        root: {
          px: "2",
          minH: "6",
          gap: "1.5",
          "--tag-avatar-size": "spacing.4.5",
          "--tag-element-size": "spacing.4",
          "--tag-element-offset": "-3px"
        },
        label: {
          textStyle: "sm"
        }
      },
      xl: {
        root: {
          px: "2.5",
          minH: "8",
          gap: "1.5",
          "--tag-avatar-size": "spacing.6",
          "--tag-element-size": "spacing.4.5",
          "--tag-element-offset": "-4px"
        },
        label: {
          textStyle: "sm"
        }
      }
    },
    variant: {
      subtle: {
        root: badgeVariant == null ? void 0 : badgeVariant.subtle
      },
      solid: {
        root: badgeVariant == null ? void 0 : badgeVariant.solid
      },
      outline: {
        root: badgeVariant == null ? void 0 : badgeVariant.outline
      },
      surface: {
        root: badgeVariant == null ? void 0 : badgeVariant.surface
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "surface"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/timeline.js
var timelineSlotRecipe = defineSlotRecipe({
  slots: timelineAnatomy.keys(),
  className: "chakra-timeline",
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      width: "full",
      "--timeline-thickness": "1px",
      "--timeline-gutter": "4px"
    },
    item: {
      display: "flex",
      position: "relative",
      alignItems: "flex-start",
      flexShrink: 0,
      gap: "4",
      _last: {
        "& :where(.chakra-timeline__separator)": { display: "none" }
      }
    },
    separator: {
      position: "absolute",
      borderStartWidth: "var(--timeline-thickness)",
      ms: "calc(-1 * var(--timeline-thickness) / 2)",
      insetInlineStart: "calc(var(--timeline-indicator-size) / 2)",
      insetBlock: "0",
      borderColor: "border"
    },
    indicator: {
      outline: "2px solid {colors.bg}",
      position: "relative",
      flexShrink: "0",
      boxSize: "var(--timeline-indicator-size)",
      fontSize: "var(--timeline-font-size)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      borderRadius: "full",
      fontWeight: "medium"
    },
    connector: {
      alignSelf: "stretch",
      position: "relative"
    },
    content: {
      pb: "6",
      display: "flex",
      flexDirection: "column",
      width: "full",
      gap: "2"
    },
    title: {
      display: "flex",
      fontWeight: "medium",
      flexWrap: "wrap",
      gap: "1.5",
      alignItems: "center",
      mt: "var(--timeline-margin)"
    },
    description: {
      color: "fg.muted",
      textStyle: "xs"
    }
  },
  variants: {
    variant: {
      subtle: {
        indicator: {
          bg: "bg.muted"
        }
      },
      solid: {
        indicator: {
          bg: "bg.inverted",
          color: "fg.inverted"
        }
      },
      outline: {
        indicator: {
          bg: "bg",
          borderWidth: "2px"
        }
      },
      plain: {}
    },
    size: {
      sm: {
        root: {
          "--timeline-indicator-size": "sizes.4",
          "--timeline-font-size": "fontSizes.2xs"
        },
        title: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          "--timeline-indicator-size": "sizes.5",
          "--timeline-font-size": "fontSizes.xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          "--timeline-indicator-size": "sizes.6",
          "--timeline-font-size": "fontSizes.xs"
        },
        title: {
          mt: "0.5",
          textStyle: "sm"
        }
      },
      xl: {
        root: {
          "--timeline-indicator-size": "sizes.8",
          "--timeline-font-size": "fontSizes.sm"
        },
        title: {
          mt: "1.5",
          textStyle: "sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/toast.js
var toastSlotRecipe = defineSlotRecipe({
  slots: toastAnatomy.keys(),
  className: "chakra-toast",
  base: {
    root: {
      width: "full",
      display: "flex",
      alignItems: "flex-start",
      position: "relative",
      gap: "3",
      py: "4",
      ps: "4",
      pe: "6",
      borderRadius: "l2",
      translate: "var(--x) var(--y)",
      scale: "var(--scale)",
      zIndex: "var(--z-index)",
      height: "var(--height)",
      opacity: "var(--opacity)",
      willChange: "translate, opacity, scale",
      transition: "translate 400ms, scale 400ms, opacity 400ms, height 400ms, box-shadow 200ms",
      transitionTimingFunction: "cubic-bezier(0.21, 1.02, 0.73, 1)",
      _closed: {
        transition: "translate 400ms, scale 400ms, opacity 200ms",
        transitionTimingFunction: "cubic-bezier(0.06, 0.71, 0.55, 1)"
      },
      bg: "bg.panel",
      color: "fg",
      boxShadow: "xl",
      "--toast-trigger-bg": "colors.bg.muted",
      "&[data-type=warning]": {
        bg: "orange.solid",
        color: "orange.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      },
      "&[data-type=success]": {
        bg: "green.solid",
        color: "green.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      },
      "&[data-type=error]": {
        bg: "red.solid",
        color: "red.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      }
    },
    title: {
      fontWeight: "medium",
      textStyle: "sm",
      marginEnd: "2"
    },
    description: {
      display: "inline",
      textStyle: "sm",
      opacity: "0.8"
    },
    indicator: {
      flexShrink: "0",
      boxSize: "5"
    },
    actionTrigger: {
      textStyle: "sm",
      fontWeight: "medium",
      height: "8",
      px: "3",
      borderRadius: "l2",
      alignSelf: "center",
      borderWidth: "1px",
      borderColor: "var(--toast-border-color, inherit)",
      transition: "background 200ms",
      _hover: {
        bg: "var(--toast-trigger-bg)"
      }
    },
    closeTrigger: {
      position: "absolute",
      top: "1",
      insetEnd: "1",
      padding: "1",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      color: "{currentColor/60}",
      borderRadius: "l2",
      textStyle: "md",
      transition: "background 200ms"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/tooltip.js
var tooltipSlotRecipe = defineSlotRecipe({
  slots: tooltipAnatomy.keys(),
  className: "chakra-tooltip",
  base: {
    content: {
      "--tooltip-bg": "colors.bg.inverted",
      bg: "var(--tooltip-bg)",
      color: "fg.inverted",
      px: "2.5",
      py: "1",
      borderRadius: "l2",
      fontWeight: "medium",
      textStyle: "xs",
      boxShadow: "md",
      maxW: "xs",
      zIndex: "tooltip",
      transformOrigin: "var(--transform-origin)",
      _open: {
        animationStyle: "scale-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "scale-fade-out",
        animationDuration: "fast"
      }
    },
    arrow: {
      "--arrow-size": "sizes.2",
      "--arrow-background": "var(--tooltip-bg)"
    },
    arrowTip: {
      borderTopWidth: "1px",
      borderInlineStartWidth: "1px",
      borderColor: "var(--tooltip-bg)"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/slot-recipes.js
var slotRecipes = {
  accordion: accordionSlotRecipe,
  actionBar: actionBarSlotRecipe,
  alert: alertSlotRecipe,
  avatar: avatarSlotRecipe,
  blockquote: blockquoteSlotRecipe,
  breadcrumb: breadcrumbSlotRecipe,
  card: cardSlotRecipe,
  checkbox: checkboxSlotRecipe,
  checkboxCard: checkboxCardSlotRecipe,
  collapsible: collapsibleSlotRecipe,
  dataList: dataListSlotRecipe,
  dialog: dialogSlotRecipe,
  drawer: drawerSlotRecipe,
  editable: editableSlotRecipe,
  emptyState: emptyStateSlotRecipe,
  field: fieldSlotRecipe,
  fieldset: fieldsetSlotRecipe,
  fileUpload: fileUploadSlotRecipe,
  hoverCard: hoverCardSlotRecipe,
  list: listSlotRecipe,
  menu: menuSlotRecipe,
  nativeSelect: nativeSelectSlotRecipe,
  numberInput: numberInputSlotRecipe,
  pinInput: pinInputSlotRecipe,
  popover: popoverSlotRecipe,
  progress: progressSlotRecipe,
  progressCircle: progressCircleSlotRecipe,
  radioCard: radioCardSlotRecipe,
  radioGroup: radioGroupSlotRecipe,
  ratingGroup: ratingGroupSlotRecipe,
  segmentGroup: segmentGroupSlotRecipe,
  select: selectSlotRecipe,
  slider: sliderSlotRecipe,
  stat: statSlotRecipe,
  steps: stepsSlotRecipe,
  switch: switchSlotRecipe,
  table: tableSlotRecipe,
  tabs: tabsSlotRecipe,
  tag: tagSlotRecipe,
  toast: toastSlotRecipe,
  tooltip: tooltipSlotRecipe,
  status: statusSlotRecipe,
  timeline: timelineSlotRecipe
};

// node_modules/@chakra-ui/react/dist/esm/theme/text-styles.js
var textStyles = defineTextStyles({
  "2xs": { value: { fontSize: "2xs", lineHeight: "0.75rem" } },
  xs: { value: { fontSize: "xs", lineHeight: "1rem" } },
  sm: { value: { fontSize: "sm", lineHeight: "1.25rem" } },
  md: { value: { fontSize: "md", lineHeight: "1.5rem" } },
  lg: { value: { fontSize: "lg", lineHeight: "1.75rem" } },
  xl: { value: { fontSize: "xl", lineHeight: "1.875rem" } },
  "2xl": { value: { fontSize: "2xl", lineHeight: "2rem" } },
  "3xl": { value: { fontSize: "3xl", lineHeight: "2.375rem" } },
  "4xl": {
    value: {
      fontSize: "4xl",
      lineHeight: "2.75rem",
      letterSpacing: "-0.025em"
    }
  },
  "5xl": {
    value: {
      fontSize: "5xl",
      lineHeight: "3.75rem",
      letterSpacing: "-0.025em"
    }
  },
  "6xl": {
    value: { fontSize: "6xl", lineHeight: "4.5rem", letterSpacing: "-0.025em" }
  },
  "7xl": {
    value: {
      fontSize: "7xl",
      lineHeight: "5.75rem",
      letterSpacing: "-0.025em"
    }
  },
  none: {
    value: {}
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/animations.js
var animations = defineTokens.animations({
  spin: { value: "spin 1s linear infinite" },
  ping: { value: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite" },
  pulse: { value: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite" },
  bounce: { value: "bounce 1s infinite" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/aspect-ratios.js
var aspectRatios = defineTokens.aspectRatios({
  square: { value: "1 / 1" },
  landscape: { value: "4 / 3" },
  portrait: { value: "3 / 4" },
  wide: { value: "16 / 9" },
  ultrawide: { value: "18 / 5" },
  golden: { value: "1.618 / 1" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/blurs.js
var blurs = defineTokens.blurs({
  none: { value: " " },
  sm: { value: "4px" },
  md: { value: "8px" },
  lg: { value: "12px" },
  xl: { value: "16px" },
  "2xl": { value: "24px" },
  "3xl": { value: "40px" },
  "4xl": { value: "64px" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/borders.js
var borders = defineTokens.borders({
  xs: { value: "0.5px solid" },
  sm: { value: "1px solid" },
  md: { value: "2px solid" },
  lg: { value: "4px solid" },
  xl: { value: "8px solid" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/colors.js
var colors = defineTokens.colors({
  transparent: { value: "transparent" },
  current: { value: "currentColor" },
  black: { value: "#09090B" },
  white: { value: "#FFFFFF" },
  whiteAlpha: {
    50: { value: "rgba(255, 255, 255, 0.04)" },
    100: { value: "rgba(255, 255, 255, 0.06)" },
    200: { value: "rgba(255, 255, 255, 0.08)" },
    300: { value: "rgba(255, 255, 255, 0.16)" },
    400: { value: "rgba(255, 255, 255, 0.24)" },
    500: { value: "rgba(255, 255, 255, 0.36)" },
    600: { value: "rgba(255, 255, 255, 0.48)" },
    700: { value: "rgba(255, 255, 255, 0.64)" },
    800: { value: "rgba(255, 255, 255, 0.80)" },
    900: { value: "rgba(255, 255, 255, 0.92)" },
    950: { value: "rgba(255, 255, 255, 0.95)" }
  },
  blackAlpha: {
    50: { value: "rgba(0, 0, 0, 0.04)" },
    100: { value: "rgba(0, 0, 0, 0.06)" },
    200: { value: "rgba(0, 0, 0, 0.08)" },
    300: { value: "rgba(0, 0, 0, 0.16)" },
    400: { value: "rgba(0, 0, 0, 0.24)" },
    500: { value: "rgba(0, 0, 0, 0.36)" },
    600: { value: "rgba(0, 0, 0, 0.48)" },
    700: { value: "rgba(0, 0, 0, 0.64)" },
    800: { value: "rgba(0, 0, 0, 0.80)" },
    900: { value: "rgba(0, 0, 0, 0.92)" },
    950: { value: "rgba(0, 0, 0, 0.95)" }
  },
  gray: {
    50: { value: "#fafafa" },
    100: { value: "#f4f4f5" },
    200: { value: "#e4e4e7" },
    300: { value: "#d4d4d8" },
    400: { value: "#a1a1aa" },
    500: { value: "#71717a" },
    600: { value: "#52525b" },
    700: { value: "#3f3f46" },
    800: { value: "#27272a" },
    900: { value: "#18181b" },
    950: { value: "#111111" }
  },
  red: {
    50: { value: "#fef2f2" },
    100: { value: "#fee2e2" },
    200: { value: "#fecaca" },
    300: { value: "#fca5a5" },
    400: { value: "#f87171" },
    500: { value: "#ef4444" },
    600: { value: "#dc2626" },
    700: { value: "#991919" },
    800: { value: "#511111" },
    900: { value: "#300c0c" },
    950: { value: "#1f0808" }
  },
  orange: {
    50: { value: "#fff7ed" },
    100: { value: "#ffedd5" },
    200: { value: "#fed7aa" },
    300: { value: "#fdba74" },
    400: { value: "#fb923c" },
    500: { value: "#f97316" },
    600: { value: "#ea580c" },
    700: { value: "#92310a" },
    800: { value: "#6c2710" },
    900: { value: "#3b1106" },
    950: { value: "#220a04" }
  },
  yellow: {
    50: { value: "#fefce8" },
    100: { value: "#fef9c3" },
    200: { value: "#fef08a" },
    300: { value: "#fde047" },
    400: { value: "#facc15" },
    500: { value: "#eab308" },
    600: { value: "#ca8a04" },
    700: { value: "#845209" },
    800: { value: "#713f12" },
    900: { value: "#422006" },
    950: { value: "#281304" }
  },
  green: {
    50: { value: "#f0fdf4" },
    100: { value: "#dcfce7" },
    200: { value: "#bbf7d0" },
    300: { value: "#86efac" },
    400: { value: "#4ade80" },
    500: { value: "#22c55e" },
    600: { value: "#16a34a" },
    700: { value: "#116932" },
    800: { value: "#124a28" },
    900: { value: "#042713" },
    950: { value: "#03190c" }
  },
  teal: {
    50: { value: "#f0fdfa" },
    100: { value: "#ccfbf1" },
    200: { value: "#99f6e4" },
    300: { value: "#5eead4" },
    400: { value: "#2dd4bf" },
    500: { value: "#14b8a6" },
    600: { value: "#0d9488" },
    700: { value: "#0c5d56" },
    800: { value: "#114240" },
    900: { value: "#032726" },
    950: { value: "#021716" }
  },
  blue: {
    50: { value: "#eff6ff" },
    100: { value: "#dbeafe" },
    200: { value: "#bfdbfe" },
    300: { value: "#a3cfff" },
    400: { value: "#60a5fa" },
    500: { value: "#3b82f6" },
    600: { value: "#2563eb" },
    700: { value: "#173da6" },
    800: { value: "#1a3478" },
    900: { value: "#14204a" },
    950: { value: "#0c142e" }
  },
  cyan: {
    50: { value: "#ecfeff" },
    100: { value: "#cffafe" },
    200: { value: "#a5f3fc" },
    300: { value: "#67e8f9" },
    400: { value: "#22d3ee" },
    500: { value: "#06b6d4" },
    600: { value: "#0891b2" },
    700: { value: "#0c5c72" },
    800: { value: "#134152" },
    900: { value: "#072a38" },
    950: { value: "#051b24" }
  },
  purple: {
    50: { value: "#faf5ff" },
    100: { value: "#f3e8ff" },
    200: { value: "#e9d5ff" },
    300: { value: "#d8b4fe" },
    400: { value: "#c084fc" },
    500: { value: "#a855f7" },
    600: { value: "#9333ea" },
    700: { value: "#641ba3" },
    800: { value: "#4a1772" },
    900: { value: "#2f0553" },
    950: { value: "#1a032e" }
  },
  pink: {
    50: { value: "#fdf2f8" },
    100: { value: "#fce7f3" },
    200: { value: "#fbcfe8" },
    300: { value: "#f9a8d4" },
    400: { value: "#f472b6" },
    500: { value: "#ec4899" },
    600: { value: "#db2777" },
    700: { value: "#a41752" },
    800: { value: "#6d0e34" },
    900: { value: "#45061f" },
    950: { value: "#2c0514" }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/cursor.js
var cursor2 = defineTokens.cursor({
  button: { value: "pointer" },
  checkbox: { value: "default" },
  disabled: { value: "not-allowed" },
  menuitem: { value: "default" },
  option: { value: "default" },
  radio: { value: "default" },
  slider: { value: "default" },
  switch: { value: "pointer" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/durations.js
var durations = defineTokens.durations({
  fastest: { value: "50ms" },
  faster: { value: "100ms" },
  fast: { value: "150ms" },
  moderate: { value: "200ms" },
  slow: { value: "300ms" },
  slower: { value: "400ms" },
  slowest: { value: "500ms" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/easings.js
var easings = defineTokens.easings({
  "ease-in": { value: "cubic-bezier(0.42, 0, 1, 1)" },
  "ease-out": { value: "cubic-bezier(0, 0, 0.58, 1)" },
  "ease-in-out": { value: "cubic-bezier(0.42, 0, 0.58, 1)" },
  "ease-in-smooth": { value: "cubic-bezier(0.32, 0.72, 0, 1)" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/font-sizes.js
var fontSizes = defineTokens.fontSizes({
  "2xs": { value: "0.625rem" },
  xs: { value: "0.75rem" },
  sm: { value: "0.875rem" },
  md: { value: "1rem" },
  lg: { value: "1.125rem" },
  xl: { value: "1.25rem" },
  "2xl": { value: "1.5rem" },
  "3xl": { value: "1.875rem" },
  "4xl": { value: "2.25rem" },
  "5xl": { value: "3rem" },
  "6xl": { value: "3.75rem" },
  "7xl": { value: "4.5rem" },
  "8xl": { value: "6rem" },
  "9xl": { value: "8rem" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/font-weights.js
var fontWeights = defineTokens.fontWeights({
  thin: { value: "100" },
  extralight: { value: "200" },
  light: { value: "300" },
  normal: { value: "400" },
  medium: { value: "500" },
  semibold: { value: "600" },
  bold: { value: "700" },
  extrabold: { value: "800" },
  black: { value: "900" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/fonts.js
var fallback3 = `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
var fonts = defineTokens.fonts({
  heading: {
    value: `Inter, ${fallback3}`
  },
  body: {
    value: `Inter, ${fallback3}`
  },
  mono: {
    value: `SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace`
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/keyframes.js
var keyframes = defineKeyframes({
  spin: {
    "0%": { transform: "rotate(0deg)" },
    "100%": { transform: "rotate(360deg)" }
  },
  pulse: {
    "50%": { opacity: "0.5" }
  },
  ping: {
    "75%, 100%": {
      transform: "scale(2)",
      opacity: "0"
    }
  },
  bounce: {
    "0%, 100%": {
      transform: "translateY(-25%)",
      animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
    },
    "50%": {
      transform: "none",
      animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
    }
  },
  "bg-position": {
    from: { backgroundPosition: "var(--animate-from, 1rem) 0" },
    to: { backgroundPosition: "var(--animate-to, 0) 0" }
  },
  position: {
    from: {
      insetInlineStart: "var(--animate-from-x)",
      insetBlockStart: "var(--animate-from-y)"
    },
    to: {
      insetInlineStart: "var(--animate-to-x)",
      insetBlockStart: "var(--animate-to-y)"
    }
  },
  "circular-progress": {
    "0%": {
      strokeDasharray: "1, 400",
      strokeDashoffset: "0"
    },
    "50%": {
      strokeDasharray: "400, 400",
      strokeDashoffset: "-100%"
    },
    "100%": {
      strokeDasharray: "400, 400",
      strokeDashoffset: "-260%"
    }
  },
  // collapse
  "expand-height": {
    from: { height: "0" },
    to: { height: "var(--height)" }
  },
  "collapse-height": {
    from: { height: "var(--height)" },
    to: { height: "0" }
  },
  "expand-width": {
    from: { width: "0" },
    to: { width: "var(--width)" }
  },
  "collapse-width": {
    from: { height: "var(--width)" },
    to: { height: "0" }
  },
  // fade
  "fade-in": {
    from: { opacity: 0 },
    to: { opacity: 1 }
  },
  "fade-out": {
    from: { opacity: 1 },
    to: { opacity: 0 }
  },
  // slide from (full)
  "slide-from-left-full": {
    from: { translate: "-100% 0" },
    to: { translate: "0 0" }
  },
  "slide-from-right-full": {
    from: { translate: "100% 0" },
    to: { translate: "0 0" }
  },
  "slide-from-top-full": {
    from: { translate: "0 -100%" },
    to: { translate: "0 0" }
  },
  "slide-from-bottom-full": {
    from: { translate: "0 100%" },
    to: { translate: "0 0" }
  },
  // slide to (full)
  "slide-to-left-full": {
    from: { translate: "0 0" },
    to: { translate: "-100% 0" }
  },
  "slide-to-right-full": {
    from: { translate: "0 0" },
    to: { translate: "100% 0" }
  },
  "slide-to-top-full": {
    from: { translate: "0 0" },
    to: { translate: "0 -100%" }
  },
  "slide-to-bottom-full": {
    from: { translate: "0 0" },
    to: { translate: "0 100%" }
  },
  // slide from
  "slide-from-top": {
    "0%": { translate: "0 -0.5rem" },
    to: { translate: "0" }
  },
  "slide-from-bottom": {
    "0%": { translate: "0 0.5rem" },
    to: { translate: "0" }
  },
  "slide-from-left": {
    "0%": { translate: "-0.5rem 0" },
    to: { translate: "0" }
  },
  "slide-from-right": {
    "0%": { translate: "0.5rem 0" },
    to: { translate: "0" }
  },
  // slide to
  "slide-to-top": {
    "0%": { translate: "0" },
    to: { translate: "0 -0.5rem" }
  },
  "slide-to-bottom": {
    "0%": { translate: "0" },
    to: { translate: "0 0.5rem" }
  },
  "slide-to-left": {
    "0%": { translate: "0" },
    to: { translate: "-0.5rem 0" }
  },
  "slide-to-right": {
    "0%": { translate: "0" },
    to: { translate: "0.5rem 0" }
  },
  // scale
  "scale-in": {
    from: { scale: "0.95" },
    to: { scale: "1" }
  },
  "scale-out": {
    from: { scale: "1" },
    to: { scale: "0.95" }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/letter-spacing.js
var letterSpacings = defineTokens.letterSpacings({
  tighter: { value: "-0.05em" },
  tight: { value: "-0.025em" },
  wide: { value: "0.025em" },
  wider: { value: "0.05em" },
  widest: { value: "0.1em" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/line-heights.js
var lineHeights = defineTokens.lineHeights({
  shorter: { value: 1.25 },
  short: { value: 1.375 },
  moderate: { value: 1.5 },
  tall: { value: 1.625 },
  taller: { value: 2 }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/radius.js
var radii = defineTokens.radii({
  none: { value: "0" },
  "2xs": { value: "0.0625rem" },
  xs: { value: "0.125rem" },
  sm: { value: "0.25rem" },
  md: { value: "0.375rem" },
  lg: { value: "0.5rem" },
  xl: { value: "0.75rem" },
  "2xl": { value: "1rem" },
  "3xl": { value: "1.5rem" },
  "4xl": { value: "2rem" },
  full: { value: "9999px" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/spacing.js
var spacing = defineTokens.spacing({
  0.5: { value: "0.125rem" },
  1: { value: "0.25rem" },
  1.5: { value: "0.375rem" },
  2: { value: "0.5rem" },
  2.5: { value: "0.625rem" },
  3: { value: "0.75rem" },
  3.5: { value: "0.875rem" },
  4: { value: "1rem" },
  4.5: { value: "1.125rem" },
  5: { value: "1.25rem" },
  6: { value: "1.5rem" },
  7: { value: "1.75rem" },
  8: { value: "2rem" },
  9: { value: "2.25rem" },
  10: { value: "2.5rem" },
  11: { value: "2.75rem" },
  12: { value: "3rem" },
  14: { value: "3.5rem" },
  16: { value: "4rem" },
  20: { value: "5rem" },
  24: { value: "6rem" },
  28: { value: "7rem" },
  32: { value: "8rem" },
  36: { value: "9rem" },
  40: { value: "10rem" },
  44: { value: "11rem" },
  48: { value: "12rem" },
  52: { value: "13rem" },
  56: { value: "14rem" },
  60: { value: "15rem" },
  64: { value: "16rem" },
  72: { value: "18rem" },
  80: { value: "20rem" },
  96: { value: "24rem" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/sizes.js
var largeSizes = defineTokens.sizes({
  "3xs": { value: "14rem" },
  "2xs": { value: "16rem" },
  xs: { value: "20rem" },
  sm: { value: "24rem" },
  md: { value: "28rem" },
  lg: { value: "32rem" },
  xl: { value: "36rem" },
  "2xl": { value: "42rem" },
  "3xl": { value: "48rem" },
  "4xl": { value: "56rem" },
  "5xl": { value: "64rem" },
  "6xl": { value: "72rem" },
  "7xl": { value: "80rem" },
  "8xl": { value: "90rem" }
});
var namedSizes = defineTokens.sizes({
  max: { value: "max-content" },
  min: { value: "min-content" },
  fit: { value: "fit-content" },
  prose: { value: "60ch" },
  full: { value: "100%" },
  dvh: { value: "100dvh" },
  svh: { value: "100svh" },
  lvh: { value: "100lvh" },
  dvw: { value: "100dvw" },
  svw: { value: "100svw" },
  lvw: { value: "100lvw" },
  vw: { value: "100vw" },
  vh: { value: "100vh" }
});
var fractionalSizes = defineTokens.sizes({
  "1/2": { value: "50%" },
  "1/3": { value: "33.333333%" },
  "2/3": { value: "66.666667%" },
  "1/4": { value: "25%" },
  "3/4": { value: "75%" },
  "1/5": { value: "20%" },
  "2/5": { value: "40%" },
  "3/5": { value: "60%" },
  "4/5": { value: "80%" },
  "1/6": { value: "16.666667%" },
  "2/6": { value: "33.333333%" },
  "3/6": { value: "50%" },
  "4/6": { value: "66.666667%" },
  "5/6": { value: "83.333333%" },
  "1/12": { value: "8.333333%" },
  "2/12": { value: "16.666667%" },
  "3/12": { value: "25%" },
  "4/12": { value: "33.333333%" },
  "5/12": { value: "41.666667%" },
  "6/12": { value: "50%" },
  "7/12": { value: "58.333333%" },
  "8/12": { value: "66.666667%" },
  "9/12": { value: "75%" },
  "10/12": { value: "83.333333%" },
  "11/12": { value: "91.666667%" }
});
var sizes = defineTokens.sizes({
  ...largeSizes,
  ...spacing,
  ...fractionalSizes,
  ...namedSizes
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/z-indices.js
var zIndices = defineTokens.zIndex({
  hide: { value: -1 },
  base: { value: 0 },
  docked: { value: 10 },
  dropdown: { value: 1e3 },
  sticky: { value: 1100 },
  banner: { value: 1200 },
  overlay: { value: 1300 },
  modal: { value: 1400 },
  popover: { value: 1500 },
  skipNav: { value: 1600 },
  toast: { value: 1700 },
  tooltip: { value: 1800 },
  max: { value: 2147483647 }
});

// node_modules/@chakra-ui/react/dist/esm/theme/index.js
var defaultThemeConfig = defineConfig({
  preflight: true,
  cssVarsPrefix: "chakra",
  cssVarsRoot: ":where(html, .chakra-theme)",
  globalCss,
  theme: {
    breakpoints,
    keyframes,
    tokens: {
      aspectRatios,
      animations,
      blurs,
      borders,
      colors,
      durations,
      easings,
      fonts,
      fontSizes,
      fontWeights,
      letterSpacings,
      lineHeights,
      radii,
      spacing,
      sizes,
      zIndex: zIndices,
      cursor: cursor2
    },
    semanticTokens: {
      colors: semanticColors,
      shadows: semanticShadows,
      radii: semanticRadii
    },
    recipes,
    slotRecipes,
    textStyles,
    layerStyles,
    animationStyles
  }
});

// node_modules/@chakra-ui/react/dist/esm/preset.js
var defaultConfig = mergeConfigs(defaultBaseConfig, defaultThemeConfig);
var defaultSystem = createSystem(defaultConfig);

// node_modules/@chakra-ui/react/dist/esm/styled-system/create-recipe-context.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react15 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/styled-system/empty.js
var EMPTY_STYLES = Object.freeze({});
var EMPTY_SLOT_STYLES = Object.freeze(
  {}
);

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-recipe.js
var import_react14 = __toESM(require_react(), 1);
function useRecipe(options) {
  const { key, recipe: recipeProp } = options;
  const sys = useChakraContext();
  return (0, import_react14.useMemo)(() => {
    const recipe = recipeProp || (key != null ? sys.getRecipe(key) : {});
    return sys.cva(structuredClone(recipe));
  }, [key, recipeProp, sys]);
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/create-recipe-context.js
var upperFirst = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function createRecipeContext(options) {
  const { key: recipeKey, recipe: recipeConfig } = options;
  const contextName = upperFirst(
    recipeKey || recipeConfig.className || "Component"
  );
  const [PropsProvider58, usePropsContext] = createContext3({
    strict: false,
    name: `${contextName}PropsContext`,
    providerName: `${contextName}PropsContext`
  });
  const withContext60 = (Component, options2) => {
    const SuperComponent = chakra(Component, {}, options2);
    const StyledComponent = (0, import_react15.forwardRef)((inProps, ref36) => {
      const props52 = mergeProps(usePropsContext(), inProps);
      const { unstyled, ...otherProps } = props52;
      const fallbackRecipe = props52.recipe || recipeConfig;
      const recipe = useRecipe({ key: recipeKey, recipe: fallbackRecipe });
      const [variantProps, localProps] = recipe.splitVariantProps(otherProps);
      const styles = unstyled ? EMPTY_STYLES : recipe(variantProps);
      return (0, import_jsx_runtime6.jsx)(
        SuperComponent,
        {
          ...localProps,
          ref: ref36,
          css: [styles, props52.css],
          className: cx(recipe.className, props52.className)
        }
      );
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  return {
    withContext: withContext60,
    PropsProvider: PropsProvider58,
    usePropsContext
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/create-slot-recipe-context.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react17 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-slot-recipe.js
var import_react16 = __toESM(require_react(), 1);
function useSlotRecipe(options) {
  const { key, recipe: recipeProp } = options;
  const sys = useChakraContext();
  return (0, import_react16.useMemo)(() => {
    const recipe = recipeProp || (key != null ? sys.getSlotRecipe(key) : {});
    return sys.sva(structuredClone(recipe));
  }, [key, recipeProp, sys]);
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/create-slot-recipe-context.js
var upperFirst2 = (str) => str.charAt(0).toUpperCase() + str.slice(1);
var createSlotRecipeContext = (options) => {
  const { key: recipeKey, recipe: recipeConfig } = options;
  const contextName = upperFirst2(
    recipeKey || recipeConfig.className || "Component"
  );
  const [StylesProvider2, useStyles] = createContext3({
    name: `${contextName}StylesContext`,
    errorMessage: `use${contextName}Styles returned is 'undefined'. Seems you forgot to wrap the components in "<${contextName}.Root />" `
  });
  const [ClassNamesProvider2, useClassNames3] = createContext3({
    name: `${contextName}ClassNameContext`,
    errorMessage: `use${contextName}ClassNames returned is 'undefined'. Seems you forgot to wrap the components in "<${contextName}.Root />" `,
    strict: false
  });
  const [PropsProvider58, usePropsContext] = createContext3({
    strict: false,
    name: `${contextName}PropsContext`,
    providerName: `${contextName}PropsContext`,
    defaultValue: {}
  });
  function useRecipeResult2(props52) {
    const { unstyled, ...restProps } = props52;
    const slotRecipe = useSlotRecipe({
      key: recipeKey,
      recipe: restProps.recipe || recipeConfig
    });
    const [variantProps, otherProps] = slotRecipe.splitVariantProps(restProps);
    const styles = unstyled ? EMPTY_SLOT_STYLES : slotRecipe(variantProps);
    return {
      styles,
      classNames: slotRecipe.classNameMap,
      props: otherProps
    };
  }
  function withRootProvider8(Component, options2 = {}) {
    const { defaultProps } = options2;
    const StyledComponent = (inProps) => {
      const props52 = mergeProps(defaultProps, usePropsContext(), inProps);
      const { styles, classNames, props: rootProps } = useRecipeResult2(props52);
      return (0, import_jsx_runtime7.jsx)(StylesProvider2, { value: styles, children: (0, import_jsx_runtime7.jsx)(ClassNamesProvider2, { value: classNames, children: (0, import_jsx_runtime7.jsx)(Component, { ...rootProps }) }) });
    };
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  }
  const withProvider38 = (Component, slot, options2) => {
    const { defaultProps, ...restOptions } = options2 ?? {};
    const SuperComponent = chakra(Component, {}, restOptions);
    const StyledComponent = (0, import_react17.forwardRef)((inProps, ref36) => {
      var _a7;
      const props52 = mergeProps(defaultProps ?? {}, usePropsContext(), inProps);
      const { styles, props: rootProps, classNames } = useRecipeResult2(props52);
      const className = classNames[slot];
      const element = (0, import_jsx_runtime7.jsx)(StylesProvider2, { value: styles, children: (0, import_jsx_runtime7.jsx)(ClassNamesProvider2, { value: classNames, children: (0, import_jsx_runtime7.jsx)(
        SuperComponent,
        {
          ref: ref36,
          ...rootProps,
          css: [styles[slot], props52.css],
          className: cx(props52.className, className)
        }
      ) }) });
      return ((_a7 = options2 == null ? void 0 : options2.wrapElement) == null ? void 0 : _a7.call(options2, element, props52)) ?? element;
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  const withContext60 = (Component, slot, options2) => {
    const SuperComponent = chakra(Component, {}, options2);
    const StyledComponent = (0, import_react17.forwardRef)((props52, ref36) => {
      const styles = useStyles();
      const classNames = useClassNames3();
      const className = classNames == null ? void 0 : classNames[slot];
      return (0, import_jsx_runtime7.jsx)(
        SuperComponent,
        {
          ...props52,
          css: [slot ? styles[slot] : void 0, props52.css],
          ref: ref36,
          className: cx(props52.className, className)
        }
      );
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  return {
    StylesProvider: StylesProvider2,
    ClassNamesProvider: ClassNamesProvider2,
    PropsProvider: PropsProvider58,
    usePropsContext,
    useRecipeResult: useRecipeResult2,
    withProvider: withProvider38,
    withContext: withContext60,
    withRootProvider: withRootProvider8,
    useStyles,
    useClassNames: useClassNames3
  };
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/recipe-props.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var [RecipePropsContextProvider, useParentRecipeProps] = createContext3({
  name: "RecipePropsContext",
  strict: false
});
function RecipePropsProvider(props52) {
  return (0, import_jsx_runtime8.jsx)(RecipePropsContextProvider, { value: props52.value, children: props52.children });
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-token.js
var import_react18 = __toESM(require_react(), 1);
function useToken(category, token2) {
  const sys = useChakraContext();
  return (0, import_react18.useMemo)(() => {
    const arr = Array.isArray(token2) ? token2 : [token2];
    return arr.map((t) => sys.token(`${category}.${t}`, t));
  }, [sys, category, token2]);
}

// node_modules/@zag-js/collection/node_modules/@zag-js/utils/dist/index.mjs
var isArrayLike2 = (value) => (value == null ? void 0 : value.constructor.name) === "Array";
var isArrayEqual2 = (a, b) => {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (!isEqual2(a[i], b[i])) return false;
  }
  return true;
};
var isEqual2 = (a, b) => {
  if (Object.is(a, b)) return true;
  if (a == null && b != null || a != null && b == null) return false;
  if (typeof (a == null ? void 0 : a.isEqual) === "function" && typeof (b == null ? void 0 : b.isEqual) === "function") {
    return a.isEqual(b);
  }
  if (typeof a === "function" && typeof b === "function") {
    return a.toString() === b.toString();
  }
  if (isArrayLike2(a) && isArrayLike2(b)) {
    return isArrayEqual2(Array.from(a), Array.from(b));
  }
  if (!(typeof a === "object") || !(typeof b === "object")) return false;
  const keys = Object.keys(b ?? /* @__PURE__ */ Object.create(null));
  const length2 = keys.length;
  for (let i = 0; i < length2; i++) {
    const hasKey = Reflect.has(a, keys[i]);
    if (!hasKey) return false;
  }
  for (let i = 0; i < length2; i++) {
    const key = keys[i];
    if (!isEqual2(a[key], b[key])) return false;
  }
  return true;
};
var isArray2 = (v) => Array.isArray(v);
var isObjectLike = (v) => v != null && typeof v === "object";
var isObject39 = (v) => isObjectLike(v) && !isArray2(v);
var hasProp2 = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
var fnToString = Function.prototype.toString;
var objectCtorString = fnToString.call(Object);

// node_modules/@zag-js/collection/dist/index.mjs
var __defProp4 = Object.defineProperty;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField4 = (obj, key, value) => __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
var fallback4 = {
  itemToValue(item) {
    if (typeof item === "string") return item;
    if (isObject39(item) && hasProp2(item, "value")) return item.value;
    return "";
  },
  itemToString(item) {
    if (typeof item === "string") return item;
    if (isObject39(item) && hasProp2(item, "label")) return item.label;
    return fallback4.itemToValue(item);
  },
  isItemDisabled(item) {
    if (isObject39(item) && hasProp2(item, "disabled")) return !!item.disabled;
    return false;
  }
};
var ListCollection = class {
  constructor(options) {
    this.options = options;
    __publicField4(this, "items");
    this.items = [...options.items];
  }
  isEqual(other) {
    return isEqual2(this.items, other.items);
  }
  /**
   * Function to update the collection items
   */
  setItems(items) {
    this.items = Array.from(items);
  }
  /**
   * Returns all the values in the collection
   */
  getValues(items = this.items) {
    return Array.from(items).map((item) => this.getItemValue(item)).filter(Boolean);
  }
  /**
   * Get the item based on its value
   */
  find(value) {
    if (value == null) return null;
    const index = this.items.findIndex((item) => this.getItemValue(item) === value);
    return index != null ? this.items[index] : null;
  }
  /**
   * Get the items based on its values
   */
  findMany(values) {
    return Array.from(values).map((value) => this.find(value)).filter(Boolean);
  }
  /**
   * Get the item based on its index
   */
  at(index) {
    return this.items[index] ?? null;
  }
  sortFn(valueA, valueB) {
    const indexA = this.indexOf(valueA);
    const indexB = this.indexOf(valueB);
    return (indexA ?? 0) - (indexB ?? 0);
  }
  /**
   * Sort the values based on their index
   */
  sort(values) {
    return [...values].sort(this.sortFn.bind(this));
  }
  /**
   * Convert an item to a value
   */
  getItemValue(item) {
    var _a7, _b6;
    if (item == null) return null;
    return ((_b6 = (_a7 = this.options).itemToValue) == null ? void 0 : _b6.call(_a7, item)) ?? fallback4.itemToValue(item);
  }
  /**
   * Whether an item is disabled
   */
  getItemDisabled(item) {
    var _a7, _b6;
    if (item == null) return false;
    return ((_b6 = (_a7 = this.options).isItemDisabled) == null ? void 0 : _b6.call(_a7, item)) ?? fallback4.isItemDisabled(item);
  }
  /**
   * Convert an item to a string
   */
  stringifyItem(item) {
    var _a7, _b6;
    if (item == null) return null;
    return ((_b6 = (_a7 = this.options).itemToString) == null ? void 0 : _b6.call(_a7, item)) ?? fallback4.itemToString(item);
  }
  /**
   * Convert a value to a string
   */
  stringify(value) {
    if (value == null) return null;
    return this.stringifyItem(this.find(value));
  }
  /**
   * Convert an array of items to a string
   */
  stringifyItems(items, separator = ", ") {
    return Array.from(items).map((item) => this.stringifyItem(item)).filter(Boolean).join(separator);
  }
  /**
   * Convert an array of items to a string
   */
  stringifyMany(value, separator) {
    return this.stringifyItems(this.findMany(value), separator);
  }
  /**
   * Whether the collection has a value
   */
  has(value) {
    return this.indexOf(value) !== -1;
  }
  /**
   * Whether the collection has an item
   */
  hasItem(item) {
    if (item == null) return false;
    return this.has(this.getItemValue(item));
  }
  /**
   * Returns the number of items in the collection
   */
  get size() {
    return this.items.length;
  }
  /**
   * Returns the first value in the collection
   */
  get firstValue() {
    let index = 0;
    while (this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the last value in the collection
   */
  get lastValue() {
    let index = this.size - 1;
    while (this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the next value in the collection
   */
  getNextValue(value, step = 1, clamp6 = false) {
    let index = this.indexOf(value);
    if (index === -1) return null;
    index = clamp6 ? Math.min(index + step, this.size - 1) : index + step;
    while (index <= this.size && this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the previous value in the collection
   */
  getPreviousValue(value, step = 1, clamp6 = false) {
    let index = this.indexOf(value);
    if (index === -1) return null;
    index = clamp6 ? Math.max(index - step, 0) : index - step;
    while (index >= 0 && this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  /**
   * Get the index of an item based on its key
   */
  indexOf(value) {
    if (value == null) return -1;
    return this.items.findIndex((item) => this.getItemValue(item) === value);
  }
  getByText(text, current) {
    let items = current != null ? wrap48(this.items, this.indexOf(current)) : this.items;
    const isSingleKey = text.length === 1;
    if (isSingleKey) items = items.filter((item) => this.getItemValue(item) !== current);
    return items.find((item) => match48(this.stringifyItem(item), text));
  }
  /**
   * Search for a value based on a query
   */
  search(queryString, options) {
    const { state: state2, currentValue, timeout = 350 } = options;
    const search = state2.keysSoFar + queryString;
    const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
    const query9 = isRepeated ? search[0] : search;
    const item = this.getByText(query9, currentValue);
    const value = this.getItemValue(item);
    function cleanup() {
      clearTimeout(state2.timer);
      state2.timer = -1;
    }
    function update(value2) {
      state2.keysSoFar = value2;
      cleanup();
      if (value2 !== "") {
        state2.timer = +setTimeout(() => {
          update("");
          cleanup();
        }, timeout);
      }
    }
    update(search);
    return value;
  }
  *[Symbol.iterator]() {
    yield* this.items;
  }
  insertBefore(value, item) {
    const index = this.indexOf(value);
    if (index === -1) return;
    this.items.splice(index, 0, item);
  }
  insertAfter(value, item) {
    const index = this.indexOf(value);
    if (index === -1) return;
    this.items.splice(index + 1, 0, item);
  }
  reorder(fromIndex, toIndex) {
    if (fromIndex === -1 || toIndex === -1) return;
    if (fromIndex === toIndex) return;
    const [removed] = this.items.splice(fromIndex, 1);
    this.items.splice(toIndex, 0, removed);
  }
  json() {
    return {
      size: this.size,
      first: this.firstValue,
      last: this.lastValue
    };
  }
};
var match48 = (label, query9) => {
  return !!(label == null ? void 0 : label.toLowerCase().startsWith(query9.toLowerCase()));
};
var wrap48 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};

// node_modules/@zag-js/store/dist/index.mjs
function getGlobal35() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal35(key, value) {
  const g = getGlobal35();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev35 = () => true;
var isObject40 = (x) => typeof x === "object" && x !== null;
var proxyStateMap35 = makeGlobal35("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet35 = makeGlobal35("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var isReactElement = (x) => typeof x === "object" && x !== null && "$$typeof" in x;
var isVueElement = (x) => typeof x === "object" && x !== null && "__v_isVNode" in x;
var isDOMElement = (x) => typeof x === "object" && x !== null && "nodeType" in x && typeof x.nodeName === "string";
var isElement2 = (x) => isReactElement(x) || isVueElement(x) || isDOMElement(x);
var buildProxyFunction35 = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject40(x) && !refSet35.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !isElement2(x) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet35.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap35.has(value)) {
      snap[key] = snapshot35(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction210 = (initialObject) => {
  if (!isObject40(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev35() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a7;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a7 = entry[1]) == null ? void 0 : _a7.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev35() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a7;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject40(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a7 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a7.set) ;
      else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap35.has(value) && canProxy(value)) {
          nextValue = proxy35(value);
        }
        const childProxyState = !refSet35.has(nextValue) && proxyStateMap35.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap35.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction210,
  // shared state
  proxyStateMap35,
  refSet35,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction35] = buildProxyFunction35();
function proxy35(initialObject = {}) {
  return proxyFunction35(initialObject);
}
function subscribe35(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap35.get(proxyObject);
  if (isDev35() && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot35(proxyObject, handlePromise) {
  const proxyState = proxyStateMap35.get(proxyObject);
  if (isDev35() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}
function ref35(obj) {
  refSet35.add(obj);
  return obj;
}
function proxyWithComputed35(initialObject, computedFns) {
  const keys = Object.keys(computedFns);
  keys.forEach((key) => {
    if (Object.getOwnPropertyDescriptor(initialObject, key)) {
      throw new Error("object property already defined");
    }
    const computedFn = computedFns[key];
    const { get, set: set18 } = typeof computedFn === "function" ? { get: computedFn } : computedFn;
    const desc = {};
    desc.get = () => get(snapshot35(proxyObject));
    if (set18) {
      desc.set = (newValue) => set18(proxyObject, newValue);
    }
    Object.defineProperty(initialObject, key, desc);
  });
  const proxyObject = proxy35(initialObject);
  return proxyObject;
}

// node_modules/@zag-js/core/node_modules/@zag-js/utils/dist/index.mjs
function clear(v) {
  while (v.length > 0) v.pop();
  return v;
}
var runIfFn2 = (v, ...a) => {
  const res = typeof v === "function" ? v(...a) : v;
  return res ?? void 0;
};
var cast2 = (v) => v;
var noop2 = () => {
};
var callAll3 = (...fns) => (...a) => {
  fns.forEach(function(fn) {
    fn == null ? void 0 : fn(...a);
  });
};
var uuid2 = /* @__PURE__ */ (() => {
  let id = 0;
  return () => {
    id++;
    return id.toString(36);
  };
})();
var isDev36 = () => true;
var isArray3 = (v) => Array.isArray(v);
var isObjectLike2 = (v) => v != null && typeof v === "object";
var isObject41 = (v) => isObjectLike2(v) && !isArray3(v);
var isNumber2 = (v) => typeof v === "number" && !Number.isNaN(v);
var isString22 = (v) => typeof v === "string";
var isFunction22 = (v) => typeof v === "function";
var hasProp3 = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
var baseGetTag = (v) => Object.prototype.toString.call(v);
var fnToString2 = Function.prototype.toString;
var objectCtorString2 = fnToString2.call(Object);
var isPlainObject = (v) => {
  if (!isObjectLike2(v) || baseGetTag(v) != "[object Object]") return false;
  const proto = Object.getPrototypeOf(v);
  if (proto === null) return true;
  const Ctor = hasProp3(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && fnToString2.call(Ctor) == objectCtorString2;
};
function compact3(obj) {
  if (!isPlainObject2(obj) || obj === void 0) {
    return obj;
  }
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact3(value);
    }
  }
  return filtered;
}
var isPlainObject2 = (value) => {
  return value && typeof value === "object" && value.constructor === Object;
};
function warn2(...a) {
  const m = a.length === 1 ? a[0] : a[1];
  const c = a.length === 2 ? a[0] : true;
  if (c && true) {
    console.warn(m);
  }
}
function invariant2(...a) {
  const m = a.length === 1 ? a[0] : a[1];
  const c = a.length === 2 ? a[0] : true;
  if (c && true) {
    throw new Error(m);
  }
}

// node_modules/@zag-js/core/dist/index.mjs
var __defProp5 = Object.defineProperty;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField5 = (obj, key, value) => __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
function deepMerge(source, ...objects) {
  for (const obj of objects) {
    const target = compact3(obj);
    for (const key in target) {
      if (isPlainObject(obj[key])) {
        if (!source[key]) {
          source[key] = {};
        }
        deepMerge(source[key], obj[key]);
      } else {
        source[key] = obj[key];
      }
    }
  }
  return source;
}
function structuredClone2(v) {
  return klona(v);
}
function toEvent(event) {
  const obj = isString22(event) ? { type: event } : event;
  return obj;
}
function toArray2(value) {
  if (!value) return [];
  return isArray3(value) ? value.slice() : [value];
}
function isGuardHelper(value) {
  return isObject41(value) && value.predicate != null;
}
var Truthy = () => true;
function exec20(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a7;
    if (isString22(guard)) {
      return !!((_a7 = guardMap[guard]) == null ? void 0 : _a7.call(guardMap, ctx, event, meta));
    }
    if (isFunction22(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or24(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec20(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and34(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec20(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not35(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec20(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn20(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards20 = { or: or24, and: and34, not: not35, stateIn: stateIn20 };
function choose3(actions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      var _a7;
      return (_a7 = actions.find((def) => {
        const guard = def.guard ?? Truthy;
        return exec20(guardMap, ctx, event, meta)(guard);
      })) == null ? void 0 : _a7.actions;
    }
  };
}
function determineGuardFn(guard, guardMap) {
  guard = guard ?? Truthy;
  return (context, event, meta) => {
    if (isString22(guard)) {
      const value = guardMap[guard];
      return isFunction22(value) ? value(context, event, meta) : value;
    }
    if (isGuardHelper(guard)) {
      return guard.predicate(guardMap)(context, event, meta);
    }
    return guard == null ? void 0 : guard(context, event, meta);
  };
}
function determineActionsFn(values, guardMap) {
  return (context, event, meta) => {
    if (isGuardHelper(values)) {
      return values.predicate(guardMap)(context, event, meta);
    }
    return values;
  };
}
function createProxy3(config) {
  var _a7, _b6;
  const computedContext = config.computed ?? cast2({});
  const initialContext = config.context ?? cast2({});
  const initialTags = config.initial ? (_b6 = (_a7 = config.states) == null ? void 0 : _a7[config.initial]) == null ? void 0 : _b6.tags : [];
  const state2 = proxy35({
    value: config.initial ?? "",
    previousValue: "",
    event: cast2({}),
    previousEvent: cast2({}),
    context: proxyWithComputed35(initialContext, computedContext),
    done: false,
    tags: initialTags ?? [],
    hasTag(tag) {
      return this.tags.includes(tag);
    },
    matches(...value) {
      return value.includes(this.value);
    },
    can(event) {
      return cast2(this).nextEvents.includes(event);
    },
    get nextEvents() {
      var _a8, _b7;
      const stateEvents = ((_b7 = (_a8 = config.states) == null ? void 0 : _a8[this.value]) == null ? void 0 : _b7["on"]) ?? {};
      const globalEvents = (config == null ? void 0 : config.on) ?? {};
      return Object.keys({ ...stateEvents, ...globalEvents });
    },
    get changed() {
      if (this.event.value === "machine.init" || !this.previousValue) return false;
      return this.value !== this.previousValue;
    }
  });
  return cast2(state2);
}
function determineDelayFn(delay3, delaysMap) {
  return (context, event) => {
    if (isNumber2(delay3)) return delay3;
    if (isFunction22(delay3)) {
      return delay3(context, event);
    }
    if (isString22(delay3)) {
      const value = Number.parseFloat(delay3);
      if (!Number.isNaN(value)) {
        return value;
      }
      if (delaysMap) {
        const valueOrFn = delaysMap == null ? void 0 : delaysMap[delay3];
        invariant2(
          valueOrFn == null,
          `[@zag-js/core > determine-delay] Cannot determine delay for \`${delay3}\`. It doesn't exist in \`options.delays\``
        );
        return isFunction22(valueOrFn) ? valueOrFn(context, event) : valueOrFn;
      }
    }
  };
}
function toTarget(target) {
  return isString22(target) ? { target } : target;
}
function determineTransitionFn(transitions, guardMap) {
  return (context, event, meta) => {
    return toArray2(transitions).map(toTarget).find((transition) => {
      const determineGuard = determineGuardFn(transition.guard, guardMap);
      const guard = determineGuard(context, event, meta);
      return guard ?? transition.target ?? transition.actions;
    });
  };
}
var Machine = class {
  // Let's get started!
  constructor(config, options) {
    var _a7, _b6, _c5, _d5, _e6;
    __publicField5(
      this,
      "status",
      "Not Started"
      /* NotStarted */
    );
    __publicField5(this, "state");
    __publicField5(this, "initialState");
    __publicField5(this, "initialContext");
    __publicField5(this, "id");
    __publicField5(
      this,
      "type",
      "machine"
      /* Machine */
    );
    __publicField5(this, "activityEvents", /* @__PURE__ */ new Map());
    __publicField5(this, "delayedEvents", /* @__PURE__ */ new Map());
    __publicField5(this, "stateListeners", /* @__PURE__ */ new Set());
    __publicField5(this, "doneListeners", /* @__PURE__ */ new Set());
    __publicField5(this, "contextWatchers", /* @__PURE__ */ new Set());
    __publicField5(this, "removeStateListener", noop2);
    __publicField5(this, "parent");
    __publicField5(this, "children", /* @__PURE__ */ new Map());
    __publicField5(this, "guardMap");
    __publicField5(this, "actionMap");
    __publicField5(this, "delayMap");
    __publicField5(this, "activityMap");
    __publicField5(this, "sync");
    __publicField5(this, "options");
    __publicField5(this, "config");
    __publicField5(this, "_created", () => {
      var _a8;
      const event = toEvent(
        "machine.created"
        /* Created */
      );
      this.executeActions((_a8 = this.config) == null ? void 0 : _a8.created, event);
    });
    __publicField5(this, "start", (init) => {
      this.state.value = "";
      this.state.tags = [];
      if (this.status === "Running") {
        return this;
      }
      this.status = "Running";
      this.removeStateListener = subscribe35(
        this.state,
        () => {
          this.stateListeners.forEach((listener) => {
            listener(this.stateSnapshot);
          });
        },
        this.sync
      );
      this.setupContextWatchers();
      this.executeActivities(
        toEvent(
          "machine.start"
          /* Start */
        ),
        toArray2(this.config.activities),
        "machine.start"
        /* Start */
      );
      this.executeActions(this.config.entry, toEvent(
        "machine.start"
        /* Start */
      ));
      const event = toEvent(
        "machine.init"
        /* Init */
      );
      const target = isObject41(init) ? init.value : init;
      const context = isObject41(init) ? init.context : void 0;
      if (context) {
        this.setContext(context);
      }
      const transition = {
        target: target ?? this.config.initial
      };
      const next3 = this.getNextStateInfo(transition, event);
      this.initialState = next3;
      this.performStateChangeEffects(this.state.value, next3, event);
      return this;
    });
    __publicField5(this, "setupContextWatchers", () => {
      const { watch } = this.config;
      if (!watch) return;
      let prev3 = snapshot35(this.state.context);
      const cleanup = subscribe35(this.state.context, () => {
        var _a8;
        const next3 = snapshot35(this.state.context);
        for (const [key, fn] of Object.entries(watch)) {
          const isEqual6 = ((_a8 = this.options.compareFns) == null ? void 0 : _a8[key]) ?? Object.is;
          if (isEqual6(prev3[key], next3[key])) continue;
          this.executeActions(fn, this.state.event);
        }
        prev3 = next3;
      });
      this.contextWatchers.add(cleanup);
    });
    __publicField5(this, "stop", () => {
      if (this.status === "Stopped") return;
      this.performExitEffects(this.state.value, toEvent(
        "machine.stop"
        /* Stop */
      ));
      this.executeActions(this.config.exit, toEvent(
        "machine.stop"
        /* Stop */
      ));
      this.setState("");
      this.setEvent(
        "machine.stop"
        /* Stop */
      );
      this.stopStateListeners();
      this.stopChildren();
      this.stopActivities();
      this.stopDelayedEvents();
      this.stopContextWatchers();
      this.status = "Stopped";
      return this;
    });
    __publicField5(this, "stopStateListeners", () => {
      this.removeStateListener();
      this.stateListeners.clear();
    });
    __publicField5(this, "stopContextWatchers", () => {
      this.contextWatchers.forEach((fn) => fn());
      this.contextWatchers.clear();
    });
    __publicField5(this, "stopDelayedEvents", () => {
      this.delayedEvents.forEach((state2) => {
        state2.forEach((stop) => stop());
      });
      this.delayedEvents.clear();
    });
    __publicField5(this, "stopActivities", (state2) => {
      var _a8, _b7;
      if (state2) {
        (_a8 = this.activityEvents.get(state2)) == null ? void 0 : _a8.forEach((stop) => stop());
        (_b7 = this.activityEvents.get(state2)) == null ? void 0 : _b7.clear();
        this.activityEvents.delete(state2);
      } else {
        this.activityEvents.forEach((state22) => {
          state22.forEach((stop) => stop());
          state22.clear();
        });
        this.activityEvents.clear();
      }
    });
    __publicField5(this, "sendChild", (evt, to) => {
      const event = toEvent(evt);
      const id = runIfFn2(to, this.contextSnapshot);
      const child = this.children.get(id);
      if (!child) {
        invariant2(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`);
      }
      child.send(event);
    });
    __publicField5(this, "stopChild", (id) => {
      if (!this.children.has(id)) {
        invariant2(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`);
      }
      this.children.get(id).stop();
      this.children.delete(id);
    });
    __publicField5(this, "removeChild", (id) => {
      this.children.delete(id);
    });
    __publicField5(this, "stopChildren", () => {
      this.children.forEach((child) => child.stop());
      this.children.clear();
    });
    __publicField5(this, "setParent", (parent) => {
      this.parent = parent;
    });
    __publicField5(this, "spawn", (src, id) => {
      const actor = runIfFn2(src);
      if (id) actor.id = id;
      actor.type = "machine.actor";
      actor.setParent(this);
      this.children.set(actor.id, cast2(actor));
      actor.onDone(() => {
        this.removeChild(actor.id);
      }).start();
      return cast2(ref35(actor));
    });
    __publicField5(this, "stopActivity", (key) => {
      var _a8;
      if (!this.state.value) return;
      const cleanups2 = this.activityEvents.get(this.state.value);
      (_a8 = cleanups2 == null ? void 0 : cleanups2.get(key)) == null ? void 0 : _a8();
      cleanups2 == null ? void 0 : cleanups2.delete(key);
    });
    __publicField5(this, "addActivityCleanup", (state2, key, cleanup) => {
      var _a8;
      if (!state2) return;
      if (!this.activityEvents.has(state2)) {
        this.activityEvents.set(state2, /* @__PURE__ */ new Map([[key, cleanup]]));
      } else {
        (_a8 = this.activityEvents.get(state2)) == null ? void 0 : _a8.set(key, cleanup);
      }
    });
    __publicField5(this, "setState", (target) => {
      this.state.previousValue = this.state.value;
      this.state.value = target;
      const stateNode = this.getStateNode(target);
      if (target == null) {
        clear(this.state.tags);
      } else {
        this.state.tags = toArray2(stateNode == null ? void 0 : stateNode.tags);
      }
    });
    __publicField5(this, "setContext", (context) => {
      if (!context) return;
      deepMerge(this.state.context, compact3(context));
    });
    __publicField5(this, "setOptions", (options2) => {
      const opts = compact3(options2);
      this.actionMap = { ...this.actionMap, ...opts.actions };
      this.delayMap = { ...this.delayMap, ...opts.delays };
      this.activityMap = { ...this.activityMap, ...opts.activities };
      this.guardMap = { ...this.guardMap, ...opts.guards };
    });
    __publicField5(this, "getStateNode", (state2) => {
      var _a8;
      if (!state2) return;
      return (_a8 = this.config.states) == null ? void 0 : _a8[state2];
    });
    __publicField5(this, "getNextStateInfo", (transitions, event) => {
      const transition = this.determineTransition(transitions, event);
      const isTargetless = !(transition == null ? void 0 : transition.target);
      const target = (transition == null ? void 0 : transition.target) ?? this.state.value;
      const changed = this.state.value !== target;
      const stateNode = this.getStateNode(target);
      const reenter = !isTargetless && !changed && !(transition == null ? void 0 : transition.internal);
      const info = {
        reenter,
        transition,
        stateNode,
        target,
        changed
      };
      this.log("NextState:", `[${event.type}]`, this.state.value, "---->", info.target);
      return info;
    });
    __publicField5(this, "getAfterActions", (transition, delay3) => {
      let id;
      const current = this.state.value;
      return {
        entry: () => {
          id = globalThis.setTimeout(() => {
            const next3 = this.getNextStateInfo(transition, this.state.event);
            this.performStateChangeEffects(current, next3, this.state.event);
          }, delay3);
        },
        exit: () => {
          globalThis.clearTimeout(id);
        }
      };
    });
    __publicField5(this, "getDelayedEventActions", (state2) => {
      const stateNode = this.getStateNode(state2);
      const event = this.state.event;
      if (!stateNode || !stateNode.after) return;
      const entries = [];
      const exits = [];
      if (isArray3(stateNode.after)) {
        const transition = this.determineTransition(stateNode.after, event);
        if (!transition) return;
        if (!hasProp3(transition, "delay")) {
          throw new Error(`[@zag-js/core > after] Delay is required for after transition: ${JSON.stringify(transition)}`);
        }
        const determineDelay = determineDelayFn(transition.delay, this.delayMap);
        const __delay = determineDelay(this.contextSnapshot, event);
        const actions = this.getAfterActions(transition, __delay);
        entries.push(actions.entry);
        exits.push(actions.exit);
        return { entries, exits };
      }
      if (isObject41(stateNode.after)) {
        for (const delay3 in stateNode.after) {
          const transition = stateNode.after[delay3];
          const determineDelay = determineDelayFn(delay3, this.delayMap);
          const __delay = determineDelay(this.contextSnapshot, event);
          const actions = this.getAfterActions(transition, __delay);
          entries.push(actions.entry);
          exits.push(actions.exit);
        }
      }
      return { entries, exits };
    });
    __publicField5(this, "executeActions", (actions, event) => {
      var _a8;
      const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta);
      for (const action of toArray2(pickedActions)) {
        const fn = isString22(action) ? (_a8 = this.actionMap) == null ? void 0 : _a8[action] : action;
        warn2(
          isString22(action) && !fn,
          `[@zag-js/core > execute-actions] No implementation found for action: \`${action}\``
        );
        fn == null ? void 0 : fn(this.state.context, event, this.meta);
      }
    });
    __publicField5(this, "executeActivities", (event, activities, state2) => {
      var _a8;
      for (const activity of activities) {
        const fn = isString22(activity) ? (_a8 = this.activityMap) == null ? void 0 : _a8[activity] : activity;
        if (!fn) {
          warn2(`[@zag-js/core > execute-activity] No implementation found for activity: \`${activity}\``);
          continue;
        }
        const cleanup = fn(this.state.context, event, this.meta);
        if (cleanup) {
          const key = isString22(activity) ? activity : activity.name || uuid2();
          this.addActivityCleanup(state2 ?? this.state.value, key, cleanup);
        }
      }
    });
    __publicField5(this, "createEveryActivities", (every, callbackfn) => {
      if (!every) return;
      if (isArray3(every)) {
        const picked = toArray2(every).find((transition) => {
          const delayOrFn = transition.delay;
          const determineDelay2 = determineDelayFn(delayOrFn, this.delayMap);
          const delay22 = determineDelay2(this.contextSnapshot, this.state.event);
          const determineGuard = determineGuardFn(transition.guard, this.guardMap);
          const guard = determineGuard(this.contextSnapshot, this.state.event, this.guardMeta);
          return guard ?? delay22 != null;
        });
        if (!picked) return;
        const determineDelay = determineDelayFn(picked.delay, this.delayMap);
        const delay3 = determineDelay(this.contextSnapshot, this.state.event);
        const activity = () => {
          const id = globalThis.setInterval(() => {
            this.executeActions(picked.actions, this.state.event);
          }, delay3);
          return () => {
            globalThis.clearInterval(id);
          };
        };
        callbackfn(activity);
      } else {
        for (const interval in every) {
          const actions = every == null ? void 0 : every[interval];
          const determineDelay = determineDelayFn(interval, this.delayMap);
          const delay3 = determineDelay(this.contextSnapshot, this.state.event);
          const activity = () => {
            const id = globalThis.setInterval(() => {
              this.executeActions(actions, this.state.event);
            }, delay3);
            return () => {
              globalThis.clearInterval(id);
            };
          };
          callbackfn(activity);
        }
      }
    });
    __publicField5(this, "setEvent", (event) => {
      this.state.previousEvent = this.state.event;
      this.state.event = ref35(toEvent(event));
    });
    __publicField5(this, "performExitEffects", (current, event) => {
      const currentState = this.state.value;
      if (currentState === "") return;
      const stateNode = current ? this.getStateNode(current) : void 0;
      this.stopActivities(currentState);
      const _exit = determineActionsFn(stateNode == null ? void 0 : stateNode.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta);
      const exitActions = toArray2(_exit);
      const afterExitActions = this.delayedEvents.get(currentState);
      if (afterExitActions) {
        exitActions.push(...afterExitActions);
      }
      this.executeActions(exitActions, event);
      this.delayedEvents.delete(currentState);
    });
    __publicField5(this, "performEntryEffects", (next3, event) => {
      const stateNode = this.getStateNode(next3);
      const activities = toArray2(stateNode == null ? void 0 : stateNode.activities);
      this.createEveryActivities(stateNode == null ? void 0 : stateNode.every, (activity) => {
        activities.unshift(activity);
      });
      if (activities.length > 0) {
        this.executeActivities(event, activities);
      }
      const pickedActions = determineActionsFn(stateNode == null ? void 0 : stateNode.entry, this.guardMap)(
        this.contextSnapshot,
        event,
        this.guardMeta
      );
      const entryActions = toArray2(pickedActions);
      const afterActions = this.getDelayedEventActions(next3);
      if ((stateNode == null ? void 0 : stateNode.after) && afterActions) {
        this.delayedEvents.set(next3, afterActions == null ? void 0 : afterActions.exits);
        entryActions.push(...afterActions.entries);
      }
      this.executeActions(entryActions, event);
      if ((stateNode == null ? void 0 : stateNode.type) === "final") {
        this.state.done = true;
        this.doneListeners.forEach((listener) => {
          listener(this.stateSnapshot);
        });
        this.stop();
      }
    });
    __publicField5(this, "performTransitionEffects", (transitions, event) => {
      const transition = this.determineTransition(transitions, event);
      this.executeActions(transition == null ? void 0 : transition.actions, event);
    });
    __publicField5(this, "performStateChangeEffects", (current, next3, event) => {
      this.setEvent(event);
      const changed = next3.changed || next3.reenter;
      if (changed) {
        this.performExitEffects(current, event);
      }
      this.performTransitionEffects(next3.transition, event);
      this.setState(next3.target);
      if (changed) {
        this.performEntryEffects(next3.target, event);
      }
    });
    __publicField5(this, "determineTransition", (transition, event) => {
      const fn = determineTransitionFn(transition, this.guardMap);
      return fn == null ? void 0 : fn(this.contextSnapshot, event, this.guardMeta);
    });
    __publicField5(this, "sendParent", (evt) => {
      var _a8;
      if (!this.parent) {
        invariant2("[@zag-js/core > send-parent] Cannot send event to an unknown parent");
      }
      const event = toEvent(evt);
      (_a8 = this.parent) == null ? void 0 : _a8.send(event);
    });
    __publicField5(this, "log", (...args) => {
      if (isDev36() && this.options.debug) {
        console.log(...args);
      }
    });
    __publicField5(this, "send", (evt) => {
      const event = toEvent(evt);
      this.transition(this.state.value, event);
    });
    __publicField5(this, "transition", (state2, evt) => {
      var _a8, _b7;
      const stateNode = isString22(state2) ? this.getStateNode(state2) : state2 == null ? void 0 : state2.stateNode;
      const event = toEvent(evt);
      if (!stateNode && !this.config.on) {
        const msg = this.status === "Stopped" ? "[@zag-js/core > transition] Cannot transition a stopped machine" : `[@zag-js/core > transition] State does not have a definition for \`state\`: ${state2}, \`event\`: ${event.type}`;
        warn2(msg);
        return;
      }
      const transitions = (
        // @ts-expect-error - Fix this
        ((_a8 = stateNode == null ? void 0 : stateNode.on) == null ? void 0 : _a8[event.type]) ?? ((_b7 = this.config.on) == null ? void 0 : _b7[event.type])
      );
      const next3 = this.getNextStateInfo(transitions, event);
      this.performStateChangeEffects(this.state.value, next3, event);
      return next3.stateNode;
    });
    __publicField5(this, "subscribe", (listener) => {
      this.stateListeners.add(listener);
      if (this.status === "Running") {
        listener(this.stateSnapshot);
      }
      return () => {
        this.stateListeners.delete(listener);
      };
    });
    __publicField5(this, "onDone", (listener) => {
      this.doneListeners.add(listener);
      return this;
    });
    __publicField5(this, "onTransition", (listener) => {
      this.stateListeners.add(listener);
      if (this.status === "Running") {
        listener(this.stateSnapshot);
      }
      return this;
    });
    this.config = structuredClone2(config);
    this.options = structuredClone2(options ?? {});
    this.id = this.config.id ?? `machine-${uuid2()}`;
    this.guardMap = ((_a7 = this.options) == null ? void 0 : _a7.guards) ?? {};
    this.actionMap = ((_b6 = this.options) == null ? void 0 : _b6.actions) ?? {};
    this.delayMap = ((_c5 = this.options) == null ? void 0 : _c5.delays) ?? {};
    this.activityMap = ((_d5 = this.options) == null ? void 0 : _d5.activities) ?? {};
    this.sync = ((_e6 = this.options) == null ? void 0 : _e6.sync) ?? false;
    this.state = createProxy3(this.config);
    this.initialContext = snapshot35(this.state.context);
  }
  // immutable state value
  get stateSnapshot() {
    return cast2(snapshot35(this.state));
  }
  getState() {
    return this.stateSnapshot;
  }
  // immutable context value
  get contextSnapshot() {
    return this.stateSnapshot.context;
  }
  /**
   * A reference to the instance methods of the machine.
   * Useful when spawning child machines and managing the communication between them.
   */
  get self() {
    const self2 = this;
    return {
      id: this.id,
      send: this.send.bind(this),
      sendParent: this.sendParent.bind(this),
      sendChild: this.sendChild.bind(this),
      stop: this.stop.bind(this),
      stopChild: this.stopChild.bind(this),
      spawn: this.spawn.bind(this),
      stopActivity: this.stopActivity.bind(this),
      get state() {
        return self2.stateSnapshot;
      },
      get initialContext() {
        return self2.initialContext;
      },
      get initialState() {
        var _a7;
        return ((_a7 = self2.initialState) == null ? void 0 : _a7.target) ?? "";
      }
    };
  }
  get meta() {
    var _a7;
    return {
      state: this.stateSnapshot,
      guards: this.guardMap,
      send: this.send.bind(this),
      self: this.self,
      initialContext: this.initialContext,
      initialState: ((_a7 = this.initialState) == null ? void 0 : _a7.target) ?? "",
      getState: () => this.stateSnapshot,
      getAction: (key) => this.actionMap[key],
      getGuard: (key) => this.guardMap[key]
    };
  }
  get guardMeta() {
    return {
      state: this.stateSnapshot
    };
  }
  get [Symbol.toStringTag]() {
    return "Machine";
  }
  getHydrationState() {
    const state2 = this.getState();
    return {
      value: state2.value,
      tags: state2.tags
    };
  }
};
var createMachine35 = (config, options) => new Machine(config, options);
var isMachine2 = (value) => {
  return value instanceof Machine || (value == null ? void 0 : value.type) === "machine";
};
var clsx2 = (...args) => args.map((str) => {
  var _a7;
  return (_a7 = str == null ? void 0 : str.trim) == null ? void 0 : _a7.call(str);
}).filter(Boolean).join(" ");
var CSS_REGEX = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
var serialize2 = (style) => {
  const res = {};
  let match50;
  while (match50 = CSS_REGEX.exec(style)) {
    res[match50[1]] = match50[2];
  }
  return res;
};
var css = (a, b) => {
  if (isString22(a)) {
    if (isString22(b)) return `${a};${b}`;
    a = serialize2(a);
  } else if (isString22(b)) {
    b = serialize2(b);
  }
  return Object.assign({}, a ?? {}, b ?? {});
};
function mergeProps3(...args) {
  let result = {};
  for (let props52 of args) {
    for (let key in result) {
      if (key.startsWith("on") && typeof result[key] === "function" && typeof props52[key] === "function") {
        result[key] = callAll3(props52[key], result[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx2(result[key], props52[key]);
        continue;
      }
      if (key === "style") {
        result[key] = css(result[key], props52[key]);
        continue;
      }
      result[key] = props52[key] !== void 0 ? props52[key] : result[key];
    }
    for (let key in props52) {
      if (result[key] === void 0) {
        result[key] = props52[key];
      }
    }
  }
  return result;
}

// node_modules/@ark-ui/react/dist/components/collection.js
var createListCollection = (options) => ref35(new ListCollection(options));

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion-context.js
var [AccordionProvider, useAccordionContext] = createContext({
  name: "AccordionContext",
  hookName: "useAccordionContext",
  providerName: "<AccordionProvider />"
});

// node_modules/@ark-ui/react/dist/components/accordion/accordion-context.js
var AccordionContext = (props52) => props52.children(useAccordionContext());

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/node_modules/@zag-js/anatomy/dist/index.mjs
var createAnatomy2 = (name, parts64 = []) => ({
  parts: (...values) => {
    if (isEmpty2(parts64)) {
      return createAnatomy2(name, values);
    }
    throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
  },
  extendWith: (...values) => createAnatomy2(name, [...parts64, ...values]),
  rename: (newName) => createAnatomy2(newName, parts64),
  keys: () => parts64,
  build: () => [...new Set(parts64)].reduce(
    (prev3, part) => Object.assign(prev3, {
      [part]: {
        selector: [
          `&[data-scope="${toKebabCase2(name)}"][data-part="${toKebabCase2(part)}"]`,
          `& [data-scope="${toKebabCase2(name)}"][data-part="${toKebabCase2(part)}"]`
        ].join(", "),
        attrs: { "data-scope": toKebabCase2(name), "data-part": toKebabCase2(part) }
      }
    }),
    {}
  )
});
var toKebabCase2 = (value) => value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty2 = (v) => v.length === 0;

// node_modules/@ark-ui/react/node_modules/@zag-js/text-selection/dist/index.mjs
var state = "default";
var userSelect = "";
var elementMap = /* @__PURE__ */ new WeakMap();
function disableTextSelectionImpl(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state === "default") {
      userSelect = rootEl.style.webkitUserSelect;
      rootEl.style.webkitUserSelect = "none";
    }
    state = "disabled";
  } else if (target) {
    elementMap.set(target, target.style.userSelect);
    target.style.userSelect = "none";
  }
  return () => restoreTextSelection2({ target, doc: docNode });
}
function restoreTextSelection2(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state !== "disabled") return;
    state = "restoring";
    setTimeout(() => {
      nextTick(() => {
        if (state === "restoring") {
          if (rootEl.style.webkitUserSelect === "none") {
            rootEl.style.webkitUserSelect = userSelect || "";
          }
          userSelect = "";
          state = "default";
        }
      });
    }, 300);
  } else {
    if (target && elementMap.has(target)) {
      const prevUserSelect = elementMap.get(target);
      if (target.style.userSelect === "none") {
        target.style.userSelect = prevUserSelect ?? "";
      }
      if (target.getAttribute("style") === "") {
        target.removeAttribute("style");
      }
      elementMap.delete(target);
    }
  }
}
function disableTextSelection2(options = {}) {
  const { defer, target, ...restOptions } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof target === "function" ? target() : target;
      cleanups2.push(disableTextSelectionImpl({ ...restOptions, target: node2 }));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}

// node_modules/@ark-ui/react/node_modules/@zag-js/dom-event/dist/index.mjs
var addDomEvent2 = (target, eventName, handler, options) => {
  const node2 = typeof target === "function" ? target() : target;
  node2 == null ? void 0 : node2.addEventListener(eventName, handler, options);
  return () => {
    node2 == null ? void 0 : node2.removeEventListener(eventName, handler, options);
  };
};
function isPrintableKey2(e) {
  return e.key.length === 1 && !e.ctrlKey && !e.metaKey;
}
var isLeftClick2 = (e) => e.button === 0;
var isContextMenuEvent2 = (e) => {
  return e.button === 2 || isMac() && e.ctrlKey && e.button === 0;
};
var isModifierKey2 = (e) => e.ctrlKey || e.altKey || e.metaKey;
function queueBeforeEvent2(element, type, cb) {
  const createTimer = (callback) => {
    const timerId = requestAnimationFrame(callback);
    return () => cancelAnimationFrame(timerId);
  };
  const cancelTimer = createTimer(() => {
    element.removeEventListener(type, callSync, true);
    cb();
  });
  const callSync = () => {
    cancelTimer();
    cb();
  };
  element.addEventListener(type, callSync, { once: true, capture: true });
  return cancelTimer;
}
function isLinkElement(element) {
  return (element == null ? void 0 : element.matches("a[href]")) ?? false;
}
function clickIfLink2(element) {
  if (!isLinkElement(element)) return;
  const click = () => element.click();
  if (isFirefox()) {
    queueBeforeEvent2(element, "keyup", click);
  } else {
    queueMicrotask(click);
  }
}
function fireCustomEvent2(el, type, init) {
  if (!el) return;
  const win = el.ownerDocument.defaultView || window;
  const event = new win.CustomEvent(type, init);
  return el.dispatchEvent(event);
}
var keyMap = {
  Up: "ArrowUp",
  Down: "ArrowDown",
  Esc: "Escape",
  " ": "Space",
  ",": "Comma",
  Left: "ArrowLeft",
  Right: "ArrowRight"
};
var rtlKeyMap = {
  ArrowLeft: "ArrowRight",
  ArrowRight: "ArrowLeft"
};
function getEventKey2(event, options = {}) {
  const { dir = "ltr", orientation = "horizontal" } = options;
  let { key } = event;
  key = keyMap[key] ?? key;
  const isRtl = dir === "rtl" && orientation === "horizontal";
  if (isRtl && key in rtlKeyMap) {
    key = rtlKeyMap[key];
  }
  return key;
}
function pointFromTouch(e, type = "client") {
  const point = e.touches[0] || e.changedTouches[0];
  return { x: point[`${type}X`], y: point[`${type}Y`] };
}
function pointFromMouse(point, type = "client") {
  return { x: point[`${type}X`], y: point[`${type}Y`] };
}
var isTouchEvent = (event) => "touches" in event && event.touches.length > 0;
function getEventPoint2(event, type = "client") {
  return isTouchEvent(event) ? pointFromTouch(event, type) : pointFromMouse(event, type);
}
var PAGE_KEYS = /* @__PURE__ */ new Set(["PageUp", "PageDown"]);
var ARROW_KEYS = /* @__PURE__ */ new Set(["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]);
function getEventStep2(event) {
  if (event.ctrlKey || event.metaKey) {
    return 0.1;
  } else {
    const isPageKey = PAGE_KEYS.has(event.key);
    const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.has(event.key);
    return isSkipKey ? 10 : 1;
  }
}
function getNativeEvent2(event) {
  return event.nativeEvent ?? event;
}
function clamp4(value) {
  return Math.max(0, Math.min(1, value));
}
function getRelativePoint2(point, element) {
  const { left, top, width, height } = element.getBoundingClientRect();
  const offset4 = { x: point.x - left, y: point.y - top };
  const percent = { x: clamp4(offset4.x / width), y: clamp4(offset4.y / height) };
  function getPercentValue3(options = {}) {
    const { dir = "ltr", orientation = "horizontal", inverted } = options;
    const invertX = typeof inverted === "object" ? inverted.x : inverted;
    const invertY = typeof inverted === "object" ? inverted.y : inverted;
    if (orientation === "horizontal") {
      return dir === "rtl" || invertX ? 1 - percent.x : percent.x;
    }
    return invertY ? 1 - percent.y : percent.y;
  }
  return { offset: offset4, percent, getPercentValue: getPercentValue3 };
}
function requestPointerLock2(doc, fn) {
  const body = doc.body;
  const supported = "pointerLockElement" in doc || "mozPointerLockElement" in doc;
  const isLocked = () => !!doc.pointerLockElement;
  function onPointerChange() {
    fn == null ? void 0 : fn(isLocked());
  }
  function onPointerError(event) {
    if (isLocked()) fn == null ? void 0 : fn(false);
    console.error("PointerLock error occured:", event);
    doc.exitPointerLock();
  }
  if (!supported) return;
  try {
    body.requestPointerLock();
  } catch {
  }
  const cleanup = [
    addDomEvent2(doc, "pointerlockchange", onPointerChange, false),
    addDomEvent2(doc, "pointerlockerror", onPointerError, false)
  ];
  return () => {
    cleanup.forEach((cleanup2) => cleanup2());
    doc.exitPointerLock();
  };
}
function trackPointerMove2(doc, handlers) {
  const { onPointerMove, onPointerUp } = handlers;
  const history = [];
  const handleMove = (event) => {
    const point = getEventPoint2(event);
    history.push({ ...point, timestamp: performance.now() });
    const distance = Math.sqrt(point.x ** 2 + point.y ** 2);
    const moveBuffer = event.pointerType === "touch" ? 10 : 5;
    if (distance < moveBuffer) return;
    if (event.pointerType === "mouse" && event.button === 0) {
      onPointerUp();
      return;
    }
    onPointerMove({ point, event, velocity: getVelocity(history, 0.1) });
  };
  const cleanups2 = [
    addDomEvent2(doc, "pointermove", handleMove, false),
    addDomEvent2(doc, "pointerup", onPointerUp, false),
    addDomEvent2(doc, "pointercancel", onPointerUp, false),
    addDomEvent2(doc, "contextmenu", onPointerUp, false),
    disableTextSelection2({ doc })
  ];
  return () => {
    cleanups2.forEach((cleanup) => cleanup());
    history.length = 0;
  };
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function ms(seconds) {
  return seconds * 1e3;
}
function sec(milliseconds) {
  return milliseconds / 1e3;
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) return { x: 0, y: 0 };
  let i = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > ms(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) return { x: 0, y: 0 };
  const time = sec(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time === 0) return { x: 0, y: 0 };
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };
  if (currentVelocity.x === Infinity) currentVelocity.x = 0;
  if (currentVelocity.y === Infinity) currentVelocity.y = 0;
  return {
    x: Math.abs(currentVelocity.x),
    y: Math.abs(currentVelocity.y)
  };
}
var pipe = (...fns) => (arg) => fns.reduce((acc, fn) => fn(acc), arg);
var noop3 = () => void 0;
function trackPress2(options) {
  const {
    pointerNode,
    keyboardNode = pointerNode,
    onPress,
    onPressStart,
    onPressEnd,
    isValidKey: isValidKey2 = (e) => e.key === "Enter"
  } = options;
  if (!pointerNode) return noop3;
  const win = getWindow(pointerNode);
  const doc = getDocument(pointerNode);
  let removeStartListeners = noop3;
  let removeEndListeners = noop3;
  let removeAccessibleListeners = noop3;
  const getInfo = (event) => ({
    point: getEventPoint2(event),
    event
  });
  function startPress(event) {
    onPressStart == null ? void 0 : onPressStart(getInfo(event));
  }
  function cancelPress(event) {
    onPressEnd == null ? void 0 : onPressEnd(getInfo(event));
  }
  const startPointerPress = (startEvent) => {
    removeEndListeners();
    const endPointerPress = (endEvent) => {
      const target = getEventTarget(endEvent);
      if (contains(pointerNode, target)) {
        onPress == null ? void 0 : onPress(getInfo(endEvent));
      } else {
        onPressEnd == null ? void 0 : onPressEnd(getInfo(endEvent));
      }
    };
    const removePointerUpListener = addDomEvent2(win, "pointerup", endPointerPress, { passive: !onPress });
    const removePointerCancelListener = addDomEvent2(win, "pointercancel", cancelPress, { passive: !onPressEnd });
    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
    if (doc.activeElement === keyboardNode && startEvent.pointerType === "mouse") {
      startEvent.preventDefault();
    }
    startPress(startEvent);
  };
  const removePointerListener = addDomEvent2(pointerNode, "pointerdown", startPointerPress, { passive: !onPressStart });
  const removeFocusListener = addDomEvent2(keyboardNode, "focus", startAccessiblePress);
  removeStartListeners = pipe(removePointerListener, removeFocusListener);
  function startAccessiblePress() {
    const handleKeydown = (keydownEvent) => {
      if (!isValidKey2(keydownEvent)) return;
      const handleKeyup = (keyupEvent) => {
        if (!isValidKey2(keyupEvent)) return;
        const evt2 = new win.PointerEvent("pointerup");
        const info = getInfo(evt2);
        onPress == null ? void 0 : onPress(info);
        onPressEnd == null ? void 0 : onPressEnd(info);
      };
      removeEndListeners();
      removeEndListeners = addDomEvent2(keyboardNode, "keyup", handleKeyup);
      const evt = new win.PointerEvent("pointerdown");
      startPress(evt);
    };
    const handleBlur = () => {
      const evt = new win.PointerEvent("pointercancel");
      cancelPress(evt);
    };
    const removeKeydownListener = addDomEvent2(keyboardNode, "keydown", handleKeydown);
    const removeBlurListener = addDomEvent2(keyboardNode, "blur", handleBlur);
    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
  }
  return function() {
    removeStartListeners();
    removeEndListeners();
    removeAccessibleListeners();
  };
}

// node_modules/@ark-ui/react/node_modules/@zag-js/utils/dist/index.mjs
var first2 = (v) => v[0];
var last2 = (v) => v[v.length - 1];
var has = (v, t) => v.indexOf(t) !== -1;
var add3 = (v, ...items) => v.concat(items);
var remove2 = (v, item) => v.filter((t) => t !== item);
var addOrRemove2 = (v, item) => {
  if (has(v, item)) return remove2(v, item);
  return add3(v, item);
};
var isArrayLike3 = (value) => (value == null ? void 0 : value.constructor.name) === "Array";
var isArrayEqual3 = (a, b) => {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (!isEqual3(a[i], b[i])) return false;
  }
  return true;
};
var isEqual3 = (a, b) => {
  if (Object.is(a, b)) return true;
  if (a == null && b != null || a != null && b == null) return false;
  if (typeof (a == null ? void 0 : a.isEqual) === "function" && typeof (b == null ? void 0 : b.isEqual) === "function") {
    return a.isEqual(b);
  }
  if (typeof a === "function" && typeof b === "function") {
    return a.toString() === b.toString();
  }
  if (isArrayLike3(a) && isArrayLike3(b)) {
    return isArrayEqual3(Array.from(a), Array.from(b));
  }
  if (!(typeof a === "object") || !(typeof b === "object")) return false;
  const keys = Object.keys(b ?? /* @__PURE__ */ Object.create(null));
  const length2 = keys.length;
  for (let i = 0; i < length2; i++) {
    const hasKey = Reflect.has(a, keys[i]);
    if (!hasKey) return false;
  }
  for (let i = 0; i < length2; i++) {
    const key = keys[i];
    if (!isEqual3(a[key], b[key])) return false;
  }
  return true;
};
var runIfFn3 = (v, ...a) => {
  const res = typeof v === "function" ? v(...a) : v;
  return res ?? void 0;
};
var cast3 = (v) => v;
var noop4 = () => {
};
var callAll4 = (...fns) => (...a) => {
  fns.forEach(function(fn) {
    fn == null ? void 0 : fn(...a);
  });
};
var uuid3 = /* @__PURE__ */ (() => {
  let id = 0;
  return () => {
    id++;
    return id.toString(36);
  };
})();
var isNumber3 = (v) => typeof v === "number" && !Number.isNaN(v);
var isString23 = (v) => typeof v === "string";
var isFunction23 = (v) => typeof v === "function";
var isNull2 = (v) => v == null;
var fnToString3 = Function.prototype.toString;
var objectCtorString3 = fnToString3.call(Object);
function splitProps30(props52, keys) {
  const rest = {};
  const result = {};
  const keySet = new Set(keys);
  for (const key in props52) {
    if (keySet.has(key)) {
      result[key] = props52[key];
    } else {
      rest[key] = props52[key];
    }
  }
  return [result, rest];
}
var createSplitProps2 = (keys) => {
  return function split(props52) {
    return splitProps30(props52, keys);
  };
};
function compact4(obj) {
  if (!isPlainObject22(obj) || obj === void 0) {
    return obj;
  }
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact4(value);
    }
  }
  return filtered;
}
var isPlainObject22 = (value) => {
  return value && typeof value === "object" && value.constructor === Object;
};
function warn3(...a) {
  const m = a.length === 1 ? a[0] : a[1];
  const c = a.length === 2 ? a[0] : true;
  if (c && true) {
    console.warn(m);
  }
}
function invariant3(...a) {
  const m = a.length === 1 ? a[0] : a[1];
  const c = a.length === 2 ? a[0] : true;
  if (c && true) {
    throw new Error(m);
  }
}

// node_modules/@zag-js/types/dist/index.mjs
function createNormalizer(fn) {
  return new Proxy({}, {
    get() {
      return fn;
    }
  });
}
var createProps30 = () => (props52) => Array.from(new Set(props52));

// node_modules/@ark-ui/react/node_modules/@zag-js/accordion/dist/index.mjs
var anatomy42 = createAnatomy2("accordion").parts("root", "item", "itemTrigger", "itemContent", "itemIndicator");
var parts35 = anatomy42.build();
var dom35 = createScope({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `accordion:${ctx.id}`;
  },
  getItemId: (ctx, value) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.item) == null ? void 0 : _b6.call(_a7, value)) ?? `accordion:${ctx.id}:item:${value}`;
  },
  getItemContentId: (ctx, value) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemContent) == null ? void 0 : _b6.call(_a7, value)) ?? `accordion:${ctx.id}:content:${value}`;
  },
  getItemTriggerId: (ctx, value) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemTrigger) == null ? void 0 : _b6.call(_a7, value)) ?? `accordion:${ctx.id}:trigger:${value}`;
  },
  getRootEl: (ctx) => dom35.getById(ctx, dom35.getRootId(ctx)),
  getTriggerEls: (ctx) => {
    const ownerId = CSS.escape(dom35.getRootId(ctx));
    const selector = `[aria-controls][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom35.getRootEl(ctx), selector);
  },
  getFirstTriggerEl: (ctx) => first2(dom35.getTriggerEls(ctx)),
  getLastTriggerEl: (ctx) => last2(dom35.getTriggerEls(ctx)),
  getNextTriggerEl: (ctx, id) => nextById(dom35.getTriggerEls(ctx), dom35.getItemTriggerId(ctx, id)),
  getPrevTriggerEl: (ctx, id) => prevById(dom35.getTriggerEls(ctx), dom35.getItemTriggerId(ctx, id))
});
function connect(state2, send, normalize2) {
  const focusedValue = state2.context.focusedValue;
  const value = state2.context.value;
  const multiple = state2.context.multiple;
  function setValue(value2) {
    let nextValue = value2;
    if (multiple && nextValue.length > 1) {
      nextValue = [nextValue[0]];
    }
    send({ type: "VALUE.SET", value: nextValue });
  }
  function getItemState(props210) {
    return {
      expanded: value.includes(props210.value),
      focused: focusedValue === props210.value,
      disabled: Boolean(props210.disabled ?? state2.context.disabled)
    };
  }
  return {
    focusedValue,
    value,
    setValue,
    getItemState,
    getRootProps() {
      return normalize2.element({
        ...parts35.root.attrs,
        dir: state2.context.dir,
        id: dom35.getRootId(state2.context),
        "data-orientation": state2.context.orientation
      });
    },
    getItemProps(props210) {
      const itemState = getItemState(props210);
      return normalize2.element({
        ...parts35.item.attrs,
        dir: state2.context.dir,
        id: dom35.getItemId(state2.context, props210.value),
        "data-state": itemState.expanded ? "open" : "closed",
        "data-focus": dataAttr(itemState.focused),
        "data-disabled": dataAttr(itemState.disabled),
        "data-orientation": state2.context.orientation
      });
    },
    getItemContentProps(props210) {
      const itemState = getItemState(props210);
      return normalize2.element({
        ...parts35.itemContent.attrs,
        dir: state2.context.dir,
        role: "region",
        id: dom35.getItemContentId(state2.context, props210.value),
        "aria-labelledby": dom35.getItemTriggerId(state2.context, props210.value),
        hidden: !itemState.expanded,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(itemState.disabled),
        "data-focus": dataAttr(itemState.focused),
        "data-orientation": state2.context.orientation
      });
    },
    getItemIndicatorProps(props210) {
      const itemState = getItemState(props210);
      return normalize2.element({
        ...parts35.itemIndicator.attrs,
        dir: state2.context.dir,
        "aria-hidden": true,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(itemState.disabled),
        "data-focus": dataAttr(itemState.focused),
        "data-orientation": state2.context.orientation
      });
    },
    getItemTriggerProps(props210) {
      const { value: value2 } = props210;
      const itemState = getItemState(props210);
      return normalize2.button({
        ...parts35.itemTrigger.attrs,
        type: "button",
        dir: state2.context.dir,
        id: dom35.getItemTriggerId(state2.context, value2),
        "aria-controls": dom35.getItemContentId(state2.context, value2),
        "aria-expanded": itemState.expanded,
        disabled: itemState.disabled,
        "data-orientation": state2.context.orientation,
        "aria-disabled": itemState.disabled,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-ownedby": dom35.getRootId(state2.context),
        onFocus() {
          if (itemState.disabled) return;
          send({ type: "TRIGGER.FOCUS", value: value2 });
        },
        onBlur() {
          if (itemState.disabled) return;
          send("TRIGGER.BLUR");
        },
        onClick(event) {
          if (itemState.disabled) return;
          if (isSafari()) {
            event.currentTarget.focus();
          }
          send({ type: "TRIGGER.CLICK", value: value2 });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (itemState.disabled) return;
          const keyMap2 = {
            ArrowDown() {
              if (state2.context.isHorizontal) return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowUp() {
              if (state2.context.isHorizontal) return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            ArrowRight() {
              if (!state2.context.isHorizontal) return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowLeft() {
              if (!state2.context.isHorizontal) return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            Home() {
              send({ type: "GOTO.FIRST", value: value2 });
            },
            End() {
              send({ type: "GOTO.LAST", value: value2 });
            }
          };
          const key = getEventKey2(event, {
            dir: state2.context.dir,
            orientation: state2.context.orientation
          });
          const exec21 = keyMap2[key];
          if (exec21) {
            exec21(event);
            event.preventDefault();
          }
        }
      });
    }
  };
}
var { and: and35, not: not36 } = guards20;
function machine(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "accordion",
      initial: "idle",
      context: {
        focusedValue: null,
        value: [],
        collapsible: false,
        multiple: false,
        orientation: "vertical",
        ...ctx
      },
      watch: {
        value: "coarseValue",
        multiple: "coarseValue"
      },
      created: "coarseValue",
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal"
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        }
      },
      states: {
        idle: {
          on: {
            "TRIGGER.FOCUS": {
              target: "focused",
              actions: "setFocusedValue"
            }
          }
        },
        focused: {
          on: {
            "GOTO.NEXT": {
              actions: "focusNextTrigger"
            },
            "GOTO.PREV": {
              actions: "focusPrevTrigger"
            },
            "TRIGGER.CLICK": [
              {
                guard: and35("isExpanded", "canToggle"),
                actions: ["collapse"]
              },
              {
                guard: not36("isExpanded"),
                actions: ["expand"]
              }
            ],
            "GOTO.FIRST": {
              actions: "focusFirstTrigger"
            },
            "GOTO.LAST": {
              actions: "focusLastTrigger"
            },
            "TRIGGER.BLUR": {
              target: "idle",
              actions: "clearFocusedValue"
            }
          }
        }
      }
    },
    {
      guards: {
        canToggle: (ctx2) => !!ctx2.collapsible || !!ctx2.multiple,
        isExpanded: (ctx2, evt) => ctx2.value.includes(evt.value)
      },
      actions: {
        collapse(ctx2, evt) {
          const next3 = ctx2.multiple ? remove2(ctx2.value, evt.value) : [];
          set3.value(ctx2, ctx2.multiple ? next3 : []);
        },
        expand(ctx2, evt) {
          const next3 = ctx2.multiple ? add3(ctx2.value, evt.value) : [evt.value];
          set3.value(ctx2, next3);
        },
        focusFirstTrigger(ctx2) {
          var _a7;
          (_a7 = dom35.getFirstTriggerEl(ctx2)) == null ? void 0 : _a7.focus();
        },
        focusLastTrigger(ctx2) {
          var _a7;
          (_a7 = dom35.getLastTriggerEl(ctx2)) == null ? void 0 : _a7.focus();
        },
        focusNextTrigger(ctx2) {
          if (!ctx2.focusedValue) return;
          const triggerEl = dom35.getNextTriggerEl(ctx2, ctx2.focusedValue);
          triggerEl == null ? void 0 : triggerEl.focus();
        },
        focusPrevTrigger(ctx2) {
          if (!ctx2.focusedValue) return;
          const triggerEl = dom35.getPrevTriggerEl(ctx2, ctx2.focusedValue);
          triggerEl == null ? void 0 : triggerEl.focus();
        },
        setFocusedValue(ctx2, evt) {
          set3.focusedValue(ctx2, evt.value);
        },
        clearFocusedValue(ctx2) {
          set3.focusedValue(ctx2, null);
        },
        setValue(ctx2, evt) {
          set3.value(ctx2, evt.value);
        },
        coarseValue(ctx2) {
          if (!ctx2.multiple && ctx2.value.length > 1) {
            warn3(`The value of accordion should be a single value when multiple is false.`);
            ctx2.value = [ctx2.value[0]];
          }
        }
      }
    }
  );
}
var invoke = {
  change(ctx) {
    var _a7;
    (_a7 = ctx.onValueChange) == null ? void 0 : _a7.call(ctx, { value: Array.from(ctx.value) });
  },
  focusChange(ctx) {
    var _a7;
    (_a7 = ctx.onFocusChange) == null ? void 0 : _a7.call(ctx, { value: ctx.focusedValue });
  }
};
var set3 = {
  value(ctx, value) {
    if (isEqual3(ctx.value, value)) return;
    ctx.value = value;
    invoke.change(ctx);
  },
  focusedValue(ctx, value) {
    if (isEqual3(ctx.focusedValue, value)) return;
    ctx.focusedValue = value;
    invoke.focusChange(ctx);
  }
};
var props29 = createProps30()([
  "collapsible",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "multiple",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "value"
]);
var splitProps31 = createSplitProps2(props29);
var itemProps10 = createProps30()(["value", "disabled"]);
var splitItemProps10 = createSplitProps2(itemProps10);

// node_modules/@zag-js/react/dist/index.mjs
var import_react19 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var normalizeProps = createNormalizer((v) => v);
var isArrayLike4 = (value) => (value == null ? void 0 : value.constructor.name) === "Array";
var isArrayEqual4 = (a, b) => {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (!isEqual4(a[i], b[i])) return false;
  }
  return true;
};
var isEqual4 = (a, b) => {
  if (Object.is(a, b)) return true;
  if (a == null && b != null || a != null && b == null) return false;
  if (typeof (a == null ? void 0 : a.isEqual) === "function" && typeof (b == null ? void 0 : b.isEqual) === "function") {
    return a.isEqual(b);
  }
  if (typeof a === "function" && typeof b === "function") {
    return a.toString() === b.toString();
  }
  if (isArrayLike4(a) && isArrayLike4(b)) {
    return isArrayEqual4(Array.from(a), Array.from(b));
  }
  if (!(typeof a === "object") || !(typeof b === "object")) return false;
  const keys = Object.keys(b ?? /* @__PURE__ */ Object.create(null));
  const length2 = keys.length;
  for (let i = 0; i < length2; i++) {
    const hasKey = Reflect.has(a, keys[i]);
    if (!hasKey) return false;
  }
  for (let i = 0; i < length2; i++) {
    const key = keys[i];
    if (!isEqual4(a[key], b[key])) return false;
  }
  return true;
};
var isDev37 = () => true;
var fnToString4 = Function.prototype.toString;
fnToString4.call(Object);
function compact5(obj) {
  if (!isPlainObject3(obj) || obj === void 0) {
    return obj;
  }
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact5(value);
    }
  }
  return filtered;
}
var isPlainObject3 = (value) => {
  return value && typeof value === "object" && value.constructor === Object;
};
function useUpdateEffect(callback, deps) {
  const render = (0, import_react19.useRef)(false);
  const effect = (0, import_react19.useRef)(false);
  (0, import_react19.useEffect)(() => {
    const mounted = render.current;
    const run = mounted && effect.current;
    if (run) {
      return callback();
    }
    effect.current = true;
  }, deps);
  (0, import_react19.useEffect)(() => {
    render.current = true;
    return () => {
      render.current = false;
    };
  }, []);
}
var { use } = import_react19.default;
var targetCache = makeGlobal35("__zag__targetCache", () => /* @__PURE__ */ new WeakMap());
function useSnapshot(service, options) {
  const { actions, context, sync: notifyInSync } = options ?? {};
  const lastSnapshot = (0, import_react19.useRef)();
  const lastAffected = (0, import_react19.useRef)();
  const currSnapshot = (0, import_react19.useSyncExternalStore)(
    (0, import_react19.useCallback)((callback) => subscribe35(service.state, callback, notifyInSync), [notifyInSync]),
    () => {
      const nextSnapshot = snapshot35(service.state, use);
      try {
        if (lastSnapshot.current && lastAffected.current && !isChanged(lastSnapshot.current, nextSnapshot, lastAffected.current, /* @__PURE__ */ new WeakMap())) {
          return lastSnapshot.current;
        }
      } catch {
      }
      return nextSnapshot;
    },
    () => snapshot35(service.state, use)
  );
  service.setOptions({ actions });
  const ctx = (0, import_react19.useMemo)(() => compact5(context ?? {}), [context]);
  useUpdateEffect(() => {
    const entries = Object.entries(ctx);
    const previousCtx = service.contextSnapshot ?? {};
    const equality = entries.map(([key, value]) => ({
      key,
      curr: value,
      prev: previousCtx[key],
      equal: isEqual4(previousCtx[key], value)
    }));
    const allEqual = equality.every(({ equal }) => equal);
    if (!allEqual) {
      service.setContext(ctx);
    }
  }, [ctx]);
  const currAffected = /* @__PURE__ */ new WeakMap();
  (0, import_react19.useEffect)(() => {
    lastSnapshot.current = currSnapshot;
    lastAffected.current = currAffected;
  });
  const proxyCache = (0, import_react19.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);
  return createProxy2(currSnapshot, currAffected, proxyCache, targetCache);
}
function useActor(service) {
  const state2 = useSnapshot(service);
  return [state2, service.send];
}
function useConstant(fn) {
  const ref36 = (0, import_react19.useRef)();
  if (!ref36.current) ref36.current = { v: fn() };
  return ref36.current.v;
}
var useSafeLayoutEffect = typeof document !== "undefined" ? import_react19.useLayoutEffect : import_react19.useEffect;
function useService(machine25, options) {
  const { state: hydratedState, context } = options ?? {};
  const service = useConstant(() => {
    const instance = typeof machine25 === "function" ? machine25() : machine25;
    if (context) instance.setContext(context);
    instance._created();
    return instance;
  });
  const snapshotRef = (0, import_react19.useRef)();
  useSafeLayoutEffect(() => {
    const stateInit = hydratedState ?? snapshotRef.current;
    service.start(stateInit);
    return () => {
      if (isDev37()) {
        snapshotRef.current = service.getHydrationState();
      }
      service.stop();
    };
  }, []);
  return service;
}
function useMachine(machine25, options) {
  const service = useService(machine25, options);
  const state2 = useSnapshot(service, options);
  return [state2, service.send, service];
}

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item.js
var import_react27 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion-item-context.js
var [AccordionItemProvider, useAccordionItemContext] = createContext({
  name: "AccordionItemContext",
  hookName: "useAccordionItemContext",
  providerName: "<AccordionItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-root.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react25 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/factory.js
var import_react20 = __toESM(require_react());

// node_modules/@ark-ui/react/dist/utils/compose-refs.js
function setRef(ref36, value) {
  if (typeof ref36 === "function") {
    ref36(value);
  } else if (ref36 !== null && ref36 !== void 0) {
    ref36.current = value;
  }
}
function composeRefs(...refs) {
  return (node2) => {
    for (const ref36 of refs) {
      setRef(ref36, node2);
    }
  };
}

// node_modules/@ark-ui/react/dist/components/factory.js
function getRef(element) {
  var _a7, _b6;
  let getter = (_a7 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a7.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b6 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b6.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var withAsChild = (Component) => {
  const Comp = (0, import_react20.memo)(
    (0, import_react20.forwardRef)((props52, ref36) => {
      const { asChild, children, ...restProps } = props52;
      if (!asChild) {
        return (0, import_react20.createElement)(Component, { ...restProps, ref: ref36 }, children);
      }
      const onlyChild = import_react20.Children.only(children);
      if (!(0, import_react20.isValidElement)(onlyChild)) {
        return null;
      }
      const childRef = getRef(onlyChild);
      return (0, import_react20.cloneElement)(onlyChild, {
        ...mergeProps3(restProps, onlyChild.props),
        ref: ref36 ? composeRefs(ref36, childRef) : childRef
      });
    })
  );
  Comp.displayName = Component.displayName || Component.name;
  return Comp;
};
var jsxFactory = () => {
  const cache2 = /* @__PURE__ */ new Map();
  return new Proxy(withAsChild, {
    apply(_target, _thisArg, argArray) {
      return withAsChild(argArray[0]);
    },
    get(_, element) {
      const asElement = element;
      if (!cache2.has(asElement)) {
        cache2.set(asElement, withAsChild(asElement));
      }
      return cache2.get(asElement);
    }
  });
};
var ark = jsxFactory();

// node_modules/@ark-ui/react/dist/utils/create-split-props.js
var createSplitProps3 = () => (props52, keys) => keys.reduce(
  (previousValue, currentValue) => {
    const [target, source] = previousValue;
    const key = currentValue;
    if (source[key] !== void 0) {
      target[key] = source[key];
    }
    delete source[key];
    return [target, source];
  },
  [{}, { ...props52 }]
);

// node_modules/@ark-ui/react/dist/components/collapsible/split-collapsible-props.js
var splitCollapsibleProps = (props52) => createSplitProps3()(props52, [
  "defaultOpen",
  "disabled",
  "id",
  "ids",
  "lazyMount",
  "onExitComplete",
  "onOpenChange",
  "open",
  "unmountOnExit"
]);

// node_modules/@ark-ui/react/node_modules/@zag-js/collapsible/dist/index.mjs
var anatomy43 = createAnatomy2("collapsible").parts("root", "trigger", "content");
var parts36 = anatomy43.build();
var dom36 = createScope({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `collapsible:${ctx.id}`;
  },
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `collapsible:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `collapsible:${ctx.id}:trigger`;
  },
  getRootEl: (ctx) => dom36.getById(ctx, dom36.getRootId(ctx)),
  getContentEl: (ctx) => dom36.getById(ctx, dom36.getContentId(ctx)),
  getTriggerEl: (ctx) => dom36.getById(ctx, dom36.getTriggerId(ctx))
});
function connect2(state2, send, normalize2) {
  const visible = state2.matches("open", "closing");
  const open = state2.matches("open");
  const height = state2.context.height;
  const width = state2.context.width;
  const disabled = !!state2.context.disabled;
  const skip = !state2.context.initial && open;
  return {
    disabled,
    visible,
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    getRootProps() {
      return normalize2.element({
        ...parts36.root.attrs,
        "data-state": open ? "open" : "closed",
        dir: state2.context.dir,
        id: dom36.getRootId(state2.context)
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts36.content.attrs,
        "data-state": skip ? void 0 : open ? "open" : "closed",
        id: dom36.getContentId(state2.context),
        "data-disabled": dataAttr(disabled),
        hidden: !visible,
        style: {
          "--height": height != null ? `${height}px` : void 0,
          "--width": width != null ? `${width}px` : void 0
        }
      });
    },
    getTriggerProps() {
      return normalize2.element({
        ...parts36.trigger.attrs,
        id: dom36.getTriggerId(state2.context),
        dir: state2.context.dir,
        type: "button",
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "aria-controls": dom36.getContentId(state2.context),
        "aria-expanded": visible || false,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          send({ type: open ? "CLOSE" : "OPEN", src: "trigger.click" });
        }
      });
    }
  };
}
function machine2(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "collapsible",
      initial: ctx.open ? "open" : "closed",
      context: {
        ...ctx,
        height: 0,
        width: 0,
        initial: false,
        stylesRef: null,
        unmountAnimationName: null
      },
      watch: {
        open: ["setInitial", "computeSize", "toggleVisibility"]
      },
      exit: ["clearInitial"],
      states: {
        closed: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": "open",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitial", "computeSize", "invokeOnOpen"]
              }
            ]
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackAnimationEvents"],
          on: {
            "CONTROLLED.CLOSE": "closed",
            "CONTROLLED.OPEN": "open",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitial", "invokeOnOpen"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnExitComplete"]
              },
              {
                target: "closed",
                actions: ["setInitial", "computeSize", "invokeOnExitComplete"]
              }
            ],
            "ANIMATION.END": {
              target: "closed",
              actions: ["invokeOnExitComplete"]
            }
          }
        },
        open: {
          tags: ["open"],
          on: {
            "CONTROLLED.CLOSE": "closing",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closing",
                actions: ["setInitial", "computeSize", "invokeOnClose"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackAnimationEvents(ctx2, _evt, { send }) {
          let cleanup;
          const rafCleanup = raf(() => {
            const contentEl = dom36.getContentEl(ctx2);
            if (!contentEl) return;
            const animationName = getComputedStyle2(contentEl).animationName;
            const hasNoAnimation = !animationName || animationName === "none";
            if (hasNoAnimation) {
              send({ type: "ANIMATION.END" });
              return;
            }
            const onEnd = (event) => {
              const win = contentEl.ownerDocument.defaultView || window;
              const animationName2 = win.getComputedStyle(contentEl).animationName;
              const target = getEventTarget(event);
              if (target === contentEl && animationName2 === ctx2.unmountAnimationName) {
                send({ type: "ANIMATION.END" });
              }
            };
            contentEl.addEventListener("animationend", onEnd);
            cleanup = () => {
              contentEl.removeEventListener("animationend", onEnd);
            };
          });
          return () => {
            rafCleanup();
            cleanup == null ? void 0 : cleanup();
          };
        }
      },
      actions: {
        setInitial(ctx2) {
          ctx2.initial = true;
        },
        clearInitial(ctx2) {
          ctx2.initial = false;
        },
        computeSize(ctx2, evt) {
          var _a7;
          (_a7 = ctx2._rafCleanup) == null ? void 0 : _a7.call(ctx2);
          ctx2._rafCleanup = raf(() => {
            const contentEl = dom36.getContentEl(ctx2);
            if (!contentEl) return;
            ctx2.stylesRef || (ctx2.stylesRef = ref35({
              animationName: contentEl.style.animationName,
              animationDuration: contentEl.style.animationDuration
            }));
            if (evt.type === "CLOSE" || !ctx2.open) {
              const win = contentEl.ownerDocument.defaultView || window;
              ctx2.unmountAnimationName = win.getComputedStyle(contentEl).animationName;
            }
            const hidden = contentEl.hidden;
            contentEl.style.animationName = "none";
            contentEl.style.animationDuration = "0s";
            contentEl.hidden = false;
            const rect = contentEl.getBoundingClientRect();
            ctx2.height = rect.height;
            ctx2.width = rect.width;
            if (ctx2.initial) {
              contentEl.style.animationName = ctx2.stylesRef.animationName;
              contentEl.style.animationDuration = ctx2.stylesRef.animationDuration;
            }
            contentEl.hidden = hidden;
          });
        },
        invokeOnOpen: (ctx2) => {
          var _a7;
          (_a7 = ctx2.onOpenChange) == null ? void 0 : _a7.call(ctx2, { open: true });
        },
        invokeOnClose: (ctx2) => {
          var _a7;
          (_a7 = ctx2.onOpenChange) == null ? void 0 : _a7.call(ctx2, { open: false });
        },
        invokeOnExitComplete(ctx2) {
          var _a7;
          (_a7 = ctx2.onExitComplete) == null ? void 0 : _a7.call(ctx2);
        },
        toggleVisibility: (ctx2, _evt, { send }) => {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE" });
        }
      }
    }
  );
}
var props30 = createProps30()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "onExitComplete",
  "onOpenChange",
  "open.controlled",
  "open"
]);
var splitProps32 = createSplitProps2(props30);

// node_modules/@ark-ui/react/dist/components/collapsible/use-collapsible.js
var import_react23 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/providers/environment/use-environment-context.js
var [EnvironmentContextProvider, useEnvironmentContext] = createContext({
  name: "EnvironmentContext",
  hookName: "useEnvironmentContext",
  providerName: "<EnvironmentProvider />",
  strict: false,
  defaultValue: {
    getRootNode: () => document,
    getDocument: () => document,
    getWindow: () => window
  }
});

// node_modules/@ark-ui/react/dist/utils/use-event.js
var import_react21 = __toESM(require_react(), 1);
function useEvent(callback, opts = {}) {
  const { sync: sync4 = false } = opts;
  const callbackRef = useLatestRef(callback);
  return (0, import_react21.useCallback)(
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    (...args) => {
      var _a7;
      if (sync4) return queueMicrotask(() => {
        var _a8;
        return (_a8 = callbackRef.current) == null ? void 0 : _a8.call(callbackRef, ...args);
      });
      return (_a7 = callbackRef.current) == null ? void 0 : _a7.call(callbackRef, ...args);
    },
    [sync4, callbackRef]
  );
}
function useLatestRef(value) {
  const ref36 = (0, import_react21.useRef)(value);
  ref36.current = value;
  return ref36;
}

// node_modules/@ark-ui/react/dist/components/collapsible/use-collapsible.js
var useCollapsible = (props52 = {}) => {
  const { lazyMount, unmountOnExit, ...collapsibleProps } = props52;
  const wasVisible = (0, import_react23.useRef)(false);
  const { dir } = useLocaleContext();
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const initialContext = {
    id: (0, import_react23.useId)(),
    dir,
    getRootNode: getRootNode2,
    open: props52.defaultOpen,
    "open.controlled": props52.open !== void 0,
    ...collapsibleProps
  };
  const context = {
    ...initialContext,
    open: props52.open,
    onOpenChange: useEvent(props52.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine2(initialContext), { context });
  const api = connect2(state2, send, normalizeProps);
  if (api.visible) {
    wasVisible.current = true;
  }
  const isUnmounted = !api.visible && !wasVisible.current && lazyMount || unmountOnExit && !api.visible && wasVisible.current;
  return { ...api, isUnmounted };
};

// node_modules/@ark-ui/react/dist/components/collapsible/use-collapsible-context.js
var [CollapsibleProvider, useCollapsibleContext] = createContext({
  name: "CollapsibleContext",
  hookName: "useCollapsibleContext",
  providerName: "<CollapsibleProvider />"
});

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-root.js
var CollapsibleRoot = (0, import_react25.forwardRef)((props52, ref36) => {
  const [useCollapsibleProps, localProps] = splitCollapsibleProps(props52);
  const collapsible = useCollapsible(useCollapsibleProps);
  const mergedProps = mergeProps3(collapsible.getRootProps(), localProps);
  return (0, import_jsx_runtime10.jsx)(CollapsibleProvider, { value: collapsible, children: (0, import_jsx_runtime10.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
});
CollapsibleRoot.displayName = "CollapsibleRoot";

// node_modules/@ark-ui/react/node_modules/@zag-js/numeric-range/dist/index.mjs
function getMinValueAtIndex(index, values, minValue) {
  return index === 0 ? minValue : values[index - 1];
}
function getMaxValueAtIndex(index, values, maxValue2) {
  return index === values.length - 1 ? maxValue2 : values[index + 1];
}
function getRoundedValue2(value, minValue, step) {
  return Math.round((value - minValue) / step) * step + minValue;
}
function clampValue2(value, minValue, maxValue2) {
  return Math.min(Math.max(value, minValue), maxValue2);
}
function getValuePercent2(value, minValue, maxValue2) {
  return (value - minValue) / (maxValue2 - minValue);
}
function getPercentValue2(percent, minValue, maxValue2, step) {
  const value = percent * (maxValue2 - minValue) + minValue;
  const roundedValue = getRoundedValue2(value, minValue, step);
  return clampValue2(roundedValue, minValue, maxValue2);
}
function roundToStepPrecision2(value, step) {
  let roundedValue = value;
  let stepString = step.toString();
  let pointIndex = stepString.indexOf(".");
  let precision = pointIndex >= 0 ? stepString.length - pointIndex : 0;
  if (precision > 0) {
    let pow = Math.pow(10, precision);
    roundedValue = Math.round(roundedValue * pow) / pow;
  }
  return roundedValue;
}
function snapValueToStep2(value, min4, max4, step) {
  min4 = Number(min4);
  max4 = Number(max4);
  let remainder = (value - (isNaN(min4) ? 0 : min4)) % step;
  let snappedValue = roundToStepPrecision2(
    Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder,
    step
  );
  if (!isNaN(min4)) {
    if (snappedValue < min4) {
      snappedValue = min4;
    } else if (!isNaN(max4) && snappedValue > max4) {
      snappedValue = min4 + Math.floor(roundToStepPrecision2((max4 - min4) / step, step)) * step;
    }
  } else if (!isNaN(max4) && snappedValue > max4) {
    snappedValue = Math.floor(roundToStepPrecision2(max4 / step, step)) * step;
  }
  snappedValue = roundToStepPrecision2(snappedValue, step);
  return snappedValue;
}
function setValueAtIndex(values, index, value) {
  if (values[index] === value) return values;
  return [...values.slice(0, index), value, ...values.slice(index + 1)];
}
function getValueSetterAtIndex(index, ctx) {
  const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min);
  const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max);
  let nextValues = ctx.values.slice();
  return function setValue(value) {
    let nextValue = snapValueToStep2(value, minValueAtIndex, maxValueAtIndex, ctx.step);
    nextValues = setValueAtIndex(nextValues, index, value);
    nextValues[index] = nextValue;
    return nextValues;
  };
}
function getNextStepValue2(index, ctx) {
  const nextValue = ctx.values[index] + ctx.step;
  return getValueSetterAtIndex(index, ctx)(nextValue);
}
function getPreviousStepValue2(index, ctx) {
  const nextValue = ctx.values[index] - ctx.step;
  return getValueSetterAtIndex(index, ctx)(nextValue);
}
function getClosestValueIndex2(values, targetValue) {
  let targetIndex = values.findIndex((value) => targetValue - value < 0);
  if (targetIndex === 0) {
    return targetIndex;
  }
  if (targetIndex === -1) {
    return values.length - 1;
  }
  let valueBefore = values[targetIndex - 1];
  let valueAfter = values[targetIndex];
  if (Math.abs(valueBefore - targetValue) < Math.abs(valueAfter - targetValue)) {
    return targetIndex - 1;
  }
  return targetIndex;
}
function getValueRanges2(values, minValue, maxValue2, gap) {
  return values.map((value, index) => {
    const min4 = index === 0 ? minValue : values[index - 1] + gap;
    const max4 = index === values.length - 1 ? maxValue2 : values[index + 1] - gap;
    return { min: min4, max: max4, value };
  });
}
function getValueTransformer2(valueA, valueB) {
  const input = { min: valueA[0], max: valueA[1] };
  const output = { min: valueB[0], max: valueB[1] };
  return function getValue(value) {
    if (input.min === input.max || output.min === output.max) return output.min;
    const ratio = (output.max - output.min) / (input.max - input.min);
    return output.min + ratio * (value - input.min);
  };
}
function toFixedNumber2(value, digits = 0, base = 10) {
  const pow = Math.pow(base, digits);
  return Math.round(value * pow) / pow;
}
function mod2(value, modulo) {
  return (value % modulo + modulo) % modulo;
}

// node_modules/@ark-ui/react/node_modules/@zag-js/color-utils/dist/index.mjs
var __defProp6 = Object.defineProperty;
var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField6 = (obj, key, value) => __defNormalProp6(obj, key + "", value);
var isEqualObject2 = (a, b) => {
  if (Object.keys(a).length !== Object.keys(b).length) return false;
  for (let key in a) if (a[key] !== b[key]) return false;
  return true;
};
var Color2 = class {
  toHexInt() {
    return this.toFormat("rgba").toHexInt();
  }
  getChannelValue(channel) {
    if (channel in this) return this[channel];
    throw new Error("Unsupported color channel: " + channel);
  }
  getChannelValuePercent(channel, valueToCheck) {
    const value = valueToCheck ?? this.getChannelValue(channel);
    const { minValue, maxValue: maxValue2 } = this.getChannelRange(channel);
    return getValuePercent2(value, minValue, maxValue2);
  }
  getChannelPercentValue(channel, percentToCheck) {
    const { minValue, maxValue: maxValue2, step } = this.getChannelRange(channel);
    const percentValue = getPercentValue2(percentToCheck, minValue, maxValue2, step);
    return snapValueToStep2(percentValue, minValue, maxValue2, step);
  }
  withChannelValue(channel, value) {
    const { minValue, maxValue: maxValue2 } = this.getChannelRange(channel);
    if (channel in this) {
      let clone = this.clone();
      clone[channel] = clampValue2(value, minValue, maxValue2);
      return clone;
    }
    throw new Error("Unsupported color channel: " + channel);
  }
  getColorAxes(xyChannels) {
    let { xChannel, yChannel } = xyChannels;
    let xCh = xChannel || this.getChannels().find((c) => c !== yChannel);
    let yCh = yChannel || this.getChannels().find((c) => c !== xCh);
    let zCh = this.getChannels().find((c) => c !== xCh && c !== yCh);
    return { xChannel: xCh, yChannel: yCh, zChannel: zCh };
  }
  incrementChannel(channel, stepSize) {
    const { minValue, maxValue: maxValue2, step } = this.getChannelRange(channel);
    const value = snapValueToStep2(
      clampValue2(this.getChannelValue(channel) + stepSize, minValue, maxValue2),
      minValue,
      maxValue2,
      step
    );
    return this.withChannelValue(channel, value);
  }
  decrementChannel(channel, stepSize) {
    return this.incrementChannel(channel, -stepSize);
  }
  isEqual(color) {
    const isSame = isEqualObject2(this.toJSON(), color.toJSON());
    return isSame && this.getChannelValue("alpha") === color.getChannelValue("alpha");
  }
};
var _RGBColor3 = class _RGBColor4 extends Color2 {
  constructor(red, green, blue, alpha) {
    super();
    this.red = red;
    this.green = green;
    this.blue = blue;
    this.alpha = alpha;
  }
  static parse(value) {
    let colors2 = [];
    if (/^#[\da-f]+$/i.test(value) && [4, 5, 7, 9].includes(value.length)) {
      const values = (value.length < 6 ? value.replace(/[^#]/gi, "$&$&") : value).slice(1).split("");
      while (values.length > 0) {
        colors2.push(parseInt(values.splice(0, 2).join(""), 16));
      }
      colors2[3] = colors2[3] !== void 0 ? colors2[3] / 255 : void 0;
    }
    const match50 = value.match(/^rgba?\((.*)\)$/);
    if (match50 == null ? void 0 : match50[1]) {
      colors2 = match50[1].split(",").map((value2) => Number(value2.trim())).map((num, i) => clampValue2(num, 0, i < 3 ? 255 : 1));
    }
    return colors2.length < 3 ? void 0 : new _RGBColor4(colors2[0], colors2[1], colors2[2], colors2[3] ?? 1);
  }
  toString(format) {
    switch (format) {
      case "hex":
        return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0")).toUpperCase();
      case "hexa":
        return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0") + Math.round(this.alpha * 255).toString(16).padStart(2, "0")).toUpperCase();
      case "rgb":
        return `rgb(${this.red}, ${this.green}, ${this.blue})`;
      case "css":
      case "rgba":
        return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;
      case "hsl":
        return this.toHSL().toString("hsl");
      case "hsb":
        return this.toHSB().toString("hsb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "rgba":
        return this;
      case "hsba":
        return this.toHSB();
      case "hsla":
        return this.toHSL();
      default:
        throw new Error("Unsupported color conversion: rgb -> " + format);
    }
  }
  toHexInt() {
    return this.red << 16 | this.green << 8 | this.blue;
  }
  /**
   * Converts an RGB color value to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSBColor object.
   */
  toHSB() {
    const red = this.red / 255;
    const green = this.green / 255;
    const blue = this.blue / 255;
    const min4 = Math.min(red, green, blue);
    const brightness = Math.max(red, green, blue);
    const chroma = brightness - min4;
    const saturation = brightness === 0 ? 0 : chroma / brightness;
    let hue = 0;
    if (chroma !== 0) {
      switch (brightness) {
        case red:
          hue = (green - blue) / chroma + (green < blue ? 6 : 0);
          break;
        case green:
          hue = (blue - red) / chroma + 2;
          break;
        case blue:
          hue = (red - green) / chroma + 4;
          break;
      }
      hue /= 6;
    }
    return new HSBColor2(
      toFixedNumber2(hue * 360, 2),
      toFixedNumber2(saturation * 100, 2),
      toFixedNumber2(brightness * 100, 2),
      toFixedNumber2(this.alpha, 2)
    );
  }
  /**
   * Converts an RGB color value to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSLColor object.
   */
  toHSL() {
    const red = this.red / 255;
    const green = this.green / 255;
    const blue = this.blue / 255;
    const min4 = Math.min(red, green, blue);
    const max4 = Math.max(red, green, blue);
    const lightness = (max4 + min4) / 2;
    const chroma = max4 - min4;
    let hue = -1;
    let saturation = -1;
    if (chroma === 0) {
      hue = saturation = 0;
    } else {
      saturation = chroma / (lightness < 0.5 ? max4 + min4 : 2 - max4 - min4);
      switch (max4) {
        case red:
          hue = (green - blue) / chroma + (green < blue ? 6 : 0);
          break;
        case green:
          hue = (blue - red) / chroma + 2;
          break;
        case blue:
          hue = (red - green) / chroma + 4;
          break;
      }
      hue /= 6;
    }
    return new HSLColor2(
      toFixedNumber2(hue * 360, 2),
      toFixedNumber2(saturation * 100, 2),
      toFixedNumber2(lightness * 100, 2),
      toFixedNumber2(this.alpha, 2)
    );
  }
  clone() {
    return new _RGBColor4(this.red, this.green, this.blue, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "red":
      case "green":
      case "blue":
        return { style: "decimal" };
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "red":
      case "green":
      case "blue":
        return { minValue: 0, maxValue: 255, step: 1, pageSize: 17 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { r: this.red, g: this.green, b: this.blue, a: this.alpha };
  }
  getFormat() {
    return "rgba";
  }
  getChannels() {
    return _RGBColor4.colorChannels;
  }
};
__publicField6(_RGBColor3, "colorChannels", ["red", "green", "blue"]);
var RGBColor2 = _RGBColor3;
var HSL_REGEX2 = /hsl\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsla\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
var _HSLColor3 = class _HSLColor4 extends Color2 {
  constructor(hue, saturation, lightness, alpha) {
    super();
    this.hue = hue;
    this.saturation = saturation;
    this.lightness = lightness;
    this.alpha = alpha;
  }
  static parse(value) {
    let m;
    if (m = value.match(HSL_REGEX2)) {
      const [h, s, l, a] = (m[1] ?? m[2]).split(",").map((n) => Number(n.trim().replace("%", "")));
      return new _HSLColor4(mod2(h, 360), clampValue2(s, 0, 100), clampValue2(l, 0, 100), clampValue2(a ?? 1, 0, 1));
    }
  }
  toString(format) {
    switch (format) {
      case "hex":
        return this.toRGB().toString("hex");
      case "hexa":
        return this.toRGB().toString("hexa");
      case "hsl":
        return `hsl(${this.hue}, ${toFixedNumber2(this.saturation, 2)}%, ${toFixedNumber2(this.lightness, 2)}%)`;
      case "css":
      case "hsla":
        return `hsla(${this.hue}, ${toFixedNumber2(this.saturation, 2)}%, ${toFixedNumber2(this.lightness, 2)}%, ${this.alpha})`;
      case "hsb":
        return this.toHSB().toString("hsb");
      case "rgb":
        return this.toRGB().toString("rgb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "hsla":
        return this;
      case "hsba":
        return this.toHSB();
      case "rgba":
        return this.toRGB();
      default:
        throw new Error("Unsupported color conversion: hsl -> " + format);
    }
  }
  /**
   * Converts a HSL color to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV.
   * @returns An HSBColor object.
   */
  toHSB() {
    let saturation = this.saturation / 100;
    let lightness = this.lightness / 100;
    let brightness = lightness + saturation * Math.min(lightness, 1 - lightness);
    saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness);
    return new HSBColor2(
      toFixedNumber2(this.hue, 2),
      toFixedNumber2(saturation * 100, 2),
      toFixedNumber2(brightness * 100, 2),
      toFixedNumber2(this.alpha, 2)
    );
  }
  /**
   * Converts a HSL color to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative.
   * @returns An RGBColor object.
   */
  toRGB() {
    let hue = this.hue;
    let saturation = this.saturation / 100;
    let lightness = this.lightness / 100;
    let a = saturation * Math.min(lightness, 1 - lightness);
    let fn = (n, k = (n + hue / 30) % 12) => lightness - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return new RGBColor2(
      Math.round(fn(0) * 255),
      Math.round(fn(8) * 255),
      Math.round(fn(4) * 255),
      toFixedNumber2(this.alpha, 2)
    );
  }
  clone() {
    return new _HSLColor4(this.hue, this.saturation, this.lightness, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "hue":
        return { style: "unit", unit: "degree", unitDisplay: "narrow" };
      case "saturation":
      case "lightness":
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    if (channel === "saturation" || channel === "lightness") {
      value /= 100;
    }
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "hue":
        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };
      case "saturation":
      case "lightness":
        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { h: this.hue, s: this.saturation, l: this.lightness, a: this.alpha };
  }
  getFormat() {
    return "hsla";
  }
  getChannels() {
    return _HSLColor4.colorChannels;
  }
};
__publicField6(_HSLColor3, "colorChannels", ["hue", "saturation", "lightness"]);
var HSLColor2 = _HSLColor3;
var HSB_REGEX2 = /hsb\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsba\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
var _HSBColor3 = class _HSBColor4 extends Color2 {
  constructor(hue, saturation, brightness, alpha) {
    super();
    this.hue = hue;
    this.saturation = saturation;
    this.brightness = brightness;
    this.alpha = alpha;
  }
  static parse(value) {
    let m;
    if (m = value.match(HSB_REGEX2)) {
      const [h, s, b, a] = (m[1] ?? m[2]).split(",").map((n) => Number(n.trim().replace("%", "")));
      return new _HSBColor4(mod2(h, 360), clampValue2(s, 0, 100), clampValue2(b, 0, 100), clampValue2(a ?? 1, 0, 1));
    }
  }
  toString(format) {
    switch (format) {
      case "css":
        return this.toHSL().toString("css");
      case "hex":
        return this.toRGB().toString("hex");
      case "hexa":
        return this.toRGB().toString("hexa");
      case "hsb":
        return `hsb(${this.hue}, ${toFixedNumber2(this.saturation, 2)}%, ${toFixedNumber2(this.brightness, 2)}%)`;
      case "hsba":
        return `hsba(${this.hue}, ${toFixedNumber2(this.saturation, 2)}%, ${toFixedNumber2(this.brightness, 2)}%, ${this.alpha})`;
      case "hsl":
        return this.toHSL().toString("hsl");
      case "rgb":
        return this.toRGB().toString("rgb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "hsba":
        return this;
      case "hsla":
        return this.toHSL();
      case "rgba":
        return this.toRGB();
      default:
        throw new Error("Unsupported color conversion: hsb -> " + format);
    }
  }
  /**
   * Converts a HSB color to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL.
   * @returns An HSLColor object.
   */
  toHSL() {
    let saturation = this.saturation / 100;
    let brightness = this.brightness / 100;
    let lightness = brightness * (1 - saturation / 2);
    saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness);
    return new HSLColor2(
      toFixedNumber2(this.hue, 2),
      toFixedNumber2(saturation * 100, 2),
      toFixedNumber2(lightness * 100, 2),
      toFixedNumber2(this.alpha, 2)
    );
  }
  /**
   * Converts a HSV color value to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative.
   * @returns An RGBColor object.
   */
  toRGB() {
    let hue = this.hue;
    let saturation = this.saturation / 100;
    let brightness = this.brightness / 100;
    let fn = (n, k = (n + hue / 60) % 6) => brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0);
    return new RGBColor2(
      Math.round(fn(5) * 255),
      Math.round(fn(3) * 255),
      Math.round(fn(1) * 255),
      toFixedNumber2(this.alpha, 2)
    );
  }
  clone() {
    return new _HSBColor4(this.hue, this.saturation, this.brightness, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "hue":
        return { style: "unit", unit: "degree", unitDisplay: "narrow" };
      case "saturation":
      case "brightness":
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    if (channel === "saturation" || channel === "brightness") {
      value /= 100;
    }
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "hue":
        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };
      case "saturation":
      case "brightness":
        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { h: this.hue, s: this.saturation, b: this.brightness, a: this.alpha };
  }
  getFormat() {
    return "hsba";
  }
  getChannels() {
    return _HSBColor4.colorChannels;
  }
};
__publicField6(_HSBColor3, "colorChannels", ["hue", "saturation", "brightness"]);
var HSBColor2 = _HSBColor3;
var nativeColors2 = "aliceblue:f0f8ff,antiquewhite:faebd7,aqua:00ffff,aquamarine:7fffd4,azure:f0ffff,beige:f5f5dc,bisque:ffe4c4,black:000000,blanchedalmond:ffebcd,blue:0000ff,blueviolet:8a2be2,brown:a52a2a,burlywood:deb887,cadetblue:5f9ea0,chartreuse:7fff00,chocolate:d2691e,coral:ff7f50,cornflowerblue:6495ed,cornsilk:fff8dc,crimson:dc143c,cyan:00ffff,darkblue:00008b,darkcyan:008b8b,darkgoldenrod:b8860b,darkgray:a9a9a9,darkgreen:006400,darkkhaki:bdb76b,darkmagenta:8b008b,darkolivegreen:556b2f,darkorange:ff8c00,darkorchid:9932cc,darkred:8b0000,darksalmon:e9967a,darkseagreen:8fbc8f,darkslateblue:483d8b,darkslategray:2f4f4f,darkturquoise:00ced1,darkviolet:9400d3,deeppink:ff1493,deepskyblue:00bfff,dimgray:696969,dodgerblue:1e90ff,firebrick:b22222,floralwhite:fffaf0,forestgreen:228b22,fuchsia:ff00ff,gainsboro:dcdcdc,ghostwhite:f8f8ff,gold:ffd700,goldenrod:daa520,gray:808080,green:008000,greenyellow:adff2f,honeydew:f0fff0,hotpink:ff69b4,indianred:cd5c5c,indigo:4b0082,ivory:fffff0,khaki:f0e68c,lavender:e6e6fa,lavenderblush:fff0f5,lawngreen:7cfc00,lemonchiffon:fffacd,lightblue:add8e6,lightcoral:f08080,lightcyan:e0ffff,lightgoldenrodyellow:fafad2,lightgrey:d3d3d3,lightgreen:90ee90,lightpink:ffb6c1,lightsalmon:ffa07a,lightseagreen:20b2aa,lightskyblue:87cefa,lightslategray:778899,lightsteelblue:b0c4de,lightyellow:ffffe0,lime:00ff00,limegreen:32cd32,linen:faf0e6,magenta:ff00ff,maroon:800000,mediumaquamarine:66cdaa,mediumblue:0000cd,mediumorchid:ba55d3,mediumpurple:9370d8,mediumseagreen:3cb371,mediumslateblue:7b68ee,mediumspringgreen:00fa9a,mediumturquoise:48d1cc,mediumvioletred:c71585,midnightblue:191970,mintcream:f5fffa,mistyrose:ffe4e1,moccasin:ffe4b5,navajowhite:ffdead,navy:000080,oldlace:fdf5e6,olive:808000,olivedrab:6b8e23,orange:ffa500,orangered:ff4500,orchid:da70d6,palegoldenrod:eee8aa,palegreen:98fb98,paleturquoise:afeeee,palevioletred:d87093,papayawhip:ffefd5,peachpuff:ffdab9,peru:cd853f,pink:ffc0cb,plum:dda0dd,powderblue:b0e0e6,purple:800080,rebeccapurple:663399,red:ff0000,rosybrown:bc8f8f,royalblue:4169e1,saddlebrown:8b4513,salmon:fa8072,sandybrown:f4a460,seagreen:2e8b57,seashell:fff5ee,sienna:a0522d,silver:c0c0c0,skyblue:87ceeb,slateblue:6a5acd,slategray:708090,snow:fffafa,springgreen:00ff7f,steelblue:4682b4,tan:d2b48c,teal:008080,thistle:d8bfd8,tomato:ff6347,turquoise:40e0d0,violet:ee82ee,wheat:f5deb3,white:ffffff,whitesmoke:f5f5f5,yellow:ffff00,yellowgreen:9acd32";
var makeMap2 = (str) => {
  const map = /* @__PURE__ */ new Map();
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    const [key, val] = list[i].split(":");
    map.set(key, `#${val}`);
    if (key.includes("gray")) map.set(key.replace("gray", "grey"), `#${val}`);
  }
  return map;
};
var nativeColorMap2 = makeMap2(nativeColors2);

// node_modules/@ark-ui/react/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css2 = getComputedStyle4(element);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement4(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement4(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets2 = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow5(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets2;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow5(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow5(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow5(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle4(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow5(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement2(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement4(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement4(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement2(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getDocumentRect(element) {
  const html = getDocumentElement2(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle4(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow5(element);
  const html = getDocumentElement2(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement4(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement2(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode2(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle4(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors2(element, [], false).filter((el) => isElement(el) && getNodeName2(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle4(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode2(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle4(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement2(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode2(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement4(offsetParent);
  const documentElement = getDocumentElement2(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  let htmlX = 0;
  let htmlY = 0;
  if (documentElement && !isOffsetParentAnElement && !isFixed) {
    const htmlRect = documentElement.getBoundingClientRect();
    htmlY = htmlRect.top + scroll.scrollTop;
    htmlX = htmlRect.left + scroll.scrollLeft - // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect);
  }
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlX;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlY;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle4(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement4(element) || getComputedStyle4(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement2(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow5(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement4(element)) {
    let svgOffsetParent = getParentNode2(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode2(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL2(element) {
  return getComputedStyle4(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement: getDocumentElement2,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL: isRTL2
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement2(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate2(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors2(referenceEl) : [], ...getOverflowAncestors2(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset3 = offset;
var shift3 = shift;
var flip3 = flip;
var size3 = size;
var hide2 = hide;
var arrow3 = arrow;
var limitShift3 = limitShift;
var computePosition3 = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@ark-ui/react/node_modules/@zag-js/popper/dist/index.mjs
function createDOMRect(x = 0, y = 0, width = 0, height = 0) {
  if (typeof DOMRect === "function") {
    return new DOMRect(x, y, width, height);
  }
  const rect = {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x
  };
  return { ...rect, toJSON: () => rect };
}
function getDOMRect(anchorRect) {
  if (!anchorRect) return createDOMRect();
  const { x, y, width, height } = anchorRect;
  return createDOMRect(x, y, width, height);
}
function getAnchorElement(anchorElement, getAnchorRect) {
  return {
    contextElement: isHTMLElement(anchorElement) ? anchorElement : void 0,
    getBoundingClientRect: () => {
      const anchor = anchorElement;
      const anchorRect = getAnchorRect == null ? void 0 : getAnchorRect(anchor);
      if (anchorRect || !anchor) {
        return getDOMRect(anchorRect);
      }
      return anchor.getBoundingClientRect();
    }
  };
}
var toVar2 = (value) => ({ variable: value, reference: `var(${value})` });
var cssVars2 = {
  arrowSize: toVar2("--arrow-size"),
  arrowSizeHalf: toVar2("--arrow-size-half"),
  arrowBg: toVar2("--arrow-background"),
  transformOrigin: toVar2("--transform-origin"),
  arrowOffset: toVar2("--arrow-offset")
};
var getTransformOrigin = (arrow22) => ({
  top: "bottom center",
  "top-start": arrow22 ? `${arrow22.x}px bottom` : "left bottom",
  "top-end": arrow22 ? `${arrow22.x}px bottom` : "right bottom",
  bottom: "top center",
  "bottom-start": arrow22 ? `${arrow22.x}px top` : "top left",
  "bottom-end": arrow22 ? `${arrow22.x}px top` : "top right",
  left: "right center",
  "left-start": arrow22 ? `right ${arrow22.y}px` : "right top",
  "left-end": arrow22 ? `right ${arrow22.y}px` : "right bottom",
  right: "left center",
  "right-start": arrow22 ? `left ${arrow22.y}px` : "left top",
  "right-end": arrow22 ? `left ${arrow22.y}px` : "left bottom"
});
var transformOriginMiddleware = {
  name: "transformOrigin",
  fn({ placement, elements, middlewareData }) {
    const { arrow: arrow22 } = middlewareData;
    const transformOrigin = getTransformOrigin(arrow22)[placement];
    const { floating } = elements;
    floating.style.setProperty(cssVars2.transformOrigin.variable, transformOrigin);
    return {
      data: { transformOrigin }
    };
  }
};
var rectMiddleware = {
  name: "rects",
  fn({ rects }) {
    return {
      data: rects
    };
  }
};
var shiftArrowMiddleware = (arrowEl) => {
  if (!arrowEl) return;
  return {
    name: "shiftArrow",
    fn({ placement, middlewareData }) {
      if (!middlewareData.arrow) return {};
      const { x, y } = middlewareData.arrow;
      const dir = placement.split("-")[0];
      Object.assign(arrowEl.style, {
        left: x != null ? `${x}px` : "",
        top: y != null ? `${y}px` : "",
        [dir]: `calc(100% + ${cssVars2.arrowOffset.reference})`
      });
      return {};
    }
  };
};
function getPlacementDetails(placement) {
  const [side, align] = placement.split("-");
  return { side, align, hasAlign: align != null };
}
function getPlacementSide2(placement) {
  return placement.split("-")[0];
}
var defaultOptions = {
  strategy: "absolute",
  placement: "bottom",
  listeners: true,
  gutter: 8,
  flip: true,
  slide: true,
  overlap: false,
  sameWidth: false,
  fitViewport: false,
  overflowPadding: 8,
  arrowPadding: 4
};
function roundByDpr(win, value) {
  const dpr = win.devicePixelRatio || 1;
  return Math.round(value * dpr) / dpr;
}
function getBoundaryMiddleware(opts) {
  return runIfFn3(opts.boundary);
}
function getArrowMiddleware(arrowElement, opts) {
  if (!arrowElement) return;
  return arrow3({
    element: arrowElement,
    padding: opts.arrowPadding
  });
}
function getOffsetMiddleware(arrowElement, opts) {
  if (isNull2(opts.offset ?? opts.gutter)) return;
  return offset3(({ placement }) => {
    var _a7, _b6;
    const arrowOffset = ((arrowElement == null ? void 0 : arrowElement.clientHeight) || 0) / 2;
    const gutter = ((_a7 = opts.offset) == null ? void 0 : _a7.mainAxis) ?? opts.gutter;
    const mainAxis = typeof gutter === "number" ? gutter + arrowOffset : gutter ?? arrowOffset;
    const { hasAlign } = getPlacementDetails(placement);
    const shift22 = !hasAlign ? opts.shift : void 0;
    const crossAxis = ((_b6 = opts.offset) == null ? void 0 : _b6.crossAxis) ?? shift22;
    return compact4({
      crossAxis,
      mainAxis,
      alignmentAxis: opts.shift
    });
  });
}
function getFlipMiddleware(opts) {
  if (!opts.flip) return;
  return flip3({
    boundary: getBoundaryMiddleware(opts),
    padding: opts.overflowPadding,
    fallbackPlacements: opts.flip === true ? void 0 : opts.flip
  });
}
function getShiftMiddleware(opts) {
  if (!opts.slide && !opts.overlap) return;
  return shift3({
    boundary: getBoundaryMiddleware(opts),
    mainAxis: opts.slide,
    crossAxis: opts.overlap,
    padding: opts.overflowPadding,
    limiter: limitShift3()
  });
}
function getSizeMiddleware(opts) {
  return size3({
    padding: opts.overflowPadding,
    apply({ elements, rects, availableHeight, availableWidth }) {
      const floating = elements.floating;
      const referenceWidth = Math.round(rects.reference.width);
      availableWidth = Math.floor(availableWidth);
      availableHeight = Math.floor(availableHeight);
      floating.style.setProperty("--reference-width", `${referenceWidth}px`);
      floating.style.setProperty("--available-width", `${availableWidth}px`);
      floating.style.setProperty("--available-height", `${availableHeight}px`);
    }
  });
}
function hideWhenDetachedMiddleware(opts) {
  var _a7;
  if (!opts.hideWhenDetached) return;
  return hide2({ strategy: "referenceHidden", boundary: ((_a7 = opts.boundary) == null ? void 0 : _a7.call(opts)) ?? "clippingAncestors" });
}
function getAutoUpdateOptions(opts) {
  if (!opts) return {};
  if (opts === true) {
    return { ancestorResize: true, ancestorScroll: true, elementResize: true, layoutShift: true };
  }
  return opts;
}
function getPlacementImpl(referenceOrVirtual, floating, opts = {}) {
  const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect);
  if (!floating || !reference) return;
  const options = Object.assign({}, defaultOptions, opts);
  const arrowEl = floating.querySelector("[data-part=arrow]");
  const middleware2 = [
    getOffsetMiddleware(arrowEl, options),
    getFlipMiddleware(options),
    getShiftMiddleware(options),
    getArrowMiddleware(arrowEl, options),
    shiftArrowMiddleware(arrowEl),
    transformOriginMiddleware,
    getSizeMiddleware(options),
    hideWhenDetachedMiddleware(options),
    rectMiddleware
  ];
  const { placement, strategy, onComplete, onPositioned } = options;
  const updatePosition = async () => {
    var _a7;
    if (!reference || !floating) return;
    const pos = await computePosition3(reference, floating, {
      placement,
      middleware: middleware2,
      strategy
    });
    onComplete == null ? void 0 : onComplete(pos);
    onPositioned == null ? void 0 : onPositioned({ placed: true });
    const win = getWindow(floating);
    const x = roundByDpr(win, pos.x);
    const y = roundByDpr(win, pos.y);
    floating.style.setProperty("--x", `${x}px`);
    floating.style.setProperty("--y", `${y}px`);
    if (options.hideWhenDetached && ((_a7 = pos.middlewareData.hide) == null ? void 0 : _a7.referenceHidden)) {
      floating.style.setProperty("visibility", "hidden");
    }
    const contentEl = floating.firstElementChild;
    if (contentEl) {
      const zIndex = win.getComputedStyle(contentEl).zIndex;
      floating.style.setProperty("--z-index", zIndex);
    }
  };
  const update = async () => {
    if (opts.updatePosition) {
      await opts.updatePosition({ updatePosition });
      onPositioned == null ? void 0 : onPositioned({ placed: true });
    } else {
      await updatePosition();
    }
  };
  const autoUpdateOptions = getAutoUpdateOptions(options.listeners);
  const cancelAutoUpdate = options.listeners ? autoUpdate2(reference, floating, update, autoUpdateOptions) : noop4;
  update();
  return () => {
    cancelAutoUpdate == null ? void 0 : cancelAutoUpdate();
    onPositioned == null ? void 0 : onPositioned({ placed: false });
  };
}
function getPlacement2(referenceOrFn, floatingOrFn, opts = {}) {
  const { defer, ...options } = opts;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const reference = typeof referenceOrFn === "function" ? referenceOrFn() : referenceOrFn;
      const floating = typeof floatingOrFn === "function" ? floatingOrFn() : floatingOrFn;
      cleanups2.push(getPlacementImpl(reference, floating, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
var ARROW_FLOATING_STYLE = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function getPlacementStyles2(options = {}) {
  const { placement, sameWidth, fitViewport, strategy = "absolute" } = options;
  return {
    arrow: {
      position: "absolute",
      width: cssVars2.arrowSize.reference,
      height: cssVars2.arrowSize.reference,
      [cssVars2.arrowSizeHalf.variable]: `calc(${cssVars2.arrowSize.reference} / 2)`,
      [cssVars2.arrowOffset.variable]: `calc(${cssVars2.arrowSizeHalf.reference} * -1)`
    },
    arrowTip: {
      // @ts-expect-error - Fix this
      transform: placement ? ARROW_FLOATING_STYLE[placement.split("-")[0]] : void 0,
      background: cssVars2.arrowBg.reference,
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      position: "absolute",
      zIndex: "inherit"
    },
    floating: {
      position: strategy,
      isolation: "isolate",
      minWidth: sameWidth ? void 0 : "max-content",
      width: sameWidth ? "var(--reference-width)" : void 0,
      maxWidth: fitViewport ? "var(--available-width)" : void 0,
      maxHeight: fitViewport ? "var(--available-height)" : void 0,
      top: "0px",
      left: "0px",
      // move off-screen if placement is not defined
      transform: placement ? "translate3d(var(--x), var(--y), 0)" : "translate3d(0, -100vh, 0)",
      zIndex: "var(--z-index)"
    }
  };
}

// node_modules/@ark-ui/react/node_modules/@zag-js/interact-outside/dist/index.mjs
function getWindowFrames(win) {
  const frames = {
    each(cb) {
      var _a7;
      for (let i = 0; i < ((_a7 = win.frames) == null ? void 0 : _a7.length); i += 1) {
        const frame = win.frames[i];
        if (frame) cb(frame);
      }
    },
    addEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.addEventListener(event, listener, options);
        } catch {
        }
      });
      return () => {
        try {
          frames.removeEventListener(event, listener, options);
        } catch {
        }
      };
    },
    removeEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.removeEventListener(event, listener, options);
        } catch {
        }
      });
    }
  };
  return frames;
}
function getParentWindow(win) {
  const parent = win.frameElement != null ? win.parent : null;
  return {
    addEventListener: (event, listener, options) => {
      try {
        parent == null ? void 0 : parent.addEventListener(event, listener, options);
      } catch {
      }
      return () => {
        try {
          parent == null ? void 0 : parent.removeEventListener(event, listener, options);
        } catch {
        }
      };
    },
    removeEventListener: (event, listener, options) => {
      try {
        parent == null ? void 0 : parent.removeEventListener(event, listener, options);
      } catch {
      }
    }
  };
}
var POINTER_OUTSIDE_EVENT = "pointerdown.outside";
var FOCUS_OUTSIDE_EVENT = "focus.outside";
function isComposedPathFocusable(composedPath) {
  for (const node2 of composedPath) {
    if (isHTMLElement(node2) && isFocusable(node2)) return true;
  }
  return false;
}
var isPointerEvent = (event) => "clientY" in event;
function isEventPointWithin(node2, event) {
  if (!isPointerEvent(event) || !node2) return false;
  const rect = node2.getBoundingClientRect();
  if (rect.width === 0 || rect.height === 0) return false;
  return rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;
}
function isEventWithinScrollbar(event, target) {
  if (!target || !isPointerEvent(event)) return false;
  const isScrollableY = target.scrollHeight > target.clientHeight;
  const onScrollbarY = isScrollableY && event.clientX > target.clientWidth;
  const isScrollableX = target.scrollWidth > target.clientWidth;
  const onScrollbarX = isScrollableX && event.clientY > target.clientHeight;
  return onScrollbarY || onScrollbarX;
}
function trackInteractOutsideImpl(node2, options) {
  const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside, defer } = options;
  if (!node2) return;
  const doc = getDocument(node2);
  const win = getWindow(node2);
  const frames = getWindowFrames(win);
  const parentWin = getParentWindow(win);
  function isEventOutside(event) {
    const target = getEventTarget(event);
    if (!isHTMLElement(target)) return false;
    if (contains(node2, target)) return false;
    if (isEventPointWithin(node2, event)) return false;
    if (isEventWithinScrollbar(event, target)) return false;
    const scrollParent = getNearestOverflowAncestor(node2);
    if (isEventWithinScrollbar(event, scrollParent)) return false;
    return !(exclude == null ? void 0 : exclude(target));
  }
  const pointerdownCleanups = /* @__PURE__ */ new Set();
  function onPointerDown(event) {
    function handler() {
      var _a7;
      const func = defer ? raf : (v) => v();
      const composedPath = ((_a7 = event.composedPath) == null ? void 0 : _a7.call(event)) ?? [event.target];
      func(() => {
        if (!node2 || !isEventOutside(event)) return;
        if (onPointerDownOutside || onInteractOutside) {
          const handler2 = callAll4(onPointerDownOutside, onInteractOutside);
          node2.addEventListener(POINTER_OUTSIDE_EVENT, handler2, { once: true });
        }
        fireCustomEvent2(node2, POINTER_OUTSIDE_EVENT, {
          bubbles: false,
          cancelable: true,
          detail: {
            originalEvent: event,
            contextmenu: isContextMenuEvent2(event),
            focusable: isComposedPathFocusable(composedPath)
          }
        });
      });
    }
    if (event.pointerType === "touch") {
      pointerdownCleanups.forEach((fn) => fn());
      pointerdownCleanups.add(addDomEvent2(doc, "click", handler, { once: true }));
      pointerdownCleanups.add(parentWin.addEventListener("click", handler, { once: true }));
      pointerdownCleanups.add(frames.addEventListener("click", handler, { once: true }));
    } else {
      handler();
    }
  }
  const cleanups2 = /* @__PURE__ */ new Set();
  const timer = setTimeout(() => {
    cleanups2.add(addDomEvent2(doc, "pointerdown", onPointerDown, true));
    cleanups2.add(parentWin.addEventListener("pointerdown", onPointerDown, true));
    cleanups2.add(frames.addEventListener("pointerdown", onPointerDown, true));
  }, 0);
  function onFocusin(event) {
    const func = defer ? raf : (v) => v();
    func(() => {
      if (!node2 || !isEventOutside(event)) return;
      if (onFocusOutside || onInteractOutside) {
        const handler = callAll4(onFocusOutside, onInteractOutside);
        node2.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true });
      }
      fireCustomEvent2(node2, FOCUS_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: event,
          contextmenu: false,
          focusable: isFocusable(getEventTarget(event))
        }
      });
    });
  }
  cleanups2.add(addDomEvent2(doc, "focusin", onFocusin, true));
  cleanups2.add(parentWin.addEventListener("focusin", onFocusin, true));
  cleanups2.add(frames.addEventListener("focusin", onFocusin, true));
  return () => {
    clearTimeout(timer);
    pointerdownCleanups.forEach((fn) => fn());
    cleanups2.forEach((fn) => fn());
  };
}
function trackInteractOutside2(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(trackInteractOutsideImpl(node2, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}

// node_modules/@ark-ui/react/node_modules/@zag-js/dismissable/dist/index.mjs
function trackEscapeKeydown(node2, fn) {
  const handleKeyDown = (event) => {
    if (event.key !== "Escape") return;
    if (event.isComposing) return;
    fn == null ? void 0 : fn(event);
  };
  return addDomEvent2(getDocument(node2), "keydown", handleKeyDown, { capture: true });
}
var layerStack = {
  layers: [],
  branches: [],
  count() {
    return this.layers.length;
  },
  pointerBlockingLayers() {
    return this.layers.filter((layer) => layer.pointerBlocking);
  },
  topMostPointerBlockingLayer() {
    return [...this.pointerBlockingLayers()].slice(-1)[0];
  },
  hasPointerBlockingLayer() {
    return this.pointerBlockingLayers().length > 0;
  },
  isBelowPointerBlockingLayer(node2) {
    var _a7;
    const index = this.indexOf(node2);
    const highestBlockingIndex = this.topMostPointerBlockingLayer() ? this.indexOf((_a7 = this.topMostPointerBlockingLayer()) == null ? void 0 : _a7.node) : -1;
    return index < highestBlockingIndex;
  },
  isTopMost(node2) {
    const layer = this.layers[this.count() - 1];
    return (layer == null ? void 0 : layer.node) === node2;
  },
  getNestedLayers(node2) {
    return Array.from(this.layers).slice(this.indexOf(node2) + 1);
  },
  isInNestedLayer(node2, target) {
    return this.getNestedLayers(node2).some((layer) => contains(layer.node, target));
  },
  isInBranch(target) {
    return Array.from(this.branches).some((branch) => contains(branch, target));
  },
  add(layer) {
    const num = this.layers.push(layer);
    layer.node.style.setProperty("--layer-index", `${num}`);
  },
  addBranch(node2) {
    this.branches.push(node2);
  },
  remove(node2) {
    const index = this.indexOf(node2);
    if (index < 0) return;
    if (index < this.count() - 1) {
      const _layers = this.getNestedLayers(node2);
      _layers.forEach((layer) => layer.dismiss());
    }
    this.layers.splice(index, 1);
    node2.style.removeProperty("--layer-index");
  },
  removeBranch(node2) {
    const index = this.branches.indexOf(node2);
    if (index >= 0) this.branches.splice(index, 1);
  },
  indexOf(node2) {
    return this.layers.findIndex((layer) => layer.node === node2);
  },
  dismiss(node2) {
    var _a7;
    (_a7 = this.layers[this.indexOf(node2)]) == null ? void 0 : _a7.dismiss();
  },
  clear() {
    this.remove(this.layers[0].node);
  }
};
var originalBodyPointerEvents;
function assignPointerEventToLayers() {
  layerStack.layers.forEach(({ node: node2 }) => {
    node2.style.pointerEvents = layerStack.isBelowPointerBlockingLayer(node2) ? "none" : "auto";
  });
}
function clearPointerEvent(node2) {
  node2.style.pointerEvents = "";
}
function disablePointerEventsOutside(node2, peristentElements) {
  const doc = getDocument(node2);
  const cleanups2 = [];
  if (layerStack.hasPointerBlockingLayer() && !doc.body.hasAttribute("data-inert")) {
    originalBodyPointerEvents = document.body.style.pointerEvents;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = "none";
      doc.body.setAttribute("data-inert", "");
    });
  }
  if (peristentElements) {
    const persistedCleanup = waitForElements(peristentElements, (el) => {
      cleanups2.push(setStyle(el, { pointerEvents: "auto" }));
    });
    cleanups2.push(persistedCleanup);
  }
  return () => {
    if (layerStack.hasPointerBlockingLayer()) return;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = originalBodyPointerEvents;
      doc.body.removeAttribute("data-inert");
      if (doc.body.style.length === 0) doc.body.removeAttribute("style");
    });
    cleanups2.forEach((fn) => fn());
  };
}
function trackDismissableElementImpl(node2, options) {
  if (!node2) {
    warn3("[@zag-js/dismissable] node is `null` or `undefined`");
    return;
  }
  const { onDismiss, pointerBlocking, exclude: excludeContainers, debug } = options;
  const layer = { dismiss: onDismiss, node: node2, pointerBlocking };
  layerStack.add(layer);
  assignPointerEventToLayers();
  function onPointerDownOutside(event) {
    var _a7, _b6;
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isBelowPointerBlockingLayer(node2) || layerStack.isInBranch(target)) return;
    (_a7 = options.onPointerDownOutside) == null ? void 0 : _a7.call(options, event);
    (_b6 = options.onInteractOutside) == null ? void 0 : _b6.call(options, event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onPointerDownOutside:", event.detail.originalEvent);
    }
    onDismiss == null ? void 0 : onDismiss();
  }
  function onFocusOutside(event) {
    var _a7, _b6;
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isInBranch(target)) return;
    (_a7 = options.onFocusOutside) == null ? void 0 : _a7.call(options, event);
    (_b6 = options.onInteractOutside) == null ? void 0 : _b6.call(options, event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onFocusOutside:", event.detail.originalEvent);
    }
    onDismiss == null ? void 0 : onDismiss();
  }
  function onEscapeKeyDown(event) {
    var _a7;
    if (!layerStack.isTopMost(node2)) return;
    (_a7 = options.onEscapeKeyDown) == null ? void 0 : _a7.call(options, event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }
  function exclude(target) {
    var _a7;
    if (!node2) return false;
    const containers = typeof excludeContainers === "function" ? excludeContainers() : excludeContainers;
    const _containers = Array.isArray(containers) ? containers : [containers];
    const persistentElements = (_a7 = options.persistentElements) == null ? void 0 : _a7.map((fn) => fn()).filter(isHTMLElement);
    if (persistentElements) _containers.push(...persistentElements);
    return _containers.some((node22) => contains(node22, target)) || layerStack.isInNestedLayer(node2, target);
  }
  const cleanups2 = [
    pointerBlocking ? disablePointerEventsOutside(node2, options.persistentElements) : void 0,
    trackEscapeKeydown(node2, onEscapeKeyDown),
    trackInteractOutside2(node2, { exclude, onFocusOutside, onPointerDownOutside, defer: options.defer })
  ];
  return () => {
    layerStack.remove(node2);
    assignPointerEventToLayers();
    clearPointerEvent(node2);
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function trackDismissableElement2(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = isFunction23(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      cleanups2.push(trackDismissableElementImpl(node2, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function trackDismissableBranch2(nodeOrFn, options = {}) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = isFunction23(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      if (!node2) {
        warn3("[@zag-js/dismissable] branch node is `null` or `undefined`");
        return;
      }
      layerStack.addBranch(node2);
      cleanups2.push(() => {
        layerStack.removeBranch(node2);
      });
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}

// node_modules/@ark-ui/react/node_modules/@zag-js/form-utils/dist/index.mjs
var getWindow11 = (el) => el.ownerDocument.defaultView || window;
function getDescriptor2(el, options) {
  const { type = "HTMLInputElement", property = "value" } = options;
  const proto = getWindow11(el)[type].prototype;
  return Object.getOwnPropertyDescriptor(proto, property) ?? {};
}
function setElementValue2(el, value, option = {}) {
  var _a7;
  const descriptor = getDescriptor2(el, option);
  (_a7 = descriptor.set) == null ? void 0 : _a7.call(el, value);
  el.setAttribute("value", value);
}
function setElementChecked2(el, checked) {
  var _a7;
  const descriptor = getDescriptor2(el, { type: "HTMLInputElement", property: "checked" });
  (_a7 = descriptor.set) == null ? void 0 : _a7.call(el, checked);
  if (checked) el.setAttribute("checked", "");
  else el.removeAttribute("checked");
}
function dispatchInputValueEvent2(el, options) {
  const { value, bubbles = true } = options;
  if (!el) return;
  const win = getWindow11(el);
  if (!(el instanceof win.HTMLInputElement)) return;
  setElementValue2(el, `${value}`);
  el.dispatchEvent(new win.Event("input", { bubbles }));
}
function dispatchInputCheckedEvent2(el, options) {
  const { checked, bubbles = true } = options;
  if (!el) return;
  const win = getWindow11(el);
  if (!(el instanceof win.HTMLInputElement)) return;
  setElementChecked2(el, checked);
  el.dispatchEvent(new win.Event("click", { bubbles }));
}
function getClosestForm(el) {
  if (isFormElement(el)) return el.form;
  else return el.closest("form");
}
function isFormElement(el) {
  return el.matches("textarea, input, select, button");
}
function trackFormReset(el, callback) {
  if (!el) return;
  const form = getClosestForm(el);
  form == null ? void 0 : form.addEventListener("reset", callback, { passive: true });
  return () => {
    form == null ? void 0 : form.removeEventListener("reset", callback);
  };
}
function trackFieldsetDisabled(el, callback) {
  const fieldset = el == null ? void 0 : el.closest("fieldset");
  if (!fieldset) return;
  callback(fieldset.disabled);
  const win = fieldset.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver(() => callback(fieldset.disabled));
  obs.observe(fieldset, {
    attributes: true,
    attributeFilter: ["disabled"]
  });
  return () => obs.disconnect();
}
function trackFormControl2(el, options) {
  if (!el) return;
  const { onFieldsetDisabledChange, onFormReset } = options;
  const cleanups2 = [trackFormReset(el, onFormReset), trackFieldsetDisabled(el, onFieldsetDisabledChange)];
  return () => {
    cleanups2.forEach((cleanup) => cleanup == null ? void 0 : cleanup());
  };
}

// node_modules/@ark-ui/react/node_modules/@zag-js/color-picker/dist/index.mjs
var anatomy44 = createAnatomy2("color-picker", [
  "root",
  "label",
  "control",
  "trigger",
  "positioner",
  "content",
  "area",
  "areaThumb",
  "valueText",
  "areaBackground",
  "channelSlider",
  "channelSliderLabel",
  "channelSliderTrack",
  "channelSliderThumb",
  "channelSliderValueText",
  "channelInput",
  "transparencyGrid",
  "swatchGroup",
  "swatchTrigger",
  "swatchIndicator",
  "swatch",
  "eyeDropperTrigger",
  "formatTrigger",
  "formatSelect"
]);
var parts37 = anatomy44.build();
var dom37 = createScope({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `color-picker:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `color-picker:${ctx.id}:label`;
  },
  getHiddenInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.hiddenInput) ?? `color-picker:${ctx.id}:hidden-input`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `color-picker:${ctx.id}:control`;
  },
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `color-picker:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `color-picker:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.positioner) ?? `color-picker:${ctx.id}:positioner`;
  },
  getFormatSelectId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.formatSelect) ?? `color-picker:${ctx.id}:format-select`;
  },
  getAreaId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.area) ?? `color-picker:${ctx.id}:area`;
  },
  getAreaGradientId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.areaGradient) ?? `color-picker:${ctx.id}:area-gradient`;
  },
  getAreaThumbId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.areaThumb) ?? `color-picker:${ctx.id}:area-thumb`;
  },
  getChannelSliderTrackId: (ctx, channel) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.channelSliderTrack) == null ? void 0 : _b6.call(_a7, channel)) ?? `color-picker:${ctx.id}:slider-track:${channel}`;
  },
  getChannelSliderThumbId: (ctx, channel) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.channelSliderThumb) == null ? void 0 : _b6.call(_a7, channel)) ?? `color-picker:${ctx.id}:slider-thumb:${channel}`;
  },
  getContentEl: (ctx) => dom37.getById(ctx, dom37.getContentId(ctx)),
  getAreaThumbEl: (ctx) => dom37.getById(ctx, dom37.getAreaThumbId(ctx)),
  getChannelSliderThumbEl: (ctx, channel) => dom37.getById(ctx, dom37.getChannelSliderThumbId(ctx, channel)),
  getChannelInputEl: (ctx, channel) => {
    const selector = `input[data-channel="${channel}"]`;
    return [
      ...queryAll(dom37.getContentEl(ctx), selector),
      ...queryAll(dom37.getControlEl(ctx), selector)
    ];
  },
  getFormatSelectEl: (ctx) => dom37.getById(ctx, dom37.getFormatSelectId(ctx)),
  getHiddenInputEl: (ctx) => dom37.getById(ctx, dom37.getHiddenInputId(ctx)),
  getAreaEl: (ctx) => dom37.getById(ctx, dom37.getAreaId(ctx)),
  getAreaValueFromPoint(ctx, point) {
    const areaEl = dom37.getAreaEl(ctx);
    if (!areaEl) return;
    const { percent } = getRelativePoint2(point, areaEl);
    return percent;
  },
  getControlEl: (ctx) => dom37.getById(ctx, dom37.getControlId(ctx)),
  getTriggerEl: (ctx) => dom37.getById(ctx, dom37.getTriggerId(ctx)),
  getPositionerEl: (ctx) => dom37.getById(ctx, dom37.getPositionerId(ctx)),
  getChannelSliderTrackEl: (ctx, channel) => {
    return dom37.getById(ctx, dom37.getChannelSliderTrackId(ctx, channel));
  },
  getChannelSliderValueFromPoint(ctx, point, channel) {
    const trackEl = dom37.getChannelSliderTrackEl(ctx, channel);
    if (!trackEl) return;
    const { percent } = getRelativePoint2(point, trackEl);
    return percent;
  },
  getChannelInputEls: (ctx) => {
    return [
      ...queryAll(dom37.getContentEl(ctx), "input[data-channel]"),
      ...queryAll(dom37.getControlEl(ctx), "input[data-channel]")
    ];
  }
});
var formats2 = ["hsba", "hsla", "rgba"];
var formatRegex2 = new RegExp(`^(${formats2.join("|")})$`);
var { and: and36 } = guards20;

// node_modules/@ark-ui/react/node_modules/@zag-js/date-picker/dist/index.mjs
var anatomy45 = createAnatomy2("date-picker").parts(
  "root",
  "label",
  "clearTrigger",
  "content",
  "control",
  "input",
  "monthSelect",
  "nextTrigger",
  "positioner",
  "prevTrigger",
  "rangeText",
  "table",
  "tableBody",
  "tableCell",
  "tableCellTrigger",
  "tableHead",
  "tableHeader",
  "tableRow",
  "trigger",
  "viewTrigger",
  "viewControl",
  "yearSelect",
  "presetTrigger"
);
var parts38 = anatomy45.build();
var dom38 = createScope({
  getLabelId: (ctx, index) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.label) == null ? void 0 : _b6.call(_a7, index)) ?? `datepicker:${ctx.id}:label:${index}`;
  },
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `datepicker:${ctx.id}`;
  },
  getTableId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.table) == null ? void 0 : _b6.call(_a7, id)) ?? `datepicker:${ctx.id}:table:${id}`;
  },
  getTableHeaderId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.tableHeader) == null ? void 0 : _b6.call(_a7, id)) ?? `datepicker:${ctx.id}:thead`;
  },
  getTableBodyId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.tableBody) == null ? void 0 : _b6.call(_a7, id)) ?? `datepicker:${ctx.id}:tbody`;
  },
  getTableRowId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.tableRow) == null ? void 0 : _b6.call(_a7, id)) ?? `datepicker:${ctx.id}:tr:${id}`;
  },
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `datepicker:${ctx.id}:content`;
  },
  getCellTriggerId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.cellTrigger) == null ? void 0 : _b6.call(_a7, id)) ?? `datepicker:${ctx.id}:cell-trigger:${id}`;
  },
  getPrevTriggerId: (ctx, view) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.prevTrigger) == null ? void 0 : _b6.call(_a7, view)) ?? `datepicker:${ctx.id}:prev:${view}`;
  },
  getNextTriggerId: (ctx, view) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.nextTrigger) == null ? void 0 : _b6.call(_a7, view)) ?? `datepicker:${ctx.id}:next:${view}`;
  },
  getViewTriggerId: (ctx, view) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.viewTrigger) == null ? void 0 : _b6.call(_a7, view)) ?? `datepicker:${ctx.id}:view:${view}`;
  },
  getClearTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.clearTrigger) ?? `datepicker:${ctx.id}:clear`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `datepicker:${ctx.id}:control`;
  },
  getInputId: (ctx, index) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.input) == null ? void 0 : _b6.call(_a7, index)) ?? `datepicker:${ctx.id}:input:${index}`;
  },
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `datepicker:${ctx.id}:trigger`;
  },
  getPositionerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.positioner) ?? `datepicker:${ctx.id}:positioner`;
  },
  getMonthSelectId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.monthSelect) ?? `datepicker:${ctx.id}:month-select`;
  },
  getYearSelectId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.yearSelect) ?? `datepicker:${ctx.id}:year-select`;
  },
  getFocusedCell: (ctx, view = ctx.view) => query(
    dom38.getContentEl(ctx),
    `[data-part=table-cell-trigger][data-view=${view}][data-focus]:not([data-outside-range])`
  ),
  getTriggerEl: (ctx) => dom38.getById(ctx, dom38.getTriggerId(ctx)),
  getContentEl: (ctx) => dom38.getById(ctx, dom38.getContentId(ctx)),
  getInputEls: (ctx) => queryAll(dom38.getControlEl(ctx), `[data-part=input]`),
  getYearSelectEl: (ctx) => dom38.getById(ctx, dom38.getYearSelectId(ctx)),
  getMonthSelectEl: (ctx) => dom38.getById(ctx, dom38.getMonthSelectId(ctx)),
  getClearTriggerEl: (ctx) => dom38.getById(ctx, dom38.getClearTriggerId(ctx)),
  getPositionerEl: (ctx) => dom38.getById(ctx, dom38.getPositionerId(ctx)),
  getControlEl: (ctx) => dom38.getById(ctx, dom38.getControlId(ctx))
});
var { and: and37 } = guards20;
var props31 = createProps30()([
  "closeOnSelect",
  "dir",
  "disabled",
  "fixedWeeks",
  "focusedValue",
  "format",
  "getRootNode",
  "id",
  "ids",
  "isDateUnavailable",
  "isDateUnavailable",
  "locale",
  "max",
  "min",
  "modal",
  "name",
  "numOfMonths",
  "onFocusChange",
  "onOpenChange",
  "onValueChange",
  "onViewChange",
  "open",
  "open.controlled",
  "positioning",
  "readOnly",
  "selectionMode",
  "startOfWeek",
  "timeZone",
  "translations",
  "value",
  "view"
]);
var splitProps33 = createSplitProps2(props31);
var inputProps2 = createProps30()(["index"]);
var splitInputProps2 = createSplitProps2(inputProps2);
var presetTriggerProps2 = createProps30()(["value"]);
var splitPresetTriggerProps2 = createSplitProps2(presetTriggerProps2);
var tableProps2 = createProps30()(["columns", "id", "view"]);
var splitTableProps2 = createSplitProps2(tableProps2);
var tableCellProps2 = createProps30()(["disabled", "value", "columns"]);
var splitTableCellProps2 = createSplitProps2(tableCellProps2);
var viewProps2 = createProps30()(["view"]);
var splitViewProps2 = createSplitProps2(viewProps2);

// node_modules/@ark-ui/react/dist/utils/render-strategy.js
var [RenderStrategyPropsProvider, useRenderStrategyPropsContext] = createContext({
  name: "RenderStrategyContext",
  hookName: "useRenderStrategyContext",
  providerName: "<RenderStrategyPropsProvider />"
});
var splitRenderStrategyProps = (props52) => createSplitProps3()(props52, ["lazyMount", "unmountOnExit"]);

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion-item-props-context.js
var [AccordionItemPropsProvider, useAccordionItemPropsContext] = createContext({
  name: "AccordionItemPropsContext",
  hookName: "useAccordionItemPropsContext",
  providerName: "<AccordionItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item.js
var AccordionItem = (0, import_react27.forwardRef)((props52, ref36) => {
  const [itemProps17, localProps] = splitItemProps10(props52);
  const accordion = useAccordionContext();
  const renderStrategy = useRenderStrategyPropsContext();
  const mergedProps = mergeProps3(accordion.getItemProps(itemProps17), localProps);
  const item = accordion.getItemState(itemProps17);
  const itemContentProps = accordion.getItemContentProps(itemProps17);
  return (0, import_jsx_runtime11.jsx)(AccordionItemPropsProvider, { value: itemProps17, children: (0, import_jsx_runtime11.jsx)(AccordionItemProvider, { value: item, children: (0, import_jsx_runtime11.jsx)(
    CollapsibleRoot,
    {
      ref: ref36,
      open: item.expanded,
      ids: { content: itemContentProps.id },
      ...renderStrategy,
      ...mergedProps
    }
  ) }) });
});
AccordionItem.displayName = "AccordionItem";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-content.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react31 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-content.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react29 = __toESM(require_react(), 1);
var CollapsibleContent = (0, import_react29.forwardRef)(
  (props52, ref36) => {
    const collapsible = useCollapsibleContext();
    if (collapsible.isUnmounted) {
      return null;
    }
    const mergedProps = mergeProps3(collapsible.getContentProps(), props52);
    return (0, import_jsx_runtime12.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
CollapsibleContent.displayName = "CollapsibleContent";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-content.js
var splitVisibilityProps = createSplitProps3();
var AccordionItemContent = (0, import_react31.forwardRef)(
  (props52, ref36) => {
    const accordion = useAccordionContext();
    const itemProps17 = useAccordionItemPropsContext();
    const contentProps3 = accordion.getItemContentProps(itemProps17);
    const [, itemContentProps] = splitVisibilityProps(contentProps3, ["hidden", "data-state"]);
    const mergedProps = mergeProps3(itemContentProps, props52);
    return (0, import_jsx_runtime13.jsx)(CollapsibleContent, { ref: ref36, ...mergedProps });
  }
);
AccordionItemContent.displayName = "AccordionItemContent";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-context.js
var AccordionItemContext = (props52) => props52.children(useAccordionItemContext());

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-indicator.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var import_react33 = __toESM(require_react(), 1);
var AccordionItemIndicator = (0, import_react33.forwardRef)(
  (props52, ref36) => {
    const accordion = useAccordionContext();
    const itemProps17 = useAccordionItemPropsContext();
    const mergedProps = mergeProps3(accordion.getItemIndicatorProps(itemProps17), props52);
    return (0, import_jsx_runtime14.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
AccordionItemIndicator.displayName = "AccordionItemIndicator";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-trigger.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_react35 = __toESM(require_react(), 1);
var AccordionItemTrigger = (0, import_react35.forwardRef)(
  (props52, ref36) => {
    const accordion = useAccordionContext();
    const itemProps17 = useAccordionItemPropsContext();
    const collapsible = useCollapsibleContext();
    const triggerProps3 = accordion.getItemTriggerProps(itemProps17);
    const mergedProps = mergeProps3(
      {
        ...triggerProps3,
        "aria-controls": collapsible.isUnmounted ? void 0 : triggerProps3["aria-controls"]
      },
      props52
    );
    return (0, import_jsx_runtime15.jsx)(ark.button, { ...mergedProps, ref: ref36 });
  }
);
AccordionItemTrigger.displayName = "AccordionItemTrigger";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-root.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_react39 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion.js
var import_react37 = __toESM(require_react(), 1);
var useAccordion = (props52 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react37.useId)(),
    dir,
    getRootNode: getRootNode2,
    value: props52.defaultValue,
    ...props52
  };
  const context = {
    ...initialContext,
    value: props52.value,
    onFocusChange: useEvent(props52.onFocusChange),
    onValueChange: useEvent(props52.onValueChange)
  };
  const [state2, send] = useMachine(machine(initialContext), { context });
  return connect(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/accordion/accordion-root.js
var AccordionRoot = (0, import_react39.forwardRef)((props52, ref36) => {
  const [renderStrategyProps, accordionProps] = splitRenderStrategyProps(props52);
  const [useAccordionProps, localProps] = createSplitProps3()(accordionProps, [
    "collapsible",
    "defaultValue",
    "disabled",
    "id",
    "ids",
    "multiple",
    "onFocusChange",
    "onValueChange",
    "orientation",
    "value"
  ]);
  const accordion = useAccordion(useAccordionProps);
  const mergedProps = mergeProps3(accordion.getRootProps(), localProps);
  return (0, import_jsx_runtime16.jsx)(AccordionProvider, { value: accordion, children: (0, import_jsx_runtime16.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime16.jsx)(ark.div, { ...mergedProps, ref: ref36 }) }) });
});
AccordionRoot.displayName = "AccordionRoot";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-root-provider.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_react41 = __toESM(require_react(), 1);
var AccordionRootProvider = (0, import_react41.forwardRef)(
  (props52, ref36) => {
    const [renderStrategyProps, accordionProps] = splitRenderStrategyProps(props52);
    const [{ value: accordion }, localProps] = createSplitProps3()(
      accordionProps,
      ["value"]
    );
    const mergedProps = mergeProps3(accordion.getRootProps(), localProps);
    return (0, import_jsx_runtime17.jsx)(AccordionProvider, { value: accordion, children: (0, import_jsx_runtime17.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime17.jsx)(ark.div, { ...mergedProps, ref: ref36 }) }) });
  }
);
AccordionRootProvider.displayName = "AccordionRootProvider";

// node_modules/@ark-ui/react/dist/components/accordion/accordion.js
var accordion_exports = {};
__export(accordion_exports, {
  Context: () => AccordionContext,
  Item: () => AccordionItem,
  ItemContent: () => AccordionItemContent,
  ItemContext: () => AccordionItemContext,
  ItemIndicator: () => AccordionItemIndicator,
  ItemTrigger: () => AccordionItemTrigger,
  Root: () => AccordionRoot,
  RootProvider: () => AccordionRootProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/accordion/accordion.js
var {
  withProvider,
  withContext,
  useStyles: useAccordionStyles,
  PropsProvider
} = createSlotRecipeContext({ key: "accordion" });
var AccordionRootProvider2 = withProvider(accordion_exports.RootProvider, "root", { forwardAsChild: true });
var AccordionRoot2 = withProvider(
  accordion_exports.Root,
  "root",
  { forwardAsChild: true }
);
var AccordionPropsProvider = PropsProvider;
var AccordionItem2 = withContext(
  accordion_exports.Item,
  "item",
  { forwardAsChild: true }
);
var AccordionItemContent2 = withContext(accordion_exports.ItemContent, "itemContent", { forwardAsChild: true });
var AccordionItemBody = withContext("div", "itemBody");
var AccordionItemTrigger2 = withContext(accordion_exports.ItemTrigger, "itemTrigger", { forwardAsChild: true });
var AccordionItemIndicator2 = withContext(accordion_exports.ItemIndicator, "itemIndicator", { forwardAsChild: true });
var AccordionContext2 = accordion_exports.Context;
var AccordionItemContext2 = accordion_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/accordion/namespace.js
var namespace_exports = {};
__export(namespace_exports, {
  Context: () => AccordionContext2,
  Item: () => AccordionItem2,
  ItemBody: () => AccordionItemBody,
  ItemContent: () => AccordionItemContent2,
  ItemContext: () => AccordionItemContext2,
  ItemIndicator: () => AccordionItemIndicator2,
  ItemTrigger: () => AccordionItemTrigger2,
  PropsProvider: () => AccordionPropsProvider,
  Root: () => AccordionRoot2,
  RootProvider: () => AccordionRootProvider2
});

// node_modules/@ark-ui/react/dist/components/popover/popover-anchor.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_react43 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/popover/use-popover-context.js
var [PopoverProvider, usePopoverContext] = createContext({
  name: "PopoverContext",
  hookName: "usePopoverContext",
  providerName: "<PopoverProvider />"
});

// node_modules/@ark-ui/react/dist/components/popover/popover-anchor.js
var PopoverAnchor = (0, import_react43.forwardRef)((props52, ref36) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps3(popover.getAnchorProps(), props52);
  return (0, import_jsx_runtime18.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
PopoverAnchor.displayName = "PopoverAnchor";

// node_modules/@ark-ui/react/dist/components/popover/popover-arrow.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_react45 = __toESM(require_react(), 1);
var PopoverArrow = (0, import_react45.forwardRef)((props52, ref36) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps3(popover.getArrowProps(), props52);
  return (0, import_jsx_runtime19.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
PopoverArrow.displayName = "PopoverArrow";

// node_modules/@ark-ui/react/dist/components/popover/popover-arrow-tip.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_react47 = __toESM(require_react(), 1);
var PopoverArrowTip = (0, import_react47.forwardRef)((props52, ref36) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps3(popover.getArrowTipProps(), props52);
  return (0, import_jsx_runtime20.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
PopoverArrowTip.displayName = "PopoverArrowTip";

// node_modules/@ark-ui/react/dist/components/popover/popover-close-trigger.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_react49 = __toESM(require_react(), 1);
var PopoverCloseTrigger = (0, import_react49.forwardRef)(
  (props52, ref36) => {
    const popover = usePopoverContext();
    const mergedProps = mergeProps3(popover.getCloseTriggerProps(), props52);
    return (0, import_jsx_runtime21.jsx)(ark.button, { ...mergedProps, ref: ref36 });
  }
);
PopoverCloseTrigger.displayName = "PopoverCloseTrigger";

// node_modules/@ark-ui/react/dist/components/popover/popover-content.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var import_react51 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/presence/use-presence-context.js
var [PresenceProvider, usePresenceContext] = createContext({
  name: "PresenceContext",
  hookName: "usePresenceContext",
  providerName: "<PresenceProvider />"
});

// node_modules/@ark-ui/react/dist/components/popover/popover-content.js
var PopoverContent = (0, import_react51.forwardRef)((props52, ref36) => {
  const popover = usePopoverContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps3(popover.getContentProps(), presence.getPresenceProps(), props52);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime22.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref36) });
});
PopoverContent.displayName = "PopoverContent";

// node_modules/@ark-ui/react/dist/components/popover/popover-context.js
var PopoverContext = (props52) => props52.children(usePopoverContext());

// node_modules/@ark-ui/react/dist/components/popover/popover-description.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var import_react53 = __toESM(require_react(), 1);
var PopoverDescription = (0, import_react53.forwardRef)(
  (props52, ref36) => {
    const popover = usePopoverContext();
    const mergedProps = mergeProps3(popover.getDescriptionProps(), props52);
    return (0, import_jsx_runtime23.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
PopoverDescription.displayName = "PopoverDescription";

// node_modules/@ark-ui/react/dist/components/popover/popover-indicator.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var import_react55 = __toESM(require_react(), 1);
var PopoverIndicator = (0, import_react55.forwardRef)((props52, ref36) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps3(popover.getIndicatorProps(), props52);
  return (0, import_jsx_runtime24.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
PopoverIndicator.displayName = "PopoverIndicator";

// node_modules/@ark-ui/react/dist/components/popover/popover-positioner.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var import_react57 = __toESM(require_react(), 1);
var PopoverPositioner = (0, import_react57.forwardRef)(
  (props52, ref36) => {
    const popover = usePopoverContext();
    const presence = usePresenceContext();
    const mergedProps = mergeProps3(popover.getPositionerProps(), props52);
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime25.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
PopoverPositioner.displayName = "PopoverPositioner";

// node_modules/@ark-ui/react/dist/components/popover/popover-root.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/presence/split-presence-props.js
var splitPresenceProps = (props52) => createSplitProps3()(props52, [
  "immediate",
  "lazyMount",
  "onExitComplete",
  "present",
  "unmountOnExit"
]);

// node_modules/@ark-ui/react/node_modules/@zag-js/presence/dist/index.mjs
function connect3(state2, send, _normalize) {
  const present = state2.matches("mounted", "unmountSuspended");
  return {
    skip: !state2.context.initial && present,
    present,
    setNode(node2) {
      if (!node2) return;
      send({ type: "NODE.SET", node: node2 });
    },
    unmount() {
      send({ type: "UNMOUNT" });
    }
  };
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function machine3(ctx) {
  return createMachine35(
    {
      initial: ctx.present ? "mounted" : "unmounted",
      context: {
        node: null,
        styles: null,
        unmountAnimationName: null,
        prevAnimationName: null,
        present: false,
        initial: false,
        ...ctx
      },
      exit: ["clearInitial"],
      watch: {
        present: ["setInitial", "syncPresence"]
      },
      on: {
        "NODE.SET": {
          actions: ["setNode", "setStyles"]
        }
      },
      states: {
        mounted: {
          on: {
            UNMOUNT: {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            },
            "UNMOUNT.SUSPEND": "unmountSuspended"
          }
        },
        unmountSuspended: {
          activities: ["trackAnimationEvents"],
          on: {
            MOUNT: {
              target: "mounted",
              actions: ["setPrevAnimationName"]
            },
            "ANIMATION.END": {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            },
            UNMOUNT: {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            }
          }
        },
        unmounted: {
          entry: ["clearPrevAnimationName"],
          on: {
            MOUNT: {
              target: "mounted",
              actions: ["setPrevAnimationName"]
            }
          }
        }
      }
    },
    {
      actions: {
        setInitial(ctx2) {
          ctx2.initial = true;
        },
        clearInitial(ctx2) {
          ctx2.initial = false;
        },
        invokeOnExitComplete(ctx2) {
          var _a7;
          (_a7 = ctx2.onExitComplete) == null ? void 0 : _a7.call(ctx2);
        },
        setNode(ctx2, evt) {
          ctx2.node = ref35(evt.node);
        },
        setStyles(ctx2, evt) {
          const win = evt.node.ownerDocument.defaultView || window;
          ctx2.styles = ref35(win.getComputedStyle(evt.node));
        },
        syncPresence(ctx2, _evt, { send }) {
          if (ctx2.present) {
            send({ type: "MOUNT", src: "presence.changed" });
            return;
          }
          const animationName = getAnimationName(ctx2.styles);
          const exec21 = ctx2.immediate ? queueMicrotask : requestAnimationFrame;
          exec21(() => {
            var _a7, _b6;
            ctx2.unmountAnimationName = animationName;
            if (animationName === "none" || animationName === ctx2.prevAnimationName || ((_a7 = ctx2.styles) == null ? void 0 : _a7.display) === "none" || ((_b6 = ctx2.styles) == null ? void 0 : _b6.animationDuration) === "0s") {
              send({ type: "UNMOUNT", src: "presence.changed" });
            } else {
              send({ type: "UNMOUNT.SUSPEND" });
            }
          });
        },
        setPrevAnimationName(ctx2) {
          const exec21 = ctx2.immediate ? queueMicrotask : requestAnimationFrame;
          exec21(() => {
            ctx2.prevAnimationName = getAnimationName(ctx2.styles);
          });
        },
        clearPrevAnimationName(ctx2) {
          ctx2.prevAnimationName = null;
        }
      },
      activities: {
        trackAnimationEvents(ctx2, _evt, { send }) {
          const node2 = ctx2.node;
          if (!node2) return;
          const onStart = (event) => {
            var _a7, _b6;
            const target = ((_b6 = (_a7 = event.composedPath) == null ? void 0 : _a7.call(event)) == null ? void 0 : _b6[0]) ?? event.target;
            if (target === node2) {
              ctx2.prevAnimationName = getAnimationName(ctx2.styles);
            }
          };
          const onEnd = (event) => {
            var _a7, _b6;
            const animationName = getAnimationName(ctx2.styles);
            const target = ((_b6 = (_a7 = event.composedPath) == null ? void 0 : _a7.call(event)) == null ? void 0 : _b6[0]) ?? event.target;
            if (target === node2 && animationName === ctx2.unmountAnimationName) {
              send({ type: "UNMOUNT", src: "animationend" });
            }
          };
          node2.addEventListener("animationstart", onStart);
          node2.addEventListener("animationcancel", onEnd);
          node2.addEventListener("animationend", onEnd);
          return () => {
            node2.removeEventListener("animationstart", onStart);
            node2.removeEventListener("animationcancel", onEnd);
            node2.removeEventListener("animationend", onEnd);
          };
        }
      }
    }
  );
}
var props32 = createProps30()(["onExitComplete", "present", "immediate"]);

// node_modules/@ark-ui/react/dist/components/presence/use-presence.js
var import_react59 = __toESM(require_react(), 1);
var usePresence = (props52) => {
  const { lazyMount, unmountOnExit, ...rest } = props52;
  const wasEverPresent = (0, import_react59.useRef)(false);
  const context = {
    ...rest,
    onExitComplete: useEvent(props52.onExitComplete)
  };
  const [state2, send] = useMachine(machine3(context), { context });
  const api = connect3(state2, send, normalizeProps);
  if (api.present) {
    wasEverPresent.current = true;
  }
  const unmounted = !api.present && !wasEverPresent.current && lazyMount || unmountOnExit && !api.present && wasEverPresent.current;
  const getPresenceProps = () => ({
    "data-state": props52.present ? "open" : "closed",
    hidden: !api.present
  });
  return {
    ref: api.setNode,
    getPresenceProps,
    present: api.present,
    unmounted
  };
};

// node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node2) {
  return node2 && (node2.host || unwrapHost(node2.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node2) {
      if (elementsToKeep.has(node2)) {
        deep(node2);
      } else {
        try {
          var attr = node2.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node2) || 0) + 1;
          var markerValue = (markerCounter.get(node2) || 0) + 1;
          counterMap.set(node2, counterValue);
          markerCounter.set(node2, markerValue);
          hiddenNodes.push(node2);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node2, true);
          }
          if (markerValue === 1) {
            node2.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node2.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node2, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node2) {
      var counterValue = counterMap.get(node2) - 1;
      var markerValue = markerCounter.get(node2) - 1;
      counterMap.set(node2, counterValue);
      markerCounter.set(node2, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node2)) {
          node2.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node2);
      }
      if (!markerValue) {
        node2.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// node_modules/@ark-ui/react/node_modules/@zag-js/aria-hidden/dist/index.mjs
var raf27 = (fn) => {
  const frameId = requestAnimationFrame(() => fn());
  return () => cancelAnimationFrame(frameId);
};
function ariaHidden2(targetsOrFn, options = {}) {
  const { defer = true } = options;
  const func = defer ? raf27 : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const targets = typeof targetsOrFn === "function" ? targetsOrFn() : targetsOrFn;
      const elements = targets.filter(Boolean);
      cleanups2.push(hideOthers(elements));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}

// node_modules/@ark-ui/react/node_modules/@zag-js/remove-scroll/dist/index.mjs
var LOCK_CLASSNAME = "data-scroll-lock";
function assignStyle(el, style) {
  if (!el) return;
  const previousStyle = el.style.cssText;
  Object.assign(el.style, style);
  return () => {
    el.style.cssText = previousStyle;
  };
}
function setCSSProperty(el, property, value) {
  if (!el) return;
  const previousValue = el.style.getPropertyValue(property);
  el.style.setProperty(property, value);
  return () => {
    if (previousValue) {
      el.style.setProperty(property, previousValue);
    } else {
      el.style.removeProperty(property);
    }
  };
}
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function preventBodyScroll2(_document) {
  const doc = _document ?? document;
  const win = doc.defaultView ?? window;
  const { documentElement, body } = doc;
  const locked = body.hasAttribute(LOCK_CLASSNAME);
  if (locked) return;
  body.setAttribute(LOCK_CLASSNAME, "");
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  const setScrollbarWidthProperty = () => setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
  const paddingProperty = getPaddingProperty(documentElement);
  const setStyle3 = () => assignStyle(body, {
    overflow: "hidden",
    [paddingProperty]: `${scrollbarWidth}px`
  });
  const setIOSStyle = () => {
    const { scrollX, scrollY, visualViewport } = win;
    const offsetLeft = (visualViewport == null ? void 0 : visualViewport.offsetLeft) ?? 0;
    const offsetTop = (visualViewport == null ? void 0 : visualViewport.offsetTop) ?? 0;
    const restoreStyle = assignStyle(body, {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0",
      [paddingProperty]: `${scrollbarWidth}px`
    });
    return () => {
      restoreStyle == null ? void 0 : restoreStyle();
      win.scrollTo({ left: scrollX, top: scrollY, behavior: "instant" });
    };
  };
  const cleanups2 = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle3()];
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
    body.removeAttribute(LOCK_CLASSNAME);
  };
}

// node_modules/@ark-ui/react/node_modules/focus-trap/dist/focus-trap.esm.js
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
var activeFocusTraps = {
  activateTrap: function activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      var activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap: function deactivateTrap(trapStack, trap) {
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var isSelectableInput = function isSelectableInput2(node2) {
  return node2.tagName && node2.tagName.toLowerCase() === "input" && typeof node2.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e) {
  return (e === null || e === void 0 ? void 0 : e.key) === "Escape" || (e === null || e === void 0 ? void 0 : e.key) === "Esc" || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;
};
var isTabEvent = function isTabEvent2(e) {
  return (e === null || e === void 0 ? void 0 : e.key) === "Tab" || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;
};
var isKeyForward = function isKeyForward2(e) {
  return isTabEvent(e) && !e.shiftKey;
};
var isKeyBackward = function isKeyBackward2(e) {
  return isTabEvent(e) && e.shiftKey;
};
var delay = function delay2(fn) {
  return setTimeout(fn, 0);
};
var findIndex = function findIndex2(arr, fn) {
  var idx = -1;
  arr.every(function(value, i) {
    if (fn(value)) {
      idx = i;
      return false;
    }
    return true;
  });
  return idx;
};
var valueOrHandler = function valueOrHandler2(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === "function" ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget2(event) {
  return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
};
var internalTrapStack = [];
var createFocusTrap2 = function createFocusTrap3(elements, userOptions) {
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
  var config = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true,
    isKeyForward,
    isKeyBackward
  }, userOptions);
  var state2 = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   posTabIndexesFound: boolean,
    //   firstTabbableNode: HTMLElement|undefined,
    //   lastTabbableNode: HTMLElement|undefined,
    //   firstDomTabbableNode: HTMLElement|undefined,
    //   lastDomTabbableNode: HTMLElement|undefined,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0,
    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
    recentNavEvent: void 0
  };
  var trap;
  var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };
  var findContainerIndex = function findContainerIndex2(element, event) {
    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
    return state2.containerGroups.findIndex(function(_ref) {
      var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node2) {
        return node2 === element;
      });
    });
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var optionValue = config[optionName];
    if (typeof optionValue === "function") {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      optionValue = optionValue.apply(void 0, params);
    }
    if (optionValue === true) {
      optionValue = void 0;
    }
    if (!optionValue) {
      if (optionValue === void 0 || optionValue === false) {
        return optionValue;
      }
      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node2 = optionValue;
    if (typeof optionValue === "string") {
      node2 = doc.querySelector(optionValue);
      if (!node2) {
        throw new Error("`".concat(optionName, "` as selector refers to no known node"));
      }
    }
    return node2;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node2 = getNodeForOption("initialFocus");
    if (node2 === false) {
      return false;
    }
    if (node2 === void 0 || !isFocusable3(node2, config.tabbableOptions)) {
      if (findContainerIndex(doc.activeElement) >= 0) {
        node2 = doc.activeElement;
      } else {
        var firstTabbableGroup = state2.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
        node2 = firstTabbableNode || getNodeForOption("fallbackFocus");
      }
    }
    if (!node2) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node2;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state2.containerGroups = state2.containers.map(function(container) {
      var tabbableNodes = tabbable(container, config.tabbableOptions);
      var focusableNodes = focusable(container, config.tabbableOptions);
      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
      var firstDomTabbableNode = focusableNodes.find(function(node2) {
        return isTabbable2(node2);
      });
      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node2) {
        return isTabbable2(node2);
      });
      var posTabIndexesFound = !!tabbableNodes.find(function(node2) {
        return getTabIndex(node2) > 0;
      });
      return {
        container,
        tabbableNodes,
        focusableNodes,
        /** True if at least one node with positive `tabindex` was found in this container. */
        posTabIndexesFound,
        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
        firstTabbableNode,
        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
        lastTabbableNode,
        // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        //  because that API doesn't work with Shadow DOM as well as it should (@see
        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
        //  to address an edge case related to positive tabindex support, this seems like a much easier,
        //  "close enough most of the time" alternative for positive tabindexes which should generally
        //  be avoided anyway...
        /** First tabbable node in container, __DOM__ order; `undefined` if none. */
        firstDomTabbableNode,
        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
        lastDomTabbableNode,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node2) {
          var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var nodeIdx = tabbableNodes.indexOf(node2);
          if (nodeIdx < 0) {
            if (forward) {
              return focusableNodes.slice(focusableNodes.indexOf(node2) + 1).find(function(el) {
                return isTabbable2(el);
              });
            }
            return focusableNodes.slice(0, focusableNodes.indexOf(node2)).reverse().find(function(el) {
              return isTabbable2(el);
            });
          }
          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
        }
      };
    });
    state2.tabbableGroups = state2.containerGroups.filter(function(group2) {
      return group2.tabbableNodes.length > 0;
    });
    if (state2.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
    if (state2.containerGroups.find(function(g) {
      return g.posTabIndexesFound;
    }) && state2.containerGroups.length > 1) {
      throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
    }
  };
  var _getActiveElement = function getActiveElement2(el) {
    var activeElement = el.activeElement;
    if (!activeElement) {
      return;
    }
    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
      return _getActiveElement(activeElement.shadowRoot);
    }
    return activeElement;
  };
  var _tryFocus = function tryFocus(node2) {
    if (node2 === false) {
      return;
    }
    if (node2 === _getActiveElement(document)) {
      return;
    }
    if (!node2 || !node2.focus) {
      _tryFocus(getInitialFocusNode());
      return;
    }
    node2.focus({
      preventScroll: !!config.preventScroll
    });
    state2.mostRecentlyFocusedNode = node2;
    if (isSelectableInput(node2)) {
      node2.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node2 = getNodeForOption("setReturnFocus", previousActiveElement);
    return node2 ? node2 : node2 === false ? false : previousActiveElement;
  };
  var findNextNavNode = function findNextNavNode2(_ref2) {
    var target = _ref2.target, event = _ref2.event, _ref2$isBackward = _ref2.isBackward, isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;
    target = target || getActualTarget(event);
    updateTabbableNodes();
    var destinationNode = null;
    if (state2.tabbableGroups.length > 0) {
      var containerIndex = findContainerIndex(target, event);
      var containerGroup = containerIndex >= 0 ? state2.containerGroups[containerIndex] : void 0;
      if (containerIndex < 0) {
        if (isBackward) {
          destinationNode = state2.tabbableGroups[state2.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          destinationNode = state2.tabbableGroups[0].firstTabbableNode;
        }
      } else if (isBackward) {
        var startOfGroupIndex = findIndex(state2.tabbableGroups, function(_ref3) {
          var firstTabbableNode = _ref3.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable3(target, config.tabbableOptions) && !isTabbable2(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state2.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state2.tabbableGroups[destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target, false);
        }
      } else {
        var lastOfGroupIndex = findIndex(state2.tabbableGroups, function(_ref4) {
          var lastTabbableNode = _ref4.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable3(target, config.tabbableOptions) && !isTabbable2(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state2.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state2.tabbableGroups[_destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target);
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    return destinationNode;
  };
  var checkPointerDown = function checkPointerDown2(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target, e) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      trap.deactivate({
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked (and if not focusable, to "nothing"); by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node), whether the
        //  outside click was on a focusable node or not
        returnFocus: config.returnFocusOnDeactivate
      });
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(event) {
    var target = getActualTarget(event);
    var targetContained = findContainerIndex(target, event) >= 0;
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state2.mostRecentlyFocusedNode = target;
      }
    } else {
      event.stopImmediatePropagation();
      var nextNode;
      var navAcrossContainers = true;
      if (state2.mostRecentlyFocusedNode) {
        if (getTabIndex(state2.mostRecentlyFocusedNode) > 0) {
          var mruContainerIdx = findContainerIndex(state2.mostRecentlyFocusedNode);
          var tabbableNodes = state2.containerGroups[mruContainerIdx].tabbableNodes;
          if (tabbableNodes.length > 0) {
            var mruTabIdx = tabbableNodes.findIndex(function(node2) {
              return node2 === state2.mostRecentlyFocusedNode;
            });
            if (mruTabIdx >= 0) {
              if (config.isKeyForward(state2.recentNavEvent)) {
                if (mruTabIdx + 1 < tabbableNodes.length) {
                  nextNode = tabbableNodes[mruTabIdx + 1];
                  navAcrossContainers = false;
                }
              } else {
                if (mruTabIdx - 1 >= 0) {
                  nextNode = tabbableNodes[mruTabIdx - 1];
                  navAcrossContainers = false;
                }
              }
            }
          }
        } else {
          if (!state2.containerGroups.some(function(g) {
            return g.tabbableNodes.some(function(n) {
              return getTabIndex(n) > 0;
            });
          })) {
            navAcrossContainers = false;
          }
        }
      } else {
        navAcrossContainers = false;
      }
      if (navAcrossContainers) {
        nextNode = findNextNavNode({
          // move FROM the MRU node, not event-related node (which will be the node that is
          //  outside the trap causing the focus escape we're trying to fix)
          target: state2.mostRecentlyFocusedNode,
          isBackward: config.isKeyBackward(state2.recentNavEvent)
        });
      }
      if (nextNode) {
        _tryFocus(nextNode);
      } else {
        _tryFocus(state2.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    }
    state2.recentNavEvent = void 0;
  };
  var checkKeyNav = function checkKeyNav2(event) {
    var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    state2.recentNavEvent = event;
    var destinationNode = findNextNavNode({
      event,
      isBackward
    });
    if (destinationNode) {
      if (isTabEvent(event)) {
        event.preventDefault();
      }
      _tryFocus(destinationNode);
    }
  };
  var checkTabKey = function checkTabKey2(event) {
    if (config.isKeyForward(event) || config.isKeyBackward(event)) {
      checkKeyNav(event, config.isKeyBackward(event));
    }
  };
  var checkEscapeKey = function checkEscapeKey2(event) {
    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
      event.preventDefault();
      trap.deactivate();
    }
  };
  var checkClick = function checkClick2(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target, e) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
    e.stopImmediatePropagation();
  };
  var addListeners = function addListeners2() {
    if (!state2.active) {
      return;
    }
    activeFocusTraps.activateTrap(trapStack, trap);
    state2.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
      _tryFocus(getInitialFocusNode());
    }) : _tryFocus(getInitialFocusNode());
    doc.addEventListener("focusin", checkFocusIn, true);
    doc.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkTabKey, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkEscapeKey);
    return trap;
  };
  var removeListeners = function removeListeners2() {
    if (!state2.active) {
      return;
    }
    doc.removeEventListener("focusin", checkFocusIn, true);
    doc.removeEventListener("mousedown", checkPointerDown, true);
    doc.removeEventListener("touchstart", checkPointerDown, true);
    doc.removeEventListener("click", checkClick, true);
    doc.removeEventListener("keydown", checkTabKey, true);
    doc.removeEventListener("keydown", checkEscapeKey);
    return trap;
  };
  var checkDomRemoval = function checkDomRemoval2(mutations) {
    var isFocusedNodeRemoved = mutations.some(function(mutation) {
      var removedNodes = Array.from(mutation.removedNodes);
      return removedNodes.some(function(node2) {
        return node2 === state2.mostRecentlyFocusedNode;
      });
    });
    if (isFocusedNodeRemoved) {
      _tryFocus(getInitialFocusNode());
    }
  };
  var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
  var updateObservedNodes = function updateObservedNodes2() {
    if (!mutationObserver) {
      return;
    }
    mutationObserver.disconnect();
    if (state2.active && !state2.paused) {
      state2.containers.map(function(container) {
        mutationObserver.observe(container, {
          subtree: true,
          childList: true
        });
      });
    }
  };
  trap = {
    get active() {
      return state2.active;
    },
    get paused() {
      return state2.paused;
    },
    activate: function activate(activateOptions) {
      if (state2.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, "onActivate");
      var onPostActivate = getOption(activateOptions, "onPostActivate");
      var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state2.active = true;
      state2.paused = false;
      state2.nodeFocusedBeforeActivation = doc.activeElement;
      onActivate === null || onActivate === void 0 || onActivate();
      var finishActivation = function finishActivation2() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        updateObservedNodes();
        onPostActivate === null || onPostActivate === void 0 || onPostActivate();
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state2.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state2.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state2.delayInitialFocusTimer);
      state2.delayInitialFocusTimer = void 0;
      removeListeners();
      state2.active = false;
      state2.paused = false;
      updateObservedNodes();
      activeFocusTraps.deactivateTrap(trapStack, trap);
      var onDeactivate = getOption(options, "onDeactivate");
      var onPostDeactivate = getOption(options, "onPostDeactivate");
      var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
      var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate === null || onDeactivate === void 0 || onDeactivate();
      var finishDeactivation = function finishDeactivation2() {
        delay(function() {
          if (returnFocus) {
            _tryFocus(getReturnFocusNode(state2.nodeFocusedBeforeActivation));
          }
          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state2.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause(pauseOptions) {
      if (state2.paused || !state2.active) {
        return this;
      }
      var onPause = getOption(pauseOptions, "onPause");
      var onPostPause = getOption(pauseOptions, "onPostPause");
      state2.paused = true;
      onPause === null || onPause === void 0 || onPause();
      removeListeners();
      updateObservedNodes();
      onPostPause === null || onPostPause === void 0 || onPostPause();
      return this;
    },
    unpause: function unpause(unpauseOptions) {
      if (!state2.paused || !state2.active) {
        return this;
      }
      var onUnpause = getOption(unpauseOptions, "onUnpause");
      var onPostUnpause = getOption(unpauseOptions, "onPostUnpause");
      state2.paused = false;
      onUnpause === null || onUnpause === void 0 || onUnpause();
      updateTabbableNodes();
      addListeners();
      updateObservedNodes();
      onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
      return this;
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state2.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc.querySelector(element) : element;
      });
      if (state2.active) {
        updateTabbableNodes();
      }
      updateObservedNodes();
      return this;
    }
  };
  trap.updateContainerElements(elements);
  return trap;
};

// node_modules/@ark-ui/react/node_modules/@zag-js/popover/dist/index.mjs
var anatomy46 = createAnatomy2("popover").parts(
  "arrow",
  "arrowTip",
  "anchor",
  "trigger",
  "indicator",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts39 = anatomy46.build();
var dom39 = createScope({
  getAnchorId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.anchor) ?? `popover:${ctx.id}:anchor`;
  },
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `popover:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `popover:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.positioner) ?? `popover:${ctx.id}:popper`;
  },
  getArrowId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.arrow) ?? `popover:${ctx.id}:arrow`;
  },
  getTitleId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.title) ?? `popover:${ctx.id}:title`;
  },
  getDescriptionId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.description) ?? `popover:${ctx.id}:desc`;
  },
  getCloseTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.closeTrigger) ?? `popover:${ctx.id}:close`;
  },
  getAnchorEl: (ctx) => dom39.getById(ctx, dom39.getAnchorId(ctx)),
  getTriggerEl: (ctx) => dom39.getById(ctx, dom39.getTriggerId(ctx)),
  getContentEl: (ctx) => dom39.getById(ctx, dom39.getContentId(ctx)),
  getPositionerEl: (ctx) => dom39.getById(ctx, dom39.getPositionerId(ctx)),
  getTitleEl: (ctx) => dom39.getById(ctx, dom39.getTitleId(ctx)),
  getDescriptionEl: (ctx) => dom39.getById(ctx, dom39.getDescriptionId(ctx)),
  getFocusableEls: (ctx) => getFocusables(dom39.getContentEl(ctx)),
  getFirstFocusableEl: (ctx) => dom39.getFocusableEls(ctx)[0]
});
function connect4(state2, send, normalize2) {
  const open = state2.matches("open");
  const currentPlacement = state2.context.currentPlacement;
  const portalled = state2.context.currentPortalled;
  const rendered = state2.context.renderedElements;
  const popperStyles = getPlacementStyles2({
    ...state2.context.positioning,
    placement: currentPlacement
  });
  return {
    portalled,
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getArrowProps() {
      return normalize2.element({
        id: dom39.getArrowId(state2.context),
        ...parts39.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts39.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getAnchorProps() {
      return normalize2.element({
        ...parts39.anchor.attrs,
        dir: state2.context.dir,
        id: dom39.getAnchorId(state2.context)
      });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts39.trigger.attrs,
        dir: state2.context.dir,
        type: "button",
        "data-placement": currentPlacement,
        id: dom39.getTriggerId(state2.context),
        "aria-haspopup": "dialog",
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": dom39.getContentId(state2.context),
        onClick(event) {
          if (event.defaultPrevented) return;
          send("TOGGLE");
        },
        onBlur(event) {
          send({ type: "TRIGGER_BLUR", target: event.relatedTarget });
        }
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        ...parts39.indicator.attrs,
        dir: state2.context.dir,
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize2.element({
        id: dom39.getPositionerId(state2.context),
        ...parts39.positioner.attrs,
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts39.content.attrs,
        dir: state2.context.dir,
        id: dom39.getContentId(state2.context),
        tabIndex: -1,
        role: "dialog",
        hidden: !open,
        "data-state": open ? "open" : "closed",
        "data-expanded": dataAttr(open),
        "aria-labelledby": rendered.title ? dom39.getTitleId(state2.context) : void 0,
        "aria-describedby": rendered.description ? dom39.getDescriptionId(state2.context) : void 0,
        "data-placement": currentPlacement
      });
    },
    getTitleProps() {
      return normalize2.element({
        ...parts39.title.attrs,
        id: dom39.getTitleId(state2.context),
        dir: state2.context.dir
      });
    },
    getDescriptionProps() {
      return normalize2.element({
        ...parts39.description.attrs,
        id: dom39.getDescriptionId(state2.context),
        dir: state2.context.dir
      });
    },
    getCloseTriggerProps() {
      return normalize2.button({
        ...parts39.closeTrigger.attrs,
        dir: state2.context.dir,
        id: dom39.getCloseTriggerId(state2.context),
        type: "button",
        "aria-label": "close",
        onClick(event) {
          if (event.defaultPrevented) return;
          send("CLOSE");
        }
      });
    }
  };
}
function machine4(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "popover",
      initial: ctx.open ? "open" : "closed",
      context: {
        closeOnInteractOutside: true,
        closeOnEscape: true,
        autoFocus: true,
        modal: false,
        portalled: true,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        },
        currentPlacement: void 0,
        ...ctx,
        renderedElements: {
          title: true,
          description: true
        }
      },
      computed: {
        currentPortalled: (ctx2) => !!ctx2.modal || !!ctx2.portalled
      },
      watch: {
        open: ["toggleVisibility"]
      },
      entry: ["checkRenderedElements"],
      states: {
        closed: {
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["setInitialFocus"]
            },
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ]
          }
        },
        open: {
          activities: [
            "trapFocus",
            "preventScroll",
            "hideContentBelow",
            "trackPositioning",
            "trackDismissableElement",
            "proxyTabFocus"
          ],
          on: {
            "CONTROLLED.CLOSE": {
              target: "closed",
              actions: ["setFinalFocus"]
            },
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose", "setFinalFocus"]
              }
            ],
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        }
      }
    },
    {
      guards: {
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const anchorEl = dom39.getAnchorEl(ctx2) ?? dom39.getTriggerEl(ctx2);
          const getPositionerEl = () => dom39.getPositionerEl(ctx2);
          return getPlacement2(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom39.getContentEl(ctx2);
          let restoreFocus = true;
          return trackDismissableElement2(getContentEl, {
            pointerBlocking: ctx2.modal,
            exclude: dom39.getTriggerEl(ctx2),
            defer: true,
            onEscapeKeyDown(event) {
              var _a7;
              (_a7 = ctx2.onEscapeKeyDown) == null ? void 0 : _a7.call(ctx2, event);
              if (ctx2.closeOnEscape) return;
              event.preventDefault();
            },
            onInteractOutside(event) {
              var _a7;
              (_a7 = ctx2.onInteractOutside) == null ? void 0 : _a7.call(ctx2, event);
              if (event.defaultPrevented) return;
              restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
              if (!ctx2.closeOnInteractOutside) {
                event.preventDefault();
              }
            },
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onFocusOutside: ctx2.onFocusOutside,
            persistentElements: ctx2.persistentElements,
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside", restoreFocus });
            }
          });
        },
        proxyTabFocus(ctx2) {
          if (ctx2.modal || !ctx2.portalled) return;
          const getContentEl = () => dom39.getContentEl(ctx2);
          return proxyTabFocus(getContentEl, {
            triggerElement: dom39.getTriggerEl(ctx2),
            defer: true,
            onFocus(el) {
              el.focus({ preventScroll: true });
            }
          });
        },
        hideContentBelow(ctx2) {
          if (!ctx2.modal) return;
          const getElements = () => [dom39.getContentEl(ctx2), dom39.getTriggerEl(ctx2)];
          return ariaHidden2(getElements, { defer: true });
        },
        preventScroll(ctx2) {
          if (!ctx2.modal) return;
          return preventBodyScroll2(dom39.getDoc(ctx2));
        },
        trapFocus(ctx2) {
          if (!ctx2.modal) return;
          let trap;
          nextTick(() => {
            const contentEl = dom39.getContentEl(ctx2);
            if (!contentEl) return;
            trap = createFocusTrap2(contentEl, {
              escapeDeactivates: false,
              allowOutsideClick: true,
              preventScroll: true,
              returnFocusOnDeactivate: true,
              document: dom39.getDoc(ctx2),
              fallbackFocus: contentEl,
              initialFocus: getInitialFocus({
                root: dom39.getContentEl(ctx2),
                getInitialEl: ctx2.initialFocusEl,
                enabled: ctx2.autoFocus
              })
            });
            try {
              trap.activate();
            } catch {
            }
          });
          return () => trap == null ? void 0 : trap.deactivate();
        }
      },
      actions: {
        reposition(ctx2, evt) {
          const anchorEl = dom39.getAnchorEl(ctx2) ?? dom39.getTriggerEl(ctx2);
          const getPositionerEl = () => dom39.getPositionerEl(ctx2);
          getPlacement2(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        checkRenderedElements(ctx2) {
          raf(() => {
            Object.assign(ctx2.renderedElements, {
              title: !!dom39.getTitleEl(ctx2),
              description: !!dom39.getDescriptionEl(ctx2)
            });
          });
        },
        setInitialFocus(ctx2) {
          if (ctx2.modal) return;
          raf(() => {
            const element = getInitialFocus({
              root: dom39.getContentEl(ctx2),
              getInitialEl: ctx2.initialFocusEl,
              enabled: ctx2.autoFocus
            });
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        setFinalFocus(ctx2, evt) {
          var _a7;
          const restoreFocus = evt.restoreFocus ?? ((_a7 = evt.previousEvent) == null ? void 0 : _a7.restoreFocus);
          if (restoreFocus != null && !restoreFocus) return;
          raf(() => {
            const element = dom39.getTriggerEl(ctx2);
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        invokeOnOpen(ctx2) {
          var _a7;
          (_a7 = ctx2.onOpenChange) == null ? void 0 : _a7.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a7;
          (_a7 = ctx2.onOpenChange) == null ? void 0 : _a7.call(ctx2, { open: false });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      }
    }
  );
}
var props33 = createProps30()([
  "autoFocus",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "open.controlled",
  "open",
  "persistentElements",
  "portalled",
  "positioning"
]);
var splitProps34 = createSplitProps2(props33);

// node_modules/@ark-ui/react/dist/components/popover/use-popover.js
var import_react61 = __toESM(require_react(), 1);
var usePopover = (props52 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react61.useId)(),
    dir,
    getRootNode: getRootNode2,
    open: props52.defaultOpen,
    "open.controlled": props52.open !== void 0,
    ...props52
  };
  const context = {
    ...initialContext,
    open: props52.open,
    onOpenChange: useEvent(props52.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine4(initialContext), { context });
  return connect4(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/popover/popover-root.js
var PopoverRoot = (props52) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props52);
  const popover = usePopover(localProps);
  const presence = usePresence(mergeProps3({ present: popover.open }, presenceProps));
  return (0, import_jsx_runtime26.jsx)(PopoverProvider, { value: popover, children: (0, import_jsx_runtime26.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/popover/popover-root-provider.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var PopoverRootProvider = (props52) => {
  const [presenceProps, { value: popover, children }] = splitPresenceProps(props52);
  const presence = usePresence(mergeProps3({ present: popover.open }, presenceProps));
  return (0, import_jsx_runtime27.jsx)(PopoverProvider, { value: popover, children: (0, import_jsx_runtime27.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/popover/popover-title.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var import_react65 = __toESM(require_react(), 1);
var PopoverTitle = (0, import_react65.forwardRef)((props52, ref36) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps3(popover.getTitleProps(), props52);
  return (0, import_jsx_runtime28.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
PopoverTitle.displayName = "PopoverTitle";

// node_modules/@ark-ui/react/dist/components/popover/popover-trigger.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var import_react67 = __toESM(require_react(), 1);
var PopoverTrigger = (0, import_react67.forwardRef)((props52, ref36) => {
  const popover = usePopoverContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps3(
    {
      ...popover.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : popover.getTriggerProps()["aria-controls"]
    },
    props52
  );
  return (0, import_jsx_runtime29.jsx)(ark.button, { ...mergedProps, ref: ref36 });
});
PopoverTrigger.displayName = "PopoverTrigger";

// node_modules/@ark-ui/react/dist/components/popover/popover.js
var popover_exports = {};
__export(popover_exports, {
  Anchor: () => PopoverAnchor,
  Arrow: () => PopoverArrow,
  ArrowTip: () => PopoverArrowTip,
  CloseTrigger: () => PopoverCloseTrigger,
  Content: () => PopoverContent,
  Context: () => PopoverContext,
  Description: () => PopoverDescription,
  Indicator: () => PopoverIndicator,
  Positioner: () => PopoverPositioner,
  Root: () => PopoverRoot,
  RootProvider: () => PopoverRootProvider,
  Title: () => PopoverTitle,
  Trigger: () => PopoverTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/action-bar/action-bar.js
var {
  withRootProvider,
  withContext: withContext2,
  useStyles: useActionBarStyles,
  PropsProvider: PropsProvider2
} = createSlotRecipeContext({ key: "actionBar" });
var ActionBarRootProvider = withRootProvider(popover_exports.Root, {
  defaultProps: {
    lazyMount: true,
    unmountOnExit: true
  }
});
var ActionBarRoot = withRootProvider(
  popover_exports.Root,
  {
    defaultProps: {
      autoFocus: false,
      lazyMount: true,
      unmountOnExit: true
    }
  }
);
var ActionBarPropsProvider = PropsProvider2;
var ActionBarPositioner = withContext2("div", "positioner", { forwardAsChild: true });
var ActionBarContent = withContext2(popover_exports.Content, "content", { forwardAsChild: true });
var ActionBarSeparator = withContext2("div", "separator");
var ActionBarSelectionTrigger = withContext2("button", "selectionTrigger");
var ActionBarCloseTrigger = withContext2(popover_exports.CloseTrigger, "closeTrigger", { forwardAsChild: true });
var ActionBarContext = popover_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/action-bar/namespace.js
var namespace_exports2 = {};
__export(namespace_exports2, {
  CloseTrigger: () => ActionBarCloseTrigger,
  Content: () => ActionBarContent,
  Context: () => ActionBarContext,
  Positioner: () => ActionBarPositioner,
  PropsProvider: () => ActionBarPropsProvider,
  Root: () => ActionBarRoot,
  RootProvider: () => ActionBarRootProvider,
  SelectionTrigger: () => ActionBarSelectionTrigger,
  Separator: () => ActionBarSeparator
});

// node_modules/@chakra-ui/react/dist/esm/components/alert/alert.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var import_react68 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/icons.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var CheckIcon = (props52) => {
  return (0, import_jsx_runtime30.jsx)(
    chakra.svg,
    {
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...props52,
      children: (0, import_jsx_runtime30.jsx)("path", { d: "M20 6 9 17l-5-5" })
    }
  );
};
var ChevronUpIcon = (props52) => (0, import_jsx_runtime30.jsx)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props52,
    children: (0, import_jsx_runtime30.jsx)("path", { d: "m18 15-6-6-6 6" })
  }
);
var ChevronDownIcon = (props52) => {
  return (0, import_jsx_runtime30.jsx)(
    chakra.svg,
    {
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...props52,
      children: (0, import_jsx_runtime30.jsx)("path", { d: "m6 9 6 6 6-6" })
    }
  );
};
var ChevronRightIcon = (props52) => (0, import_jsx_runtime30.jsx)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props52,
    children: (0, import_jsx_runtime30.jsx)("path", { d: "m9 18 6-6-6-6" })
  }
);
var EllpsisIcon = (props52) => (0, import_jsx_runtime30.jsxs)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props52,
    children: [
      (0, import_jsx_runtime30.jsx)("circle", { cx: "12", cy: "12", r: "1" }),
      (0, import_jsx_runtime30.jsx)("circle", { cx: "19", cy: "12", r: "1" }),
      (0, import_jsx_runtime30.jsx)("circle", { cx: "5", cy: "12", r: "1" })
    ]
  }
);
var ArrowUpIcon = (props52) => (0, import_jsx_runtime30.jsxs)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "3",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props52,
    children: [
      (0, import_jsx_runtime30.jsx)("path", { d: "m5 12 7-7 7 7" }),
      (0, import_jsx_runtime30.jsx)("path", { d: "M12 19V5" })
    ]
  }
);
var ArrowDownIcon = (props52) => (0, import_jsx_runtime30.jsxs)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "3",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props52,
    children: [
      (0, import_jsx_runtime30.jsx)("path", { d: "M12 5v14" }),
      (0, import_jsx_runtime30.jsx)("path", { d: "m19 12-7 7-7-7" })
    ]
  }
);
var CheckCircleIcon = (props52) => (0, import_jsx_runtime30.jsx)(
  chakra.svg,
  {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 24 24",
    ...props52,
    children: (0, import_jsx_runtime30.jsx)("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11.0026 16L6.75999 11.7574L8.17421 10.3431L11.0026 13.1716L16.6595 7.51472L18.0737 8.92893L11.0026 16Z" })
  }
);
var WarningIcon = (props52) => (0, import_jsx_runtime30.jsx)(
  chakra.svg,
  {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 24 24",
    ...props52,
    children: (0, import_jsx_runtime30.jsx)("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 15H13V17H11V15ZM11 7H13V13H11V7Z" })
  }
);
var InfoIcon = (props52) => (0, import_jsx_runtime30.jsx)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "currentColor",
    stroke: "currentColor",
    strokeWidth: "0",
    ...props52,
    children: (0, import_jsx_runtime30.jsx)("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 7H13V9H11V7ZM11 11H13V17H11V11Z" })
  }
);
var QuoteIcon = (props52) => (0, import_jsx_runtime30.jsx)(chakra.svg, { viewBox: "0 0 24 24", fill: "currentColor", ...props52, children: (0, import_jsx_runtime30.jsx)("path", { d: "M6.5 10c-.223 0-.437.034-.65.065.069-.232.14-.468.254-.68.114-.308.292-.575.469-.844.148-.291.409-.488.601-.737.201-.242.475-.403.692-.604.213-.21.492-.315.714-.463.232-.133.434-.28.65-.35l.539-.222.474-.197-.485-1.938-.597.144c-.191.048-.424.104-.689.171-.271.05-.56.187-.882.312-.318.142-.686.238-1.028.466-.344.218-.741.4-1.091.692-.339.301-.748.562-1.05.945-.33.358-.656.734-.909 1.162-.293.408-.492.856-.702 1.299-.19.443-.343.896-.468 1.336-.237.882-.343 1.72-.384 2.437-.034.718-.014 1.315.028 1.747.015.204.043.402.063.539l.025.168.026-.006A4.5 4.5 0 1 0 6.5 10zm11 0c-.223 0-.437.034-.65.065.069-.232.14-.468.254-.68.114-.308.292-.575.469-.844.148-.291.409-.488.601-.737.201-.242.475-.403.692-.604.213-.21.492-.315.714-.463.232-.133.434-.28.65-.35l.539-.222.474-.197-.485-1.938-.597.144c-.191.048-.424.104-.689.171-.271.05-.56.187-.882.312-.317.143-.686.238-1.028.467-.344.218-.741.4-1.091.692-.339.301-.748.562-1.05.944-.33.358-.656.734-.909 1.162-.293.408-.492.856-.702 1.299-.19.443-.343.896-.468 1.336-.237.882-.343 1.72-.384 2.437-.034.718-.014 1.315.028 1.747.015.204.043.402.063.539l.025.168.026-.006A4.5 4.5 0 1 0 17.5 10z" }) });
var StarIcon = (props52) => (0, import_jsx_runtime30.jsx)(chakra.svg, { viewBox: "0 0 24 24", fill: "currentColor", ...props52, children: (0, import_jsx_runtime30.jsx)("path", { d: "M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z" }) });
var CloseIcon = (props52) => (0, import_jsx_runtime30.jsx)(chakra.svg, { viewBox: "0 0 24 24", fill: "currentColor", ...props52, children: (0, import_jsx_runtime30.jsx)(
  "path",
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M18.7071 6.70711C19.0976 6.31658 19.0976 5.68342 18.7071 5.29289C18.3166 4.90237 17.6834 4.90237 17.2929 5.29289L12 10.5858L6.70711 5.29289C6.31658 4.90237 5.68342 4.90237 5.29289 5.29289C4.90237 5.68342 4.90237 6.31658 5.29289 6.70711L10.5858 12L5.29289 17.2929C4.90237 17.6834 4.90237 18.3166 5.29289 18.7071C5.68342 19.0976 6.31658 19.0976 6.70711 18.7071L12 13.4142L17.2929 18.7071C17.6834 19.0976 18.3166 19.0976 18.7071 18.7071C19.0976 18.3166 19.0976 17.6834 18.7071 17.2929L13.4142 12L18.7071 6.70711Z"
  }
) });

// node_modules/@chakra-ui/react/dist/esm/components/alert/alert.js
var [AlertStatusProvider, useAlertStatusContext] = createContext3({
  name: "AlertStatusContext",
  hookName: "useAlertStatusContext",
  providerName: "<Alert />"
});
var {
  withProvider: withProvider2,
  withContext: withContext3,
  useStyles: useAlertStyles,
  PropsProvider: PropsProvider3
} = createSlotRecipeContext({ key: "alert" });
var AlertRoot = withProvider2(
  "div",
  "root",
  {
    forwardAsChild: true,
    wrapElement(element, props52) {
      return (
        // @ts-ignore fix later
        (0, import_jsx_runtime31.jsx)(AlertStatusProvider, { value: { status: props52.status || "info" }, children: element })
      );
    }
  }
);
var AlertPropsProvider = PropsProvider3;
var AlertTitle = withContext3(
  "div",
  "title"
);
var AlertDescription = withContext3("div", "description");
var AlertContent = withContext3(
  "div",
  "content"
);
var iconMap = {
  info: InfoIcon,
  warning: WarningIcon,
  success: CheckCircleIcon,
  error: WarningIcon,
  neutral: InfoIcon
};
var AlertIndicator = (0, import_react68.forwardRef)(
  function AlertIndicator2(props52, ref36) {
    const api = useAlertStatusContext();
    const styles = useAlertStyles();
    const Icon2 = typeof api.status === "string" ? iconMap[api.status] : import_react68.Fragment;
    const { children = (0, import_jsx_runtime31.jsx)(Icon2, {}), ...rest } = props52;
    return (0, import_jsx_runtime31.jsx)(chakra.span, { ref: ref36, ...rest, css: [styles.indicator, props52.css], children });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/alert/namespace.js
var namespace_exports3 = {};
__export(namespace_exports3, {
  Content: () => AlertContent,
  Description: () => AlertDescription,
  Indicator: () => AlertIndicator,
  Root: () => AlertRoot,
  RootPropsProvider: () => AlertPropsProvider,
  Title: () => AlertTitle
});

// node_modules/@chakra-ui/react/dist/esm/components/aspect-ratio/aspect-ratio.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var import_react69 = __toESM(require_react(), 1);
var AspectRatio = (0, import_react69.forwardRef)(
  function AspectRatio2(props52, ref36) {
    const { ratio = 4 / 3, children, className, ...rest } = props52;
    const child = import_react69.Children.only(children);
    return (0, import_jsx_runtime32.jsx)(
      chakra.div,
      {
        ref: ref36,
        position: "relative",
        className: cx("chakra-aspect-ratio", className),
        _before: {
          height: 0,
          content: `""`,
          display: "block",
          paddingBottom: mapObject(ratio, (r) => `${1 / r * 100}%`)
        },
        css: {
          "& > *:not(style)": {
            overflow: "hidden",
            position: "absolute",
            top: "0",
            right: "0",
            bottom: "0",
            left: "0",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            width: "100%",
            height: "100%"
          },
          "& > img, & > video": {
            objectFit: "cover"
          },
          ...props52.css
        },
        ...rest,
        children: child
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/avatar/avatar.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/avatar/use-avatar-context.js
var [AvatarProvider, useAvatarContext] = createContext({
  name: "AvatarContext",
  hookName: "useAvatarContext",
  providerName: "<AvatarProvider />"
});

// node_modules/@ark-ui/react/dist/components/avatar/avatar-context.js
var AvatarContext = (props52) => props52.children(useAvatarContext());

// node_modules/@ark-ui/react/dist/components/avatar/avatar-fallback.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var import_react71 = __toESM(require_react(), 1);
var AvatarFallback = (0, import_react71.forwardRef)((props52, ref36) => {
  const avatar = useAvatarContext();
  const mergedProps = mergeProps3(avatar.getFallbackProps(), props52);
  return (0, import_jsx_runtime33.jsx)(ark.span, { ...mergedProps, ref: ref36 });
});
AvatarFallback.displayName = "AvatarFallback";

// node_modules/@ark-ui/react/dist/components/avatar/avatar-image.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var import_react73 = __toESM(require_react(), 1);
var AvatarImage = (0, import_react73.forwardRef)((props52, ref36) => {
  const avatar = useAvatarContext();
  const mergedProps = mergeProps3(avatar.getImageProps(), props52);
  return (0, import_jsx_runtime34.jsx)(ark.img, { ...mergedProps, ref: ref36 });
});
AvatarImage.displayName = "AvatarImage";

// node_modules/@ark-ui/react/dist/components/avatar/avatar-root.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var import_react77 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/node_modules/@zag-js/avatar/dist/index.mjs
var anatomy47 = createAnatomy2("avatar").parts("root", "image", "fallback");
var parts40 = anatomy47.build();
var dom40 = createScope({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `avatar:${ctx.id}`;
  },
  getImageId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.image) ?? `avatar:${ctx.id}:image`;
  },
  getFallbackId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.fallback) ?? `avatar:${ctx.id}:fallback`;
  },
  getRootEl: (ctx) => dom40.getById(ctx, dom40.getRootId(ctx)),
  getImageEl: (ctx) => dom40.getById(ctx, dom40.getImageId(ctx))
});
function connect5(state2, send, normalize2) {
  const loaded = state2.matches("loaded");
  return {
    loaded,
    setSrc(src) {
      send({ type: "SRC.SET", src });
    },
    setLoaded() {
      send({ type: "IMG.LOADED", src: "api" });
    },
    setError() {
      send({ type: "IMG.ERROR", src: "api" });
    },
    getRootProps() {
      return normalize2.element({
        ...parts40.root.attrs,
        dir: state2.context.dir,
        id: dom40.getRootId(state2.context)
      });
    },
    getImageProps() {
      return normalize2.img({
        ...parts40.image.attrs,
        hidden: !loaded,
        dir: state2.context.dir,
        id: dom40.getImageId(state2.context),
        "data-state": loaded ? "visible" : "hidden",
        onLoad() {
          send({ type: "IMG.LOADED", src: "element" });
        },
        onError() {
          send({ type: "IMG.ERROR", src: "element" });
        }
      });
    },
    getFallbackProps() {
      return normalize2.element({
        ...parts40.fallback.attrs,
        dir: state2.context.dir,
        id: dom40.getFallbackId(state2.context),
        hidden: loaded,
        "data-state": loaded ? "hidden" : "visible"
      });
    }
  };
}
function machine5(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "avatar",
      initial: "loading",
      activities: ["trackImageRemoval"],
      context: ctx,
      on: {
        "SRC.CHANGE": {
          target: "loading"
        },
        "IMG.UNMOUNT": {
          target: "error"
        }
      },
      states: {
        loading: {
          activities: ["trackSrcChange"],
          entry: ["checkImageStatus"],
          on: {
            "IMG.LOADED": {
              target: "loaded",
              actions: ["invokeOnLoad"]
            },
            "IMG.ERROR": {
              target: "error",
              actions: ["invokeOnError"]
            }
          }
        },
        error: {
          activities: ["trackSrcChange"],
          on: {
            "IMG.LOADED": {
              target: "loaded",
              actions: ["invokeOnLoad"]
            }
          }
        },
        loaded: {
          activities: ["trackSrcChange"],
          on: {
            "IMG.ERROR": {
              target: "error",
              actions: ["invokeOnError"]
            }
          }
        }
      }
    },
    {
      activities: {
        trackSrcChange(ctx2, _evt, { send }) {
          const imageEl = dom40.getImageEl(ctx2);
          return observeAttributes(imageEl, {
            attributes: ["src", "srcset"],
            callback() {
              send({ type: "SRC.CHANGE" });
            }
          });
        },
        trackImageRemoval(ctx2, _evt, { send }) {
          const rootEl = dom40.getRootEl(ctx2);
          return observeChildren(rootEl, {
            callback(records) {
              const removedNodes = Array.from(records[0].removedNodes);
              const removed = removedNodes.find(
                (node2) => node2.nodeType === Node.ELEMENT_NODE && node2.matches("[data-scope=avatar][data-part=image]")
              );
              if (removed) {
                send({ type: "IMG.UNMOUNT" });
              }
            }
          });
        }
      },
      actions: {
        invokeOnLoad(ctx2) {
          var _a7;
          (_a7 = ctx2.onStatusChange) == null ? void 0 : _a7.call(ctx2, { status: "loaded" });
        },
        invokeOnError(ctx2) {
          var _a7;
          (_a7 = ctx2.onStatusChange) == null ? void 0 : _a7.call(ctx2, { status: "error" });
        },
        checkImageStatus(ctx2, _evt, { send }) {
          const imageEl = dom40.getImageEl(ctx2);
          if (imageEl == null ? void 0 : imageEl.complete) {
            const type = hasLoaded(imageEl) ? "IMG.LOADED" : "IMG.ERROR";
            send({ type, src: "ssr" });
          }
        }
      }
    }
  );
}
function hasLoaded(image) {
  return image.complete && image.naturalWidth !== 0 && image.naturalHeight !== 0;
}
var props34 = createProps30()(["dir", "id", "ids", "onStatusChange", "getRootNode"]);
var splitProps35 = createSplitProps2(props34);

// node_modules/@ark-ui/react/dist/components/avatar/use-avatar.js
var import_react75 = __toESM(require_react(), 1);
var useAvatar = (props52 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react75.useId)(),
    dir,
    getRootNode: getRootNode2,
    ...props52
  };
  const context = {
    ...initialContext,
    onStatusChange: useEvent(props52.onStatusChange)
  };
  const [state2, send] = useMachine(machine5(initialContext), { context });
  return connect5(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/avatar/avatar-root.js
var AvatarRoot = (0, import_react77.forwardRef)((props52, ref36) => {
  const [useAvatarProps, localProps] = createSplitProps3()(props52, [
    "id",
    "ids",
    "onStatusChange"
  ]);
  const avatar = useAvatar(useAvatarProps);
  const mergedProps = mergeProps3(avatar.getRootProps(), localProps);
  return (0, import_jsx_runtime35.jsx)(AvatarProvider, { value: avatar, children: (0, import_jsx_runtime35.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
});
AvatarRoot.displayName = "AvatarRoot";

// node_modules/@ark-ui/react/dist/components/avatar/avatar-root-provider.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var import_react79 = __toESM(require_react(), 1);
var AvatarRootProvider = (0, import_react79.forwardRef)(
  (props52, ref36) => {
    const [{ value: avatar }, localProps] = createSplitProps3()(props52, ["value"]);
    const mergedProps = mergeProps3(avatar.getRootProps(), localProps);
    return (0, import_jsx_runtime36.jsx)(AvatarProvider, { value: avatar, children: (0, import_jsx_runtime36.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
  }
);
AvatarRootProvider.displayName = "AvatarRootProvider";

// node_modules/@ark-ui/react/dist/components/avatar/avatar.js
var avatar_exports = {};
__export(avatar_exports, {
  Context: () => AvatarContext,
  Fallback: () => AvatarFallback,
  Image: () => AvatarImage,
  Root: () => AvatarRoot,
  RootProvider: () => AvatarRootProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/avatar/avatar.js
var import_react80 = __toESM(require_react(), 1);
var {
  withProvider: withProvider3,
  withContext: withContext4,
  useStyles: useAvatarStyles,
  PropsProvider: PropsProvider4
} = createSlotRecipeContext({ key: "avatar" });
var AvatarRootProvider2 = withProvider3(avatar_exports.RootProvider, "root", { forwardAsChild: true });
var AvatarRoot2 = withProvider3(
  avatar_exports.Root,
  "root",
  { forwardAsChild: true }
);
var AvatarPropsProvider = PropsProvider4;
var AvatarFallback2 = withContext4(
  avatar_exports.Fallback,
  "fallback",
  { forwardAsChild: true }
);
var AvatarImage2 = withContext4(
  avatar_exports.Image,
  "image",
  {
    forwardAsChild: true,
    defaultProps: {
      draggable: "false",
      referrerPolicy: "no-referrer"
    }
  }
);
var AvatarIcon = (0, import_react80.forwardRef)(
  function AvatarIcon2(props52, ref36) {
    return (0, import_jsx_runtime37.jsx)(
      chakra.svg,
      {
        stroke: "currentColor",
        fill: "currentColor",
        strokeWidth: "0",
        viewBox: "0 0 24 24",
        height: "1.2em",
        width: "1.2em",
        ref: ref36,
        ...props52,
        children: (0, import_jsx_runtime37.jsx)("path", { d: "M20 22H18V20C18 18.3431 16.6569 17 15 17H9C7.34315 17 6 18.3431 6 20V22H4V20C4 17.2386 6.23858 15 9 15H15C17.7614 15 20 17.2386 20 20V22ZM12 13C8.68629 13 6 10.3137 6 7C6 3.68629 8.68629 1 12 1C15.3137 1 18 3.68629 18 7C18 10.3137 15.3137 13 12 13ZM12 11C14.2091 11 16 9.20914 16 7C16 4.79086 14.2091 3 12 3C9.79086 3 8 4.79086 8 7C8 9.20914 9.79086 11 12 11Z" })
      }
    );
  }
);
var AvatarContext2 = avatar_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/avatar/namespace.js
var namespace_exports4 = {};
__export(namespace_exports4, {
  Context: () => AvatarContext2,
  Fallback: () => AvatarFallback2,
  Icon: () => AvatarIcon,
  Image: () => AvatarImage2,
  PropsProvider: () => AvatarPropsProvider,
  Root: () => AvatarRoot2
});

// node_modules/@chakra-ui/react/dist/esm/components/badge/badge.js
var { PropsProvider: PropsProvider5, withContext: withContext5 } = createRecipeContext({
  key: "badge"
});
var Badge = withContext5("span");
var BadgePropsProvider = PropsProvider5;

// node_modules/@chakra-ui/react/dist/esm/components/bleed/bleed.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var import_react81 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/unit.js
var lengthUnits = "cm,mm,Q,in,pc,pt,px,em,ex,ch,rem,lh,rlh,vw,vh,vmin,vmax,vb,vi,svw,svh,lvw,lvh,dvw,dvh,cqw,cqh,cqi,cqb,cqmin,cqmax,%";
var lengthUnitsPattern = `(?:${lengthUnits.split(",").join("|")})`;
var lengthRegExp = new RegExp(
  `^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${lengthUnitsPattern}$`
);
var isCssUnit = (v) => typeof v === "string" && lengthRegExp.test(v);

// node_modules/@chakra-ui/react/dist/esm/components/bleed/bleed.js
var valueFn = (v) => isCssUnit(v) || isCssVar(v) ? v : `token(spacing.${v}, ${v})`;
var Bleed = (0, import_react81.forwardRef)(
  function Bleed2(props52, ref36) {
    const {
      inline: inline2,
      inlineStart,
      inlineEnd,
      block,
      blockStart,
      blockEnd,
      ...rest
    } = props52;
    return (0, import_jsx_runtime38.jsx)(
      chakra.div,
      {
        ref: ref36,
        ...rest,
        css: {
          "--bleed-inline-start": mapObject(inline2 ?? inlineStart, valueFn),
          "--bleed-inline-end": mapObject(inline2 ?? inlineEnd, valueFn),
          "--bleed-block-start": mapObject(block ?? blockStart, valueFn),
          "--bleed-block-end": mapObject(block ?? blockEnd, valueFn),
          marginInlineStart: "calc(var(--bleed-inline-start, 0) * -1)",
          marginInlineEnd: "calc(var(--bleed-inline-end, 0) * -1)",
          marginBlockStart: "calc(var(--bleed-block-start, 0) * -1)",
          marginBlockEnd: "calc(var(--bleed-block-end, 0) * -1)"
        }
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/blockquote/blockquote.js
var {
  withProvider: withProvider4,
  withContext: withContext6,
  useStyles: useBlockquoteStyles,
  PropsProvider: PropsProvider6
} = createSlotRecipeContext({ key: "blockquote" });
var BlockquoteRoot = withProvider4(
  "figure",
  "root"
);
var BlockquotePropsProvider = PropsProvider6;
var BlockquoteContent = withContext6("blockquote", "content");
var BlockquoteCaption = withContext6("figcaption", "caption");
var BlockquoteIcon = withContext6(
  QuoteIcon,
  "icon"
);

// node_modules/@chakra-ui/react/dist/esm/components/blockquote/namespace.js
var namespace_exports5 = {};
__export(namespace_exports5, {
  Caption: () => BlockquoteCaption,
  Content: () => BlockquoteContent,
  Icon: () => BlockquoteIcon,
  PropsProvider: () => BlockquotePropsProvider,
  Root: () => BlockquoteRoot
});

// node_modules/@chakra-ui/react/dist/esm/components/box/box.js
var Box = chakra("div");
Box.displayName = "Box";

// node_modules/@chakra-ui/react/dist/esm/components/box/square.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var import_react82 = __toESM(require_react(), 1);
var Square = (0, import_react82.forwardRef)(
  function Square2(props52, ref36) {
    const { size: size4, ...rest } = props52;
    return (0, import_jsx_runtime39.jsx)(
      Box,
      {
        ...rest,
        ref: ref36,
        boxSize: size4,
        css: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          flexShrink: 0,
          flexGrow: 0,
          ...props52.css
        }
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/box/circle.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var import_react83 = __toESM(require_react(), 1);
var Circle = (0, import_react83.forwardRef)(
  function Circle2(props52, ref36) {
    const { size: size4, ...rest } = props52;
    return (0, import_jsx_runtime40.jsx)(Square, { size: size4, ref: ref36, borderRadius: "9999px", ...rest });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/box/span.js
var Span = chakra("span");

// node_modules/@chakra-ui/react/dist/esm/components/box/sticky.js
var Sticky = chakra("div", {
  base: {
    position: "sticky",
    top: 0
  }
});
Sticky.displayName = "Sticky";

// node_modules/@chakra-ui/react/dist/esm/components/breadcrumb/breadcrumb.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var {
  withProvider: withProvider5,
  withContext: withContext7,
  useStyles: useBreadcrumbStyles,
  PropsProvider: PropsProvider7
} = createSlotRecipeContext({ key: "breadcrumb" });
var BreadcrumbRoot = withProvider5(
  "nav",
  "root",
  {
    defaultProps: { "aria-label": "breadcrumb" }
  }
);
var BreadcrumbPropsProvider = PropsProvider7;
var BreadcrumbList = withContext7(
  "ol",
  "list"
);
var BreadcrumbItem = withContext7(
  "li",
  "item"
);
var BreadcrumbLink = withContext7("a", "link");
var BreadcrumbCurrentLink = withContext7("span", "currentLink", {
  defaultProps: {
    role: "link",
    "aria-current": "page"
  }
});
var BreadcrumbSeparator = withContext7("li", "separator", {
  defaultProps: {
    children: (0, import_jsx_runtime41.jsx)(ChevronRightIcon, {})
  }
});
var BreadcrumbEllipsis = withContext7("span", "ellipsis", {
  defaultProps: {
    role: "presentation",
    "aria-hidden": true,
    children: (0, import_jsx_runtime41.jsx)(EllpsisIcon, {})
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/breadcrumb/namespace.js
var namespace_exports6 = {};
__export(namespace_exports6, {
  CurrentLink: () => BreadcrumbCurrentLink,
  Ellipsis: () => BreadcrumbEllipsis,
  Item: () => BreadcrumbItem,
  Link: () => BreadcrumbLink,
  List: () => BreadcrumbList,
  PropsProvider: () => BreadcrumbPropsProvider,
  Root: () => BreadcrumbRoot,
  Separator: () => BreadcrumbSeparator
});

// node_modules/@chakra-ui/react/dist/esm/components/button/button.js
var { withContext: withContext8, PropsProvider: PropsProvider8 } = createRecipeContext({
  key: "button"
});
var Button = withContext8("button", {
  defaultProps: { type: "button" }
});

// node_modules/@chakra-ui/react/dist/esm/components/button/icon-button.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var import_react84 = __toESM(require_react(), 1);
var IconButton = (0, import_react84.forwardRef)(
  function IconButton2(props52, ref36) {
    return (0, import_jsx_runtime42.jsx)(
      Button,
      {
        px: "0",
        py: "0",
        _icon: { fontSize: "1.2em" },
        ref: ref36,
        ...props52
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/card/card.js
var {
  withProvider: withProvider6,
  withContext: withContext9,
  useStyles: useCardStyles,
  PropsProvider: PropsProvider9
} = createSlotRecipeContext({ key: "card" });
var CardRoot = withProvider6(
  "div",
  "root"
);
var CardPropsProvider = PropsProvider9;
var CardBody = withContext9(
  "div",
  "body"
);
var CardHeader = withContext9(
  "div",
  "header"
);
var CardFooter = withContext9(
  "div",
  "footer"
);
var CardTitle = withContext9(
  "h3",
  "title"
);
var CardDescription = withContext9("p", "description");

// node_modules/@chakra-ui/react/dist/esm/components/card/namespace.js
var namespace_exports7 = {};
__export(namespace_exports7, {
  Body: () => CardBody,
  Description: () => CardDescription,
  Footer: () => CardFooter,
  Header: () => CardHeader,
  PropsProvider: () => CardPropsProvider,
  Root: () => CardRoot,
  Title: () => CardTitle
});

// node_modules/@chakra-ui/react/dist/esm/components/center/center.js
var Center = chakra("div", {
  base: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  variants: {
    inline: {
      true: {
        display: "inline-flex"
      }
    }
  }
});
Center.displayName = "Center";

// node_modules/@chakra-ui/react/dist/esm/components/center/absolute-center.js
var AbsoluteCenter = chakra("div", {
  base: {
    position: "absolute",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  variants: {
    axis: {
      horizontal: {
        insetStart: "50%",
        transform: "translateX(-50%)"
      },
      vertical: {
        top: "50%",
        transform: "translateY(-50%)"
      },
      both: {
        insetStart: "50%",
        top: "50%",
        transform: "translate(-50%, -50%)"
      }
    }
  },
  defaultVariants: {
    axis: "both"
  }
});
AbsoluteCenter.displayName = "AbsoluteCenter";

// node_modules/@chakra-ui/react/dist/esm/components/checkbox/checkbox.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-context.js
var [CheckboxProvider, useCheckboxContext] = createContext({
  name: "CheckboxContext",
  hookName: "useCheckboxContext",
  providerName: "<CheckboxProvider />"
});

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-context.js
var CheckboxContext = (props52) => props52.children(useCheckboxContext());

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-control.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var import_react86 = __toESM(require_react(), 1);
var CheckboxControl = (0, import_react86.forwardRef)((props52, ref36) => {
  const checkbox = useCheckboxContext();
  const mergedProps = mergeProps3(checkbox.getControlProps(), props52);
  return (0, import_jsx_runtime43.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
CheckboxControl.displayName = "CheckboxControl";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-group.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var import_react88 = __toESM(require_react(), 1);

// node_modules/@zag-js/focus-visible/dist/index.mjs
function isVirtualClick(event) {
  if (event.mozInputSource === 0 && event.isTrusted) return true;
  return event.detail === 0 && !event.pointerType;
}
function isValidKey(e) {
  return !(e.metaKey || !isMac() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
var nonTextInputTypes = /* @__PURE__ */ new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);
function isKeyboardFocusEvent(isTextInput, modality, e) {
  const target = e ? getEventTarget(e) : null;
  const win = getWindow(target);
  isTextInput = isTextInput || target instanceof win.HTMLInputElement && !nonTextInputTypes.has(target == null ? void 0 : target.type) || target instanceof win.HTMLTextAreaElement || target instanceof win.HTMLElement && target.isContentEditable;
  return !(isTextInput && modality === "keyboard" && e instanceof win.KeyboardEvent && !Reflect.has(FOCUS_VISIBLE_INPUT_KEYS, e.key));
}
var currentModality = null;
var changeHandlers = /* @__PURE__ */ new Set();
var listenerMap = /* @__PURE__ */ new Map();
var hasEventBeforeFocus = false;
var hasBlurredWindowRecently = false;
var FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function triggerChangeHandlers(modality, e) {
  for (let handler of changeHandlers) {
    handler(modality, e);
  }
}
function handleKeyboardEvent(e) {
  hasEventBeforeFocus = true;
  if (isValidKey(e)) {
    currentModality = "keyboard";
    triggerChangeHandlers("keyboard", e);
  }
}
function handlePointerEvent(e) {
  currentModality = "pointer";
  if (e.type === "mousedown" || e.type === "pointerdown") {
    hasEventBeforeFocus = true;
    triggerChangeHandlers("pointer", e);
  }
}
function handleClickEvent(e) {
  if (isVirtualClick(e)) {
    hasEventBeforeFocus = true;
    currentModality = "virtual";
  }
}
function handleFocusEvent(e) {
  const target = getEventTarget(e);
  if (target === getWindow(target) || target === getDocument(target)) {
    return;
  }
  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", e);
  }
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = false;
}
function handleWindowBlur() {
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = true;
}
function setupGlobalFocusEvents(root) {
  if (typeof window === "undefined" || listenerMap.get(getWindow(root))) {
    return;
  }
  const win = getWindow(root);
  const doc = getDocument(root);
  let focus = win.HTMLElement.prototype.focus;
  win.HTMLElement.prototype.focus = function() {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", null);
    hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  };
  doc.addEventListener("keydown", handleKeyboardEvent, true);
  doc.addEventListener("keyup", handleKeyboardEvent, true);
  doc.addEventListener("click", handleClickEvent, true);
  win.addEventListener("focus", handleFocusEvent, true);
  win.addEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.addEventListener("pointerdown", handlePointerEvent, true);
    doc.addEventListener("pointermove", handlePointerEvent, true);
    doc.addEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.addEventListener("mousedown", handlePointerEvent, true);
    doc.addEventListener("mousemove", handlePointerEvent, true);
    doc.addEventListener("mouseup", handlePointerEvent, true);
  }
  win.addEventListener(
    "beforeunload",
    () => {
      tearDownWindowFocusTracking(root);
    },
    { once: true }
  );
  listenerMap.set(win, { focus });
}
var tearDownWindowFocusTracking = (root, loadListener) => {
  const win = getWindow(root);
  const doc = getDocument(root);
  if (!listenerMap.has(win)) {
    return;
  }
  win.HTMLElement.prototype.focus = listenerMap.get(win).focus;
  doc.removeEventListener("keydown", handleKeyboardEvent, true);
  doc.removeEventListener("keyup", handleKeyboardEvent, true);
  doc.removeEventListener("click", handleClickEvent, true);
  win.removeEventListener("focus", handleFocusEvent, true);
  win.removeEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.removeEventListener("pointerdown", handlePointerEvent, true);
    doc.removeEventListener("pointermove", handlePointerEvent, true);
    doc.removeEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.removeEventListener("mousedown", handlePointerEvent, true);
    doc.removeEventListener("mousemove", handlePointerEvent, true);
    doc.removeEventListener("mouseup", handlePointerEvent, true);
  }
  listenerMap.delete(win);
};
function isFocusVisible() {
  return currentModality === "keyboard";
}
function trackFocusVisible2(props52 = {}) {
  const { isTextInput, autoFocus, onChange, root } = props52;
  setupGlobalFocusEvents(root);
  onChange == null ? void 0 : onChange({ isFocusVisible: autoFocus || isFocusVisible(), modality: currentModality });
  const handler = (modality, e) => {
    if (!isKeyboardFocusEvent(!!isTextInput, modality, e)) return;
    onChange == null ? void 0 : onChange({ isFocusVisible: isFocusVisible(), modality });
  };
  changeHandlers.add(handler);
  return () => {
    changeHandlers.delete(handler);
  };
}

// node_modules/@ark-ui/react/node_modules/@zag-js/checkbox/dist/index.mjs
var anatomy48 = createAnatomy2("checkbox").parts("root", "label", "control", "indicator");
var parts41 = anatomy48.build();
var dom41 = createScope({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `checkbox:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `checkbox:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `checkbox:${ctx.id}:control`;
  },
  getHiddenInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.hiddenInput) ?? `checkbox:${ctx.id}:input`;
  },
  getRootEl: (ctx) => dom41.getById(ctx, dom41.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom41.getById(ctx, dom41.getHiddenInputId(ctx))
});
function connect6(state2, send, normalize2) {
  const disabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  const focused = !disabled && state2.context.focused;
  const focusVisible = !disabled && state2.context.focusVisible;
  const checked = state2.context.isChecked;
  const indeterminate = state2.context.isIndeterminate;
  const dataAttrs = {
    "data-active": dataAttr(state2.context.active),
    "data-focus": dataAttr(focused),
    "data-focus-visible": dataAttr(focusVisible),
    "data-readonly": dataAttr(readOnly),
    "data-hover": dataAttr(state2.context.hovered),
    "data-disabled": dataAttr(disabled),
    "data-state": indeterminate ? "indeterminate" : state2.context.checked ? "checked" : "unchecked",
    "data-invalid": dataAttr(state2.context.invalid)
  };
  return {
    checked,
    disabled,
    indeterminate,
    focused,
    checkedState: state2.context.checked,
    setChecked(checked2) {
      send({ type: "CHECKED.SET", checked: checked2, isTrusted: false });
    },
    toggleChecked() {
      send({ type: "CHECKED.TOGGLE", checked, isTrusted: false });
    },
    getRootProps() {
      return normalize2.label({
        ...parts41.root.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom41.getRootId(state2.context),
        htmlFor: dom41.getHiddenInputId(state2.context),
        onPointerMove() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: true } });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: false } });
        },
        onClick(event) {
          const target = getEventTarget(event);
          if (target === dom41.getHiddenInputEl(state2.context)) {
            event.stopPropagation();
          }
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        ...parts41.label.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom41.getLabelId(state2.context)
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts41.control.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom41.getControlId(state2.context),
        "aria-hidden": true
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        ...parts41.indicator.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        hidden: !indeterminate && !state2.context.checked
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        id: dom41.getHiddenInputId(state2.context),
        type: "checkbox",
        required: state2.context.required,
        defaultChecked: checked,
        disabled,
        "aria-labelledby": dom41.getLabelId(state2.context),
        "aria-invalid": state2.context.invalid,
        name: state2.context.name,
        form: state2.context.form,
        value: state2.context.value,
        style: visuallyHiddenStyle,
        onFocus() {
          const focusVisible2 = isFocusVisible();
          send({ type: "CONTEXT.SET", context: { focused: true, focusVisible: focusVisible2 } });
        },
        onBlur() {
          send({ type: "CONTEXT.SET", context: { focused: false, focusVisible: false } });
        },
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          const checked2 = event.currentTarget.checked;
          send({ type: "CHECKED.SET", checked: checked2, isTrusted: true });
        }
      });
    }
  };
}
var { not: not37 } = guards20;
function machine6(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "checkbox",
      initial: "ready",
      context: {
        checked: false,
        value: "on",
        disabled: false,
        ...ctx,
        fieldsetDisabled: false,
        focusVisible: false
      },
      watch: {
        disabled: "removeFocusIfNeeded",
        checked: "syncInputElement"
      },
      activities: ["trackFormControlState", "trackPressEvent", "trackFocusVisible"],
      on: {
        "CHECKED.TOGGLE": [
          {
            guard: not37("isTrusted"),
            actions: ["toggleChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["toggleChecked"]
          }
        ],
        "CHECKED.SET": [
          {
            guard: not37("isTrusted"),
            actions: ["setChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["setChecked"]
          }
        ],
        "CONTEXT.SET": {
          actions: ["setContext"]
        }
      },
      computed: {
        isIndeterminate: (ctx2) => isIndeterminate(ctx2.checked),
        isChecked: (ctx2) => isChecked(ctx2.checked),
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled
      },
      states: {
        ready: {}
      }
    },
    {
      guards: {
        isTrusted: (_ctx, evt) => !!evt.isTrusted
      },
      activities: {
        trackPressEvent(ctx2) {
          if (ctx2.isDisabled) return;
          return trackPress2({
            pointerNode: dom41.getRootEl(ctx2),
            keyboardNode: dom41.getHiddenInputEl(ctx2),
            isValidKey: (event) => event.key === " ",
            onPress: () => ctx2.active = false,
            onPressStart: () => ctx2.active = true,
            onPressEnd: () => ctx2.active = false
          });
        },
        trackFocusVisible(ctx2) {
          if (ctx2.isDisabled) return;
          return trackFocusVisible2({ root: dom41.getRootNode(ctx2) });
        },
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl2(dom41.getHiddenInputEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "CHECKED.SET", checked: !!initialContext.checked });
            }
          });
        }
      },
      actions: {
        setContext(ctx2, evt) {
          Object.assign(ctx2, evt.context);
        },
        syncInputElement(ctx2) {
          const inputEl = dom41.getHiddenInputEl(ctx2);
          if (!inputEl) return;
          setElementChecked2(inputEl, ctx2.isChecked);
          inputEl.indeterminate = ctx2.isIndeterminate;
        },
        removeFocusIfNeeded(ctx2) {
          if (ctx2.disabled && ctx2.focused) {
            ctx2.focused = false;
            ctx2.focusVisible = false;
          }
        },
        setChecked(ctx2, evt) {
          set4.checked(ctx2, evt.checked);
        },
        toggleChecked(ctx2) {
          const checked = isIndeterminate(ctx2.checked) ? true : !ctx2.checked;
          set4.checked(ctx2, checked);
        },
        dispatchChangeEvent(ctx2) {
          const inputEl = dom41.getHiddenInputEl(ctx2);
          dispatchInputCheckedEvent2(inputEl, { checked: isChecked(ctx2.checked) });
        }
      }
    }
  );
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function isChecked(checked) {
  return isIndeterminate(checked) ? false : !!checked;
}
var invoke2 = {
  change: (ctx) => {
    var _a7;
    (_a7 = ctx.onCheckedChange) == null ? void 0 : _a7.call(ctx, { checked: ctx.checked });
  }
};
var set4 = {
  checked: (ctx, checked) => {
    if (isEqual3(ctx.checked, checked)) return;
    ctx.checked = checked;
    invoke2.change(ctx);
  }
};
var props35 = createProps30()([
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
var splitProps36 = createSplitProps2(props35);

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox.anatomy.js
var checkboxAnatomy2 = anatomy48.extendWith("group");

// node_modules/@ark-ui/react/dist/utils/use-controllable-state.js
var import_react87 = __toESM(require_react(), 1);
function useControllableState2(props52) {
  const { value, onChange, defaultValue } = props52;
  const [uncontrolledValue, setUncontrolledValue] = (0, import_react87.useState)(defaultValue);
  const controlled = value !== void 0;
  const currentValue = controlled ? value : uncontrolledValue;
  const setValue = (0, import_react87.useCallback)(
    (value2) => {
      if (controlled) {
        return onChange == null ? void 0 : onChange(value2);
      }
      setUncontrolledValue(value2);
      return onChange == null ? void 0 : onChange(value2);
    },
    [controlled, onChange]
  );
  return [currentValue, setValue];
}

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-group.js
function useCheckboxGroup(props52 = {}) {
  const {
    defaultValue,
    value: controlledValue,
    onValueChange,
    disabled,
    readOnly,
    name,
    invalid
  } = props52;
  const interative = !(disabled || readOnly);
  const onChangeProp = useEvent(onValueChange, { sync: true });
  const [value, setValue] = useControllableState2({
    value: controlledValue,
    defaultValue: defaultValue || [],
    onChange: onChangeProp
  });
  const isChecked2 = (val) => {
    return value.some((v) => String(v) === String(val));
  };
  const toggleValue = (val) => {
    isChecked2(val) ? removeValue(val) : addValue(val);
  };
  const addValue = (val) => {
    if (!interative) return;
    if (isChecked2(val)) return;
    setValue(value.concat(val));
  };
  const removeValue = (val) => {
    if (!interative) return;
    setValue(value.filter((v) => String(v) !== String(val)));
  };
  const getItemProps = (props210) => {
    return {
      checked: props210.value != null ? isChecked2(props210.value) : void 0,
      onCheckedChange() {
        if (props210.value != null) {
          toggleValue(props210.value);
        }
      },
      name,
      disabled,
      readOnly,
      invalid
    };
  };
  return {
    isChecked: isChecked2,
    value,
    name,
    disabled: !!disabled,
    readOnly: !!readOnly,
    invalid: !!invalid,
    setValue,
    addValue,
    toggleValue,
    getItemProps
  };
}

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-group-context.js
var [CheckboxGroupContextProvider, useCheckboxGroupContext] = createContext({
  name: "CheckboxGroupContext",
  hookName: "useCheckboxGroupContext",
  providerName: "<CheckboxGroupProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-group.js
var CheckboxGroup = (0, import_react88.forwardRef)((props52, ref36) => {
  const [checkboxGroupProps, localProps] = createSplitProps3()(props52, [
    "defaultValue",
    "value",
    "onValueChange",
    "disabled",
    "invalid",
    "readOnly",
    "name"
  ]);
  const checkboxGroup = useCheckboxGroup(checkboxGroupProps);
  return (0, import_jsx_runtime44.jsx)(CheckboxGroupContextProvider, { value: checkboxGroup, children: (0, import_jsx_runtime44.jsx)(ark.div, { ref: ref36, role: "group", ...localProps, ...checkboxAnatomy2.build().group.attrs }) });
});
CheckboxGroup.displayName = "CheckboxGroup";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-hidden-input.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var import_react90 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/field/use-field-context.js
var [FieldProvider, useFieldContext] = createContext({
  name: "FieldContext",
  hookName: "useFieldContext",
  providerName: "<FieldProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-hidden-input.js
var CheckboxHiddenInput = (0, import_react90.forwardRef)(
  (props52, ref36) => {
    const checkbox = useCheckboxContext();
    const mergedProps = mergeProps3(checkbox.getHiddenInputProps(), props52);
    const field = useFieldContext();
    return (0, import_jsx_runtime45.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref36 });
  }
);
CheckboxHiddenInput.displayName = "CheckboxHiddenInput";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-indicator.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var import_react92 = __toESM(require_react(), 1);
var CheckboxIndicator = (0, import_react92.forwardRef)(
  (props52, ref36) => {
    const { indeterminate, ...rest } = props52;
    const checkbox = useCheckboxContext();
    const mergedProps = mergeProps3(checkbox.getIndicatorProps(), rest);
    const isVisible3 = indeterminate ? checkbox.indeterminate : checkbox.checked;
    return (0, import_jsx_runtime46.jsx)(ark.div, { ...mergedProps, hidden: !isVisible3, ref: ref36 });
  }
);
CheckboxIndicator.displayName = "CheckboxIndicator";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-label.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var import_react94 = __toESM(require_react(), 1);
var CheckboxLabel = (0, import_react94.forwardRef)((props52, ref36) => {
  const checkbox = useCheckboxContext();
  const mergedProps = mergeProps3(checkbox.getLabelProps(), props52);
  return (0, import_jsx_runtime47.jsx)(ark.span, { ...mergedProps, ref: ref36 });
});
CheckboxLabel.displayName = "CheckboxLabel";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var import_react98 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox.js
var import_react96 = __toESM(require_react(), 1);
var useCheckbox = (ownProps = {}) => {
  const checkboxGroup = useCheckboxGroupContext();
  const field = useFieldContext();
  const props52 = (0, import_react96.useMemo)(() => {
    return mergeProps3(ownProps, (checkboxGroup == null ? void 0 : checkboxGroup.getItemProps({ value: ownProps.value })) ?? {});
  }, [ownProps, checkboxGroup]);
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react96.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    invalid: field == null ? void 0 : field.invalid,
    required: field == null ? void 0 : field.required,
    getRootNode: getRootNode2,
    checked: props52.defaultChecked,
    ...props52
  };
  const context = {
    ...initialContext,
    checked: props52.checked,
    onCheckedChange: useEvent(props52.onCheckedChange, { sync: true })
  };
  const [state2, send] = useMachine(machine6(initialContext), { context });
  return connect6(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root.js
var CheckboxRoot = (0, import_react98.forwardRef)((props52, ref36) => {
  const [useCheckboxProps, localProps] = createSplitProps3()(props52, [
    "checked",
    "defaultChecked",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "name",
    "onCheckedChange",
    "readOnly",
    "required",
    "value"
  ]);
  const checkbox = useCheckbox(useCheckboxProps);
  const mergedProps = mergeProps3(checkbox.getRootProps(), localProps);
  return (0, import_jsx_runtime48.jsx)(CheckboxProvider, { value: checkbox, children: (0, import_jsx_runtime48.jsx)(ark.label, { ...mergedProps, ref: ref36 }) });
});
CheckboxRoot.displayName = "CheckboxRoot";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root-provider.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var import_react100 = __toESM(require_react(), 1);
var CheckboxRootProvider = (0, import_react100.forwardRef)(
  (props52, ref36) => {
    const [{ value: checkbox }, localProps] = createSplitProps3()(props52, [
      "value"
    ]);
    const mergedProps = mergeProps3(checkbox.getRootProps(), localProps);
    return (0, import_jsx_runtime49.jsx)(CheckboxProvider, { value: checkbox, children: (0, import_jsx_runtime49.jsx)(ark.label, { ...mergedProps, ref: ref36 }) });
  }
);
CheckboxRootProvider.displayName = "CheckboxRootProvider";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox.js
var checkbox_exports = {};
__export(checkbox_exports, {
  Context: () => CheckboxContext,
  Control: () => CheckboxControl,
  Group: () => CheckboxGroup,
  HiddenInput: () => CheckboxHiddenInput,
  Indicator: () => CheckboxIndicator,
  Label: () => CheckboxLabel,
  Root: () => CheckboxRoot,
  RootProvider: () => CheckboxRootProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/checkbox/checkbox.js
var import_react102 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/checkmark/checkmark.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
var import_react101 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/attr.js
var dataAttr31 = (condition) => condition ? "" : void 0;

// node_modules/@chakra-ui/react/dist/esm/components/checkmark/checkmark.js
var Checkmark = (0, import_react101.forwardRef)(
  function Checkmark2(props52, ref36) {
    const recipe = useRecipe({ key: "checkmark", recipe: props52.recipe });
    const [variantProps, restProps] = recipe.splitVariantProps(props52);
    const { checked, indeterminate, disabled, unstyled, children, ...rest } = restProps;
    const styles = unstyled ? EMPTY_STYLES : recipe(variantProps);
    return (0, import_jsx_runtime50.jsx)(
      chakra.svg,
      {
        ref: ref36,
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "3px",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        "data-state": indeterminate ? "indeterminate" : checked ? "checked" : "unchecked",
        "data-disabled": dataAttr31(disabled),
        css: [styles, props52.css],
        ...rest,
        children: indeterminate ? (0, import_jsx_runtime50.jsx)("path", { d: "M5 12h14" }) : checked ? (0, import_jsx_runtime50.jsx)("polyline", { points: "20 6 9 17 4 12" }) : null
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/checkbox/checkbox.js
var {
  withProvider: withProvider7,
  withContext: withContext10,
  useStyles: useCheckboxStyles,
  PropsProvider: PropsProvider10
} = createSlotRecipeContext({ key: "checkbox" });
var CheckboxRoot2 = withProvider7(
  checkbox_exports.Root,
  "root",
  { forwardAsChild: true }
);
var CheckboxPropsProvider = PropsProvider10;
var CheckboxLabel2 = withContext10(
  checkbox_exports.Label,
  "label",
  { forwardAsChild: true }
);
var CheckboxControl2 = withContext10(
  checkbox_exports.Control,
  "control",
  { forwardAsChild: true }
);
var CheckboxIndicator2 = (0, import_react102.forwardRef)(function CheckboxIndicator22(props52, ref36) {
  const { checked, indeterminate, ...rest } = props52;
  const api = useCheckboxContext();
  const styles = useCheckboxStyles();
  if (checked && api.checked) {
    return (0, import_jsx_runtime51.jsx)(
      chakra.svg,
      {
        ref: ref36,
        asChild: true,
        ...rest,
        css: [styles.indicator, props52.css],
        children: checked
      }
    );
  }
  if (indeterminate && api.indeterminate) {
    return (0, import_jsx_runtime51.jsx)(
      chakra.svg,
      {
        ref: ref36,
        asChild: true,
        ...rest,
        css: [styles.indicator, props52.css],
        children: indeterminate
      }
    );
  }
  return (0, import_jsx_runtime51.jsx)(
    Checkmark,
    {
      ref: ref36,
      checked: api.checked,
      indeterminate: api.indeterminate,
      disabled: api.disabled,
      unstyled: true,
      ...rest,
      css: [styles.indicator, props52.css]
    }
  );
});
var CheckboxGroup2 = chakra(
  checkbox_exports.Group,
  {
    base: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    }
  },
  { forwardAsChild: true }
);
var CheckboxContext2 = checkbox_exports.Context;
var CheckboxHiddenInput2 = checkbox_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/checkbox/namespace.js
var namespace_exports8 = {};
__export(namespace_exports8, {
  Context: () => CheckboxContext2,
  Control: () => CheckboxControl2,
  Group: () => CheckboxGroup2,
  HiddenInput: () => CheckboxHiddenInput2,
  Indicator: () => CheckboxIndicator2,
  Label: () => CheckboxLabel2,
  PropsProvider: () => CheckboxPropsProvider,
  Root: () => CheckboxRoot2
});

// node_modules/@chakra-ui/react/dist/esm/components/checkbox-card/checkbox-card.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var import_react103 = __toESM(require_react(), 1);
var {
  withProvider: withProvider8,
  withContext: withContext11,
  useStyles: useCheckboxCardStyles,
  PropsProvider: PropsProvider11
} = createSlotRecipeContext({ key: "checkboxCard" });
var CheckboxCardRootProvider = withProvider8(checkbox_exports.RootProvider, "root", { forwardAsChild: true });
var CheckboxCardRoot = withProvider8(checkbox_exports.Root, "root", { forwardAsChild: true });
var CheckboxCardRootPropsProvider = PropsProvider11;
var CheckboxCardLabel = withContext11(checkbox_exports.Label, "label", { forwardAsChild: true });
var CheckboxCardDescription = withContext11("div", "description");
var CheckboxCardControl = withContext11(checkbox_exports.Control, "control", { forwardAsChild: true });
var CheckboxCardContent = withContext11("div", "content");
var CheckboxCardIndicator = (0, import_react103.forwardRef)(function CheckboxCardIndicator2(props52, ref36) {
  const api = useCheckboxContext();
  const styles = useCheckboxCardStyles();
  return (0, import_jsx_runtime52.jsx)(
    Checkmark,
    {
      ref: ref36,
      checked: api.checked,
      indeterminate: api.indeterminate,
      disabled: api.disabled,
      unstyled: true,
      ...props52,
      css: [styles.indicator, props52.css]
    }
  );
});
var CheckboxCardAddon = withContext11("div", "addon");
var CheckboxCardContext = checkbox_exports.Context;
var CheckboxCardHiddenInput = checkbox_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/checkbox-card/namespace.js
var namespace_exports9 = {};
__export(namespace_exports9, {
  Addon: () => CheckboxCardAddon,
  Content: () => CheckboxCardContent,
  Context: () => CheckboxCardContext,
  Control: () => CheckboxCardControl,
  Description: () => CheckboxCardDescription,
  HiddenInput: () => CheckboxCardHiddenInput,
  Indicator: () => CheckboxCardIndicator,
  Label: () => CheckboxCardLabel,
  Root: () => CheckboxCardRoot,
  RootPropsProvider: () => CheckboxCardRootPropsProvider,
  RootProvider: () => CheckboxCardRootProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/client-only/client-only.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var import_react104 = __toESM(require_react(), 1);
var ClientOnly = (props52) => {
  const { children, fallback: fallback5 } = props52;
  const [hasMounted, setHasMounted] = (0, import_react104.useState)(false);
  (0, import_react104.useEffect)(() => {
    setHasMounted(true);
  }, []);
  if (!hasMounted) {
    return fallback5 || null;
  }
  return (0, import_jsx_runtime53.jsx)(import_jsx_runtime53.Fragment, { children });
};

// node_modules/@ark-ui/react/dist/components/clipboard/use-clipboard-context.js
var [ClipboardProvider, useClipboardContext] = createContext({
  name: "ClipboardContext",
  hookName: "useClipboardContext",
  providerName: "<ClipboardProvider />"
});

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-context.js
var ClipboardContext = (props52) => props52.children(useClipboardContext());

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-control.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var import_react106 = __toESM(require_react(), 1);
var ClipboardControl = (0, import_react106.forwardRef)((props52, ref36) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps3(clipboard.getControlProps(), props52);
  return (0, import_jsx_runtime54.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
ClipboardControl.displayName = "ClipboardControl";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-indicator.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var import_react108 = __toESM(require_react(), 1);
var ClipboardIndicator = (0, import_react108.forwardRef)(
  (props52, ref36) => {
    const { children, copied, ...localProps } = props52;
    const clipboard = useClipboardContext();
    const mergedProps = mergeProps3(
      clipboard.getIndicatorProps({ copied: clipboard.copied }),
      localProps
    );
    return (0, import_jsx_runtime55.jsx)(ark.div, { ...mergedProps, ref: ref36, children: clipboard.copied ? copied : children });
  }
);
ClipboardIndicator.displayName = "ClipboardIndicator";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-input.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var import_react110 = __toESM(require_react(), 1);
var ClipboardInput = (0, import_react110.forwardRef)((props52, ref36) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps3(clipboard.getInputProps(), props52);
  return (0, import_jsx_runtime56.jsx)(ark.input, { ...mergedProps, ref: ref36 });
});
ClipboardInput.displayName = "ClipboardInput";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-label.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var import_react112 = __toESM(require_react(), 1);
var ClipboardLabel = (0, import_react112.forwardRef)((props52, ref36) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps3(clipboard.getLabelProps(), props52);
  return (0, import_jsx_runtime57.jsx)(ark.label, { ...mergedProps, ref: ref36 });
});
ClipboardLabel.displayName = "ClipboardLabel";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-root.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var import_react116 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/node_modules/@zag-js/clipboard/dist/index.mjs
var anatomy49 = createAnatomy2("clipboard").parts("root", "control", "trigger", "indicator", "input", "label");
var parts42 = anatomy49.build();
var dom42 = createScope({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `clip:${ctx.id}`;
  },
  getInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.input) ?? `clip:${ctx.id}:input`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `clip:${ctx.id}:label`;
  },
  getInputEl: (ctx) => dom42.getById(ctx, dom42.getInputId(ctx)),
  writeToClipboard: (ctx) => copyText2(dom42.getDoc(ctx), ctx.value)
});
function createNode2(doc, text) {
  const node2 = doc.createElement("pre");
  Object.assign(node2.style, {
    width: "1px",
    height: "1px",
    position: "fixed",
    top: "5px"
  });
  node2.textContent = text;
  return node2;
}
function copyNode2(node2) {
  const win = getWindow(node2);
  const selection = win.getSelection();
  if (selection == null) {
    return Promise.reject(new Error());
  }
  selection.removeAllRanges();
  const doc = node2.ownerDocument;
  const range2 = doc.createRange();
  range2.selectNodeContents(node2);
  selection.addRange(range2);
  doc.execCommand("copy");
  selection.removeAllRanges();
  return Promise.resolve();
}
function copyText2(doc, text) {
  var _a7;
  const win = doc.defaultView || window;
  if (((_a7 = win.navigator.clipboard) == null ? void 0 : _a7.writeText) !== void 0) {
    return win.navigator.clipboard.writeText(text);
  }
  if (!doc.body) {
    return Promise.reject(new Error());
  }
  const node2 = createNode2(doc, text);
  doc.body.appendChild(node2);
  copyNode2(node2);
  doc.body.removeChild(node2);
  return Promise.resolve();
}
function connect7(state2, send, normalize2) {
  const copied = state2.matches("copied");
  return {
    copied,
    value: state2.context.value,
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    copy() {
      send({ type: "COPY" });
    },
    getRootProps() {
      return normalize2.element({
        ...parts42.root.attrs,
        "data-copied": dataAttr(copied),
        id: dom42.getRootId(state2.context)
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts42.label.attrs,
        htmlFor: dom42.getInputId(state2.context),
        "data-copied": dataAttr(copied),
        id: dom42.getLabelId(state2.context)
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts42.control.attrs,
        "data-copied": dataAttr(copied)
      });
    },
    getInputProps() {
      return normalize2.input({
        ...parts42.input.attrs,
        defaultValue: state2.context.value,
        "data-copied": dataAttr(copied),
        readOnly: true,
        "data-readonly": "true",
        id: dom42.getInputId(state2.context),
        onFocus(event) {
          event.currentTarget.select();
        },
        onCopy() {
          send({ type: "INPUT.COPY" });
        }
      });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts42.trigger.attrs,
        "aria-label": copied ? "Copied to clipboard" : "Copy to clipboard",
        "data-copied": dataAttr(copied),
        onClick() {
          send({ type: "COPY" });
        }
      });
    },
    getIndicatorProps(props210) {
      return normalize2.element({
        ...parts42.indicator.attrs,
        hidden: props210.copied !== copied
      });
    }
  };
}
function machine7(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "clipboard",
      initial: "idle",
      context: {
        value: "",
        timeout: 3e3,
        ...ctx
      },
      watch: {
        value: ["syncInputElement"]
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        },
        COPY: {
          target: "copied",
          actions: ["copyToClipboard", "invokeOnCopy"]
        }
      },
      states: {
        idle: {
          on: {
            "INPUT.COPY": {
              target: "copied",
              actions: ["invokeOnCopy"]
            }
          }
        },
        copied: {
          after: {
            COPY_TIMEOUT: "idle"
          },
          on: {
            COPY: {
              target: "copied",
              actions: ["copyToClipboard", "invokeOnCopy"]
            },
            "INPUT.COPY": {
              actions: ["invokeOnCopy"]
            }
          }
        }
      }
    },
    {
      actions: {
        setValue(ctx2, evt) {
          ctx2.value = evt.value;
        },
        copyToClipboard(ctx2) {
          dom42.writeToClipboard(ctx2);
        },
        invokeOnCopy(ctx2) {
          var _a7;
          (_a7 = ctx2.onStatusChange) == null ? void 0 : _a7.call(ctx2, { copied: true });
        },
        syncInputElement(ctx2) {
          dom42.setValue(dom42.getInputEl(ctx2), ctx2.value);
        }
      },
      delays: {
        COPY_TIMEOUT: (ctx2) => ctx2.timeout
      }
    }
  );
}
var props36 = createProps30()([
  "getRootNode",
  "id",
  "ids",
  "value",
  "timeout",
  "onStatusChange"
]);
var contextProps2 = createSplitProps2(props36);
var indicatorProps3 = createProps30()(["copied"]);
var splitIndicatorProps3 = createSplitProps2(indicatorProps3);

// node_modules/@ark-ui/react/dist/components/clipboard/use-clipboard.js
var import_react114 = __toESM(require_react(), 1);
var useClipboard = (props52 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const initialContext = {
    id: (0, import_react114.useId)(),
    getRootNode: getRootNode2,
    ...props52
  };
  const context = {
    ...initialContext
  };
  const [state2, send] = useMachine(machine7(initialContext), { context });
  return connect7(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-root.js
var ClipboardRoot = (0, import_react116.forwardRef)((props52, ref36) => {
  const [useClipboardProps, localProps] = createSplitProps3()(props52, [
    "id",
    "ids",
    "onStatusChange",
    "timeout",
    "value"
  ]);
  const clipboard = useClipboard(useClipboardProps);
  const mergedProps = mergeProps3(clipboard.getRootProps(), localProps);
  return (0, import_jsx_runtime58.jsx)(ClipboardProvider, { value: clipboard, children: (0, import_jsx_runtime58.jsx)(ark.div, { ref: ref36, ...mergedProps }) });
});
ClipboardRoot.displayName = "ClipboardRoot";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-root-provider.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var import_react118 = __toESM(require_react(), 1);
var ClipboardRootProvider = (0, import_react118.forwardRef)(
  (props52, ref36) => {
    const [{ value: clipboard }, localProps] = createSplitProps3()(props52, [
      "value"
    ]);
    const mergedProps = mergeProps3(clipboard.getRootProps(), localProps);
    return (0, import_jsx_runtime59.jsx)(ClipboardProvider, { value: clipboard, children: (0, import_jsx_runtime59.jsx)(ark.div, { ref: ref36, ...mergedProps }) });
  }
);
ClipboardRootProvider.displayName = "ClipboardRootProvider";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-trigger.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
var import_react120 = __toESM(require_react(), 1);
var ClipboardTrigger = (0, import_react120.forwardRef)(
  (props52, ref36) => {
    const clipboard = useClipboardContext();
    const mergedProps = mergeProps3(clipboard.getTriggerProps(), props52);
    return (0, import_jsx_runtime60.jsx)(ark.button, { ...mergedProps, ref: ref36 });
  }
);
ClipboardTrigger.displayName = "ClipboardTrigger";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard.js
var clipboard_exports = {};
__export(clipboard_exports, {
  Context: () => ClipboardContext,
  Control: () => ClipboardControl,
  Indicator: () => ClipboardIndicator,
  Input: () => ClipboardInput,
  Label: () => ClipboardLabel,
  Root: () => ClipboardRoot,
  RootProvider: () => ClipboardRootProvider,
  Trigger: () => ClipboardTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/clipboard/clipboard.js
var {
  withProvider: withProvider9,
  withContext: withContext12,
  useStyles: useClipboardStyles,
  PropsProvider: PropsProvider12
} = createSlotRecipeContext({ key: "clipboard" });
var ClipboardRootProvider2 = withProvider9(clipboard_exports.RootProvider, "root", { forwardAsChild: true });
var ClipboardRoot2 = withProvider9(
  clipboard_exports.Root,
  "root",
  { forwardAsChild: true }
);
var ClipboardPropsProvider = PropsProvider12;
var ClipboardTrigger2 = withContext12(clipboard_exports.Trigger, "trigger", { forwardAsChild: true });
var ClipboardControl2 = withContext12(clipboard_exports.Control, "control", { forwardAsChild: true });
var ClipboardIndicator2 = withContext12(clipboard_exports.Indicator, "indicator", { forwardAsChild: true });
var ClipboardInput2 = withContext12(clipboard_exports.Input, "input", { forwardAsChild: true });
var ClipboardLabel2 = withContext12(clipboard_exports.Label, "label", { forwardAsChild: true });
var ClipboardContext2 = clipboard_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/clipboard/namespace.js
var namespace_exports10 = {};
__export(namespace_exports10, {
  Context: () => ClipboardContext2,
  Control: () => ClipboardControl2,
  Indicator: () => ClipboardIndicator2,
  Input: () => ClipboardInput2,
  Label: () => ClipboardLabel2,
  PropsProvider: () => ClipboardPropsProvider,
  Root: () => ClipboardRoot2,
  RootProvider: () => ClipboardRootProvider2,
  Trigger: () => ClipboardTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/code/code.js
var { withContext: withContext13, PropsProvider: PropsProvider13 } = createRecipeContext({
  key: "code"
});
var Code = withContext13("code");
var CodePropsProvider = PropsProvider13;

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-context.js
var CollapsibleContext = (props52) => props52.children(useCollapsibleContext());

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-root-provider.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
var import_react122 = __toESM(require_react(), 1);
var CollapsibleRootProvider = (0, import_react122.forwardRef)(
  (props52, ref36) => {
    const [{ value: collapsible }, localProps] = createSplitProps3()(props52, [
      "value"
    ]);
    const mergedProps = mergeProps3(collapsible.getRootProps(), localProps);
    return (0, import_jsx_runtime61.jsx)(CollapsibleProvider, { value: collapsible, children: (0, import_jsx_runtime61.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
  }
);
CollapsibleRootProvider.displayName = "CollapsibleRootProvider";

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-trigger.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var import_react124 = __toESM(require_react(), 1);
var CollapsibleTrigger = (0, import_react124.forwardRef)(
  (props52, ref36) => {
    const collapsible = useCollapsibleContext();
    const mergedProps = mergeProps3(collapsible.getTriggerProps(), props52);
    return (0, import_jsx_runtime62.jsx)(ark.button, { ...mergedProps, ref: ref36 });
  }
);
CollapsibleTrigger.displayName = "CollapsibleTrigger";

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible.js
var collapsible_exports = {};
__export(collapsible_exports, {
  Content: () => CollapsibleContent,
  Context: () => CollapsibleContext,
  Root: () => CollapsibleRoot,
  RootProvider: () => CollapsibleRootProvider,
  Trigger: () => CollapsibleTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/collapsible/collapsible.js
var {
  withProvider: withProvider10,
  withContext: withContext14,
  useStyles: useCollapsibleStyles,
  PropsProvider: PropsProvider14
} = createSlotRecipeContext({ key: "collapsible" });
var CollapsibleRootProvider2 = withProvider10(collapsible_exports.RootProvider, "root", { forwardAsChild: true });
var CollapsibleRoot2 = withProvider10(collapsible_exports.Root, "root", { forwardAsChild: true });
var CollapsiblePropsProvider = PropsProvider14;
var CollapsibleTrigger2 = withContext14(collapsible_exports.Trigger, "trigger", { forwardAsChild: true });
var CollapsibleContent2 = withContext14(collapsible_exports.Content, "content", { forwardAsChild: true });
var CollapsibleContext2 = collapsible_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/collapsible/namespace.js
var namespace_exports11 = {};
__export(namespace_exports11, {
  Content: () => CollapsibleContent2,
  Context: () => CollapsibleContext2,
  PropsProvider: () => CollapsiblePropsProvider,
  Root: () => CollapsibleRoot2,
  RootProvider: () => CollapsibleRootProvider2,
  Trigger: () => CollapsibleTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/container/container.js
var { withContext: withContext15, PropsProvider: PropsProvider15 } = createRecipeContext({
  key: "container"
});
var Container = withContext15("div");
var ContainerPropsProvider = PropsProvider15;

// node_modules/@chakra-ui/react/dist/esm/components/data-list/data-list.js
var {
  withProvider: withProvider11,
  withContext: withContext16,
  useStyles: useDataListStyles,
  PropsProvider: PropsProvider16
} = createSlotRecipeContext({ key: "dataList" });
var DataListRoot = withProvider11(
  "dl",
  "root"
);
var DataListPropsProvider = PropsProvider16;
var DataListItem = withContext16(
  "div",
  "item"
);
var DataListItemLabel = withContext16("dt", "itemLabel");
var DataListItemValue = withContext16("dd", "itemValue");

// node_modules/@chakra-ui/react/dist/esm/components/data-list/namespace.js
var namespace_exports12 = {};
__export(namespace_exports12, {
  Item: () => DataListItem,
  ItemLabel: () => DataListItemLabel,
  ItemValue: () => DataListItemValue,
  PropsProvider: () => DataListPropsProvider,
  Root: () => DataListRoot
});

// node_modules/@chakra-ui/react/dist/esm/components/dialog/dialog.js
var import_jsx_runtime72 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/dialog/dialog-backdrop.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
var import_react126 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/dialog/use-dialog-context.js
var [DialogProvider, useDialogContext] = createContext({
  name: "DialogContext",
  hookName: "useDialogContext",
  providerName: "<DialogProvider />"
});

// node_modules/@ark-ui/react/dist/components/dialog/dialog-backdrop.js
var DialogBackdrop = (0, import_react126.forwardRef)((props52, ref36) => {
  const dialog = useDialogContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const presence = usePresence({ ...renderStrategyProps, present: dialog.open });
  const mergedProps = mergeProps3(dialog.getBackdropProps(), presence.getPresenceProps(), props52);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime63.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref36) });
});
DialogBackdrop.displayName = "DialogBackdrop";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-close-trigger.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
var import_react128 = __toESM(require_react(), 1);
var DialogCloseTrigger = (0, import_react128.forwardRef)(
  (props52, ref36) => {
    const dialog = useDialogContext();
    const mergedProps = mergeProps3(dialog.getCloseTriggerProps(), props52);
    return (0, import_jsx_runtime64.jsx)(ark.button, { ...mergedProps, ref: ref36 });
  }
);
DialogCloseTrigger.displayName = "DialogCloseTrigger";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-content.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
var import_react130 = __toESM(require_react(), 1);
var DialogContent = (0, import_react130.forwardRef)((props52, ref36) => {
  const dialog = useDialogContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps3(dialog.getContentProps(), presence.getPresenceProps(), props52);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime65.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref36) });
});
DialogContent.displayName = "DialogContent";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-context.js
var DialogContext = (props52) => props52.children(useDialogContext());

// node_modules/@ark-ui/react/dist/components/dialog/dialog-description.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);
var import_react132 = __toESM(require_react(), 1);
var DialogDescription = (0, import_react132.forwardRef)(
  (props52, ref36) => {
    const dialog = useDialogContext();
    const mergedProps = mergeProps3(dialog.getDescriptionProps(), props52);
    return (0, import_jsx_runtime66.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
DialogDescription.displayName = "DialogDescription";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-positioner.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
var import_react134 = __toESM(require_react(), 1);
var DialogPositioner = (0, import_react134.forwardRef)((props52, ref36) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps3(dialog.getPositionerProps(), props52);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime67.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
DialogPositioner.displayName = "DialogPositioner";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-root.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/node_modules/@zag-js/dialog/dist/index.mjs
var anatomy50 = createAnatomy2("dialog").parts(
  "trigger",
  "backdrop",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts43 = anatomy50.build();
var dom43 = createScope({
  getPositionerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.positioner) ?? `dialog:${ctx.id}:positioner`;
  },
  getBackdropId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.backdrop) ?? `dialog:${ctx.id}:backdrop`;
  },
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `dialog:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `dialog:${ctx.id}:trigger`;
  },
  getTitleId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.title) ?? `dialog:${ctx.id}:title`;
  },
  getDescriptionId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.description) ?? `dialog:${ctx.id}:description`;
  },
  getCloseTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.closeTrigger) ?? `dialog:${ctx.id}:close`;
  },
  getContentEl: (ctx) => dom43.getById(ctx, dom43.getContentId(ctx)),
  getPositionerEl: (ctx) => dom43.getById(ctx, dom43.getPositionerId(ctx)),
  getBackdropEl: (ctx) => dom43.getById(ctx, dom43.getBackdropId(ctx)),
  getTriggerEl: (ctx) => dom43.getById(ctx, dom43.getTriggerId(ctx)),
  getTitleEl: (ctx) => dom43.getById(ctx, dom43.getTitleId(ctx)),
  getDescriptionEl: (ctx) => dom43.getById(ctx, dom43.getDescriptionId(ctx)),
  getCloseTriggerEl: (ctx) => dom43.getById(ctx, dom43.getCloseTriggerId(ctx))
});
function connect8(state2, send, normalize2) {
  const ariaLabel = state2.context["aria-label"];
  const open = state2.matches("open");
  const rendered = state2.context.renderedElements;
  return {
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts43.trigger.attrs,
        dir: state2.context.dir,
        id: dom43.getTriggerId(state2.context),
        "aria-haspopup": "dialog",
        type: "button",
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": dom43.getContentId(state2.context),
        onClick(event) {
          if (event.defaultPrevented) return;
          send("TOGGLE");
        }
      });
    },
    getBackdropProps() {
      return normalize2.element({
        ...parts43.backdrop.attrs,
        dir: state2.context.dir,
        hidden: !open,
        id: dom43.getBackdropId(state2.context),
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts43.positioner.attrs,
        dir: state2.context.dir,
        id: dom43.getPositionerId(state2.context),
        style: {
          pointerEvents: open ? void 0 : "none"
        }
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts43.content.attrs,
        dir: state2.context.dir,
        role: state2.context.role,
        hidden: !open,
        id: dom43.getContentId(state2.context),
        tabIndex: -1,
        "data-state": open ? "open" : "closed",
        "aria-modal": true,
        "aria-label": ariaLabel || void 0,
        "aria-labelledby": ariaLabel || !rendered.title ? void 0 : dom43.getTitleId(state2.context),
        "aria-describedby": rendered.description ? dom43.getDescriptionId(state2.context) : void 0
      });
    },
    getTitleProps() {
      return normalize2.element({
        ...parts43.title.attrs,
        dir: state2.context.dir,
        id: dom43.getTitleId(state2.context)
      });
    },
    getDescriptionProps() {
      return normalize2.element({
        ...parts43.description.attrs,
        dir: state2.context.dir,
        id: dom43.getDescriptionId(state2.context)
      });
    },
    getCloseTriggerProps() {
      return normalize2.button({
        ...parts43.closeTrigger.attrs,
        dir: state2.context.dir,
        id: dom43.getCloseTriggerId(state2.context),
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          event.stopPropagation();
          send("CLOSE");
        }
      });
    }
  };
}
function machine8(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "dialog",
      initial: ctx.open ? "open" : "closed",
      context: {
        role: "dialog",
        renderedElements: {
          title: true,
          description: true
        },
        modal: true,
        trapFocus: true,
        preventScroll: true,
        closeOnInteractOutside: true,
        closeOnEscape: true,
        restoreFocus: true,
        ...ctx
      },
      created: ["setAlertDialogProps"],
      watch: {
        open: ["toggleVisibility"]
      },
      states: {
        open: {
          entry: ["checkRenderedElements", "syncZIndex"],
          activities: ["trackDismissableElement", "trapFocus", "preventScroll", "hideContentBelow"],
          on: {
            "CONTROLLED.CLOSE": {
              target: "closed"
            },
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          }
        },
        closed: {
          on: {
            "CONTROLLED.OPEN": {
              target: "open"
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom43.getContentEl(ctx2);
          return trackDismissableElement2(getContentEl, {
            defer: true,
            pointerBlocking: ctx2.modal,
            exclude: [dom43.getTriggerEl(ctx2)],
            onInteractOutside(event) {
              var _a7;
              (_a7 = ctx2.onInteractOutside) == null ? void 0 : _a7.call(ctx2, event);
              if (!ctx2.closeOnInteractOutside) {
                event.preventDefault();
              }
            },
            persistentElements: ctx2.persistentElements,
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onEscapeKeyDown(event) {
              var _a7;
              (_a7 = ctx2.onEscapeKeyDown) == null ? void 0 : _a7.call(ctx2, event);
              if (!ctx2.closeOnEscape) {
                event.preventDefault();
              }
            },
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside" });
            }
          });
        },
        preventScroll(ctx2) {
          if (!ctx2.preventScroll) return;
          return preventBodyScroll2(dom43.getDoc(ctx2));
        },
        trapFocus(ctx2) {
          if (!ctx2.trapFocus || !ctx2.modal) return;
          let trap;
          const cleanup = nextTick(() => {
            var _a7;
            const contentEl = dom43.getContentEl(ctx2);
            if (!contentEl) return;
            trap = createFocusTrap2(contentEl, {
              document: dom43.getDoc(ctx2),
              escapeDeactivates: false,
              preventScroll: true,
              fallbackFocus: contentEl,
              returnFocusOnDeactivate: ctx2.restoreFocus,
              allowOutsideClick: true,
              initialFocus: ((_a7 = ctx2.initialFocusEl) == null ? void 0 : _a7.call(ctx2)) ?? void 0,
              setReturnFocus(triggerEl) {
                var _a8;
                return ((_a8 = ctx2.finalFocusEl) == null ? void 0 : _a8.call(ctx2)) ?? triggerEl;
              }
            });
            try {
              trap.activate();
            } catch {
            }
          });
          return () => {
            trap == null ? void 0 : trap.deactivate();
            cleanup();
          };
        },
        hideContentBelow(ctx2) {
          if (!ctx2.modal) return;
          const getElements = () => [dom43.getContentEl(ctx2)];
          return ariaHidden2(getElements, { defer: true });
        }
      },
      actions: {
        setAlertDialogProps(ctx2) {
          if (ctx2.role !== "alertdialog") return;
          ctx2.initialFocusEl || (ctx2.initialFocusEl = () => dom43.getCloseTriggerEl(ctx2));
          ctx2.closeOnInteractOutside = false;
        },
        checkRenderedElements(ctx2) {
          raf(() => {
            ctx2.renderedElements.title = !!dom43.getTitleEl(ctx2);
            ctx2.renderedElements.description = !!dom43.getDescriptionEl(ctx2);
          });
        },
        syncZIndex(ctx2) {
          raf(() => {
            const contentEl = dom43.getContentEl(ctx2);
            if (!contentEl) return;
            const win = dom43.getWin(ctx2);
            const styles = win.getComputedStyle(contentEl);
            const elems = [dom43.getPositionerEl(ctx2), dom43.getBackdropEl(ctx2)];
            elems.forEach((node2) => {
              node2 == null ? void 0 : node2.style.setProperty("--z-index", styles.zIndex);
            });
          });
        },
        invokeOnClose(ctx2) {
          var _a7;
          (_a7 = ctx2.onOpenChange) == null ? void 0 : _a7.call(ctx2, { open: false });
        },
        invokeOnOpen(ctx2) {
          var _a7;
          (_a7 = ctx2.onOpenChange) == null ? void 0 : _a7.call(ctx2, { open: true });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      }
    }
  );
}
var props37 = createProps30()([
  "aria-label",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "finalFocusEl",
  "getRootNode",
  "getRootNode",
  "id",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "open.controlled",
  "open",
  "persistentElements",
  "preventScroll",
  "restoreFocus",
  "role",
  "trapFocus"
]);
var splitProps37 = createSplitProps2(props37);

// node_modules/@ark-ui/react/dist/components/dialog/use-dialog.js
var import_react136 = __toESM(require_react(), 1);
var useDialog = (props52 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react136.useId)(),
    getRootNode: getRootNode2,
    dir,
    open: props52.defaultOpen,
    "open.controlled": props52.open !== void 0,
    ...props52
  };
  const context = {
    ...initialContext,
    open: props52.open,
    onOpenChange: useEvent(props52.onOpenChange, { sync: true }),
    onEscapeKeyDown: useEvent(props52.onEscapeKeyDown),
    onInteractOutside: useEvent(props52.onInteractOutside)
  };
  const [state2, send] = useMachine(machine8(initialContext), { context });
  return connect8(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/dialog/dialog-root.js
var DialogRoot = (props52) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props52);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const dialog = useDialog(localProps);
  const presence = usePresence(mergeProps3({ present: dialog.open }, presenceProps));
  return (0, import_jsx_runtime68.jsx)(DialogProvider, { value: dialog, children: (0, import_jsx_runtime68.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime68.jsx)(PresenceProvider, { value: presence, children }) }) });
};

// node_modules/@ark-ui/react/dist/components/dialog/dialog-root-provider.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);
var DialogRootProvider = (props52) => {
  const [presenceProps, { value: dialog, children }] = splitPresenceProps(props52);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const presence = usePresence(mergeProps3({ present: dialog.open }, presenceProps));
  return (0, import_jsx_runtime69.jsx)(DialogProvider, { value: dialog, children: (0, import_jsx_runtime69.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime69.jsx)(PresenceProvider, { value: presence, children }) }) });
};

// node_modules/@ark-ui/react/dist/components/dialog/dialog-title.js
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var import_react140 = __toESM(require_react(), 1);
var DialogTitle = (0, import_react140.forwardRef)((props52, ref36) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps3(dialog.getTitleProps(), props52);
  return (0, import_jsx_runtime70.jsx)(ark.h2, { ...mergedProps, ref: ref36 });
});
DialogTitle.displayName = "DialogTitle";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-trigger.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime(), 1);
var import_react142 = __toESM(require_react(), 1);
var DialogTrigger = (0, import_react142.forwardRef)((props52, ref36) => {
  const dialog = useDialogContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps3(
    {
      ...dialog.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : dialog.getTriggerProps()["aria-controls"]
    },
    props52
  );
  return (0, import_jsx_runtime71.jsx)(ark.button, { ...mergedProps, ref: ref36 });
});
DialogTrigger.displayName = "DialogTrigger";

// node_modules/@ark-ui/react/dist/components/dialog/dialog.js
var dialog_exports = {};
__export(dialog_exports, {
  Backdrop: () => DialogBackdrop,
  CloseTrigger: () => DialogCloseTrigger,
  Content: () => DialogContent,
  Context: () => DialogContext,
  Description: () => DialogDescription,
  Positioner: () => DialogPositioner,
  Root: () => DialogRoot,
  RootProvider: () => DialogRootProvider,
  Title: () => DialogTitle,
  Trigger: () => DialogTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/dialog/dialog.js
var import_react143 = __toESM(require_react(), 1);
var {
  withRootProvider: withRootProvider2,
  withContext: withContext17,
  useStyles: useDialogStyles,
  PropsProvider: PropsProvider17
} = createSlotRecipeContext({ key: "dialog" });
var DialogRootProvider2 = withRootProvider2(
  dialog_exports.RootProvider,
  {
    defaultProps: { unmountOnExit: true, lazyMount: true }
  }
);
var DialogRoot2 = withRootProvider2(dialog_exports.Root, {
  defaultProps: { unmountOnExit: true, lazyMount: true }
});
var DialogPropsProvider = PropsProvider17;
var DialogTrigger2 = withContext17(
  dialog_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var DialogPositioner2 = withContext17(dialog_exports.Positioner, "positioner", { forwardAsChild: true });
var DialogContent2 = withContext17(
  dialog_exports.Content,
  "content",
  { forwardAsChild: true }
);
var DialogDescription2 = withContext17(dialog_exports.Description, "description", { forwardAsChild: true });
var DialogTitle2 = withContext17(
  dialog_exports.Title,
  "title",
  { forwardAsChild: true }
);
var DialogCloseTrigger2 = withContext17(dialog_exports.CloseTrigger, "closeTrigger", { forwardAsChild: true });
var DialogActionTrigger = (0, import_react143.forwardRef)(function DialogActionTrigger2(props52, ref36) {
  const dialog = useDialogContext();
  return (0, import_jsx_runtime72.jsx)(chakra.button, { ...props52, ref: ref36, onClick: () => dialog.setOpen(false) });
});
var DialogBackdrop2 = withContext17(
  dialog_exports.Backdrop,
  "backdrop",
  { forwardAsChild: true }
);
var DialogBody = withContext17(
  "div",
  "body"
);
var DialogFooter = withContext17(
  "div",
  "footer"
);
var DialogHeader = withContext17(
  "div",
  "header"
);
var DialogContext2 = dialog_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/dialog/namespace.js
var namespace_exports13 = {};
__export(namespace_exports13, {
  ActionTrigger: () => DialogActionTrigger,
  Backdrop: () => DialogBackdrop2,
  Body: () => DialogBody,
  CloseTrigger: () => DialogCloseTrigger2,
  Content: () => DialogContent2,
  Context: () => DialogContext2,
  Description: () => DialogDescription2,
  Footer: () => DialogFooter,
  Header: () => DialogHeader,
  Positioner: () => DialogPositioner2,
  PropsProvider: () => DialogPropsProvider,
  Root: () => DialogRoot2,
  RootProvider: () => DialogRootProvider2,
  Title: () => DialogTitle2,
  Trigger: () => DialogTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/drawer/drawer.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime(), 1);
var import_react144 = __toESM(require_react(), 1);
var {
  withRootProvider: withRootProvider3,
  withContext: withContext18,
  useStyles: useDrawerStyles,
  PropsProvider: PropsProvider18
} = createSlotRecipeContext({ key: "drawer" });
var DrawerRootProvider = withRootProvider3(
  dialog_exports.RootProvider,
  {
    defaultProps: { unmountOnExit: true, lazyMount: true }
  }
);
var DrawerRoot = withRootProvider3(dialog_exports.Root, {
  defaultProps: { unmountOnExit: true, lazyMount: true }
});
var DrawerRootPropsProvider = PropsProvider18;
var DrawerTrigger = withContext18(
  dialog_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var DrawerPositioner = withContext18(dialog_exports.Positioner, "positioner", { forwardAsChild: true });
var DrawerContent = withContext18(
  dialog_exports.Content,
  "content",
  { forwardAsChild: true }
);
var DrawerDescription = withContext18(dialog_exports.Description, "description", { forwardAsChild: true });
var DrawerTitle = withContext18(
  dialog_exports.Title,
  "title",
  { forwardAsChild: true }
);
var DrawerCloseTrigger = withContext18(dialog_exports.CloseTrigger, "closeTrigger", { forwardAsChild: true });
var DrawerActionTrigger = (0, import_react144.forwardRef)(function DrawerActionTrigger2(props52, ref36) {
  const drawer = useDialogContext();
  return (0, import_jsx_runtime73.jsx)(chakra.button, { ...props52, ref: ref36, onClick: () => drawer.setOpen(false) });
});
var DrawerBackdrop = withContext18(
  dialog_exports.Backdrop,
  "backdrop",
  { forwardAsChild: true }
);
var DrawerBody = withContext18(
  "div",
  "body"
);
var DrawerFooter = withContext18(
  "div",
  "footer"
);
var DrawerHeader = withContext18(
  "div",
  "header"
);
var DrawerContext = dialog_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/drawer/namespace.js
var namespace_exports14 = {};
__export(namespace_exports14, {
  ActionTrigger: () => DrawerActionTrigger,
  Backdrop: () => DrawerBackdrop,
  Body: () => DrawerBody,
  CloseTrigger: () => DrawerCloseTrigger,
  Content: () => DrawerContent,
  Context: () => DrawerContext,
  Description: () => DrawerDescription,
  Footer: () => DrawerFooter,
  Header: () => DrawerHeader,
  Positioner: () => DrawerPositioner,
  Root: () => DrawerRoot,
  RootPropsProvider: () => DrawerRootPropsProvider,
  RootProvider: () => DrawerRootProvider,
  Title: () => DrawerTitle,
  Trigger: () => DrawerTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/editable/editable.js
var import_jsx_runtime84 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/editable/editable-area.js
var import_jsx_runtime74 = __toESM(require_jsx_runtime(), 1);
var import_react146 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/editable/use-editable-context.js
var [EditableProvider, useEditableContext] = createContext({
  name: "EditableContext",
  hookName: "useEditableContext",
  providerName: "<EditableProvider />"
});

// node_modules/@ark-ui/react/dist/components/editable/editable-area.js
var EditableArea = (0, import_react146.forwardRef)((props52, ref36) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps3(editable.getAreaProps(), props52);
  return (0, import_jsx_runtime74.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
EditableArea.displayName = "EditableArea";

// node_modules/@ark-ui/react/dist/components/editable/editable-cancel-trigger.js
var import_jsx_runtime75 = __toESM(require_jsx_runtime(), 1);
var import_react148 = __toESM(require_react(), 1);
var EditableCancelTrigger = (0, import_react148.forwardRef)(
  (props52, ref36) => {
    const editable = useEditableContext();
    const mergedProps = mergeProps3(editable.getCancelTriggerProps(), props52);
    return (0, import_jsx_runtime75.jsx)(ark.button, { ...mergedProps, ref: ref36 });
  }
);
EditableCancelTrigger.displayName = "EditableCancelTrigger";

// node_modules/@ark-ui/react/dist/components/editable/editable-context.js
var EditableContext = (props52) => props52.children(useEditableContext());

// node_modules/@ark-ui/react/dist/components/editable/editable-control.js
var import_jsx_runtime76 = __toESM(require_jsx_runtime(), 1);
var import_react150 = __toESM(require_react(), 1);
var EditableControl = (0, import_react150.forwardRef)((props52, ref36) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps3(editable.getControlProps(), props52);
  return (0, import_jsx_runtime76.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
EditableControl.displayName = "EditableControl";

// node_modules/@ark-ui/react/dist/components/editable/editable-edit-trigger.js
var import_jsx_runtime77 = __toESM(require_jsx_runtime(), 1);
var import_react152 = __toESM(require_react(), 1);
var EditableEditTrigger = (0, import_react152.forwardRef)(
  (props52, ref36) => {
    const editable = useEditableContext();
    const mergedProps = mergeProps3(editable.getEditTriggerProps(), props52);
    return (0, import_jsx_runtime77.jsx)(ark.button, { ...mergedProps, ref: ref36 });
  }
);
EditableEditTrigger.displayName = "EditableEditTrigger";

// node_modules/@ark-ui/react/dist/components/editable/editable-input.js
var import_jsx_runtime78 = __toESM(require_jsx_runtime(), 1);
var import_react154 = __toESM(require_react(), 1);
var EditableInput = (0, import_react154.forwardRef)((props52, ref36) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps3(editable.getInputProps(), props52);
  const field = useFieldContext();
  return (0, import_jsx_runtime78.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref36 });
});
EditableInput.displayName = "EditableInput";

// node_modules/@ark-ui/react/dist/components/editable/editable-label.js
var import_jsx_runtime79 = __toESM(require_jsx_runtime(), 1);
var import_react156 = __toESM(require_react(), 1);
var EditableLabel = (0, import_react156.forwardRef)((props52, ref36) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps3(editable.getLabelProps(), props52);
  return (0, import_jsx_runtime79.jsx)(ark.label, { ...mergedProps, ref: ref36 });
});
EditableLabel.displayName = "EditableLabel";

// node_modules/@ark-ui/react/dist/components/editable/editable-preview.js
var import_jsx_runtime80 = __toESM(require_jsx_runtime(), 1);
var import_react158 = __toESM(require_react(), 1);
var EditablePreview = (0, import_react158.forwardRef)((props52, ref36) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps3(editable.getPreviewProps(), props52);
  return (0, import_jsx_runtime80.jsx)(ark.span, { ...mergedProps, ref: ref36 });
});
EditablePreview.displayName = "EditablePreview";

// node_modules/@ark-ui/react/dist/components/editable/editable-root.js
var import_jsx_runtime81 = __toESM(require_jsx_runtime(), 1);
var import_react162 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/node_modules/@zag-js/editable/dist/index.mjs
var anatomy51 = createAnatomy2("editable").parts(
  "root",
  "area",
  "label",
  "preview",
  "input",
  "editTrigger",
  "submitTrigger",
  "cancelTrigger",
  "control"
);
var parts44 = anatomy51.build();
var dom44 = createScope({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `editable:${ctx.id}`;
  },
  getAreaId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.area) ?? `editable:${ctx.id}:area`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `editable:${ctx.id}:label`;
  },
  getPreviewId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.preview) ?? `editable:${ctx.id}:preview`;
  },
  getInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.input) ?? `editable:${ctx.id}:input`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `editable:${ctx.id}:control`;
  },
  getSubmitTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.submitTrigger) ?? `editable:${ctx.id}:submit`;
  },
  getCancelTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.cancelTrigger) ?? `editable:${ctx.id}:cancel`;
  },
  getEditTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.editTrigger) ?? `editable:${ctx.id}:edit`;
  },
  getInputEl: (ctx) => dom44.getById(ctx, dom44.getInputId(ctx)),
  getPreviewEl: (ctx) => dom44.getById(ctx, dom44.getPreviewId(ctx)),
  getSubmitTriggerEl: (ctx) => dom44.getById(ctx, dom44.getSubmitTriggerId(ctx)),
  getCancelTriggerEl: (ctx) => dom44.getById(ctx, dom44.getCancelTriggerId(ctx)),
  getEditTriggerEl: (ctx) => dom44.getById(ctx, dom44.getEditTriggerId(ctx))
});
function connect9(state2, send, normalize2) {
  const disabled = state2.context.disabled;
  const interactive = state2.context.isInteractive;
  const readOnly = state2.context.readOnly;
  const invalid = state2.context.invalid;
  const autoResize = state2.context.autoResize;
  const translations = state2.context.translations;
  const editing = state2.matches("edit");
  const placeholderProp = state2.context.placeholder;
  const placeholder = typeof placeholderProp === "string" ? { edit: placeholderProp, preview: placeholderProp } : placeholderProp;
  const value = state2.context.value;
  const empty2 = value.trim() === "";
  const valueText = empty2 ? (placeholder == null ? void 0 : placeholder.preview) ?? "" : value;
  return {
    editing,
    empty: empty2,
    value,
    valueText,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2, src: "setValue" });
    },
    clearValue() {
      send({ type: "VALUE.SET", value: "", src: "clearValue" });
    },
    edit() {
      if (!interactive) return;
      send("EDIT");
    },
    cancel() {
      if (!interactive) return;
      send("CANCEL");
    },
    submit() {
      if (!interactive) return;
      send("SUBMIT");
    },
    getRootProps() {
      return normalize2.element({
        ...parts44.root.attrs,
        id: dom44.getRootId(state2.context),
        dir: state2.context.dir
      });
    },
    getAreaProps() {
      return normalize2.element({
        ...parts44.area.attrs,
        id: dom44.getAreaId(state2.context),
        dir: state2.context.dir,
        style: autoResize ? { display: "inline-grid" } : void 0,
        "data-focus": dataAttr(editing),
        "data-disabled": dataAttr(disabled),
        "data-placeholder-shown": dataAttr(empty2)
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts44.label.attrs,
        id: dom44.getLabelId(state2.context),
        dir: state2.context.dir,
        htmlFor: dom44.getInputId(state2.context),
        "data-focus": dataAttr(editing),
        "data-invalid": dataAttr(invalid),
        onClick() {
          if (editing) return;
          const previewEl = dom44.getPreviewEl(state2.context);
          previewEl == null ? void 0 : previewEl.focus({ preventScroll: true });
        }
      });
    },
    getInputProps() {
      return normalize2.input({
        ...parts44.input.attrs,
        dir: state2.context.dir,
        "aria-label": translations.input,
        name: state2.context.name,
        form: state2.context.form,
        id: dom44.getInputId(state2.context),
        hidden: autoResize ? void 0 : !editing,
        placeholder: placeholder == null ? void 0 : placeholder.edit,
        maxLength: state2.context.maxLength,
        required: state2.context.required,
        disabled,
        "data-disabled": dataAttr(disabled),
        readOnly,
        "data-readonly": dataAttr(readOnly),
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        defaultValue: value,
        size: autoResize ? 1 : void 0,
        onChange(event) {
          send({ type: "VALUE.SET", src: "input.change", value: event.currentTarget.value });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const keyMap2 = {
            Escape() {
              send("CANCEL");
              event.preventDefault();
            },
            Enter(event2) {
              if (!state2.context.submitOnEnter) return;
              const { localName } = event2.currentTarget;
              if (localName === "textarea") {
                const submitMod = isApple() ? event2.metaKey : event2.ctrlKey;
                if (!submitMod) return;
                send({ type: "SUBMIT", src: "keydown.enter" });
                return;
              }
              if (localName === "input" && !event2.shiftKey && !event2.metaKey) {
                send({ type: "SUBMIT", src: "keydown.enter" });
                event2.preventDefault();
              }
            }
          };
          const exec21 = keyMap2[event.key];
          if (exec21) {
            exec21(event);
          }
        },
        style: autoResize ? {
          all: "unset",
          gridArea: "1 / 1 / auto / auto",
          visibility: !editing ? "hidden" : void 0
        } : void 0
      });
    },
    getPreviewProps() {
      return normalize2.element({
        id: dom44.getPreviewId(state2.context),
        ...parts44.preview.attrs,
        dir: state2.context.dir,
        "data-placeholder-shown": dataAttr(empty2),
        "aria-readonly": ariaAttr(readOnly),
        "data-readonly": dataAttr(disabled),
        "data-disabled": dataAttr(disabled),
        "aria-disabled": ariaAttr(disabled),
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        "aria-label": translations.edit,
        children: valueText,
        hidden: autoResize ? void 0 : editing,
        tabIndex: interactive ? 0 : void 0,
        onClick() {
          if (!interactive) return;
          if (state2.context.activationMode !== "click") return;
          send({ type: "EDIT", src: "click" });
        },
        onFocus() {
          if (!interactive) return;
          if (state2.context.activationMode !== "focus") return;
          send({ type: "EDIT", src: "focus" });
        },
        onDoubleClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          if (state2.context.activationMode !== "dblclick") return;
          send({ type: "EDIT", src: "dblclick" });
        },
        style: autoResize ? {
          whiteSpace: "pre",
          userSelect: "none",
          gridArea: "1 / 1 / auto / auto",
          visibility: editing ? "hidden" : void 0,
          // in event the preview overflow's the parent element
          overflow: "hidden",
          textOverflow: "ellipsis"
        } : void 0
      });
    },
    getEditTriggerProps() {
      return normalize2.button({
        ...parts44.editTrigger.attrs,
        id: dom44.getEditTriggerId(state2.context),
        dir: state2.context.dir,
        "aria-label": translations.edit,
        hidden: editing,
        type: "button",
        disabled,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "EDIT", src: "edit.click" });
        }
      });
    },
    getControlProps() {
      return normalize2.element({
        id: dom44.getControlId(state2.context),
        ...parts44.control.attrs,
        dir: state2.context.dir
      });
    },
    getSubmitTriggerProps() {
      return normalize2.button({
        ...parts44.submitTrigger.attrs,
        dir: state2.context.dir,
        id: dom44.getSubmitTriggerId(state2.context),
        "aria-label": translations.submit,
        hidden: !editing,
        disabled,
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "SUBMIT", src: "submit.click" });
        }
      });
    },
    getCancelTriggerProps() {
      return normalize2.button({
        ...parts44.cancelTrigger.attrs,
        dir: state2.context.dir,
        "aria-label": translations.cancel,
        id: dom44.getCancelTriggerId(state2.context),
        hidden: !editing,
        type: "button",
        disabled,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "CANCEL", src: "cancel.click" });
        }
      });
    }
  };
}
var submitOnEnter = (ctx) => ["both", "enter"].includes(ctx.submitMode);
var submitOnBlur = (ctx) => ["both", "blur"].includes(ctx.submitMode);
function machine9(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "editable",
      initial: ctx.edit ? "edit" : "preview",
      entry: ctx.edit ? ["focusInput"] : void 0,
      context: {
        activationMode: "focus",
        submitMode: "both",
        value: "",
        previousValue: "",
        selectOnFocus: true,
        disabled: false,
        readOnly: false,
        ...ctx,
        translations: {
          input: "editable input",
          edit: "edit",
          submit: "submit",
          cancel: "cancel",
          ...ctx.translations
        }
      },
      watch: {
        value: ["syncInputValue"],
        edit: ["toggleEditing"]
      },
      computed: {
        submitOnEnter,
        submitOnBlur,
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly)
      },
      on: {
        "VALUE.SET": {
          actions: "setValue"
        }
      },
      states: {
        preview: {
          // https://bugzilla.mozilla.org/show_bug.cgi?id=559561
          entry: ["blurInputIfNeeded"],
          on: {
            "CONTROLLED.EDIT": {
              target: "edit",
              actions: ["setPreviousValue", "focusInput"]
            },
            EDIT: [
              {
                guard: "isEditControlled",
                actions: ["invokeOnEdit"]
              },
              {
                target: "edit",
                actions: ["setPreviousValue", "focusInput", "invokeOnEdit"]
              }
            ]
          }
        },
        edit: {
          activities: ["trackInteractOutside"],
          on: {
            "CONTROLLED.PREVIEW": [
              {
                guard: "isSubmitEvent",
                target: "preview",
                actions: ["setPreviousValue", "restoreFocus", "invokeOnSubmit"]
              },
              {
                target: "preview",
                actions: ["revertValue", "restoreFocus", "invokeOnCancel"]
              }
            ],
            CANCEL: [
              {
                guard: "isEditControlled",
                actions: ["invokeOnPreview"]
              },
              {
                target: "preview",
                actions: ["revertValue", "restoreFocus", "invokeOnCancel", "invokeOnPreview"]
              }
            ],
            SUBMIT: [
              {
                guard: "isEditControlled",
                actions: ["invokeOnPreview"]
              },
              {
                target: "preview",
                actions: ["setPreviousValue", "restoreFocus", "invokeOnSubmit", "invokeOnPreview"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isEditControlled: (ctx2) => !!ctx2["edit.controlled"],
        isSubmitEvent: (_ctx, evt) => {
          var _a7;
          return ((_a7 = evt.previousEvent) == null ? void 0 : _a7.type) === "SUBMIT";
        }
      },
      activities: {
        trackInteractOutside(ctx2, _evt, { send }) {
          return trackInteractOutside2(dom44.getInputEl(ctx2), {
            exclude(target) {
              const ignore = [dom44.getCancelTriggerEl(ctx2), dom44.getSubmitTriggerEl(ctx2)];
              return ignore.some((el) => contains(el, target));
            },
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onInteractOutside(event) {
              var _a7;
              (_a7 = ctx2.onInteractOutside) == null ? void 0 : _a7.call(ctx2, event);
              if (event.defaultPrevented) return;
              const { focusable: focusable3 } = event.detail;
              send({ type: submitOnBlur(ctx2) ? "SUBMIT" : "CANCEL", src: "interact-outside", focusable: focusable3 });
            }
          });
        }
      },
      actions: {
        restoreFocus(ctx2, evt) {
          if (evt.focusable) return;
          raf(() => {
            var _a7;
            const finalEl = ((_a7 = ctx2.finalFocusEl) == null ? void 0 : _a7.call(ctx2)) ?? dom44.getEditTriggerEl(ctx2);
            finalEl == null ? void 0 : finalEl.focus({ preventScroll: true });
          });
        },
        focusInput(ctx2) {
          raf(() => {
            const inputEl = dom44.getInputEl(ctx2);
            if (!inputEl) return;
            if (ctx2.selectOnFocus) {
              inputEl.select();
            } else {
              inputEl.focus({ preventScroll: true });
            }
          });
        },
        invokeOnCancel(ctx2) {
          var _a7;
          (_a7 = ctx2.onValueRevert) == null ? void 0 : _a7.call(ctx2, { value: ctx2.previousValue });
        },
        invokeOnSubmit(ctx2) {
          var _a7;
          (_a7 = ctx2.onValueCommit) == null ? void 0 : _a7.call(ctx2, { value: ctx2.value });
        },
        invokeOnEdit(ctx2) {
          var _a7;
          (_a7 = ctx2.onEditChange) == null ? void 0 : _a7.call(ctx2, { edit: true });
        },
        invokeOnPreview(ctx2) {
          var _a7;
          (_a7 = ctx2.onEditChange) == null ? void 0 : _a7.call(ctx2, { edit: false });
        },
        toggleEditing(ctx2, evt, { send }) {
          send({ type: ctx2.edit ? "CONTROLLED.EDIT" : "CONTROLLED.PREVIEW", previousEvent: evt });
        },
        syncInputValue(ctx2) {
          sync.value(ctx2);
        },
        setValue(ctx2, evt) {
          const value = ctx2.maxLength != null ? evt.value.slice(0, ctx2.maxLength) : evt.value;
          set5.value(ctx2, value);
        },
        setPreviousValue(ctx2) {
          ctx2.previousValue = ctx2.value;
        },
        revertValue(ctx2) {
          set5.value(ctx2, ctx2.previousValue);
        },
        blurInputIfNeeded(ctx2) {
          var _a7;
          (_a7 = dom44.getInputEl(ctx2)) == null ? void 0 : _a7.blur();
        }
      }
    }
  );
}
var sync = {
  value: (ctx) => {
    const inputEl = dom44.getInputEl(ctx);
    dom44.setValue(inputEl, ctx.value);
  }
};
var invoke3 = {
  change(ctx) {
    var _a7;
    (_a7 = ctx.onValueChange) == null ? void 0 : _a7.call(ctx, { value: ctx.value });
    sync.value(ctx);
  }
};
var set5 = {
  value(ctx, value) {
    if (isEqual3(ctx.value, value)) return;
    ctx.value = value;
    invoke3.change(ctx);
  }
};
var props38 = createProps30()([
  "activationMode",
  "autoResize",
  "dir",
  "disabled",
  "finalFocusEl",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "maxLength",
  "name",
  "onEditChange",
  "onFocusOutside",
  "onInteractOutside",
  "onPointerDownOutside",
  "onValueChange",
  "onValueCommit",
  "onValueRevert",
  "placeholder",
  "readOnly",
  "required",
  "selectOnFocus",
  "edit",
  "edit.controlled",
  "submitMode",
  "translations",
  "value"
]);
var splitProps38 = createSplitProps2(props38);

// node_modules/@ark-ui/react/dist/components/editable/use-editable.js
var import_react160 = __toESM(require_react(), 1);
var useEditable = (props52 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react160.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      input: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    invalid: field == null ? void 0 : field.invalid,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    getRootNode: getRootNode2,
    edit: props52.defaultEdit,
    value: props52.defaultValue,
    "edit.controlled": props52.edit !== void 0,
    ...props52
  };
  const context = {
    ...initialContext,
    value: props52.value,
    onValueChange: useEvent(props52.onValueChange, { sync: true }),
    onEditChange: useEvent(props52.onEditChange),
    onValueCommit: useEvent(props52.onValueCommit),
    onValueRevert: useEvent(props52.onValueRevert)
  };
  const [state2, send] = useMachine(machine9(initialContext), { context });
  return connect9(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/editable/editable-root.js
var EditableRoot = (0, import_react162.forwardRef)((props52, ref36) => {
  const [useEditableProps, localProps] = createSplitProps3()(props52, [
    "activationMode",
    "autoResize",
    "defaultEdit",
    "defaultValue",
    "disabled",
    "edit",
    "finalFocusEl",
    "form",
    "id",
    "ids",
    "invalid",
    "maxLength",
    "name",
    "onEditChange",
    "onFocusOutside",
    "onInteractOutside",
    "onPointerDownOutside",
    "onValueChange",
    "onValueCommit",
    "onValueRevert",
    "placeholder",
    "readOnly",
    "required",
    "selectOnFocus",
    "submitMode",
    "translations",
    "value"
  ]);
  const editable = useEditable(useEditableProps);
  const mergedProps = mergeProps3(editable.getRootProps(), localProps);
  return (0, import_jsx_runtime81.jsx)(EditableProvider, { value: editable, children: (0, import_jsx_runtime81.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
});
EditableRoot.displayName = "EditableRoot";

// node_modules/@ark-ui/react/dist/components/editable/editable-root-provider.js
var import_jsx_runtime82 = __toESM(require_jsx_runtime(), 1);
var import_react164 = __toESM(require_react(), 1);
var EditableRootProvider = (0, import_react164.forwardRef)(
  (props52, ref36) => {
    const [{ value: editable }, localProps] = createSplitProps3()(props52, [
      "value"
    ]);
    const mergedProps = mergeProps3(editable.getRootProps(), localProps);
    return (0, import_jsx_runtime82.jsx)(EditableProvider, { value: editable, children: (0, import_jsx_runtime82.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
  }
);
EditableRootProvider.displayName = "EditableRootProvider";

// node_modules/@ark-ui/react/dist/components/editable/editable-submit-trigger.js
var import_jsx_runtime83 = __toESM(require_jsx_runtime(), 1);
var import_react166 = __toESM(require_react(), 1);
var EditableSubmitTrigger = (0, import_react166.forwardRef)(
  (props52, ref36) => {
    const editable = useEditableContext();
    const mergedProps = mergeProps3(editable.getSubmitTriggerProps(), props52);
    return (0, import_jsx_runtime83.jsx)(ark.button, { ...mergedProps, ref: ref36 });
  }
);
EditableSubmitTrigger.displayName = "EditableSubmitTrigger";

// node_modules/@ark-ui/react/dist/components/editable/editable.js
var editable_exports = {};
__export(editable_exports, {
  Area: () => EditableArea,
  CancelTrigger: () => EditableCancelTrigger,
  Context: () => EditableContext,
  Control: () => EditableControl,
  EditTrigger: () => EditableEditTrigger,
  Input: () => EditableInput,
  Label: () => EditableLabel,
  Preview: () => EditablePreview,
  Root: () => EditableRoot,
  RootProvider: () => EditableRootProvider,
  SubmitTrigger: () => EditableSubmitTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/editable/editable.js
var import_react167 = __toESM(require_react(), 1);
var {
  withProvider: withProvider12,
  withContext: withContext19,
  useStyles: useEditableStyles,
  PropsProvider: PropsProvider19
} = createSlotRecipeContext({ key: "editable" });
var EditableRootProvider2 = withProvider12(editable_exports.RootProvider, "root", { forwardAsChild: true });
var EditableRoot2 = withProvider12(
  editable_exports.Root,
  "root",
  { forwardAsChild: true }
);
var EditablePropsProvider = PropsProvider19;
var EditablePreview2 = withContext19(editable_exports.Preview, "preview", { forwardAsChild: true });
var EditableInput2 = withContext19(
  editable_exports.Input,
  "input",
  { forwardAsChild: true }
);
var ArkEditableTextarea = (0, import_react167.forwardRef)(function EditableTextarea2(props52, ref36) {
  const editable = useEditableContext();
  const mergedProps = mergeProps(editable.getInputProps(), props52);
  return (0, import_jsx_runtime84.jsx)(ark.textarea, { ref: ref36, ...mergedProps });
});
var EditableTextarea = withContext19(ArkEditableTextarea, "input", { forwardAsChild: true });
var EditableControl2 = withContext19(editable_exports.Control, "control", { forwardAsChild: true });
var EditableArea2 = withContext19(
  editable_exports.Area,
  "area",
  { forwardAsChild: true }
);
var EditableEditTrigger2 = withContext19(editable_exports.EditTrigger, "editTrigger", { forwardAsChild: true });
var EditableSubmitTrigger2 = withContext19(editable_exports.SubmitTrigger, "submitTrigger", { forwardAsChild: true });
var EditableCancelTrigger2 = withContext19(editable_exports.CancelTrigger, "cancelTrigger", { forwardAsChild: true });
var EditableContext2 = editable_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/editable/namespace.js
var namespace_exports15 = {};
__export(namespace_exports15, {
  Area: () => EditableArea2,
  CancelTrigger: () => EditableCancelTrigger2,
  Context: () => EditableContext2,
  Control: () => EditableControl2,
  EditTrigger: () => EditableEditTrigger2,
  Input: () => EditableInput2,
  Preview: () => EditablePreview2,
  PropsProvider: () => EditablePropsProvider,
  Root: () => EditableRoot2,
  RootProvider: () => EditableRootProvider2,
  SubmitTrigger: () => EditableSubmitTrigger2,
  Textarea: () => EditableTextarea
});

// node_modules/@chakra-ui/react/dist/esm/components/empty-state/empty-state.js
var {
  withProvider: withProvider13,
  withContext: withContext20,
  useStyles: useEmptyStateStyles,
  PropsProvider: PropsProvider20
} = createSlotRecipeContext({ key: "emptyState" });
var EmptyStateRoot = withProvider13(
  "div",
  "root"
);
var EmptyStatePropsProvider = PropsProvider20;
var EmptyStateContent = withContext20("div", "content");
var EmptyStateIndicator = withContext20("div", "indicator");
var EmptyStateTitle = withContext20("h3", "title");
var EmptyStateDescription = withContext20("p", "description");

// node_modules/@chakra-ui/react/dist/esm/components/empty-state/namespace.js
var namespace_exports16 = {};
__export(namespace_exports16, {
  Content: () => EmptyStateContent,
  Description: () => EmptyStateDescription,
  Indicator: () => EmptyStateIndicator,
  PropsProvider: () => EmptyStatePropsProvider,
  Root: () => EmptyStateRoot,
  Title: () => EmptyStateTitle
});

// node_modules/@ark-ui/react/dist/providers/environment/environment-provider.js
var import_jsx_runtime85 = __toESM(require_jsx_runtime(), 1);
var import_react168 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/run-if-fn.js
var isFunction24 = (value) => typeof value === "function";
var runIfFn4 = (valueOrFn, ...args) => isFunction24(valueOrFn) ? valueOrFn(...args) : valueOrFn;

// node_modules/@ark-ui/react/dist/providers/environment/environment-provider.js
var EnvironmentProvider = (props52) => {
  const { value, children } = props52;
  const [spanRef, setSpanRef] = (0, import_react168.useState)();
  const getRootNode2 = (0, import_react168.useMemo)(() => {
    return () => runIfFn4(value) ?? (spanRef == null ? void 0 : spanRef.ownerDocument) ?? document;
  }, [value, spanRef]);
  const environment = (0, import_react168.useMemo)(
    () => ({
      getRootNode: getRootNode2,
      getWindow: () => getWindow(getRootNode2()),
      getDocument: () => getDocument(getRootNode2())
    }),
    [getRootNode2]
  );
  return (0, import_jsx_runtime85.jsxs)(EnvironmentContextProvider, { value: environment, children: [
    children,
    !value && (0, import_jsx_runtime85.jsx)("span", { hidden: true, ref: setSpanRef })
  ] });
};

// node_modules/@chakra-ui/react/dist/esm/components/field/field.js
var import_jsx_runtime95 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/field/field-context.js
var FieldContext = (props52) => props52.children(useFieldContext());

// node_modules/@ark-ui/react/dist/components/field/field-error-text.js
var import_jsx_runtime86 = __toESM(require_jsx_runtime(), 1);
var import_react170 = __toESM(require_react(), 1);
var FieldErrorText = (0, import_react170.forwardRef)((props52, ref36) => {
  const field = useFieldContext();
  const mergedProps = mergeProps3(field.getErrorTextProps(), props52);
  if (field == null ? void 0 : field.invalid) {
    return (0, import_jsx_runtime86.jsx)(ark.span, { ...mergedProps, ref: ref36 });
  }
  return null;
});
FieldErrorText.displayName = "FieldErrorText";

// node_modules/@ark-ui/react/dist/components/field/field-helper-text.js
var import_jsx_runtime87 = __toESM(require_jsx_runtime(), 1);
var import_react172 = __toESM(require_react(), 1);
var FieldHelperText = (0, import_react172.forwardRef)((props52, ref36) => {
  const field = useFieldContext();
  const mergedProps = mergeProps3(field == null ? void 0 : field.getHelperTextProps(), props52);
  return (0, import_jsx_runtime87.jsx)(ark.span, { ...mergedProps, ref: ref36 });
});
FieldHelperText.displayName = "FieldHelperText";

// node_modules/@ark-ui/react/dist/components/field/field-input.js
var import_jsx_runtime88 = __toESM(require_jsx_runtime(), 1);
var import_react174 = __toESM(require_react(), 1);
var FieldInput = (0, import_react174.forwardRef)((props52, ref36) => {
  const field = useFieldContext();
  const mergedProps = mergeProps3(field == null ? void 0 : field.getInputProps(), props52);
  return (0, import_jsx_runtime88.jsx)(ark.input, { ...mergedProps, ref: ref36 });
});
FieldInput.displayName = "FieldInput";

// node_modules/@ark-ui/react/dist/components/field/field-label.js
var import_jsx_runtime89 = __toESM(require_jsx_runtime(), 1);
var import_react176 = __toESM(require_react(), 1);
var FieldLabel = (0, import_react176.forwardRef)((props52, ref36) => {
  const field = useFieldContext();
  const mergedProps = mergeProps3(field == null ? void 0 : field.getLabelProps(), props52);
  return (0, import_jsx_runtime89.jsx)(ark.label, { ...mergedProps, ref: ref36 });
});
FieldLabel.displayName = "FieldLabel";

// node_modules/@ark-ui/react/dist/components/field/field-root.js
var import_jsx_runtime90 = __toESM(require_jsx_runtime(), 1);
var import_react180 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/field/use-field.js
var import_react178 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/use-safe-layout-effect.js
var import_react177 = __toESM(require_react(), 1);
var useSafeLayoutEffect2 = typeof window !== "undefined" ? import_react177.useLayoutEffect : import_react177.useEffect;

// node_modules/@ark-ui/react/dist/components/fieldset/use-fieldset-context.js
var [FieldsetProvider, useFieldsetContext] = createContext({
  name: "FieldsetContext",
  hookName: "useFieldsetContext",
  providerName: "<FieldsetProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/field/field.anatomy.js
var fieldAnatomy2 = createAnatomy2("field").parts(
  "root",
  "errorText",
  "helperText",
  "input",
  "label",
  "select",
  "textarea"
);
var parts45 = fieldAnatomy2.build();

// node_modules/@ark-ui/react/dist/components/field/use-field.js
var useField = (props52) => {
  const fieldset = useFieldsetContext();
  const {
    ids,
    disabled = Boolean(fieldset == null ? void 0 : fieldset.disabled),
    invalid = false,
    readOnly = false,
    required = false
  } = props52;
  const hasErrorText = (0, import_react178.useRef)(false);
  const hasHelperText = (0, import_react178.useRef)(false);
  const id = props52.id ?? (0, import_react178.useId)();
  const rootRef = (0, import_react178.useRef)(null);
  const rootId = (ids == null ? void 0 : ids.control) ?? `field::${id}`;
  const errorTextId = (ids == null ? void 0 : ids.errorText) ?? `field::${id}::error-text`;
  const helperTextId = (ids == null ? void 0 : ids.helperText) ?? `field::${id}::helper-text`;
  const labelId = (ids == null ? void 0 : ids.label) ?? `field::${id}::label`;
  useSafeLayoutEffect2(() => {
    const rootNode = rootRef.current;
    if (!rootNode) return;
    const win = getWindow(rootNode);
    const doc = win.document;
    const checkTextElements = () => {
      hasErrorText.current = !!doc.getElementById(errorTextId);
      hasHelperText.current = !!doc.getElementById(helperTextId);
    };
    checkTextElements();
    const observer = new win.MutationObserver(checkTextElements);
    observer.observe(rootNode, { childList: true, subtree: true });
    return () => observer.disconnect();
  }, [errorTextId, helperTextId]);
  const labelIds = (0, import_react178.useMemo)(() => {
    const ids2 = [];
    if (hasErrorText.current && invalid) ids2.push(errorTextId);
    if (hasHelperText.current) ids2.push(helperTextId);
    return ids2.join(" ") || void 0;
  }, [invalid, errorTextId, helperTextId]);
  const getRootProps = (0, import_react178.useMemo)(
    () => () => ({
      ...parts45.root.attrs,
      id: rootId,
      ref: rootRef,
      role: "group",
      "data-disabled": dataAttr(disabled),
      "data-invalid": dataAttr(invalid),
      "data-readonly": dataAttr(readOnly)
    }),
    [disabled, invalid, readOnly, rootId]
  );
  const getLabelProps = (0, import_react178.useMemo)(
    () => () => ({
      ...parts45.label.attrs,
      id: labelId,
      "data-disabled": dataAttr(disabled),
      "data-invalid": dataAttr(invalid),
      "data-readonly": dataAttr(readOnly),
      htmlFor: id
    }),
    [disabled, invalid, readOnly, id, labelId]
  );
  const getControlProps = (0, import_react178.useMemo)(
    () => () => ({
      "aria-describedby": labelIds,
      "aria-invalid": ariaAttr(invalid),
      "data-invalid": dataAttr(invalid),
      "data-required": dataAttr(required),
      "data-readonly": dataAttr(readOnly),
      id,
      required,
      disabled,
      readOnly
    }),
    [labelIds, invalid, required, readOnly, id, disabled]
  );
  const getInputProps = (0, import_react178.useMemo)(
    () => () => ({
      ...getControlProps(),
      ...parts45.input.attrs
    }),
    [getControlProps]
  );
  const getTextareaProps = (0, import_react178.useMemo)(
    () => () => ({
      ...getControlProps(),
      ...parts45.textarea.attrs
    }),
    [getControlProps]
  );
  const getSelectProps = (0, import_react178.useMemo)(
    () => () => ({
      ...getControlProps(),
      ...parts45.select.attrs
    }),
    [getControlProps]
  );
  const getHelperTextProps = (0, import_react178.useMemo)(
    () => () => ({
      id: helperTextId,
      ...parts45.helperText.attrs
    }),
    [helperTextId]
  );
  const getErrorTextProps = (0, import_react178.useMemo)(
    () => () => ({
      id: errorTextId,
      ...parts45.errorText.attrs,
      "aria-live": "polite"
    }),
    [errorTextId]
  );
  return {
    ariaDescribedby: labelIds,
    ids: {
      root: rootId,
      control: id,
      label: labelId,
      errorText: errorTextId,
      helperText: helperTextId
    },
    refs: {
      rootRef
    },
    disabled,
    invalid,
    readOnly,
    required,
    getLabelProps,
    getRootProps,
    getInputProps,
    getTextareaProps,
    getSelectProps,
    getHelperTextProps,
    getErrorTextProps
  };
};

// node_modules/@ark-ui/react/dist/components/field/field-root.js
var FieldRoot = (0, import_react180.forwardRef)((props52, ref36) => {
  const [useFieldProps, localProps] = createSplitProps3()(props52, [
    "id",
    "ids",
    "disabled",
    "invalid",
    "readOnly",
    "required"
  ]);
  const field = useField(useFieldProps);
  const mergedProps = mergeProps3(field.getRootProps(), localProps);
  return (0, import_jsx_runtime90.jsx)(FieldProvider, { value: field, children: (0, import_jsx_runtime90.jsx)(ark.div, { ...mergedProps, ref: composeRefs(ref36, field.refs.rootRef) }) });
});
FieldRoot.displayName = "FieldRoot";

// node_modules/@ark-ui/react/dist/components/field/field-root-provider.js
var import_jsx_runtime91 = __toESM(require_jsx_runtime(), 1);
var import_react182 = __toESM(require_react(), 1);
var FieldRootProvider = (0, import_react182.forwardRef)(
  (props52, ref36) => {
    const [{ value: field }, localProps] = createSplitProps3()(props52, ["value"]);
    const mergedProps = mergeProps3(field.getRootProps(), localProps);
    return (0, import_jsx_runtime91.jsx)(FieldProvider, { value: field, children: (0, import_jsx_runtime91.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
  }
);
FieldRootProvider.displayName = "FieldRootProvider";

// node_modules/@ark-ui/react/dist/components/field/field-select.js
var import_jsx_runtime92 = __toESM(require_jsx_runtime(), 1);
var import_react184 = __toESM(require_react(), 1);
var FieldSelect = (0, import_react184.forwardRef)((props52, ref36) => {
  const field = useFieldContext();
  const mergedProps = mergeProps3(field == null ? void 0 : field.getSelectProps(), props52);
  return (0, import_jsx_runtime92.jsx)(ark.select, { ...mergedProps, ref: ref36 });
});
FieldSelect.displayName = "FieldSelect";

// node_modules/@ark-ui/react/dist/components/field/field-textarea.js
var import_jsx_runtime93 = __toESM(require_jsx_runtime(), 1);
var import_react186 = __toESM(require_react(), 1);
var FieldTextarea = (0, import_react186.forwardRef)((props52, ref36) => {
  const field = useFieldContext();
  const mergedProps = mergeProps3(field == null ? void 0 : field.getTextareaProps(), props52);
  return (0, import_jsx_runtime93.jsx)(ark.textarea, { ...mergedProps, ref: ref36 });
});
FieldTextarea.displayName = "FieldTextarea";

// node_modules/@ark-ui/react/dist/components/field/field.js
var field_exports = {};
__export(field_exports, {
  Context: () => FieldContext,
  ErrorText: () => FieldErrorText,
  HelperText: () => FieldHelperText,
  Input: () => FieldInput,
  Label: () => FieldLabel,
  Root: () => FieldRoot,
  RootProvider: () => FieldRootProvider,
  Select: () => FieldSelect,
  Textarea: () => FieldTextarea
});

// node_modules/@chakra-ui/react/dist/esm/components/field/field.js
var import_react188 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/icon/create-icon.js
var import_jsx_runtime94 = __toESM(require_jsx_runtime(), 1);
var import_react187 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/icon/icon.js
var { withContext: withContext21 } = createRecipeContext({ key: "icon" });
var Icon = withContext21("svg", {
  defaultProps: {
    focusable: false,
    asChild: true,
    "aria-hidden": true
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/icon/create-icon.js
function createIcon(options) {
  const {
    viewBox = "0 0 24 24",
    d: pathDefinition,
    displayName,
    defaultProps = {}
  } = options;
  const path = import_react187.Children.toArray(options.path);
  const Comp = (0, import_react187.forwardRef)((props52, ref36) => (0, import_jsx_runtime94.jsx)(
    Icon,
    {
      ref: ref36,
      asChild: false,
      viewBox,
      ...defaultProps,
      ...props52,
      children: path.length ? path : (0, import_jsx_runtime94.jsx)("path", { fill: "currentColor", d: pathDefinition })
    }
  ));
  Comp.displayName = displayName;
  return Comp;
}

// node_modules/@chakra-ui/react/dist/esm/components/field/field.js
var {
  withProvider: withProvider14,
  withContext: withContext22,
  useStyles: useFieldStyles,
  useClassNames,
  PropsProvider: PropsProvider21
} = createSlotRecipeContext({ key: "field" });
var FieldRoot2 = withProvider14(
  field_exports.Root,
  "root",
  { forwardAsChild: true }
);
var FieldPropsProvider = PropsProvider21;
var FieldLabel2 = withContext22(
  field_exports.Label,
  "label",
  { forwardAsChild: true }
);
var FieldHelperText2 = withContext22(field_exports.HelperText, "helperText", { forwardAsChild: true });
var FieldErrorText2 = withContext22(
  field_exports.ErrorText,
  "errorText",
  { forwardAsChild: true }
);
var FieldErrorIcon = createIcon({
  d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
});
var FieldRequiredIndicator = (0, import_react188.forwardRef)(function RequiredIndicator(props52, ref36) {
  const { fallback: fallback5, children = "*", ...restProps } = props52;
  const field = useFieldContext();
  const classNames = useClassNames();
  const styles = useFieldStyles();
  if (!(field == null ? void 0 : field.required)) {
    return fallback5;
  }
  return (0, import_jsx_runtime95.jsx)(
    chakra.span,
    {
      ref: ref36,
      "aria-hidden": "true",
      ...restProps,
      className: cx(classNames.requiredIndicator, props52.className),
      css: [styles.requiredIndicator, props52.css],
      children
    }
  );
});

// node_modules/@chakra-ui/react/dist/esm/components/field/namespace.js
var namespace_exports17 = {};
__export(namespace_exports17, {
  ErrorIcon: () => FieldErrorIcon,
  ErrorText: () => FieldErrorText2,
  HelperText: () => FieldHelperText2,
  Label: () => FieldLabel2,
  PropsProvider: () => FieldPropsProvider,
  RequiredIndicator: () => FieldRequiredIndicator,
  Root: () => FieldRoot2
});

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-context.js
var FieldsetContext = (props52) => props52.children(useFieldsetContext());

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-error-text.js
var import_jsx_runtime96 = __toESM(require_jsx_runtime(), 1);
var import_react190 = __toESM(require_react(), 1);
var FieldsetErrorText = (0, import_react190.forwardRef)(
  (props52, ref36) => {
    const fieldset = useFieldsetContext();
    const mergedProps = mergeProps3(fieldset.getErrorTextProps(), props52);
    return fieldset.invalid ? (0, import_jsx_runtime96.jsx)(ark.span, { ...mergedProps, ref: ref36 }) : null;
  }
);
FieldsetErrorText.displayName = "FieldsetErrorText";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-helper-text.js
var import_jsx_runtime97 = __toESM(require_jsx_runtime(), 1);
var import_react192 = __toESM(require_react(), 1);
var FieldsetHelperText = (0, import_react192.forwardRef)(
  (props52, ref36) => {
    const fieldset = useFieldsetContext();
    const mergedProps = mergeProps3(fieldset.getHelperTextProps(), props52);
    return (0, import_jsx_runtime97.jsx)(ark.span, { ...mergedProps, ref: ref36 });
  }
);
FieldsetHelperText.displayName = "FieldsetHelperText";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-legend.js
var import_jsx_runtime98 = __toESM(require_jsx_runtime(), 1);
var import_react194 = __toESM(require_react(), 1);
var FieldsetLegend = (0, import_react194.forwardRef)((props52, ref36) => {
  const fieldset = useFieldsetContext();
  const mergedProps = mergeProps3(fieldset.getLegendProps(), props52);
  return (0, import_jsx_runtime98.jsx)(ark.legend, { ...mergedProps, ref: ref36 });
});
FieldsetLegend.displayName = "FieldsetLegend";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-root.js
var import_jsx_runtime99 = __toESM(require_jsx_runtime(), 1);
var import_react197 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/fieldset/use-fieldset.js
var import_react195 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset.anatomy.js
var fieldsetAnatomy = createAnatomy2("fieldset").parts(
  "root",
  "errorText",
  "helperText",
  "legend"
);
var parts46 = fieldsetAnatomy.build();

// node_modules/@ark-ui/react/dist/components/fieldset/use-fieldset.js
var useFieldset = (props52) => {
  const { disabled = false, invalid = false } = props52;
  const hasErrorText = (0, import_react195.useRef)(false);
  const hasHelperText = (0, import_react195.useRef)(false);
  const id = props52.id ?? (0, import_react195.useId)();
  const rootRef = (0, import_react195.useRef)(null);
  const errorTextId = `fieldset::${id}::error-text`;
  const helperTextId = `fieldset::${id}::helper-text`;
  useSafeLayoutEffect2(() => {
    const rootNode = rootRef.current;
    if (!rootNode) return;
    const win = getWindow(rootNode);
    const doc = win.document;
    const checkTextElements = () => {
      hasErrorText.current = !!doc.getElementById(errorTextId);
      hasHelperText.current = !!doc.getElementById(helperTextId);
    };
    checkTextElements();
    const observer = new win.MutationObserver(checkTextElements);
    observer.observe(rootNode, { childList: true, subtree: true });
    return () => observer.disconnect();
  }, [errorTextId, helperTextId]);
  const labelIds = (0, import_react195.useMemo)(() => {
    const ids = [];
    if (hasErrorText.current && invalid) ids.push(errorTextId);
    if (hasHelperText.current) ids.push(helperTextId);
    return ids.join(" ") || void 0;
  }, [invalid, errorTextId, helperTextId]);
  const getRootProps = (0, import_react195.useMemo)(
    () => () => ({
      ...parts46.root.attrs,
      ref: rootRef,
      disabled,
      "data-disabled": disabled ? "true" : void 0,
      "data-invalid": invalid ? "true" : void 0,
      "aria-describedby": labelIds
    }),
    [disabled, invalid, labelIds]
  );
  const getLegendProps = (0, import_react195.useMemo)(
    () => () => ({
      ...parts46.legend.attrs,
      "data-disabled": disabled ? "true" : void 0,
      "data-invalid": invalid ? "true" : void 0
    }),
    [disabled, invalid]
  );
  const getHelperTextProps = (0, import_react195.useMemo)(
    () => () => ({
      id: helperTextId,
      ...parts46.helperText.attrs
    }),
    [helperTextId]
  );
  const getErrorTextProps = (0, import_react195.useMemo)(
    () => () => ({
      id: errorTextId,
      ...parts46.errorText.attrs,
      "aria-live": "polite"
    }),
    [errorTextId]
  );
  return {
    refs: {
      rootRef
    },
    disabled,
    invalid,
    getRootProps,
    getLegendProps,
    getHelperTextProps,
    getErrorTextProps
  };
};

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-root.js
var FieldsetRoot = (0, import_react197.forwardRef)((props52, ref36) => {
  const [useFieldsetProps, localProps] = createSplitProps3()(props52, [
    "id",
    "disabled",
    "invalid"
  ]);
  const fieldset = useFieldset(useFieldsetProps);
  const mergedProps = mergeProps3(fieldset.getRootProps(), localProps);
  return (0, import_jsx_runtime99.jsx)(FieldsetProvider, { value: fieldset, children: (0, import_jsx_runtime99.jsx)(ark.fieldset, { ...mergedProps, ref: composeRefs(ref36, fieldset.refs.rootRef) }) });
});
FieldsetRoot.displayName = "FieldsetRoot";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-root-provider.js
var import_jsx_runtime100 = __toESM(require_jsx_runtime(), 1);
var import_react199 = __toESM(require_react(), 1);
var FieldsetRootProvider = (0, import_react199.forwardRef)(
  (props52, ref36) => {
    const [{ value: fieldset }, localProps] = createSplitProps3()(props52, [
      "value"
    ]);
    const mergedProps = mergeProps3(fieldset.getRootProps(), localProps);
    return (0, import_jsx_runtime100.jsx)(FieldsetProvider, { value: fieldset, children: (0, import_jsx_runtime100.jsx)(ark.fieldset, { ...mergedProps, ref: ref36 }) });
  }
);
FieldsetRootProvider.displayName = "FieldsetRootProvider";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset.js
var fieldset_exports = {};
__export(fieldset_exports, {
  Context: () => FieldsetContext,
  ErrorText: () => FieldsetErrorText,
  HelperText: () => FieldsetHelperText,
  Legend: () => FieldsetLegend,
  Root: () => FieldsetRoot,
  RootProvider: () => FieldsetRootProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/fieldset/fieldset.js
var { withProvider: withProvider15, withContext: withContext23 } = createSlotRecipeContext({
  key: "fieldset"
});
var FieldsetRoot2 = withProvider15(fieldset_exports.Root, "root");
var FieldsetErrorText2 = withContext23(fieldset_exports.ErrorText, "errorText");
var FieldsetHelperText2 = withContext23(fieldset_exports.HelperText, "helperText");
var FieldsetLegend2 = withContext23(fieldset_exports.Legend, "legend");
var FieldsetContent = withContext23(ark.div, "content");
var FieldsetContext2 = fieldset_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/fieldset/namespace.js
var namespace_exports18 = {};
__export(namespace_exports18, {
  Content: () => FieldsetContent,
  Context: () => FieldsetContext2,
  ErrorText: () => FieldsetErrorText2,
  HelperText: () => FieldsetHelperText2,
  Legend: () => FieldsetLegend2,
  Root: () => FieldsetRoot2
});

// node_modules/@chakra-ui/react/dist/esm/components/file-upload/file-upload.js
var import_jsx_runtime115 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-clear-trigger.js
var import_jsx_runtime101 = __toESM(require_jsx_runtime(), 1);
var import_react201 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/file-upload/use-file-upload-context.js
var [FileUploadProvider, useFileUploadContext] = createContext({
  name: "FileUploadContext",
  hookName: "useFileUploadContext",
  providerName: "<FileUploadProvider />"
});

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-clear-trigger.js
var FileUploadClearTrigger = (0, import_react201.forwardRef)(
  (props52, ref36) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps3(fileUpload.getClearTriggerProps(), props52);
    return (0, import_jsx_runtime101.jsx)(ark.button, { ...mergedProps, ref: ref36 });
  }
);
FileUploadClearTrigger.displayName = "FileUploadClearTrigger";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-context.js
var FileUploadContext = (props52) => props52.children(useFileUploadContext());

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-dropzone.js
var import_jsx_runtime102 = __toESM(require_jsx_runtime(), 1);
var import_react203 = __toESM(require_react(), 1);
var FileUploadDropzone = (0, import_react203.forwardRef)(
  (props52, ref36) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps3(fileUpload.getDropzoneProps(), props52);
    return (0, import_jsx_runtime102.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
FileUploadDropzone.displayName = "FileUploadDropzone";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-hidden-input.js
var import_jsx_runtime103 = __toESM(require_jsx_runtime(), 1);
var import_react205 = __toESM(require_react(), 1);
var FileUploadHiddenInput = (0, import_react205.forwardRef)(
  (props52, ref36) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps3(fileUpload.getHiddenInputProps(), props52);
    const field = useFieldContext();
    return (0, import_jsx_runtime103.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref36 });
  }
);
FileUploadHiddenInput.displayName = "FileUploadHiddenInput";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item.js
var import_jsx_runtime104 = __toESM(require_jsx_runtime(), 1);
var import_react207 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/file-upload/use-file-upload-item-props-context.js
var [FileUploadItemPropsProvider, useFileUploadItemPropsContext] = createContext({
  name: "FileUploadItemPropsContext",
  hookName: "useFileUploadItemPropsContext",
  providerName: "<FileUploadItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item.js
var FileUploadItem = (0, import_react207.forwardRef)((props52, ref36) => {
  const [itemProps17, localProps] = createSplitProps3()(props52, ["file"]);
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps3(fileUpload.getItemProps(itemProps17), localProps);
  return (0, import_jsx_runtime104.jsx)(FileUploadItemPropsProvider, { value: itemProps17, children: (0, import_jsx_runtime104.jsx)(ark.li, { ...mergedProps, ref: ref36 }) });
});
FileUploadItem.displayName = "FileUploadItem";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-delete-trigger.js
var import_jsx_runtime105 = __toESM(require_jsx_runtime(), 1);
var import_react209 = __toESM(require_react(), 1);
var FileUploadItemDeleteTrigger = (0, import_react209.forwardRef)((props52, ref36) => {
  const fileUpload = useFileUploadContext();
  const itemProps17 = useFileUploadItemPropsContext();
  const mergedProps = mergeProps3(fileUpload.getItemDeleteTriggerProps(itemProps17), props52);
  return (0, import_jsx_runtime105.jsx)(ark.button, { ...mergedProps, ref: ref36 });
});
FileUploadItemDeleteTrigger.displayName = "FileUploadItemDeleteTrigger";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-group.js
var import_jsx_runtime106 = __toESM(require_jsx_runtime(), 1);
var import_react211 = __toESM(require_react(), 1);
var FileUploadItemGroup = (0, import_react211.forwardRef)(
  (props52, ref36) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps3(fileUpload.getItemGroupProps(), props52);
    return (0, import_jsx_runtime106.jsx)(ark.ul, { ...mergedProps, ref: ref36 });
  }
);
FileUploadItemGroup.displayName = "FileUploadItemGroup";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-name.js
var import_jsx_runtime107 = __toESM(require_jsx_runtime(), 1);
var import_react213 = __toESM(require_react(), 1);
var FileUploadItemName = (0, import_react213.forwardRef)(
  (props52, ref36) => {
    const { children, ...rest } = props52;
    const fileUpload = useFileUploadContext();
    const itemProps17 = useFileUploadItemPropsContext();
    const mergedProps = mergeProps3(fileUpload.getItemNameProps(itemProps17), rest);
    return (0, import_jsx_runtime107.jsx)(ark.div, { ...mergedProps, ref: ref36, children: children || itemProps17.file.name });
  }
);
FileUploadItemName.displayName = "FileUploadItemName";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-preview.js
var import_jsx_runtime108 = __toESM(require_jsx_runtime(), 1);
var import_react215 = __toESM(require_react(), 1);
var FileUploadItemPreview = (0, import_react215.forwardRef)(
  (props52, ref36) => {
    const fileUpload = useFileUploadContext();
    const itemProps17 = useFileUploadItemPropsContext();
    const mergedProps = mergeProps3(fileUpload.getItemPreviewProps(itemProps17), props52);
    if (!itemProps17.file.type.match(props52.type ?? ".*")) return null;
    return (0, import_jsx_runtime108.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
FileUploadItemPreview.displayName = "FileUploadItemPreview";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-preview-image.js
var import_jsx_runtime109 = __toESM(require_jsx_runtime(), 1);
var import_react217 = __toESM(require_react(), 1);
var FileUploadItemPreviewImage = (0, import_react217.forwardRef)((props52, ref36) => {
  const [url, setUrl] = (0, import_react217.useState)("");
  const fileUpload = useFileUploadContext();
  const itemProps17 = useFileUploadItemPropsContext();
  const mergedProps = mergeProps3(fileUpload.getItemPreviewImageProps({ ...itemProps17, url }), props52);
  (0, import_react217.useEffect)(() => {
    return fileUpload.createFileUrl(itemProps17.file, (url2) => setUrl(url2));
  }, [itemProps17, fileUpload]);
  return (0, import_jsx_runtime109.jsx)(ark.img, { ...mergedProps, ref: ref36 });
});
FileUploadItemPreviewImage.displayName = "FileUploadItemPreviewImage";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-size-text.js
var import_jsx_runtime110 = __toESM(require_jsx_runtime(), 1);
var import_react219 = __toESM(require_react(), 1);
var FileUploadItemSizeText = (0, import_react219.forwardRef)(
  (props52, ref36) => {
    const { children, ...rest } = props52;
    const fileUpload = useFileUploadContext();
    const itemProps17 = useFileUploadItemPropsContext();
    const mergedProps = mergeProps3(fileUpload.getItemSizeTextProps(itemProps17), rest);
    return (0, import_jsx_runtime110.jsx)(ark.div, { ...mergedProps, ref: ref36, children: children || fileUpload.getFileSize(itemProps17.file) });
  }
);
FileUploadItemSizeText.displayName = "FileUploadItemSizeText";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-label.js
var import_jsx_runtime111 = __toESM(require_jsx_runtime(), 1);
var import_react221 = __toESM(require_react(), 1);
var FileUploadLabel = (0, import_react221.forwardRef)((props52, ref36) => {
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps3(fileUpload.getLabelProps(), props52);
  return (0, import_jsx_runtime111.jsx)(ark.label, { ...mergedProps, ref: ref36 });
});
FileUploadLabel.displayName = "FileUploadLabel";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-root.js
var import_jsx_runtime112 = __toESM(require_jsx_runtime(), 1);
var import_react225 = __toESM(require_react(), 1);

// node_modules/@zag-js/file-utils/dist/index.mjs
function isMIMEType(v) {
  return v === "audio/*" || v === "video/*" || v === "image/*" || v === "text/*" || /\w+\/[-+.\w]+/g.test(v);
}
function isExt(v) {
  return /^.*\.[\w]+$/.test(v);
}
var isValidMIME = (v) => isMIMEType(v) || isExt(v);
function getAcceptAttrString2(accept) {
  if (!accept) return;
  if (typeof accept === "string") {
    return accept;
  }
  if (Array.isArray(accept)) {
    return accept.filter(isValidMIME).join(",");
  }
  return Object.entries(accept).reduce((a, [mimeType, ext]) => [...a, mimeType, ...ext], []).filter(isValidMIME).join(",");
}
var isFileEqual2 = (file1, file2) => {
  return file1.name === file2.name && file1.size === file2.size && file1.type === file2.type;
};
var isDefined = (v) => v !== void 0 && v !== null;
function isValidFileSize2(file, minSize, maxSize) {
  if (isDefined(file.size)) {
    if (isDefined(minSize) && isDefined(maxSize)) {
      if (file.size > maxSize) return [false, "FILE_TOO_LARGE"];
      if (file.size < minSize) return [false, "FILE_TOO_SMALL"];
    } else if (isDefined(minSize) && file.size < minSize) {
      return [false, "FILE_TOO_SMALL"];
    } else if (isDefined(maxSize) && file.size > maxSize) {
      return [false, "FILE_TOO_LARGE"];
    }
  }
  return [true, null];
}
function isFileAccepted(file, accept) {
  if (file && accept) {
    const types = Array.isArray(accept) ? accept : accept.split(",");
    const fileName = file.name || "";
    const mimeType = (file.type || "").toLowerCase();
    const baseMimeType = mimeType.replace(/\/.*$/, "");
    return types.some((type) => {
      const validType = type.trim().toLowerCase();
      if (validType.charAt(0) === ".") {
        return fileName.toLowerCase().endsWith(validType);
      }
      if (validType.endsWith("/*")) {
        return baseMimeType === validType.replace(/\/.*$/, "");
      }
      return mimeType === validType;
    });
  }
  return true;
}
function isValidFileType2(file, accept) {
  const isAcceptable = file.type === "application/x-moz-file" || isFileAccepted(file, accept);
  return [isAcceptable, isAcceptable ? null : "FILE_INVALID_TYPE"];
}

// node_modules/@ark-ui/react/node_modules/@zag-js/file-upload/dist/index.mjs
var anatomy52 = createAnatomy2("file-upload").parts(
  "root",
  "dropzone",
  "item",
  "itemDeleteTrigger",
  "itemGroup",
  "itemName",
  "itemPreview",
  "itemPreviewImage",
  "itemSizeText",
  "label",
  "trigger",
  "clearTrigger"
);
var parts47 = anatomy52.build();
var dom45 = createScope({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `file:${ctx.id}`;
  },
  getDropzoneId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.dropzone) ?? `file:${ctx.id}:dropzone`;
  },
  getHiddenInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.hiddenInput) ?? `file:${ctx.id}:input`;
  },
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `file:${ctx.id}:trigger`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `file:${ctx.id}:label`;
  },
  getItemId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.item) == null ? void 0 : _b6.call(_a7, id)) ?? `file:${ctx.id}:item:${id}`;
  },
  getItemNameId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemName) == null ? void 0 : _b6.call(_a7, id)) ?? `file:${ctx.id}:item-name:${id}`;
  },
  getItemSizeTextId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemSizeText) == null ? void 0 : _b6.call(_a7, id)) ?? `file:${ctx.id}:item-size:${id}`;
  },
  getItemPreviewId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemPreview) == null ? void 0 : _b6.call(_a7, id)) ?? `file:${ctx.id}:item-preview:${id}`;
  },
  getHiddenInputEl: (ctx) => dom45.getById(ctx, dom45.getHiddenInputId(ctx)),
  getDropzoneEl: (ctx) => dom45.getById(ctx, dom45.getDropzoneId(ctx))
});
function isEventWithFiles(event) {
  const target = getEventTarget(event);
  if (!event.dataTransfer) return !!target && "files" in target;
  return event.dataTransfer.types.some((type) => {
    return type === "Files" || type === "application/x-moz-file";
  });
}
function isFilesWithinRange(ctx, incomingCount) {
  if (!ctx.multiple && incomingCount > 1) return false;
  if (!ctx.multiple && incomingCount + ctx.acceptedFiles.length === 2) return true;
  if (incomingCount + ctx.acceptedFiles.length > ctx.maxFiles) return false;
  return true;
}
function getFilesFromEvent(ctx, files) {
  const acceptedFiles = [];
  const rejectedFiles = [];
  files.forEach((file) => {
    var _a7;
    const [accepted, acceptError] = isValidFileType2(file, ctx.acceptAttr);
    const [sizeMatch, sizeError] = isValidFileSize2(file, ctx.minFileSize, ctx.maxFileSize);
    const validateErrors = (_a7 = ctx.validate) == null ? void 0 : _a7.call(ctx, file);
    const valid = validateErrors ? validateErrors.length === 0 : true;
    if (accepted && sizeMatch && valid) {
      acceptedFiles.push(file);
    } else {
      const errors = [acceptError, sizeError];
      if (!valid) errors.push(...validateErrors ?? []);
      rejectedFiles.push({ file, errors: errors.filter(Boolean) });
    }
  });
  if (!isFilesWithinRange(ctx, acceptedFiles.length)) {
    acceptedFiles.forEach((file) => {
      rejectedFiles.push({ file, errors: ["TOO_MANY_FILES"] });
    });
    acceptedFiles.splice(0);
  }
  return {
    acceptedFiles,
    rejectedFiles
  };
}
function connect10(state2, send, normalize2) {
  const disabled = state2.context.disabled;
  const allowDrop = state2.context.allowDrop;
  const translations = state2.context.translations;
  const dragging = state2.matches("dragging");
  const focused = state2.matches("focused") && !disabled;
  return {
    dragging,
    focused,
    openFilePicker() {
      send("OPEN");
    },
    deleteFile(file) {
      send({ type: "FILE.DELETE", file });
    },
    acceptedFiles: state2.context.acceptedFiles,
    rejectedFiles: state2.context.rejectedFiles,
    setFiles(files) {
      const count = files.length;
      send({ type: "FILES.SET", files, count });
    },
    clearRejectedFiles() {
      send({ type: "REJECTED_FILES.CLEAR" });
    },
    clearFiles() {
      send({ type: "FILES.CLEAR" });
    },
    getFileSize(file) {
      return formatBytes(file.size, state2.context.locale);
    },
    createFileUrl(file, cb) {
      const win = dom45.getWin(state2.context);
      const url = win.URL.createObjectURL(file);
      cb(url);
      return () => win.URL.revokeObjectURL(url);
    },
    getRootProps() {
      return normalize2.element({
        ...parts47.root.attrs,
        dir: state2.context.dir,
        id: dom45.getRootId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-dragging": dataAttr(dragging)
      });
    },
    getDropzoneProps() {
      return normalize2.element({
        ...parts47.dropzone.attrs,
        dir: state2.context.dir,
        id: dom45.getDropzoneId(state2.context),
        tabIndex: disabled ? void 0 : 0,
        role: "button",
        "aria-label": translations.dropzone,
        "aria-disabled": disabled,
        "data-invalid": dataAttr(state2.context.invalid),
        "data-disabled": dataAttr(disabled),
        "data-dragging": dataAttr(dragging),
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          if (event.key !== "Enter" && event.key !== " ") return;
          send({ type: "DROPZONE.CLICK", src: "keydown" });
        },
        onClick(event) {
          const isLabel = event.currentTarget.localName === "label";
          if (isLabel) event.preventDefault();
          send("DROPZONE.CLICK");
        },
        onDragOver(event) {
          if (!allowDrop) return;
          event.preventDefault();
          event.stopPropagation();
          try {
            event.dataTransfer.dropEffect = "copy";
          } catch {
          }
          const hasFiles = isEventWithFiles(event);
          if (!hasFiles) return;
          const count = event.dataTransfer.items.length;
          send({ type: "DROPZONE.DRAG_OVER", count });
        },
        onDragLeave(event) {
          if (!allowDrop || disabled) return;
          if (contains(event.currentTarget, event.relatedTarget)) return;
          send({ type: "DROPZONE.DRAG_LEAVE" });
        },
        onDrop(event) {
          if (allowDrop) {
            event.preventDefault();
            event.stopPropagation();
          }
          const hasFiles = isEventWithFiles(event);
          if (disabled || !hasFiles) return;
          send({ type: "DROPZONE.DROP", files: Array.from(event.dataTransfer.files) });
        },
        onFocus() {
          send("DROPZONE.FOCUS");
        },
        onBlur() {
          send("DROPZONE.BLUR");
        }
      });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts47.trigger.attrs,
        dir: state2.context.dir,
        id: dom45.getTriggerId(state2.context),
        disabled,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(state2.context.invalid),
        type: "button",
        onClick(event) {
          if (disabled) return;
          if (contains(dom45.getDropzoneEl(state2.context), event.currentTarget)) {
            event.stopPropagation();
          }
          send("OPEN");
        }
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        id: dom45.getHiddenInputId(state2.context),
        tabIndex: -1,
        disabled,
        type: "file",
        required: state2.context.required,
        capture: state2.context.capture,
        name: state2.context.name,
        accept: state2.context.acceptAttr,
        webkitdirectory: state2.context.directory ? "" : void 0,
        multiple: state2.context.multiple || state2.context.maxFiles > 1,
        onClick(event) {
          event.stopPropagation();
          event.currentTarget.value = "";
        },
        onChange(event) {
          if (disabled) return;
          const { files } = event.currentTarget;
          send({ type: "FILES.SET", files: files ? Array.from(files) : [] });
        },
        style: visuallyHiddenStyle
      });
    },
    getItemGroupProps() {
      return normalize2.element({
        ...parts47.itemGroup.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemProps(props210) {
      const { file } = props210;
      return normalize2.element({
        ...parts47.item.attrs,
        dir: state2.context.dir,
        id: dom45.getItemId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemNameProps(props210) {
      const { file } = props210;
      return normalize2.element({
        ...parts47.itemName.attrs,
        dir: state2.context.dir,
        id: dom45.getItemNameId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemSizeTextProps(props210) {
      const { file } = props210;
      return normalize2.element({
        ...parts47.itemSizeText.attrs,
        dir: state2.context.dir,
        id: dom45.getItemSizeTextId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemPreviewProps(props210) {
      const { file } = props210;
      return normalize2.element({
        ...parts47.itemPreview.attrs,
        dir: state2.context.dir,
        id: dom45.getItemPreviewId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemPreviewImageProps(props210) {
      var _a7;
      const { file, url } = props210;
      const isImage = file.type.startsWith("image/");
      if (!isImage) {
        throw new Error("Preview Image is only supported for image files");
      }
      return normalize2.img({
        ...parts47.itemPreviewImage.attrs,
        alt: (_a7 = translations.itemPreview) == null ? void 0 : _a7.call(translations, file),
        src: url,
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemDeleteTriggerProps(props210) {
      var _a7;
      const { file } = props210;
      return normalize2.button({
        ...parts47.itemDeleteTrigger.attrs,
        dir: state2.context.dir,
        type: "button",
        disabled,
        "data-disabled": dataAttr(disabled),
        "aria-label": (_a7 = translations.deleteFile) == null ? void 0 : _a7.call(translations, file),
        onClick() {
          if (disabled) return;
          send({ type: "FILE.DELETE", file });
        }
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts47.label.attrs,
        dir: state2.context.dir,
        id: dom45.getLabelId(state2.context),
        htmlFor: dom45.getHiddenInputId(state2.context),
        "data-disabled": dataAttr(disabled)
      });
    },
    getClearTriggerProps() {
      return normalize2.button({
        ...parts47.clearTrigger.attrs,
        dir: state2.context.dir,
        type: "button",
        disabled,
        hidden: state2.context.acceptedFiles.length === 0,
        "data-disabled": dataAttr(disabled),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          send({ type: "FILES.CLEAR" });
        }
      });
    }
  };
}
function machine10(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "fileupload",
      initial: "idle",
      context: {
        minFileSize: 0,
        maxFileSize: Infinity,
        maxFiles: 1,
        allowDrop: true,
        ...ctx,
        acceptedFiles: ref35([]),
        rejectedFiles: ref35([]),
        translations: {
          dropzone: "dropzone",
          itemPreview: (file) => `preview of ${file.name}`,
          deleteFile: (file) => `delete file ${file.name}`,
          ...ctx.translations
        }
      },
      computed: {
        acceptAttr: (ctx2) => getAcceptAttrString2(ctx2.accept),
        multiple: (ctx2) => ctx2.maxFiles > 1
      },
      on: {
        "FILES.SET": {
          actions: ["setFilesFromEvent"]
        },
        "FILE.DELETE": {
          actions: ["removeFile"]
        },
        "FILES.CLEAR": {
          actions: ["clearFiles"]
        },
        "REJECTED_FILES.CLEAR": {
          actions: ["clearRejectedFiles"]
        }
      },
      states: {
        idle: {
          on: {
            OPEN: {
              actions: ["openFilePicker"]
            },
            "DROPZONE.CLICK": {
              actions: ["openFilePicker"]
            },
            "DROPZONE.FOCUS": "focused",
            "DROPZONE.DRAG_OVER": {
              target: "dragging"
            }
          }
        },
        focused: {
          on: {
            "DROPZONE.BLUR": "idle",
            OPEN: {
              actions: ["openFilePicker"]
            },
            "DROPZONE.CLICK": {
              actions: ["openFilePicker"]
            },
            "DROPZONE.DRAG_OVER": {
              target: "dragging"
            }
          }
        },
        dragging: {
          on: {
            "DROPZONE.DROP": {
              target: "idle",
              actions: ["setFilesFromEvent", "syncInputElement"]
            },
            "DROPZONE.DRAG_LEAVE": {
              target: "idle"
            }
          }
        }
      }
    },
    {
      actions: {
        syncInputElement(ctx2) {
          const inputEl = dom45.getHiddenInputEl(ctx2);
          if (!inputEl) return;
          const win = dom45.getWin(ctx2);
          const dataTransfer = new win.DataTransfer();
          ctx2.acceptedFiles.forEach((v) => {
            dataTransfer.items.add(v);
          });
          inputEl.files = dataTransfer.files;
        },
        openFilePicker(ctx2) {
          raf(() => {
            var _a7;
            (_a7 = dom45.getHiddenInputEl(ctx2)) == null ? void 0 : _a7.click();
          });
        },
        setFilesFromEvent(ctx2, evt) {
          const result = getFilesFromEvent(ctx2, evt.files);
          const { acceptedFiles, rejectedFiles } = result;
          if (ctx2.multiple) {
            const files = ref35([...ctx2.acceptedFiles, ...acceptedFiles]);
            set6.files(ctx2, files, rejectedFiles);
            return;
          }
          if (acceptedFiles.length) {
            const files = ref35([acceptedFiles[0]]);
            set6.files(ctx2, files, rejectedFiles);
          } else if (rejectedFiles.length) {
            set6.files(ctx2, ctx2.acceptedFiles, rejectedFiles);
          }
        },
        removeFile(ctx2, evt) {
          const nextFiles = ctx2.acceptedFiles.filter((file) => file !== evt.file);
          ctx2.acceptedFiles = ref35(nextFiles);
          invoke4.change(ctx2);
        },
        clearRejectedFiles(ctx2) {
          ctx2.rejectedFiles = ref35([]);
          invoke4.change(ctx2);
        },
        clearFiles(ctx2) {
          ctx2.acceptedFiles = ref35([]);
          ctx2.rejectedFiles = ref35([]);
          invoke4.change(ctx2);
        }
      },
      compareFns: {
        acceptedFiles: (a, b) => a.length === b.length && a.every((file, i) => isFileEqual2(file, b[i]))
      }
    }
  );
}
var invoke4 = {
  change: (ctx) => {
    var _a7;
    (_a7 = ctx.onFileChange) == null ? void 0 : _a7.call(ctx, {
      acceptedFiles: ctx.acceptedFiles,
      rejectedFiles: ctx.rejectedFiles
    });
  },
  accept: (ctx) => {
    var _a7;
    (_a7 = ctx.onFileAccept) == null ? void 0 : _a7.call(ctx, { files: ctx.acceptedFiles });
  },
  reject: (ctx) => {
    var _a7;
    (_a7 = ctx.onFileReject) == null ? void 0 : _a7.call(ctx, { files: ctx.rejectedFiles });
  }
};
var set6 = {
  files: (ctx, acceptedFiles, rejectedFiles) => {
    ctx.acceptedFiles = ref35(acceptedFiles);
    invoke4.accept(ctx);
    if (rejectedFiles) {
      ctx.rejectedFiles = ref35(rejectedFiles);
      invoke4.reject(ctx);
    }
    invoke4.change(ctx);
  }
};
var props39 = createProps30()([
  "accept",
  "allowDrop",
  "capture",
  "dir",
  "directory",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "locale",
  "maxFiles",
  "maxFileSize",
  "minFileSize",
  "name",
  "invalid",
  "onFileAccept",
  "onFileReject",
  "onFileChange",
  "required",
  "translations",
  "validate"
]);
var splitProps39 = createSplitProps2(props39);
var itemProps11 = createProps30()(["file"]);
var splitItemProps11 = createSplitProps2(itemProps11);

// node_modules/@ark-ui/react/dist/components/file-upload/use-file-upload.js
var import_react223 = __toESM(require_react(), 1);
var useFileUpload = (props52 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react223.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    required: field == null ? void 0 : field.required,
    invalid: field == null ? void 0 : field.invalid,
    getRootNode: getRootNode2,
    ...props52
  };
  const context = {
    ...initialContext,
    onFileAccept: useEvent(props52.onFileAccept),
    onFileReject: useEvent(props52.onFileReject),
    onFileChange: useEvent(props52.onFileChange, { sync: true })
  };
  const [state2, send] = useMachine(machine10(initialContext), { context });
  return connect10(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-root.js
var FileUploadRoot = (0, import_react225.forwardRef)((props52, ref36) => {
  const [useFileUploadProps, localProps] = createSplitProps3()(props52, [
    "accept",
    "allowDrop",
    "capture",
    "directory",
    "disabled",
    "id",
    "ids",
    "invalid",
    "locale",
    "maxFiles",
    "maxFileSize",
    "minFileSize",
    "name",
    "onFileAccept",
    "onFileChange",
    "onFileReject",
    "required",
    "translations",
    "validate"
  ]);
  const fileUpload = useFileUpload(useFileUploadProps);
  const mergedProps = mergeProps3(fileUpload.getRootProps(), localProps);
  return (0, import_jsx_runtime112.jsx)(FileUploadProvider, { value: fileUpload, children: (0, import_jsx_runtime112.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
});
FileUploadRoot.displayName = "FileUploadRoot";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-root-provider.js
var import_jsx_runtime113 = __toESM(require_jsx_runtime(), 1);
var import_react227 = __toESM(require_react(), 1);
var FileUploadRootProvider = (0, import_react227.forwardRef)(
  (props52, ref36) => {
    const [{ value: fileUpload }, localProps] = createSplitProps3()(props52, [
      "value"
    ]);
    const mergedProps = mergeProps3(fileUpload.getRootProps(), localProps);
    return (0, import_jsx_runtime113.jsx)(FileUploadProvider, { value: fileUpload, children: (0, import_jsx_runtime113.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
  }
);
FileUploadRootProvider.displayName = "FileUploadRootProvider";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-trigger.js
var import_jsx_runtime114 = __toESM(require_jsx_runtime(), 1);
var import_react229 = __toESM(require_react(), 1);
var FileUploadTrigger = (0, import_react229.forwardRef)(
  (props52, ref36) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps3(fileUpload.getTriggerProps(), props52);
    return (0, import_jsx_runtime114.jsx)(ark.button, { ...mergedProps, ref: ref36 });
  }
);
FileUploadTrigger.displayName = "FileUploadTrigger";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload.js
var file_upload_exports = {};
__export(file_upload_exports, {
  ClearTrigger: () => FileUploadClearTrigger,
  Context: () => FileUploadContext,
  Dropzone: () => FileUploadDropzone,
  HiddenInput: () => FileUploadHiddenInput,
  Item: () => FileUploadItem,
  ItemDeleteTrigger: () => FileUploadItemDeleteTrigger,
  ItemGroup: () => FileUploadItemGroup,
  ItemName: () => FileUploadItemName,
  ItemPreview: () => FileUploadItemPreview,
  ItemPreviewImage: () => FileUploadItemPreviewImage,
  ItemSizeText: () => FileUploadItemSizeText,
  Label: () => FileUploadLabel,
  Root: () => FileUploadRoot,
  RootProvider: () => FileUploadRootProvider,
  Trigger: () => FileUploadTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/file-upload/file-upload.js
var import_react230 = __toESM(require_react(), 1);
var {
  withProvider: withProvider16,
  withContext: withContext24,
  useStyles: useFileUploadStyles,
  PropsProvider: PropsProvider22
} = createSlotRecipeContext({ key: "fileUpload" });
var FileUploadRootProvider2 = withProvider16(file_upload_exports.RootProvider, "root", { forwardAsChild: true });
var FileUploadRoot2 = withProvider16(
  file_upload_exports.Root,
  "root",
  { forwardAsChild: true }
);
var FileUploadPropsProvider = PropsProvider22;
var FileUploadClearTrigger2 = (0, import_react230.forwardRef)(function FileUploadClearTrigger22(props52, ref36) {
  const fileUpload = useFileUploadContext();
  return (0, import_jsx_runtime115.jsx)(
    chakra.button,
    {
      ref: ref36,
      type: "button",
      "data-scope": "file-upload",
      "data-part": "clear-trigger",
      "aria-label": "Clear selected files",
      hidden: fileUpload.acceptedFiles.length === 0,
      ...props52,
      onClick: (event) => {
        var _a7;
        (_a7 = props52.onClick) == null ? void 0 : _a7.call(props52, event);
        if (event.defaultPrevented) return;
        fileUpload.clearFiles();
      }
    }
  );
});
var FileUploadDropzone2 = withContext24(file_upload_exports.Dropzone, "dropzone", { forwardAsChild: true });
var FileUploadDropzoneContent = withContext24("div", "dropzoneContent");
var FileUploadItem2 = withContext24(
  file_upload_exports.Item,
  "item",
  { forwardAsChild: true }
);
var FileUploadItemContent = withContext24("div", "itemContent");
var FileUploadItemDeleteTrigger2 = withContext24(file_upload_exports.ItemDeleteTrigger, "itemDeleteTrigger", {
  forwardAsChild: true
});
var FileUploadItemGroup2 = withContext24(file_upload_exports.ItemGroup, "itemGroup", { forwardAsChild: true });
var FileUploadItemName2 = withContext24(file_upload_exports.ItemName, "itemName", { forwardAsChild: true });
var FileUploadItemPreview2 = withContext24(file_upload_exports.ItemPreview, "itemPreview", { forwardAsChild: true });
var FileUploadItemPreviewImage2 = withContext24(file_upload_exports.ItemPreviewImage, "itemPreviewImage", { forwardAsChild: true });
var FileUploadItemSizeText2 = withContext24(file_upload_exports.ItemSizeText, "itemSizeText", { forwardAsChild: true });
var FileUploadLabel2 = withContext24(file_upload_exports.Label, "label", { forwardAsChild: true });
var FileUploadTrigger2 = withContext24(file_upload_exports.Trigger, "trigger", { forwardAsChild: true });
var FileUploadContext2 = file_upload_exports.Context;
var FileUploadHiddenInput2 = file_upload_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/file-upload/namespace.js
var namespace_exports19 = {};
__export(namespace_exports19, {
  ClearTrigger: () => FileUploadClearTrigger2,
  Context: () => FileUploadContext2,
  Dropzone: () => FileUploadDropzone2,
  DropzoneContent: () => FileUploadDropzoneContent,
  HiddenInput: () => FileUploadHiddenInput2,
  Item: () => FileUploadItem2,
  ItemContent: () => FileUploadItemContent,
  ItemDeleteTrigger: () => FileUploadItemDeleteTrigger2,
  ItemGroup: () => FileUploadItemGroup2,
  ItemName: () => FileUploadItemName2,
  ItemPreview: () => FileUploadItemPreview2,
  ItemPreviewImage: () => FileUploadItemPreviewImage2,
  ItemSizeText: () => FileUploadItemSizeText2,
  Label: () => FileUploadLabel2,
  PropsProvider: () => FileUploadPropsProvider,
  Root: () => FileUploadRoot2,
  RootProvider: () => FileUploadRootProvider2,
  Trigger: () => FileUploadTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/flex/flex.js
var import_jsx_runtime116 = __toESM(require_jsx_runtime(), 1);
var import_react231 = __toESM(require_react(), 1);
var Flex = (0, import_react231.forwardRef)(
  function Flex2(props52, ref36) {
    const {
      direction,
      align,
      justify,
      wrap: wrap50,
      basis,
      grow,
      shrink,
      inline: inline2,
      ...rest
    } = props52;
    return (0, import_jsx_runtime116.jsx)(
      chakra.div,
      {
        ref: ref36,
        ...rest,
        css: {
          display: inline2 ? "inline-flex" : "flex",
          flexDirection: direction,
          alignItems: align,
          justifyContent: justify,
          flexWrap: wrap50,
          flexBasis: basis,
          flexGrow: grow,
          flexShrink: shrink,
          ...props52.css
        }
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/float/float.js
var import_jsx_runtime117 = __toESM(require_jsx_runtime(), 1);
var import_react232 = __toESM(require_react(), 1);
var Float = (0, import_react232.forwardRef)(
  function Float2(props52, ref36) {
    const {
      offsetX,
      offsetY,
      offset: offset4 = "0",
      placement = "top-end",
      ...rest
    } = props52;
    const styles = (0, import_react232.useMemo)(
      () => ({
        display: "inline-flex",
        justifyContent: "center",
        alignItems: "center",
        position: "absolute",
        insetBlockStart: mapObject(placement, (v) => {
          const [side] = v.split("-");
          const map = {
            top: offsetY ?? offset4,
            middle: "50%",
            bottom: "auto"
          };
          return map[side];
        }),
        insetBlockEnd: mapObject(placement, (v) => {
          const [side] = v.split("-");
          const map = {
            top: "auto",
            middle: "50%",
            bottom: offsetY ?? offset4
          };
          return map[side];
        }),
        insetStart: mapObject(placement, (v) => {
          const [, align] = v.split("-");
          const map = {
            start: offsetX ?? offset4,
            center: "50%",
            end: "auto"
          };
          return map[align];
        }),
        insetEnd: mapObject(placement, (v) => {
          const [, align] = v.split("-");
          const map = {
            start: "auto",
            center: "50%",
            end: offsetX ?? offset4
          };
          return map[align];
        }),
        translate: mapObject(placement, (v) => {
          const [side, align] = v.split("-");
          const mapX = { start: "-50%", center: "-50%", end: "50%" };
          const mapY = { top: "-50%", middle: "-50%", bottom: "50%" };
          return `${mapX[align]} ${mapY[side]}`;
        })
      }),
      [offset4, offsetX, offsetY, placement]
    );
    return (0, import_jsx_runtime117.jsx)(chakra.div, { ref: ref36, css: styles, ...rest });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/for/for.js
function For(props52) {
  const { each: each2, fallback: fallback5, children } = props52;
  if ((each2 == null ? void 0 : each2.length) === 0) {
    return fallback5 || null;
  }
  return each2 == null ? void 0 : each2.map(children);
}

// node_modules/@chakra-ui/react/dist/esm/components/grid/grid.js
var import_jsx_runtime118 = __toESM(require_jsx_runtime(), 1);
var import_react233 = __toESM(require_react(), 1);
var Grid = (0, import_react233.forwardRef)(
  function Grid2(props52, ref36) {
    const {
      templateAreas,
      column: column2,
      row,
      autoFlow,
      autoRows,
      templateRows,
      autoColumns,
      templateColumns,
      inline: inline2,
      ...rest
    } = props52;
    return (0, import_jsx_runtime118.jsx)(
      chakra.div,
      {
        ...rest,
        ref: ref36,
        css: [
          {
            display: inline2 ? "inline-grid" : "grid",
            gridTemplateAreas: templateAreas,
            gridAutoColumns: autoColumns,
            gridColumn: column2,
            gridRow: row,
            gridAutoFlow: autoFlow,
            gridAutoRows: autoRows,
            gridTemplateRows: templateRows,
            gridTemplateColumns: templateColumns
          },
          props52.css
        ]
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/grid/grid-item.js
var import_jsx_runtime119 = __toESM(require_jsx_runtime(), 1);
var import_react234 = __toESM(require_react(), 1);
function spanFn(span) {
  return mapObject(
    span,
    (value) => value === "auto" ? "auto" : `span ${value}/span ${value}`
  );
}
var GridItem = (0, import_react234.forwardRef)(
  function GridItem2(props52, ref36) {
    const {
      area,
      colSpan,
      colStart,
      colEnd,
      rowEnd,
      rowSpan,
      rowStart,
      ...rest
    } = props52;
    const styles = compact({
      gridArea: area,
      gridColumn: spanFn(colSpan),
      gridRow: spanFn(rowSpan),
      gridColumnStart: colStart,
      gridColumnEnd: colEnd,
      gridRowStart: rowStart,
      gridRowEnd: rowEnd
    });
    return (0, import_jsx_runtime119.jsx)(chakra.div, { ref: ref36, css: styles, ...rest });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/grid/simple-grid.js
var import_jsx_runtime120 = __toESM(require_jsx_runtime(), 1);
var import_react235 = __toESM(require_react(), 1);
var SimpleGrid = (0, import_react235.forwardRef)(
  function SimpleGrid2(props52, ref36) {
    const { columns, minChildWidth, ...rest } = props52;
    const sys = useChakraContext();
    const templateColumns = minChildWidth ? widthToColumns(minChildWidth, sys) : countToColumns(columns);
    return (0, import_jsx_runtime120.jsx)(Grid, { ref: ref36, templateColumns, ...rest });
  }
);
function toPx2(n) {
  return typeof n === "number" ? `${n}px` : n;
}
function widthToColumns(width, sys) {
  return mapObject(width, (value) => {
    const _value = sys.tokens.getVar(`sizes.${value}`, toPx2(value));
    return value === null ? null : `repeat(auto-fit, minmax(${_value}, 1fr))`;
  });
}
function countToColumns(count) {
  return mapObject(
    count,
    (value) => value === null ? null : `repeat(${value}, minmax(0, 1fr))`
  );
}

// node_modules/@chakra-ui/react/dist/esm/components/group/group.js
var import_jsx_runtime121 = __toESM(require_jsx_runtime(), 1);
var import_react236 = __toESM(require_react(), 1);
var StyledGroup = chakra("div", {
  base: {
    display: "inline-flex",
    gap: "0.5rem",
    isolation: "isolate",
    position: "relative",
    "& [data-group-item]": {
      _focusVisible: {
        zIndex: 1
      }
    }
  },
  variants: {
    orientation: {
      horizontal: {
        flexDirection: "row"
      },
      vertical: {
        flexDirection: "column"
      }
    },
    attached: {
      true: {
        gap: "0!"
      }
    },
    grow: {
      true: {
        display: "flex",
        "& > *": {
          flex: 1
        }
      }
    },
    stacking: {
      "first-on-top": {
        "& > [data-group-item]": {
          zIndex: "calc(var(--group-count) - var(--group-index))"
        }
      },
      "last-on-top": {
        "& > [data-group-item]": {
          zIndex: "var(--group-index)"
        }
      }
    }
  },
  compoundVariants: [
    {
      orientation: "horizontal",
      attached: true,
      css: {
        "& > *[data-first]": {
          borderEndRadius: "0!",
          marginEnd: "-1px"
        },
        "& > *[data-between]": {
          borderRadius: "0!",
          marginEnd: "-1px"
        },
        "& > *[data-last]": {
          borderStartRadius: "0!"
        }
      }
    },
    {
      orientation: "vertical",
      attached: true,
      css: {
        "& > *[data-first]": {
          borderBottomRadius: "0!",
          marginBottom: "-1px"
        },
        "& > *[data-between]": {
          borderRadius: "0!",
          marginBottom: "-1px"
        },
        "& > *[data-last]": {
          borderTopRadius: "0!"
        }
      }
    }
  ],
  defaultVariants: {
    orientation: "horizontal"
  }
});
var Group = (0, import_react236.memo)(
  (0, import_react236.forwardRef)(function Group2(props52, ref36) {
    const {
      align = "center",
      justify = "flex-start",
      children,
      wrap: wrap50,
      ...rest
    } = props52;
    const count = import_react236.Children.count(children);
    const _children = (0, import_react236.useMemo)(() => {
      const childArray = import_react236.Children.toArray(children).filter(
        import_react236.isValidElement
      );
      return childArray.map((child, index) => {
        const childProps = child.props;
        return (0, import_react236.cloneElement)(child, {
          ...childProps,
          "data-group-item": "",
          "data-first": dataAttr31(index === 0),
          "data-last": dataAttr31(index === count - 1),
          "data-between": dataAttr31(index > 0 && index < count - 1),
          style: {
            "--group-count": count,
            "--group-index": index,
            ...(childProps == null ? void 0 : childProps.style) ?? {}
          }
        });
      });
    }, [children, count]);
    return (0, import_jsx_runtime121.jsx)(
      StyledGroup,
      {
        ref: ref36,
        alignItems: align,
        justifyContent: justify,
        flexWrap: wrap50,
        ...rest,
        children: _children
      }
    );
  })
);

// node_modules/@chakra-ui/react/dist/esm/components/highlight/highlight.js
var import_jsx_runtime123 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/highlight/highlight.js
var import_jsx_runtime122 = __toESM(require_jsx_runtime(), 1);
var import_react238 = __toESM(require_react(), 1);

// node_modules/@zag-js/highlight-word/dist/index.mjs
var normalizeSpan = (spans, len) => {
  const result = [];
  const append2 = (start, end, match50) => {
    if (end - start > 0) result.push({ start, end, match: match50 });
  };
  if (spans.length === 0) {
    append2(0, len, false);
  } else {
    let lastIndex = 0;
    for (const chunk4 of spans) {
      append2(lastIndex, chunk4.start, false);
      append2(chunk4.start, chunk4.end, true);
      lastIndex = chunk4.end;
    }
    append2(lastIndex, len, false);
  }
  return result;
};
function highlightFirst(props52) {
  const { text, query: query9, ignoreCase } = props52;
  const searchText = ignoreCase ? text.toLowerCase() : text;
  const searchQuery = ignoreCase ? typeof query9 === "string" ? query9.toLowerCase() : query9 : query9;
  const start = typeof searchText === "string" ? searchText.indexOf(searchQuery) : -1;
  if (start === -1) {
    return [{ text, match: false }];
  }
  const end = start + searchQuery.length;
  const spans = [{ start, end }];
  return normalizeSpan(spans, text.length).map((chunk4) => ({
    text: text.slice(chunk4.start, chunk4.end),
    match: !!chunk4.match
  }));
}
var escapeRegexp = (term) => term.replace(/[|\\{}()[\]^$+*?.-]/g, (char2) => `\\${char2}`);
var buildRegex = (queryProp, flags) => {
  const query9 = queryProp.filter(Boolean).map((text) => escapeRegexp(text));
  return new RegExp(`(${query9.join("|")})`, flags);
};
var getRegexFlags = (ignoreCase, matchAll = true) => `${ignoreCase ? "i" : ""}${matchAll ? "g" : ""}`;
function highlightMultiple(props52) {
  const { text, query: query9, ignoreCase, matchAll } = props52;
  if (query9.length === 0) {
    return [{ text, match: false }];
  }
  const flags = getRegexFlags(ignoreCase, matchAll);
  const regex = buildRegex(Array.isArray(query9) ? query9 : [query9], flags);
  const spans = [...text.matchAll(regex)].map((match50) => ({
    start: match50.index || 0,
    end: (match50.index || 0) + match50[0].length
  }));
  return normalizeSpan(spans, props52.text.length).map((chunk4) => ({
    text: props52.text.slice(chunk4.start, chunk4.end),
    match: !!chunk4.match
  }));
}
var highlightWord = (props52) => {
  if (props52.matchAll == null) {
    props52.matchAll = Array.isArray(props52.query);
  }
  if (!props52.matchAll && Array.isArray(props52.query)) {
    throw new Error("matchAll must be true when using multiple queries");
  }
  return props52.matchAll ? highlightMultiple(props52) : highlightFirst(props52);
};

// node_modules/@ark-ui/react/dist/components/highlight/use-highlight.js
var import_react237 = __toESM(require_react(), 1);
var useHighlight = (props52) => {
  return (0, import_react237.useMemo)(() => highlightWord(props52), [props52]);
};

// node_modules/@chakra-ui/react/dist/esm/components/highlight/highlight.js
var import_react239 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/typography/mark.js
var { withContext: withContext25, PropsProvider: PropsProvider23 } = createRecipeContext({
  key: "mark"
});
var Mark = withContext25("mark");
var MarkPropsProvider = PropsProvider23;

// node_modules/@chakra-ui/react/dist/esm/components/highlight/highlight.js
function Highlight2(props52) {
  const { children, query: query9, ignoreCase, matchAll, styles } = props52;
  if (typeof children !== "string") {
    throw new Error("The children prop of Highlight must be a string");
  }
  const chunks = useHighlight({
    query: query9,
    text: children,
    matchAll,
    ignoreCase
  });
  return (0, import_jsx_runtime123.jsx)(For, { each: chunks, children: (chunk4, index) => {
    return chunk4.match ? (0, import_jsx_runtime123.jsx)(Mark, { css: styles, children: chunk4.text }, index) : (0, import_jsx_runtime123.jsx)(import_react239.Fragment, { children: chunk4.text }, index);
  } });
}

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-arrow.js
var import_jsx_runtime124 = __toESM(require_jsx_runtime(), 1);
var import_react241 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/hover-card/use-hover-card-context.js
var [HoverCardProvider, useHoverCardContext] = createContext({
  name: "HoverCardContext",
  hookName: "useHoverCardContext",
  providerName: "<HoverCardProvider />"
});

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-arrow.js
var HoverCardArrow = (0, import_react241.forwardRef)((props52, ref36) => {
  const hoverCard = useHoverCardContext();
  const mergedProps = mergeProps3(hoverCard.getArrowProps(), props52);
  return (0, import_jsx_runtime124.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
HoverCardArrow.displayName = "HoverCardArrow";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-arrow-tip.js
var import_jsx_runtime125 = __toESM(require_jsx_runtime(), 1);
var import_react243 = __toESM(require_react(), 1);
var HoverCardArrowTip = (0, import_react243.forwardRef)(
  (props52, ref36) => {
    const hoverCard = useHoverCardContext();
    const mergedProps = mergeProps3(hoverCard.getArrowTipProps(), props52);
    return (0, import_jsx_runtime125.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
HoverCardArrowTip.displayName = "HoverCardArrowTip";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-content.js
var import_jsx_runtime126 = __toESM(require_jsx_runtime(), 1);
var import_react245 = __toESM(require_react(), 1);
var HoverCardContent = (0, import_react245.forwardRef)((props52, ref36) => {
  const hoverCard = useHoverCardContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps3(hoverCard.getContentProps(), presence.getPresenceProps(), props52);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime126.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref36) });
});
HoverCardContent.displayName = "HoverCardContent";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-context.js
var HoverCardContext = (props52) => props52.children(useHoverCardContext());

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-positioner.js
var import_jsx_runtime127 = __toESM(require_jsx_runtime(), 1);
var import_react247 = __toESM(require_react(), 1);
var HoverCardPositioner = (0, import_react247.forwardRef)(
  (props52, ref36) => {
    const hoverCard = useHoverCardContext();
    const mergedProps = mergeProps3(hoverCard.getPositionerProps(), props52);
    const presence = usePresenceContext();
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime127.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
HoverCardPositioner.displayName = "HoverCardPositioner";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-root.js
var import_jsx_runtime128 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/node_modules/@zag-js/hover-card/dist/index.mjs
var anatomy53 = createAnatomy2("hoverCard").parts("arrow", "arrowTip", "trigger", "positioner", "content");
var parts48 = anatomy53.build();
var dom46 = createScope({
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `hover-card:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `hover-card:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.positioner) ?? `hover-card:${ctx.id}:popper`;
  },
  getArrowId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.arrow) ?? `hover-card:${ctx.id}:arrow`;
  },
  getTriggerEl: (ctx) => dom46.getById(ctx, dom46.getTriggerId(ctx)),
  getContentEl: (ctx) => dom46.getById(ctx, dom46.getContentId(ctx)),
  getPositionerEl: (ctx) => dom46.getById(ctx, dom46.getPositionerId(ctx))
});
function connect11(state2, send, normalize2) {
  const open = state2.hasTag("open");
  const popperStyles = getPlacementStyles2({
    ...state2.context.positioning,
    placement: state2.context.currentPlacement
  });
  return {
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getArrowProps() {
      return normalize2.element({
        id: dom46.getArrowId(state2.context),
        ...parts48.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts48.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getTriggerProps() {
      return normalize2.element({
        ...parts48.trigger.attrs,
        dir: state2.context.dir,
        "data-placement": state2.context.currentPlacement,
        id: dom46.getTriggerId(state2.context),
        "data-state": open ? "open" : "closed",
        onPointerEnter(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_ENTER", src: "trigger" });
        },
        onPointerLeave(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_LEAVE", src: "trigger" });
        },
        onFocus() {
          send("TRIGGER_FOCUS");
        },
        onBlur() {
          send("TRIGGER_BLUR");
        },
        onTouchStart(event) {
          event.preventDefault();
        }
      });
    },
    getPositionerProps() {
      return normalize2.element({
        id: dom46.getPositionerId(state2.context),
        ...parts48.positioner.attrs,
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts48.content.attrs,
        dir: state2.context.dir,
        id: dom46.getContentId(state2.context),
        hidden: !open,
        "data-state": open ? "open" : "closed",
        "data-placement": state2.context.currentPlacement,
        onPointerEnter(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_ENTER", src: "content" });
        },
        onPointerLeave(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_LEAVE", src: "content" });
        }
      });
    }
  };
}
var { not: not38, and: and38 } = guards20;
function machine11(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "hover-card",
      initial: ctx.open ? "open" : "closed",
      context: {
        openDelay: 700,
        closeDelay: 300,
        currentPlacement: void 0,
        ...ctx,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        }
      },
      watch: {
        open: ["toggleVisibility"]
      },
      states: {
        closed: {
          tags: ["closed"],
          entry: ["clearIsPointer"],
          on: {
            "CONTROLLED.OPEN": "open",
            POINTER_ENTER: {
              target: "opening",
              actions: ["setIsPointer"]
            },
            TRIGGER_FOCUS: "opening",
            OPEN: "opening"
          }
        },
        opening: {
          tags: ["closed"],
          after: {
            OPEN_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            POINTER_LEAVE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            TRIGGER_BLUR: [
              {
                guard: and38("isOpenControlled", not38("isPointer")),
                actions: ["invokeOnClose"]
              },
              {
                guard: not38("isPointer"),
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackDismissableElement", "trackPositioning"],
          on: {
            "CONTROLLED.CLOSE": "closed",
            POINTER_ENTER: {
              actions: ["setIsPointer"]
            },
            POINTER_LEAVE: "closing",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            TRIGGER_BLUR: [
              {
                guard: and38("isOpenControlled", not38("isPointer")),
                actions: ["invokeOnClose"]
              },
              {
                guard: not38("isPointer"),
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackPositioning"],
          after: {
            CLOSE_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          },
          on: {
            "CONTROLLED.CLOSE": "closed",
            POINTER_ENTER: {
              target: "open",
              // no need to invokeOnOpen here because it's still open (but about to close)
              actions: ["setIsPointer"]
            }
          }
        }
      }
    },
    {
      guards: {
        isPointer: (ctx2) => !!ctx2.isPointer,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const getPositionerEl = () => dom46.getPositionerEl(ctx2);
          return getPlacement2(dom46.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom46.getContentEl(ctx2);
          return trackDismissableElement2(getContentEl, {
            defer: true,
            exclude: [dom46.getTriggerEl(ctx2)],
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside" });
            },
            onFocusOutside(event) {
              event.preventDefault();
            }
          });
        }
      },
      actions: {
        invokeOnClose(ctx2) {
          var _a7;
          (_a7 = ctx2.onOpenChange) == null ? void 0 : _a7.call(ctx2, { open: false });
        },
        invokeOnOpen(ctx2) {
          var _a7;
          (_a7 = ctx2.onOpenChange) == null ? void 0 : _a7.call(ctx2, { open: true });
        },
        setIsPointer(ctx2) {
          ctx2.isPointer = true;
        },
        clearIsPointer(ctx2) {
          ctx2.isPointer = false;
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom46.getPositionerEl(ctx2);
          getPlacement2(dom46.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      },
      delays: {
        OPEN_DELAY: (ctx2) => ctx2.openDelay,
        CLOSE_DELAY: (ctx2) => ctx2.closeDelay
      }
    }
  );
}
var props40 = createProps30()([
  "closeDelay",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onOpenChange",
  "open.controlled",
  "open",
  "openDelay",
  "positioning"
]);
var splitProps40 = createSplitProps2(props40);

// node_modules/@ark-ui/react/dist/components/hover-card/use-hover-card.js
var import_react249 = __toESM(require_react(), 1);
var useHoverCard = (props52 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react249.useId)(),
    dir,
    getRootNode: getRootNode2,
    open: props52.defaultOpen,
    "open.controlled": props52.open !== void 0,
    ...props52
  };
  const context = {
    ...initialContext,
    open: props52.open,
    onOpenChange: useEvent(props52.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine11(initialContext), { context });
  return connect11(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-root.js
var HoverCardRoot = (props52) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props52);
  const hoverCard = useHoverCard(localProps);
  const presence = usePresence(mergeProps3({ present: hoverCard.open }, presenceProps));
  return (0, import_jsx_runtime128.jsx)(HoverCardProvider, { value: hoverCard, children: (0, import_jsx_runtime128.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-root-provider.js
var import_jsx_runtime129 = __toESM(require_jsx_runtime(), 1);
var HoverCardRootProvider = (props52) => {
  const [presenceProps, { value: hoverCard, children }] = splitPresenceProps(props52);
  const presence = usePresence(mergeProps3({ present: hoverCard.open }, presenceProps));
  return (0, import_jsx_runtime129.jsx)(HoverCardProvider, { value: hoverCard, children: (0, import_jsx_runtime129.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-trigger.js
var import_jsx_runtime130 = __toESM(require_jsx_runtime(), 1);
var import_react253 = __toESM(require_react(), 1);
var HoverCardTrigger = (0, import_react253.forwardRef)(
  (props52, ref36) => {
    const hoverCard = useHoverCardContext();
    const mergedProps = mergeProps3(hoverCard.getTriggerProps(), props52);
    return (0, import_jsx_runtime130.jsx)(ark.button, { ...mergedProps, ref: ref36 });
  }
);
HoverCardTrigger.displayName = "HoverCardTrigger";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card.js
var hover_card_exports = {};
__export(hover_card_exports, {
  Arrow: () => HoverCardArrow,
  ArrowTip: () => HoverCardArrowTip,
  Content: () => HoverCardContent,
  Context: () => HoverCardContext,
  Positioner: () => HoverCardPositioner,
  Root: () => HoverCardRoot,
  RootProvider: () => HoverCardRootProvider,
  Trigger: () => HoverCardTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/hover-card/hover-card.js
var {
  withRootProvider: withRootProvider4,
  withContext: withContext26,
  useStyles: useHoverCardStyles,
  PropsProvider: PropsProvider24
} = createSlotRecipeContext({ key: "hoverCard" });
var HoverCardRootProvider2 = withRootProvider4(hover_card_exports.Root);
var HoverCardRoot2 = withRootProvider4(
  hover_card_exports.Root
);
var HoverCardPropsProvider = PropsProvider24;
var HoverCardTrigger2 = withContext26(hover_card_exports.Trigger, "trigger", { forwardAsChild: true });
var HoverCardPositioner2 = withContext26(hover_card_exports.Positioner, "positioner", { forwardAsChild: true });
var HoverCardContent2 = withContext26(hover_card_exports.Content, "content", { forwardAsChild: true });
var HoverCardArrow2 = withContext26(
  hover_card_exports.Arrow,
  "arrow",
  { forwardAsChild: true }
);
var HoverCardArrowTip2 = withContext26(hover_card_exports.ArrowTip, "arrowTip", { forwardAsChild: true });
var HoverCardContext2 = hover_card_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/hover-card/namespace.js
var namespace_exports20 = {};
__export(namespace_exports20, {
  Arrow: () => HoverCardArrow2,
  ArrowTip: () => HoverCardArrowTip2,
  Content: () => HoverCardContent2,
  Context: () => HoverCardContext2,
  Positioner: () => HoverCardPositioner2,
  PropsProvider: () => HoverCardPropsProvider,
  Root: () => HoverCardRoot2,
  RootProvider: () => HoverCardRootProvider2,
  Trigger: () => HoverCardTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/image/image.js
var import_jsx_runtime131 = __toESM(require_jsx_runtime(), 1);
var import_react254 = __toESM(require_react(), 1);
var Image = (0, import_react254.forwardRef)(
  function Image2(props52, ref36) {
    const { align, fit = "cover", ...rest } = props52;
    return (0, import_jsx_runtime131.jsx)(
      chakra.img,
      {
        ref: ref36,
        objectFit: fit,
        objectPosition: align,
        className: cx("chakra-image", props52.className),
        ...rest
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/input/input.js
var { withContext: withContext27, PropsProvider: PropsProvider25 } = createRecipeContext({
  key: "input"
});
var Input = withContext27(field_exports.Input);
var InputPropsProvider = PropsProvider25;

// node_modules/@chakra-ui/react/dist/esm/components/input/input-addon.js
var import_jsx_runtime132 = __toESM(require_jsx_runtime(), 1);
var import_react255 = __toESM(require_react(), 1);
var InputAddon = (0, import_react255.forwardRef)(
  function InputAddon2({ unstyled, ...props52 }, ref36) {
    const recipe = useRecipe({ key: "inputAddon", recipe: props52.recipe });
    const [variantProps, localProps] = recipe.splitVariantProps(props52);
    const styles = unstyled ? EMPTY_SLOT_STYLES : recipe(variantProps);
    return (0, import_jsx_runtime132.jsx)(chakra.div, { ref: ref36, ...localProps, css: [styles, props52.css] });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/input/input-element.js
var InputElement = chakra("div", {
  base: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    zIndex: 2,
    color: "fg.subtle",
    height: "full",
    fontSize: "sm",
    px: "3"
  },
  variants: {
    placement: {
      start: {
        insetInlineStart: "0"
      },
      end: {
        insetInlineEnd: "0"
      }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/kbd/kbd.js
var { withContext: withContext28, PropsProvider: PropsProvider26 } = createRecipeContext({
  key: "kbd"
});
var Kbd = withContext28("kbd");

// node_modules/@chakra-ui/react/dist/esm/components/link/link.js
var { withContext: withContext29, PropsProvider: PropsProvider27 } = createRecipeContext({
  key: "link"
});
var Link = withContext29("a");
var LinkPropsProvider = PropsProvider27;

// node_modules/@chakra-ui/react/dist/esm/components/link/link-box.js
var import_jsx_runtime133 = __toESM(require_jsx_runtime(), 1);
var import_react256 = __toESM(require_react(), 1);
var LinkOverlay = (0, import_react256.forwardRef)(
  function LinkOverlay2(props52, ref36) {
    const { rel, className, ...rest } = props52;
    return (0, import_jsx_runtime133.jsx)(
      chakra.a,
      {
        ...rest,
        ref: ref36,
        className: cx("chakra-linkbox__overlay", className),
        css: [
          {
            position: "static",
            "&::before": {
              content: "''",
              cursor: "inherit",
              display: "block",
              position: "absolute",
              top: 0,
              left: 0,
              zIndex: 0,
              width: "100%",
              height: "100%"
            }
          },
          props52.css
        ]
      }
    );
  }
);
var LinkBox = (0, import_react256.forwardRef)(
  function LinkBox2(props52, ref36) {
    const { className, ...rest } = props52;
    return (0, import_jsx_runtime133.jsx)(
      chakra.div,
      {
        ref: ref36,
        position: "relative",
        ...rest,
        className: cx("chakra-linkbox", className),
        css: [
          {
            /* Elevate the links and abbreviations up */
            "& a[href]:not(.chakra-linkbox__overlay), abbr[title]": {
              position: "relative",
              zIndex: 1
            }
          },
          props52.css
        ]
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/list/list.js
var {
  withProvider: withProvider17,
  withContext: withContext30,
  useStyles: useListStyles,
  PropsProvider: PropsProvider28
} = createSlotRecipeContext({ key: "list" });
var ListRoot = withProvider17(
  "ul",
  "root",
  { defaultProps: { role: "list" } }
);
var ListRootPropsProvider = PropsProvider28;
var ListItem = withContext30("li", "item");
var ListIndicator = withContext30(
  "span",
  "indicator"
);

// node_modules/@chakra-ui/react/dist/esm/components/list/namespace.js
var namespace_exports21 = {};
__export(namespace_exports21, {
  Indicator: () => ListIndicator,
  Item: () => ListItem,
  Root: () => ListRoot,
  RootPropsProvider: () => ListRootPropsProvider
});

// node_modules/@ark-ui/react/dist/providers/locale/locale-provider.js
var import_jsx_runtime134 = __toESM(require_jsx_runtime(), 1);
var LocaleProvider = (props52) => {
  const { children, locale } = props52;
  const context = {
    locale,
    dir: isRTL(locale) ? "rtl" : "ltr"
  };
  return (0, import_jsx_runtime134.jsx)(LocaleContextProvider, { value: context, children });
};

// node_modules/@ark-ui/react/dist/components/menu/menu-arrow.js
var import_jsx_runtime135 = __toESM(require_jsx_runtime(), 1);
var import_react258 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/menu/use-menu-context.js
var [MenuProvider, useMenuContext] = createContext({
  name: "MenuContext",
  hookName: "useMenuContext",
  providerName: "<MenuProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/menu/menu-arrow.js
var MenuArrow = (0, import_react258.forwardRef)((props52, ref36) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps3(menu.getArrowProps(), props52);
  return (0, import_jsx_runtime135.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
MenuArrow.displayName = "MenuArrow";

// node_modules/@ark-ui/react/dist/components/menu/menu-arrow-tip.js
var import_jsx_runtime136 = __toESM(require_jsx_runtime(), 1);
var import_react260 = __toESM(require_react(), 1);
var MenuArrowTip = (0, import_react260.forwardRef)((props52, ref36) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps3(menu.getArrowTipProps(), props52);
  return (0, import_jsx_runtime136.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
MenuArrowTip.displayName = "MenuArrowTip";

// node_modules/@ark-ui/react/dist/components/menu/menu-checkbox-item.js
var import_jsx_runtime137 = __toESM(require_jsx_runtime(), 1);
var import_react262 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/menu/use-menu-item-context.js
var [MenuItemProvider, useMenuItemContext] = createContext({
  name: "MenuItemContext",
  hookName: "useMenuItemContext",
  providerName: "<MenuItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/menu/use-menu-option-item-props-context.js
var [MenuOptionItemPropsProvider, useMenuOptionItemPropsContext] = createContext({
  name: "MenuOptionItemPropsContext",
  hookName: "useMenuOptionItemPropsContext",
  providerName: "<MenuOptionItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/menu/menu-checkbox-item.js
var MenuCheckboxItem = (0, import_react262.forwardRef)((props52, ref36) => {
  const [partialOptionItemProps, localProps] = createSplitProps3()(props52, [
    "checked",
    "closeOnSelect",
    "disabled",
    "onCheckedChange",
    "value",
    "valueText"
  ]);
  const optionItemProps3 = {
    ...partialOptionItemProps,
    type: "checkbox"
  };
  const menu = useMenuContext();
  const mergedProps = mergeProps3(menu.getOptionItemProps(optionItemProps3), localProps);
  const optionItemState = menu.getOptionItemState(optionItemProps3);
  return (0, import_jsx_runtime137.jsx)(MenuOptionItemPropsProvider, { value: optionItemProps3, children: (0, import_jsx_runtime137.jsx)(MenuItemProvider, { value: optionItemState, children: (0, import_jsx_runtime137.jsx)(ark.div, { ...mergedProps, ref: ref36 }) }) });
});
MenuCheckboxItem.displayName = "MenuCheckboxItem";

// node_modules/@ark-ui/react/dist/components/menu/menu-content.js
var import_jsx_runtime138 = __toESM(require_jsx_runtime(), 1);
var import_react264 = __toESM(require_react(), 1);
var MenuContent = (0, import_react264.forwardRef)((props52, ref36) => {
  const menu = useMenuContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps3(menu.getContentProps(), presence.getPresenceProps(), props52);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime138.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref36) });
});
MenuContent.displayName = "MenuContent";

// node_modules/@ark-ui/react/dist/components/menu/menu-context.js
var MenuContext = (props52) => props52.children(useMenuContext());

// node_modules/@ark-ui/react/dist/components/menu/menu-context-trigger.js
var import_jsx_runtime139 = __toESM(require_jsx_runtime(), 1);
var import_react266 = __toESM(require_react(), 1);
var MenuContextTrigger = (0, import_react266.forwardRef)(
  (props52, ref36) => {
    const menu = useMenuContext();
    const mergedProps = mergeProps3(menu.getContextTriggerProps(), props52);
    return (0, import_jsx_runtime139.jsx)(ark.button, { ...mergedProps, ref: ref36 });
  }
);
MenuContextTrigger.displayName = "MenuContextTrigger";

// node_modules/@ark-ui/react/dist/components/menu/menu-indicator.js
var import_jsx_runtime140 = __toESM(require_jsx_runtime(), 1);
var import_react268 = __toESM(require_react(), 1);
var MenuIndicator = (0, import_react268.forwardRef)((props52, ref36) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps3(menu.getIndicatorProps(), props52);
  return (0, import_jsx_runtime140.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
MenuIndicator.displayName = "MenuIndicator";

// node_modules/@ark-ui/react/dist/components/menu/menu-item.js
var import_jsx_runtime141 = __toESM(require_jsx_runtime(), 1);
var import_react270 = __toESM(require_react(), 1);
var MenuItem = (0, import_react270.forwardRef)((props52, ref36) => {
  const [itemProps17, localProps] = createSplitProps3()(props52, [
    "closeOnSelect",
    "disabled",
    "value",
    "valueText"
  ]);
  const menu = useMenuContext();
  const mergedProps = mergeProps3(menu.getItemProps(itemProps17), localProps);
  const itemState = menu.getItemState(itemProps17);
  return (0, import_jsx_runtime141.jsx)(MenuItemProvider, { value: itemState, children: (0, import_jsx_runtime141.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
});
MenuItem.displayName = "MenuItem";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-context.js
var MenuItemContext = (props52) => props52.children(useMenuItemContext());

// node_modules/@ark-ui/react/dist/components/menu/menu-item-group.js
var import_jsx_runtime142 = __toESM(require_jsx_runtime(), 1);
var import_react272 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/menu/use-menu-item-group-context.js
var [MenuItemGroupProvider, useMenuItemGroupContext] = createContext({
  name: "MenuItemGroupContext",
  hookName: "useMenuItemGroupContext",
  providerName: "<MenuItemGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/menu/menu-item-group.js
var MenuItemGroup = (0, import_react272.forwardRef)((props52, ref36) => {
  const [optionalItemGroupProps, localProps] = createSplitProps3()(props52, [
    "id"
  ]);
  const menu = useMenuContext();
  const id = (0, import_react272.useId)();
  const itemGroupProps5 = { id, ...optionalItemGroupProps };
  const mergedProps = mergeProps3(menu.getItemGroupProps(itemGroupProps5), localProps);
  return (0, import_jsx_runtime142.jsx)(MenuItemGroupProvider, { value: itemGroupProps5, children: (0, import_jsx_runtime142.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
});
MenuItemGroup.displayName = "MenuItemGroup";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-group-label.js
var import_jsx_runtime143 = __toESM(require_jsx_runtime(), 1);
var import_react274 = __toESM(require_react(), 1);
var MenuItemGroupLabel = (0, import_react274.forwardRef)(
  (props52, ref36) => {
    const menu = useMenuContext();
    const itemGroup = useMenuItemGroupContext();
    const mergedProps = mergeProps3(menu.getItemGroupLabelProps({ htmlFor: itemGroup.id }), props52);
    return (0, import_jsx_runtime143.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
MenuItemGroupLabel.displayName = "MenuItemGroupLabel";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-indicator.js
var import_jsx_runtime144 = __toESM(require_jsx_runtime(), 1);
var import_react276 = __toESM(require_react(), 1);
var MenuItemIndicator = (0, import_react276.forwardRef)(
  (props52, ref36) => {
    const menu = useMenuContext();
    const optionItemProps3 = useMenuOptionItemPropsContext();
    const mergedProps = mergeProps3(menu.getItemIndicatorProps(optionItemProps3), props52);
    return (0, import_jsx_runtime144.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
MenuItemIndicator.displayName = "MenuItemIndicator";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-text.js
var import_jsx_runtime145 = __toESM(require_jsx_runtime(), 1);
var import_react278 = __toESM(require_react(), 1);
var MenuItemText = (0, import_react278.forwardRef)((props52, ref36) => {
  const menu = useMenuContext();
  const optionItemProps3 = useMenuOptionItemPropsContext();
  const mergedProps = mergeProps3(menu.getItemTextProps(optionItemProps3), props52);
  return (0, import_jsx_runtime145.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
MenuItemText.displayName = "MenuItemText";

// node_modules/@ark-ui/react/dist/components/menu/menu-positioner.js
var import_jsx_runtime146 = __toESM(require_jsx_runtime(), 1);
var import_react280 = __toESM(require_react(), 1);
var MenuPositioner = (0, import_react280.forwardRef)((props52, ref36) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps3(menu.getPositionerProps(), props52);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime146.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
MenuPositioner.displayName = "MenuPositioner";

// node_modules/@ark-ui/react/dist/components/menu/menu-radio-item.js
var import_jsx_runtime147 = __toESM(require_jsx_runtime(), 1);
var import_react282 = __toESM(require_react(), 1);
var MenuRadioItem = (0, import_react282.forwardRef)((props52, ref36) => {
  const [partialItemProps, localProps] = createSplitProps3()(props52, [
    "closeOnSelect",
    "disabled",
    "value",
    "valueText"
  ]);
  const menu = useMenuContext();
  const itemGroup = useMenuItemGroupContext();
  const optionItemProps3 = {
    ...partialItemProps,
    checked: itemGroup.value === partialItemProps.value,
    type: "radio",
    onCheckedChange: () => {
      var _a7;
      return (_a7 = itemGroup.onValueChange) == null ? void 0 : _a7.call(itemGroup, { value: partialItemProps.value });
    }
  };
  const mergedProps = mergeProps3(menu.getOptionItemProps(optionItemProps3), localProps);
  const optionItemState = menu.getOptionItemState(optionItemProps3);
  return (0, import_jsx_runtime147.jsx)(MenuOptionItemPropsProvider, { value: optionItemProps3, children: (0, import_jsx_runtime147.jsx)(MenuItemProvider, { value: optionItemState, children: (0, import_jsx_runtime147.jsx)(ark.div, { ...mergedProps, ref: ref36 }) }) });
});
MenuRadioItem.displayName = "MenuRadioItem";

// node_modules/@ark-ui/react/dist/components/menu/menu-radio-item-group.js
var import_jsx_runtime148 = __toESM(require_jsx_runtime(), 1);
var import_react284 = __toESM(require_react(), 1);
var MenuRadioItemGroup = (0, import_react284.forwardRef)(
  (props52, ref36) => {
    const [optionalItemGroupProps, localProps] = createSplitProps3()(props52, ["id", "onValueChange", "value"]);
    const menu = useMenuContext();
    const id = (0, import_react284.useId)();
    const itemGroupProps5 = { id, ...optionalItemGroupProps };
    const mergedProps = mergeProps3(menu.getItemGroupProps({ id: itemGroupProps5.id }), localProps);
    return (0, import_jsx_runtime148.jsx)(MenuItemGroupProvider, { value: itemGroupProps5, children: (0, import_jsx_runtime148.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
  }
);
MenuRadioItemGroup.displayName = "MenuRadioItemGroup";

// node_modules/@ark-ui/react/dist/components/menu/menu-root.js
var import_jsx_runtime149 = __toESM(require_jsx_runtime(), 1);
var import_react289 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/use-effect-once.js
var import_react285 = __toESM(require_react(), 1);
var useEffectOnce = (cb) => {
  const savedCallback = (0, import_react285.useRef)(cb);
  const effectGuard = (0, import_react285.useRef)(false);
  (0, import_react285.useEffect)(() => {
    savedCallback.current = cb;
  });
  (0, import_react285.useEffect)(() => {
    if (effectGuard.current !== true) {
      effectGuard.current = true;
      savedCallback.current();
    }
  }, []);
};

// node_modules/@ark-ui/react/node_modules/@zag-js/rect-utils/dist/index.mjs
var createPoint = (x, y) => ({ x, y });
function createRect(r) {
  const { x, y, width, height } = r;
  const midX = x + width / 2;
  const midY = y + height / 2;
  return {
    x,
    y,
    width,
    height,
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height,
    midX,
    midY,
    center: createPoint(midX, midY)
  };
}
function getRectCorners(v) {
  const top = createPoint(v.minX, v.minY);
  const right = createPoint(v.maxX, v.minY);
  const bottom = createPoint(v.maxX, v.maxY);
  const left = createPoint(v.minX, v.maxY);
  return { top, right, bottom, left };
}
var { min: min3, max: max3 } = Math;
function getElementPolygon2(rectValue, placement) {
  const rect = createRect(rectValue);
  const { top, right, left, bottom } = getRectCorners(rect);
  const [base] = placement.split("-");
  return {
    top: [left, top, right, bottom],
    right: [top, right, bottom, left],
    bottom: [top, left, bottom, right],
    left: [right, top, left, bottom]
  }[base];
}
function isPointInPolygon2(polygon, point) {
  const { x, y } = point;
  let c = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {
      c = !c;
    }
  }
  return c;
}
var { sign: sign2, abs: abs3, min: min23 } = Math;

// node_modules/@ark-ui/react/node_modules/@zag-js/menu/dist/index.mjs
var anatomy54 = createAnatomy2("menu").parts(
  "arrow",
  "arrowTip",
  "content",
  "contextTrigger",
  "indicator",
  "item",
  "itemGroup",
  "itemGroupLabel",
  "itemIndicator",
  "itemText",
  "positioner",
  "separator",
  "trigger",
  "triggerItem"
);
var parts49 = anatomy54.build();
var dom47 = createScope({
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `menu:${ctx.id}:trigger`;
  },
  getContextTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.contextTrigger) ?? `menu:${ctx.id}:ctx-trigger`;
  },
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `menu:${ctx.id}:content`;
  },
  getArrowId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.arrow) ?? `menu:${ctx.id}:arrow`;
  },
  getPositionerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.positioner) ?? `menu:${ctx.id}:popper`;
  },
  getGroupId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.group) == null ? void 0 : _b6.call(_a7, id)) ?? `menu:${ctx.id}:group:${id}`;
  },
  getGroupLabelId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.groupLabel) == null ? void 0 : _b6.call(_a7, id)) ?? `menu:${ctx.id}:group-label:${id}`;
  },
  getContentEl: (ctx) => dom47.getById(ctx, dom47.getContentId(ctx)),
  getPositionerEl: (ctx) => dom47.getById(ctx, dom47.getPositionerId(ctx)),
  getTriggerEl: (ctx) => dom47.getById(ctx, dom47.getTriggerId(ctx)),
  getHighlightedItemEl: (ctx) => ctx.highlightedValue ? dom47.getById(ctx, ctx.highlightedValue) : null,
  getArrowEl: (ctx) => dom47.getById(ctx, dom47.getArrowId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom47.getContentId(ctx));
    const selector = `[role^="menuitem"][data-ownedby=${ownerId}]:not([data-disabled])`;
    return queryAll(dom47.getContentEl(ctx), selector);
  },
  getFirstEl: (ctx) => first2(dom47.getElements(ctx)),
  getLastEl: (ctx) => last2(dom47.getElements(ctx)),
  getNextEl: (ctx, loop) => nextById(dom47.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),
  getPrevEl: (ctx, loop) => prevById(dom47.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),
  getElemByKey: (ctx, key) => getByTypeahead(dom47.getElements(ctx), { state: ctx.typeaheadState, key, activeId: ctx.highlightedValue }),
  isTargetDisabled: (v) => {
    return isHTMLElement(v) && (v.dataset.disabled === "" || v.hasAttribute("disabled"));
  },
  isTriggerItem: (el) => {
    var _a7;
    return !!((_a7 = el == null ? void 0 : el.getAttribute("role")) == null ? void 0 : _a7.startsWith("menuitem")) && !!(el == null ? void 0 : el.hasAttribute("aria-controls"));
  },
  getOptionFromItemEl(el) {
    return {
      id: el.id,
      name: el.dataset.name,
      value: el.dataset.value,
      valueText: el.dataset.valueText,
      type: el.dataset.type
    };
  }
});
function connect12(state2, send, normalize2) {
  const isSubmenu = state2.context.isSubmenu;
  const isTypingAhead = state2.context.isTypingAhead;
  const composite = state2.context.composite;
  const open = state2.hasTag("open");
  const popperStyles = getPlacementStyles2({
    ...state2.context.positioning,
    placement: state2.context.anchorPoint ? "bottom" : state2.context.currentPlacement
  });
  function getItemState(props210) {
    return {
      disabled: !!props210.disabled,
      highlighted: state2.context.highlightedValue === props210.value
    };
  }
  function getOptionItemProps(props210) {
    const valueText = props210.valueText ?? props210.value;
    return { ...props210, id: props210.value, valueText };
  }
  function getOptionItemState(props210) {
    const itemState = getItemState(getOptionItemProps(props210));
    return {
      ...itemState,
      checked: !!props210.checked
    };
  }
  function getItemProps(props210) {
    const { value: id, closeOnSelect, valueText } = props210;
    const itemState = getItemState(props210);
    return normalize2.element({
      ...parts49.item.attrs,
      id,
      role: "menuitem",
      "aria-disabled": itemState.disabled,
      "data-disabled": dataAttr(itemState.disabled),
      "data-ownedby": dom47.getContentId(state2.context),
      "data-highlighted": dataAttr(itemState.highlighted),
      "data-valuetext": valueText,
      onDragStart(event) {
        const isLink = event.currentTarget.matches("a[href]");
        if (isLink) event.preventDefault();
      },
      onPointerMove(event) {
        if (itemState.disabled) return;
        if (event.pointerType !== "mouse") return;
        const target = event.currentTarget;
        if (itemState.highlighted) return;
        send({ type: "ITEM_POINTERMOVE", id, target, closeOnSelect });
      },
      onPointerLeave(event) {
        if (itemState.disabled) return;
        if (event.pointerType !== "mouse") return;
        const pointerMoved = state2.previousEvent.type.includes("POINTER");
        if (!pointerMoved) return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERLEAVE", id, target, closeOnSelect });
      },
      onPointerDown(event) {
        if (itemState.disabled) return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERDOWN", target, id, closeOnSelect });
      },
      onClick(event) {
        if (isDownloadingEvent(event)) return;
        if (isOpeningInNewTab(event)) return;
        if (itemState.disabled) return;
        const target = event.currentTarget;
        send({ type: "ITEM_CLICK", target, id, closeOnSelect });
      }
    });
  }
  return {
    highlightedValue: state2.context.highlightedValue,
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    setHighlightedValue(value) {
      send({ type: "HIGHLIGHTED.SET", id: value });
    },
    setParent(parent) {
      send({ type: "PARENT.SET", value: parent, id: parent.state.context.id });
    },
    setChild(child) {
      send({ type: "CHILD.SET", value: child, id: child.state.context.id });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getContextTriggerProps() {
      return normalize2.element({
        ...parts49.contextTrigger.attrs,
        dir: state2.context.dir,
        id: dom47.getContextTriggerId(state2.context),
        onPointerDown(event) {
          if (event.pointerType === "mouse") return;
          const point = getEventPoint2(event);
          send({ type: "CONTEXT_MENU_START", point });
        },
        onPointerCancel(event) {
          if (event.pointerType === "mouse") return;
          send("CONTEXT_MENU_CANCEL");
        },
        onPointerMove(event) {
          if (event.pointerType === "mouse") return;
          send("CONTEXT_MENU_CANCEL");
        },
        onPointerUp(event) {
          if (event.pointerType === "mouse") return;
          send("CONTEXT_MENU_CANCEL");
        },
        onContextMenu(event) {
          const point = getEventPoint2(event);
          send({ type: "CONTEXT_MENU", point });
          event.preventDefault();
        },
        style: {
          WebkitTouchCallout: "none",
          WebkitUserSelect: "none",
          userSelect: "none"
        }
      });
    },
    getTriggerItemProps(childApi) {
      return mergeProps3(
        getItemProps({ value: childApi.getTriggerProps().id }),
        childApi.getTriggerProps()
      );
    },
    getTriggerProps() {
      return normalize2.button({
        ...isSubmenu ? parts49.triggerItem.attrs : parts49.trigger.attrs,
        "data-placement": state2.context.currentPlacement,
        type: "button",
        dir: state2.context.dir,
        id: dom47.getTriggerId(state2.context),
        "data-uid": state2.context.id,
        "aria-haspopup": composite ? "menu" : "dialog",
        "aria-controls": dom47.getContentId(state2.context),
        "aria-expanded": open || void 0,
        "data-state": open ? "open" : "closed",
        onPointerMove(event) {
          if (event.pointerType !== "mouse") return;
          const disabled = dom47.isTargetDisabled(event.currentTarget);
          if (disabled || !isSubmenu) return;
          send({ type: "TRIGGER_POINTERMOVE", target: event.currentTarget });
        },
        onPointerLeave(event) {
          if (dom47.isTargetDisabled(event.currentTarget)) return;
          if (event.pointerType !== "mouse") return;
          if (!isSubmenu) return;
          const point = getEventPoint2(event);
          send({ type: "TRIGGER_POINTERLEAVE", target: event.currentTarget, point });
        },
        onPointerDown(event) {
          if (dom47.isTargetDisabled(event.currentTarget)) return;
          if (isContextMenuEvent2(event)) return;
          event.preventDefault();
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (dom47.isTargetDisabled(event.currentTarget)) return;
          send({ type: "TRIGGER_CLICK", target: event.currentTarget });
        },
        onBlur() {
          send("TRIGGER_BLUR");
        },
        onFocus() {
          send("TRIGGER_FOCUS");
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          const keyMap2 = {
            ArrowDown() {
              send("ARROW_DOWN");
            },
            ArrowUp() {
              send("ARROW_UP");
            },
            Enter() {
              send({ type: "ARROW_DOWN", src: "enter" });
            },
            Space() {
              send({ type: "ARROW_DOWN", src: "space" });
            }
          };
          const key = getEventKey2(event, state2.context);
          const exec21 = keyMap2[key];
          if (exec21) {
            event.preventDefault();
            exec21(event);
          }
        }
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        ...parts49.indicator.attrs,
        dir: state2.context.dir,
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts49.positioner.attrs,
        dir: state2.context.dir,
        id: dom47.getPositionerId(state2.context),
        style: popperStyles.floating
      });
    },
    getArrowProps() {
      return normalize2.element({
        id: dom47.getArrowId(state2.context),
        ...parts49.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts49.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts49.content.attrs,
        id: dom47.getContentId(state2.context),
        "aria-label": state2.context["aria-label"],
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: composite ? "menu" : "dialog",
        tabIndex: 0,
        dir: state2.context.dir,
        "aria-activedescendant": state2.context.highlightedValue ?? void 0,
        "aria-labelledby": dom47.getTriggerId(state2.context),
        "data-placement": state2.context.currentPlacement,
        onPointerEnter(event) {
          if (event.pointerType !== "mouse") return;
          send("MENU_POINTERENTER");
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          const target = getEventTarget(event);
          const sameMenu = (target == null ? void 0 : target.closest("[role=menu]")) === event.currentTarget || target === event.currentTarget;
          if (!sameMenu) return;
          if (event.key === "Tab") {
            const valid = isValidTabEvent(event);
            if (!valid) {
              event.preventDefault();
              return;
            }
          }
          const item = dom47.getHighlightedItemEl(state2.context);
          const keyMap2 = {
            ArrowDown() {
              send("ARROW_DOWN");
            },
            ArrowUp() {
              send("ARROW_UP");
            },
            ArrowLeft() {
              send("ARROW_LEFT");
            },
            ArrowRight() {
              send("ARROW_RIGHT");
            },
            Enter() {
              send("ENTER");
              clickIfLink2(item);
            },
            Space(event2) {
              var _a7;
              if (isTypingAhead) {
                send({ type: "TYPEAHEAD", key: event2.key });
              } else {
                (_a7 = keyMap2.Enter) == null ? void 0 : _a7.call(keyMap2, event2);
              }
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = getEventKey2(event, { dir: state2.context.dir });
          const exec21 = keyMap2[key];
          if (exec21) {
            exec21(event);
            event.stopPropagation();
            event.preventDefault();
            return;
          }
          if (!state2.context.typeahead) return;
          if (!isPrintableKey2(event)) return;
          if (isModifierKey2(event)) return;
          if (isEditableElement(target)) return;
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      });
    },
    getSeparatorProps() {
      return normalize2.element({
        ...parts49.separator.attrs,
        role: "separator",
        dir: state2.context.dir,
        "aria-orientation": "horizontal"
      });
    },
    getItemState,
    getItemProps,
    getOptionItemState,
    getOptionItemProps(props210) {
      const { type, disabled, onCheckedChange, closeOnSelect } = props210;
      const option = getOptionItemProps(props210);
      const itemState = getOptionItemState(props210);
      return {
        ...getItemProps(option),
        ...normalize2.element({
          "data-type": type,
          ...parts49.item.attrs,
          dir: state2.context.dir,
          "data-value": option.value,
          role: `menuitem${type}`,
          "aria-checked": !!itemState.checked,
          "data-state": itemState.checked ? "checked" : "unchecked",
          onClick(event) {
            if (disabled) return;
            if (isDownloadingEvent(event)) return;
            if (isOpeningInNewTab(event)) return;
            const target = event.currentTarget;
            send({ type: "ITEM_CLICK", target, option, closeOnSelect });
            onCheckedChange == null ? void 0 : onCheckedChange(!itemState.checked);
          }
        })
      };
    },
    getItemIndicatorProps(props210) {
      const itemState = getOptionItemState(props210);
      return normalize2.element({
        ...parts49.itemIndicator.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": itemState.checked ? "checked" : "unchecked",
        hidden: !itemState.checked
      });
    },
    getItemTextProps(props210) {
      const itemState = getOptionItemState(props210);
      return normalize2.element({
        ...parts49.itemText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": itemState.checked ? "checked" : "unchecked"
      });
    },
    getItemGroupLabelProps(props210) {
      return normalize2.element({
        id: dom47.getGroupLabelId(state2.context, props210.htmlFor),
        dir: state2.context.dir,
        ...parts49.itemGroupLabel.attrs
      });
    },
    getItemGroupProps(props210) {
      return normalize2.element({
        id: dom47.getGroupId(state2.context, props210.id),
        ...parts49.itemGroup.attrs,
        dir: state2.context.dir,
        "aria-labelledby": dom47.getGroupLabelId(state2.context, props210.id),
        role: "group"
      });
    }
  };
}
var { not: not39, and: and39, or: or25 } = guards20;
function machine12(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "menu",
      initial: ctx.open ? "open" : "idle",
      context: {
        highlightedValue: null,
        loopFocus: false,
        anchorPoint: null,
        closeOnSelect: true,
        typeahead: true,
        composite: true,
        ...ctx,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        },
        intentPolygon: null,
        parent: null,
        lastHighlightedValue: null,
        children: cast3(ref35({})),
        suspendPointer: false,
        restoreFocus: true,
        typeaheadState: getByTypeahead.defaultOptions
      },
      computed: {
        isSubmenu: (ctx2) => ctx2.parent !== null,
        isRtl: (ctx2) => ctx2.dir === "rtl",
        isTypingAhead: (ctx2) => ctx2.typeaheadState.keysSoFar !== ""
      },
      watch: {
        isSubmenu: "setSubmenuPlacement",
        anchorPoint: "reposition",
        open: "toggleVisibility"
      },
      on: {
        "PARENT.SET": {
          actions: "setParentMenu"
        },
        "CHILD.SET": {
          actions: "setChildMenu"
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: "invokeOnOpen"
          },
          {
            target: "open",
            actions: "invokeOnOpen"
          }
        ],
        OPEN_AUTOFOCUS: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            internal: true,
            target: "open",
            actions: ["highlightFirstItem", "invokeOnOpen"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: "invokeOnClose"
          },
          {
            target: "closed",
            actions: "invokeOnClose"
          }
        ],
        "HIGHLIGHTED.RESTORE": {
          actions: "restoreHighlightedItem"
        },
        "HIGHLIGHTED.SET": {
          actions: "setHighlightedItem"
        }
      },
      states: {
        idle: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: [
              {
                guard: "isOpenControlled",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              }
            ],
            TRIGGER_CLICK: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ],
            TRIGGER_FOCUS: {
              guard: not39("isSubmenu"),
              target: "closed"
            },
            TRIGGER_POINTERMOVE: {
              guard: "isSubmenu",
              target: "opening"
            }
          }
        },
        "opening:contextmenu": {
          tags: ["closed"],
          after: {
            LONG_PRESS_DELAY: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            CONTEXT_MENU_CANCEL: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: "invokeOnClose"
              }
            ]
          }
        },
        opening: {
          tags: ["closed"],
          after: {
            SUBMENU_OPEN_DELAY: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            BLUR: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: "invokeOnClose"
              }
            ],
            TRIGGER_POINTERLEAVE: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: "invokeOnClose"
              }
            ]
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackPointerMove", "trackInteractOutside"],
          after: {
            SUBMENU_CLOSE_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["focusParentMenu", "restoreParentHiglightedItem", "invokeOnClose"]
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": {
              target: "closed",
              actions: ["focusParentMenu", "restoreParentHiglightedItem"]
            },
            // don't invoke on open here since the menu is still open (we're only keeping it open)
            MENU_POINTERENTER: {
              target: "open",
              actions: "clearIntentPolygon"
            },
            POINTER_MOVED_AWAY_FROM_SUBMENU: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: ["focusParentMenu", "restoreParentHiglightedItem"]
              }
            ]
          }
        },
        closed: {
          tags: ["closed"],
          entry: ["clearHighlightedItem", "focusTrigger", "resumePointer"],
          on: {
            "CONTROLLED.OPEN": [
              {
                guard: or25("isOpenAutoFocusEvent", "isArrowDownEvent"),
                target: "open",
                actions: "highlightFirstItem"
              },
              {
                guard: "isArrowUpEvent",
                target: "open",
                actions: "highlightLastItem"
              },
              {
                target: "open"
              }
            ],
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: [
              {
                guard: "isOpenControlled",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              }
            ],
            TRIGGER_CLICK: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ],
            TRIGGER_POINTERMOVE: {
              guard: "isTriggerItem",
              target: "opening"
            },
            TRIGGER_BLUR: "idle",
            ARROW_DOWN: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: ["highlightFirstItem", "invokeOnOpen"]
              }
            ],
            ARROW_UP: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: ["highlightLastItem", "invokeOnOpen"]
              }
            ]
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackInteractOutside", "trackPositioning", "scrollToHighlightedItem"],
          entry: ["focusMenu", "resumePointer"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                target: "closed",
                guard: "isArrowLeftEvent",
                actions: ["focusParentMenu"]
              },
              {
                target: "closed"
              }
            ],
            TRIGGER_CLICK: [
              {
                guard: and39(not39("isTriggerItem"), "isOpenControlled"),
                actions: "invokeOnClose"
              },
              {
                guard: not39("isTriggerItem"),
                target: "closed",
                actions: "invokeOnClose"
              }
            ],
            ARROW_UP: {
              actions: ["highlightPrevItem", "focusMenu"]
            },
            ARROW_DOWN: {
              actions: ["highlightNextItem", "focusMenu"]
            },
            ARROW_LEFT: [
              {
                guard: and39("isSubmenu", "isOpenControlled"),
                actions: "invokeOnClose"
              },
              {
                guard: "isSubmenu",
                target: "closed",
                actions: ["focusParentMenu", "invokeOnClose"]
              }
            ],
            HOME: {
              actions: ["highlightFirstItem", "focusMenu"]
            },
            END: {
              actions: ["highlightLastItem", "focusMenu"]
            },
            ARROW_RIGHT: {
              guard: "isTriggerItemHighlighted",
              actions: "openSubmenu"
            },
            ENTER: [
              {
                guard: "isTriggerItemHighlighted",
                actions: "openSubmenu"
              },
              {
                actions: "clickHighlightedItem"
              }
            ],
            ITEM_POINTERMOVE: [
              {
                guard: not39("suspendPointer"),
                actions: ["setHighlightedItem", "focusMenu"]
              },
              {
                actions: "setLastHighlightedItem"
              }
            ],
            ITEM_POINTERLEAVE: {
              guard: and39(not39("suspendPointer"), not39("isTriggerItem")),
              actions: "clearHighlightedItem"
            },
            ITEM_CLICK: [
              // == grouped ==
              {
                guard: and39(
                  not39("isTriggerItemHighlighted"),
                  not39("isHighlightedItemEditable"),
                  "closeOnSelect",
                  "isOpenControlled"
                ),
                actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
              },
              {
                guard: and39(not39("isTriggerItemHighlighted"), not39("isHighlightedItemEditable"), "closeOnSelect"),
                target: "closed",
                actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
              },
              //
              {
                guard: and39(not39("isTriggerItemHighlighted"), not39("isHighlightedItemEditable")),
                actions: ["invokeOnSelect", "setOptionState"]
              },
              { actions: "setHighlightedItem" }
            ],
            TRIGGER_POINTERLEAVE: {
              target: "closing",
              actions: "setIntentPolygon"
            },
            ITEM_POINTERDOWN: {
              actions: "setHighlightedItem"
            },
            TYPEAHEAD: {
              actions: "highlightMatchedItem"
            },
            FOCUS_MENU: {
              actions: "focusMenu"
            },
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        }
      }
    },
    {
      delays: {
        LONG_PRESS_DELAY: 700,
        SUBMENU_OPEN_DELAY: 100,
        SUBMENU_CLOSE_DELAY: 100
      },
      guards: {
        closeOnSelect: (ctx2, evt) => !!((evt == null ? void 0 : evt.closeOnSelect) ?? ctx2.closeOnSelect),
        // whether the trigger is also a menu item
        isTriggerItem: (_ctx, evt) => dom47.isTriggerItem(evt.target),
        // whether the trigger item is the active item
        isTriggerItemHighlighted: (ctx2, evt) => {
          const target = evt.target ?? dom47.getHighlightedItemEl(ctx2);
          return !!(target == null ? void 0 : target.hasAttribute("aria-controls"));
        },
        isSubmenu: (ctx2) => ctx2.isSubmenu,
        suspendPointer: (ctx2) => ctx2.suspendPointer,
        isHighlightedItemEditable: (ctx2) => isEditableElement(dom47.getHighlightedItemEl(ctx2)),
        isWithinPolygon: (ctx2, evt) => {
          if (!ctx2.intentPolygon) return false;
          return isPointInPolygon2(ctx2.intentPolygon, evt.point);
        },
        // guard assertions (for controlled mode)
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        isArrowLeftEvent: (_ctx, evt) => {
          var _a7;
          return ((_a7 = evt.previousEvent) == null ? void 0 : _a7.type) === "ARROW_LEFT";
        },
        isArrowUpEvent: (_ctx, evt) => {
          var _a7;
          return ((_a7 = evt.previousEvent) == null ? void 0 : _a7.type) === "ARROW_UP";
        },
        isArrowDownEvent: (_ctx, evt) => {
          var _a7;
          return ((_a7 = evt.previousEvent) == null ? void 0 : _a7.type) === "ARROW_DOWN";
        },
        isOpenAutoFocusEvent: (_ctx, evt) => {
          var _a7;
          return ((_a7 = evt.previousEvent) == null ? void 0 : _a7.type) === "OPEN_AUTOFOCUS";
        }
      },
      activities: {
        trackPositioning(ctx2) {
          if (ctx2.anchorPoint) return;
          ctx2.currentPlacement = ctx2.positioning.placement;
          const getPositionerEl = () => dom47.getPositionerEl(ctx2);
          return getPlacement2(dom47.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackInteractOutside(ctx2, _evt, { send }) {
          const getContentEl = () => dom47.getContentEl(ctx2);
          return trackDismissableElement2(getContentEl, {
            defer: true,
            exclude: [dom47.getTriggerEl(ctx2)],
            onInteractOutside: ctx2.onInteractOutside,
            onFocusOutside: ctx2.onFocusOutside,
            onEscapeKeyDown(event) {
              var _a7;
              (_a7 = ctx2.onEscapeKeyDown) == null ? void 0 : _a7.call(ctx2, event);
              if (ctx2.isSubmenu) event.preventDefault();
              closeRootMenu(ctx2);
            },
            onPointerDownOutside(event) {
              var _a7;
              ctx2.restoreFocus = !event.detail.focusable;
              (_a7 = ctx2.onPointerDownOutside) == null ? void 0 : _a7.call(ctx2, event);
            },
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside" });
            }
          });
        },
        trackPointerMove(ctx2, _evt, { guards: guards22, send }) {
          const { isWithinPolygon } = guards22;
          ctx2.parent.state.context.suspendPointer = true;
          const doc = dom47.getDoc(ctx2);
          return addDomEvent2(doc, "pointermove", (e) => {
            const point = { x: e.clientX, y: e.clientY };
            const isMovingToSubmenu = isWithinPolygon(ctx2, { point });
            if (!isMovingToSubmenu) {
              send("POINTER_MOVED_AWAY_FROM_SUBMENU");
              ctx2.parent.state.context.suspendPointer = false;
            }
          });
        },
        scrollToHighlightedItem(ctx2, _evt, { getState }) {
          const exec21 = () => {
            const state2 = getState();
            if (state2.event.type.startsWith("ITEM_POINTER")) return;
            const itemEl = dom47.getHighlightedItemEl(ctx2);
            const contentEl2 = dom47.getContentEl(ctx2);
            scrollIntoView(itemEl, { rootEl: contentEl2, block: "nearest" });
          };
          raf(() => exec21());
          const contentEl = () => dom47.getContentEl(ctx2);
          return observeAttributes(contentEl, {
            defer: true,
            attributes: ["aria-activedescendant"],
            callback: exec21
          });
        }
      },
      actions: {
        setAnchorPoint(ctx2, evt) {
          ctx2.anchorPoint = evt.point;
        },
        setSubmenuPlacement(ctx2) {
          if (!ctx2.isSubmenu) return;
          ctx2.positioning.placement = ctx2.isRtl ? "left-start" : "right-start";
          ctx2.positioning.gutter = 0;
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom47.getPositionerEl(ctx2);
          const getAnchorRect = ctx2.anchorPoint ? () => ({ width: 0, height: 0, ...ctx2.anchorPoint }) : void 0;
          getPlacement2(dom47.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            getAnchorRect,
            ...evt.options ?? {},
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        setOptionState(_ctx, evt) {
          if (!evt.option) return;
          const { checked, onCheckedChange, type } = evt.option;
          if (type === "radio") {
            onCheckedChange == null ? void 0 : onCheckedChange(true);
          } else if (type === "checkbox") {
            onCheckedChange == null ? void 0 : onCheckedChange(!checked);
          }
        },
        clickHighlightedItem(ctx2, _evt) {
          const itemEl = dom47.getHighlightedItemEl(ctx2);
          if (!itemEl || itemEl.dataset.disabled) return;
          queueMicrotask(() => itemEl.click());
        },
        setIntentPolygon(ctx2, evt) {
          const menu = dom47.getContentEl(ctx2);
          const placement = ctx2.currentPlacement;
          if (!menu || !placement) return;
          const rect = menu.getBoundingClientRect();
          const polygon = getElementPolygon2(rect, placement);
          if (!polygon) return;
          const rightSide = getPlacementSide2(placement) === "right";
          const bleed = rightSide ? -5 : 5;
          ctx2.intentPolygon = [{ ...evt.point, x: evt.point.x + bleed }, ...polygon];
        },
        clearIntentPolygon(ctx2) {
          ctx2.intentPolygon = null;
        },
        resumePointer(ctx2) {
          if (!ctx2.parent) return;
          ctx2.parent.state.context.suspendPointer = false;
        },
        setHighlightedItem(ctx2, evt) {
          set7.highlighted(ctx2, evt.id);
        },
        clearHighlightedItem(ctx2) {
          set7.highlighted(ctx2, null);
        },
        focusMenu(ctx2) {
          raf(() => {
            const contentEl = dom47.getContentEl(ctx2);
            const initialFocusEl = getInitialFocus({
              root: contentEl,
              enabled: !contains(contentEl, dom47.getActiveElement(ctx2)),
              filter(node2) {
                var _a7;
                return !((_a7 = node2.role) == null ? void 0 : _a7.startsWith("menuitem"));
              }
            });
            initialFocusEl == null ? void 0 : initialFocusEl.focus({ preventScroll: true });
          });
        },
        highlightFirstItem(ctx2) {
          const fn = !!dom47.getContentEl(ctx2) ? queueMicrotask : raf;
          fn(() => {
            const first22 = dom47.getFirstEl(ctx2);
            if (!first22) return;
            set7.highlighted(ctx2, first22.id);
          });
        },
        highlightLastItem(ctx2) {
          const fn = !!dom47.getContentEl(ctx2) ? queueMicrotask : raf;
          fn(() => {
            const last22 = dom47.getLastEl(ctx2);
            if (!last22) return;
            set7.highlighted(ctx2, last22.id);
          });
        },
        highlightNextItem(ctx2, evt) {
          const next3 = dom47.getNextEl(ctx2, evt.loop);
          set7.highlighted(ctx2, (next3 == null ? void 0 : next3.id) ?? null);
        },
        highlightPrevItem(ctx2, evt) {
          const prev3 = dom47.getPrevEl(ctx2, evt.loop);
          set7.highlighted(ctx2, (prev3 == null ? void 0 : prev3.id) ?? null);
        },
        invokeOnSelect(ctx2) {
          var _a7;
          if (!ctx2.highlightedValue) return;
          (_a7 = ctx2.onSelect) == null ? void 0 : _a7.call(ctx2, { value: ctx2.highlightedValue });
        },
        focusTrigger(ctx2) {
          if (ctx2.isSubmenu || ctx2.anchorPoint || !ctx2.restoreFocus) return;
          queueMicrotask(() => {
            var _a7;
            return (_a7 = dom47.getTriggerEl(ctx2)) == null ? void 0 : _a7.focus({ preventScroll: true });
          });
        },
        highlightMatchedItem(ctx2, evt) {
          const node2 = dom47.getElemByKey(ctx2, evt.key);
          if (!node2) return;
          set7.highlighted(ctx2, node2.id);
        },
        setParentMenu(ctx2, evt) {
          ctx2.parent = ref35(evt.value);
        },
        setChildMenu(ctx2, evt) {
          ctx2.children[evt.id] = ref35(evt.value);
        },
        closeRootMenu(ctx2) {
          closeRootMenu(ctx2);
        },
        openSubmenu(ctx2) {
          const item = dom47.getHighlightedItemEl(ctx2);
          const id = item == null ? void 0 : item.getAttribute("data-uid");
          const child = id ? ctx2.children[id] : null;
          child == null ? void 0 : child.send("OPEN_AUTOFOCUS");
        },
        focusParentMenu(ctx2) {
          var _a7;
          (_a7 = ctx2.parent) == null ? void 0 : _a7.send("FOCUS_MENU");
        },
        setLastHighlightedItem(ctx2, evt) {
          ctx2.lastHighlightedValue = evt.id;
        },
        restoreHighlightedItem(ctx2) {
          if (!ctx2.lastHighlightedValue) return;
          set7.highlighted(ctx2, ctx2.lastHighlightedValue);
          ctx2.lastHighlightedValue = null;
        },
        restoreParentHiglightedItem(ctx2) {
          var _a7;
          (_a7 = ctx2.parent) == null ? void 0 : _a7.send("HIGHLIGHTED.RESTORE");
        },
        invokeOnOpen(ctx2) {
          var _a7;
          (_a7 = ctx2.onOpenChange) == null ? void 0 : _a7.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a7;
          (_a7 = ctx2.onOpenChange) == null ? void 0 : _a7.call(ctx2, { open: false });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      }
    }
  );
}
function closeRootMenu(ctx) {
  let parent = ctx.parent;
  while (parent && parent.state.context.isSubmenu) {
    parent = parent.state.context.parent;
  }
  parent == null ? void 0 : parent.send("CLOSE");
}
var set7 = {
  highlighted(ctx, value) {
    var _a7;
    if (isEqual3(ctx.highlightedValue, value)) return;
    ctx.highlightedValue = value;
    (_a7 = ctx.onHighlightChange) == null ? void 0 : _a7.call(ctx, { highlightedValue: value });
  }
};
var props41 = createProps30()([
  "anchorPoint",
  "aria-label",
  "closeOnSelect",
  "dir",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "loopFocus",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onEscapeKeyDown",
  "onSelect",
  "onHighlightChange",
  "open",
  "open.controlled",
  "positioning",
  "typeahead",
  "composite"
]);
var splitProps41 = createSplitProps2(props41);
var itemProps12 = createProps30()(["closeOnSelect", "disabled", "value", "valueText"]);
var splitItemProps12 = createSplitProps2(itemProps12);
var itemGroupLabelProps3 = createProps30()(["htmlFor"]);
var splitItemGroupLabelProps3 = createSplitProps2(itemGroupLabelProps3);
var itemGroupProps3 = createProps30()(["id"]);
var splitItemGroupProps3 = createSplitProps2(itemGroupProps3);
var optionItemProps2 = createProps30()([
  "disabled",
  "valueText",
  "closeOnSelect",
  "type",
  "value",
  "checked",
  "onCheckedChange"
]);
var splitOptionItemProps2 = createSplitProps2(optionItemProps2);

// node_modules/@ark-ui/react/dist/components/menu/use-menu.js
var import_react287 = __toESM(require_react(), 1);
var useMenu = (props52 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react287.useId)(),
    dir,
    getRootNode: getRootNode2,
    open: props52.defaultOpen,
    "open.controlled": props52.open !== void 0,
    ...props52
  };
  const context = {
    ...initialContext,
    onOpenChange: useEvent(props52.onOpenChange),
    onSelect: useEvent(props52.onSelect)
  };
  const [state2, send, machine25] = useMachine(machine12(initialContext), { context });
  const api = connect12(state2, send, normalizeProps);
  return { api, machine: machine25 };
};

// node_modules/@ark-ui/react/dist/components/menu/use-menu-machine-context.js
var [MenuMachineProvider, useMenuMachineContext] = createContext({
  name: "MenuMachineContext",
  hookName: "useMenuMachineContext",
  providerName: "<MenuMachineProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/menu/use-menu-trigger-item-context.js
var [MenuTriggerItemProvider, useMenuTriggerItemContext] = createContext({
  name: "MenuMachineContext",
  hookName: "useMenuMachineContext",
  providerName: "<MenuMachineProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/menu/menu-root.js
var MenuRoot = (props52) => {
  const [presenceProps, menuProps] = splitPresenceProps(props52);
  const [useMenuProps, localProps] = createSplitProps3()(menuProps, [
    "anchorPoint",
    "aria-label",
    "closeOnSelect",
    "composite",
    "defaultOpen",
    "highlightedValue",
    "id",
    "ids",
    "loopFocus",
    "onEscapeKeyDown",
    "onFocusOutside",
    "onHighlightChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onSelect",
    "open",
    "positioning",
    "typeahead"
  ]);
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const { api, machine: machine25 } = useMenu(useMenuProps);
  const presence = usePresence(mergeProps3({ present: api.open }, presenceProps));
  useEffectOnce(() => {
    if (!parentMachine) return;
    if (!parentApi) return;
    parentApi.setChild(machine25);
    api.setParent(parentMachine);
  });
  const triggerItemContext = (0, import_react289.useCallback)(
    () => parentApi == null ? void 0 : parentApi.getTriggerItemProps(api),
    [api, parentApi]
  );
  return (0, import_jsx_runtime149.jsx)(MenuTriggerItemProvider, { value: triggerItemContext, children: (0, import_jsx_runtime149.jsx)(MenuMachineProvider, { value: machine25, children: (0, import_jsx_runtime149.jsx)(MenuProvider, { value: api, children: (0, import_jsx_runtime149.jsx)(PresenceProvider, { value: presence, ...localProps }) }) }) });
};

// node_modules/@ark-ui/react/dist/components/menu/menu-root-provider.js
var import_jsx_runtime150 = __toESM(require_jsx_runtime(), 1);
var import_react291 = __toESM(require_react(), 1);
var MenuRootProvider = (props52) => {
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const [presenceProps, { value: menu, children }] = splitPresenceProps(props52);
  const { api, machine: machine25 } = menu;
  const presence = usePresence(mergeProps3({ present: api.open }, presenceProps));
  useEffectOnce(() => {
    if (!parentMachine) return;
    if (!parentApi) return;
    parentApi.setChild(machine25);
    api.setParent(parentMachine);
  });
  const triggerItemContext = (0, import_react291.useCallback)(
    () => parentApi == null ? void 0 : parentApi.getTriggerItemProps(api),
    [api, parentApi]
  );
  return (0, import_jsx_runtime150.jsx)(MenuTriggerItemProvider, { value: triggerItemContext, children: (0, import_jsx_runtime150.jsx)(MenuMachineProvider, { value: machine25, children: (0, import_jsx_runtime150.jsx)(MenuProvider, { value: api, children: (0, import_jsx_runtime150.jsx)(PresenceProvider, { value: presence, children }) }) }) });
};

// node_modules/@ark-ui/react/dist/components/menu/menu-separator.js
var import_jsx_runtime151 = __toESM(require_jsx_runtime(), 1);
var import_react293 = __toESM(require_react(), 1);
var MenuSeparator = (0, import_react293.forwardRef)((props52, ref36) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps3(menu.getSeparatorProps(), props52);
  return (0, import_jsx_runtime151.jsx)(ark.hr, { ...mergedProps, ref: ref36 });
});
MenuSeparator.displayName = "MenuSeparator";

// node_modules/@ark-ui/react/dist/components/menu/menu-trigger.js
var import_jsx_runtime152 = __toESM(require_jsx_runtime(), 1);
var import_react295 = __toESM(require_react(), 1);
var MenuTrigger = (0, import_react295.forwardRef)((props52, ref36) => {
  const menu = useMenuContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps3(
    {
      ...menu.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : menu.getTriggerProps()["aria-controls"]
    },
    props52
  );
  return (0, import_jsx_runtime152.jsx)(ark.button, { ...mergedProps, ref: ref36 });
});
MenuTrigger.displayName = "MenuTrigger";

// node_modules/@ark-ui/react/dist/components/menu/menu-trigger-item.js
var import_jsx_runtime153 = __toESM(require_jsx_runtime(), 1);
var import_react297 = __toESM(require_react(), 1);
var MenuTriggerItem = (0, import_react297.forwardRef)((props52, ref36) => {
  const getTriggerItemProps = useMenuTriggerItemContext();
  const mergedProps = mergeProps3((getTriggerItemProps == null ? void 0 : getTriggerItemProps()) ?? {}, props52);
  return (0, import_jsx_runtime153.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
MenuTriggerItem.displayName = "MenuTriggerItem";

// node_modules/@ark-ui/react/dist/components/menu/menu.js
var menu_exports = {};
__export(menu_exports, {
  Arrow: () => MenuArrow,
  ArrowTip: () => MenuArrowTip,
  CheckboxItem: () => MenuCheckboxItem,
  Content: () => MenuContent,
  Context: () => MenuContext,
  ContextTrigger: () => MenuContextTrigger,
  Indicator: () => MenuIndicator,
  Item: () => MenuItem,
  ItemContext: () => MenuItemContext,
  ItemGroup: () => MenuItemGroup,
  ItemGroupLabel: () => MenuItemGroupLabel,
  ItemIndicator: () => MenuItemIndicator,
  ItemText: () => MenuItemText,
  Positioner: () => MenuPositioner,
  RadioItem: () => MenuRadioItem,
  RadioItemGroup: () => MenuRadioItemGroup,
  Root: () => MenuRoot,
  RootProvider: () => MenuRootProvider,
  Separator: () => MenuSeparator,
  Trigger: () => MenuTrigger,
  TriggerItem: () => MenuTriggerItem
});

// node_modules/@chakra-ui/react/dist/esm/components/menu/menu.js
var {
  withRootProvider: withRootProvider5,
  withContext: withContext31,
  useStyles: useMenuStyles,
  PropsProvider: PropsProvider29
} = createSlotRecipeContext({ key: "menu" });
var MenuRootProvider2 = withRootProvider5(
  menu_exports.RootProvider
);
var MenuRoot2 = withRootProvider5(menu_exports.Root);
var MenuPropsProvider = PropsProvider29;
var MenuTrigger2 = withContext31(
  menu_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var MenuContextTrigger2 = withContext31(menu_exports.ContextTrigger, "contextTrigger", { forwardAsChild: true });
var MenuPositioner2 = withContext31(
  menu_exports.Positioner,
  "positioner",
  { forwardAsChild: true }
);
var MenuSeparator2 = withContext31(
  menu_exports.Separator,
  "separator",
  { forwardAsChild: true }
);
var MenuContent2 = withContext31(
  menu_exports.Content,
  "content",
  { forwardAsChild: true }
);
var MenuArrow2 = withContext31(
  menu_exports.Arrow,
  "arrow",
  { forwardAsChild: true }
);
var MenuArrowTip2 = withContext31(
  menu_exports.ArrowTip,
  "arrowTip",
  { forwardAsChild: true }
);
var MenuIndicator2 = withContext31(
  menu_exports.Indicator,
  "indicator",
  { forwardAsChild: true }
);
var MenuItemGroup2 = withContext31(
  menu_exports.ItemGroup,
  "itemGroup",
  { forwardAsChild: true }
);
var MenuItemGroupLabel2 = withContext31(menu_exports.ItemGroupLabel, "itemGroupLabel", { forwardAsChild: true });
var MenuItem2 = withContext31(
  menu_exports.Item,
  "item",
  { forwardAsChild: true }
);
var MenuTriggerItem2 = withContext31(menu_exports.TriggerItem, "item", { forwardAsChild: true });
var MenuItemText2 = withContext31(
  menu_exports.ItemText,
  "itemText",
  { forwardAsChild: true }
);
var MenuItemCommand = withContext31(
  "kbd",
  "itemCommand"
);
var MenuItemIndicator2 = withContext31(menu_exports.ItemIndicator, "itemIndicator", { forwardAsChild: true });
var MenuCheckboxItem2 = withContext31(menu_exports.CheckboxItem, "item", { forwardAsChild: true });
var MenuRadioItemGroup2 = withContext31(menu_exports.RadioItemGroup, "itemGroup", { forwardAsChild: true });
var MenuRadioItem2 = withContext31(
  menu_exports.RadioItem,
  "item",
  { forwardAsChild: true }
);
var MenuContext2 = menu_exports.Context;
var MenuItemContext2 = menu_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/menu/namespace.js
var namespace_exports22 = {};
__export(namespace_exports22, {
  Arrow: () => MenuArrow2,
  ArrowTip: () => MenuArrowTip2,
  CheckboxItem: () => MenuCheckboxItem2,
  Content: () => MenuContent2,
  Context: () => MenuContext2,
  ContextTrigger: () => MenuContextTrigger2,
  Indicator: () => MenuIndicator2,
  Item: () => MenuItem2,
  ItemCommand: () => MenuItemCommand,
  ItemContext: () => MenuItemContext2,
  ItemGroup: () => MenuItemGroup2,
  ItemGroupLabel: () => MenuItemGroupLabel2,
  ItemIndicator: () => MenuItemIndicator2,
  ItemText: () => MenuItemText2,
  Positioner: () => MenuPositioner2,
  RadioItem: () => MenuRadioItem2,
  RadioItemGroup: () => MenuRadioItemGroup2,
  Root: () => MenuRoot2,
  RootPropsProvider: () => MenuPropsProvider,
  RootProvider: () => MenuRootProvider2,
  Separator: () => MenuSeparator2,
  Trigger: () => MenuTrigger2,
  TriggerItem: () => MenuTriggerItem2
});

// node_modules/@chakra-ui/react/dist/esm/components/native-select/native-select.js
var import_jsx_runtime154 = __toESM(require_jsx_runtime(), 1);
var import_react298 = __toESM(require_react(), 1);
var [BasePropsProvider, useBasePropsContext] = createContext3({
  name: "BasePropsContext",
  hookName: "useBasePropsContext",
  providerName: "<NativeSelect />",
  strict: false
});
var {
  withProvider: withProvider18,
  useClassNames: useClassNames2,
  useStyles: useNativeSelectStyles,
  PropsProvider: PropsProvider30
} = createSlotRecipeContext({ key: "nativeSelect" });
var NativeSelectRoot = withProvider18("div", "root", {
  wrapElement(element, props52) {
    const field = useFieldContext();
    const disabled = Boolean((field == null ? void 0 : field.disabled) ?? props52.disabled);
    const invalid = Boolean((field == null ? void 0 : field.invalid) ?? props52.invalid);
    return (0, import_jsx_runtime154.jsx)(BasePropsProvider, { value: { disabled, invalid }, children: element });
  }
});
var NativeSelectPropsProvider = PropsProvider30;
var StyledSelect = chakra(field_exports.Select, {}, { forwardAsChild: true });
var NativeSelectField = (0, import_react298.forwardRef)(function NativeSelectField2(props52, ref36) {
  const { children, placeholder, ...restProps } = props52;
  const styles = useNativeSelectStyles();
  const classNames = useClassNames2();
  return (0, import_jsx_runtime154.jsxs)(
    StyledSelect,
    {
      ...restProps,
      ref: ref36,
      className: cx(classNames.field, props52.className),
      css: [styles.field, props52.css],
      children: [
        placeholder && (0, import_jsx_runtime154.jsx)("option", { value: "", children: placeholder }),
        children
      ]
    }
  );
});
function NativeSelectIndicator(props52) {
  const styles = useNativeSelectStyles();
  const { disabled, invalid } = useBasePropsContext();
  const classNames = useClassNames2();
  return (0, import_jsx_runtime154.jsx)(
    chakra.div,
    {
      ...props52,
      "data-disabled": dataAttr31(disabled),
      "data-invalid": dataAttr31(invalid),
      className: cx(classNames.indicator, props52.className),
      css: [styles.indicator, props52.css],
      children: props52.children ?? (0, import_jsx_runtime154.jsx)(ChevronDownIcon, {})
    }
  );
}

// node_modules/@chakra-ui/react/dist/esm/components/native-select/namespace.js
var namespace_exports23 = {};
__export(namespace_exports23, {
  Field: () => NativeSelectField,
  Indicator: () => NativeSelectIndicator,
  PropsProvider: () => NativeSelectPropsProvider,
  Root: () => NativeSelectRoot
});

// node_modules/@chakra-ui/react/dist/esm/components/number-input/number-input.js
var import_jsx_runtime164 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/number-input/use-number-input-context.js
var [NumberInputProvider, useNumberInputContext] = createContext({
  name: "NumberInputContext",
  hookName: "useNumberInputContext",
  providerName: "<NumberInputProvider />"
});

// node_modules/@ark-ui/react/dist/components/number-input/number-input-context.js
var NumberInputContext = (props52) => props52.children(useNumberInputContext());

// node_modules/@ark-ui/react/dist/components/number-input/number-input-control.js
var import_jsx_runtime155 = __toESM(require_jsx_runtime(), 1);
var import_react300 = __toESM(require_react(), 1);
var NumberInputControl = (0, import_react300.forwardRef)(
  (props52, ref36) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps3(numberInput.getControlProps(), props52);
    return (0, import_jsx_runtime155.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
NumberInputControl.displayName = "NumberInputControl";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-decrement-trigger.js
var import_jsx_runtime156 = __toESM(require_jsx_runtime(), 1);
var import_react302 = __toESM(require_react(), 1);
var NumberInputDecrementTrigger = (0, import_react302.forwardRef)((props52, ref36) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps3(numberInput.getDecrementTriggerProps(), props52);
  return (0, import_jsx_runtime156.jsx)(ark.button, { ...mergedProps, ref: ref36 });
});
NumberInputDecrementTrigger.displayName = "NumberInputDecrementTrigger";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-increment-trigger.js
var import_jsx_runtime157 = __toESM(require_jsx_runtime(), 1);
var import_react304 = __toESM(require_react(), 1);
var NumberInputIncrementTrigger = (0, import_react304.forwardRef)((props52, ref36) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps3(numberInput.getIncrementTriggerProps(), props52);
  return (0, import_jsx_runtime157.jsx)(ark.button, { ...mergedProps, ref: ref36 });
});
NumberInputIncrementTrigger.displayName = "NumberInputIncrementTrigger";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-input.js
var import_jsx_runtime158 = __toESM(require_jsx_runtime(), 1);
var import_react306 = __toESM(require_react(), 1);
var NumberInputInput = (0, import_react306.forwardRef)(
  (props52, ref36) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps3(numberInput.getInputProps(), props52);
    const field = useFieldContext();
    return (0, import_jsx_runtime158.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref36 });
  }
);
NumberInputInput.displayName = "NumberInputInput";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-label.js
var import_jsx_runtime159 = __toESM(require_jsx_runtime(), 1);
var import_react308 = __toESM(require_react(), 1);
var NumberInputLabel = (0, import_react308.forwardRef)(
  (props52, ref36) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps3(numberInput.getLabelProps(), props52);
    return (0, import_jsx_runtime159.jsx)(ark.label, { ...mergedProps, ref: ref36 });
  }
);
NumberInputLabel.displayName = "NumberInputLabel";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-root.js
var import_jsx_runtime160 = __toESM(require_jsx_runtime(), 1);
var import_react312 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/node_modules/@zag-js/number-utils/dist/index.mjs
function wrap49(num, max4) {
  return (num % max4 + max4) % max4;
}
function roundToDevicePixel2(num) {
  if (typeof window.devicePixelRatio !== "number") return Math.round(num);
  const dp = window.devicePixelRatio;
  return Math.floor(num * dp + 0.5) / dp;
}
function clamp5(v, o) {
  return Math.min(Math.max(nan(v), o.min), o.max);
}
function countDecimals(value) {
  if (!Number.isFinite(value)) return 0;
  let e = 1, p = 0;
  while (Math.round(value * e) / e !== value) {
    e *= 10;
    p += 1;
  }
  return p;
}
var increment2 = (v, s) => decimalOperation(nan(v), "+", s);
var decrement2 = (v, s) => decimalOperation(nan(v), "-", s);
function nan(v) {
  return Number.isNaN(v) ? 0 : v;
}
function isAtMax2(val, o) {
  return nan(val) >= o.max;
}
function isAtMin2(val, o) {
  return nan(val) <= o.min;
}
function isWithinRange2(val, o) {
  return nan(val) >= o.min && nan(val) <= o.max;
}
function decimalOperation(a, op, b) {
  let result = op === "+" ? a + b : a - b;
  if (a % 1 !== 0 || b % 1 !== 0) {
    const multiplier = 10 ** Math.max(countDecimals(a), countDecimals(b));
    a = Math.round(a * multiplier);
    b = Math.round(b * multiplier);
    result = op === "+" ? a + b : a - b;
    result /= multiplier;
  }
  return result;
}
var nf2 = new Intl.NumberFormat("en-US", { style: "decimal", maximumFractionDigits: 20 });

// node_modules/@ark-ui/react/node_modules/@zag-js/number-input/dist/index.mjs
var anatomy55 = createAnatomy2("numberInput").parts(
  "root",
  "label",
  "input",
  "control",
  "valueText",
  "incrementTrigger",
  "decrementTrigger",
  "scrubber"
);
var parts50 = anatomy55.build();
var dom48 = createScope({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `number-input:${ctx.id}`;
  },
  getInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.input) ?? `number-input:${ctx.id}:input`;
  },
  getIncrementTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.incrementTrigger) ?? `number-input:${ctx.id}:inc`;
  },
  getDecrementTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.decrementTrigger) ?? `number-input:${ctx.id}:dec`;
  },
  getScrubberId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.scrubber) ?? `number-input:${ctx.id}:scrubber`;
  },
  getCursorId: (ctx) => `number-input:${ctx.id}:cursor`,
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `number-input:${ctx.id}:label`;
  },
  getInputEl: (ctx) => dom48.getById(ctx, dom48.getInputId(ctx)),
  getIncrementTriggerEl: (ctx) => dom48.getById(ctx, dom48.getIncrementTriggerId(ctx)),
  getDecrementTriggerEl: (ctx) => dom48.getById(ctx, dom48.getDecrementTriggerId(ctx)),
  getScrubberEl: (ctx) => dom48.getById(ctx, dom48.getScrubberId(ctx)),
  getCursorEl: (ctx) => dom48.getDoc(ctx).getElementById(dom48.getCursorId(ctx)),
  getPressedTriggerEl: (ctx, hint = ctx.hint) => {
    let btnEl = null;
    if (hint === "increment") {
      btnEl = dom48.getIncrementTriggerEl(ctx);
    }
    if (hint === "decrement") {
      btnEl = dom48.getDecrementTriggerEl(ctx);
    }
    return btnEl;
  },
  setupVirtualCursor(ctx) {
    if (isSafari()) return;
    dom48.createVirtualCursor(ctx);
    return () => {
      var _a7;
      (_a7 = dom48.getCursorEl(ctx)) == null ? void 0 : _a7.remove();
    };
  },
  preventTextSelection(ctx) {
    const doc = dom48.getDoc(ctx);
    const html = doc.documentElement;
    const body = doc.body;
    body.style.pointerEvents = "none";
    html.style.userSelect = "none";
    html.style.cursor = "ew-resize";
    return () => {
      body.style.pointerEvents = "";
      html.style.userSelect = "";
      html.style.cursor = "";
      if (!html.style.length) {
        html.removeAttribute("style");
      }
      if (!body.style.length) {
        body.removeAttribute("style");
      }
    };
  },
  getMousementValue(ctx, event) {
    const x = roundToDevicePixel2(event.movementX);
    const y = roundToDevicePixel2(event.movementY);
    let hint = x > 0 ? "increment" : x < 0 ? "decrement" : null;
    if (ctx.isRtl && hint === "increment") hint = "decrement";
    if (ctx.isRtl && hint === "decrement") hint = "increment";
    const point = {
      x: ctx.scrubberCursorPoint.x + x,
      y: ctx.scrubberCursorPoint.y + y
    };
    const win = dom48.getWin(ctx);
    const width = win.innerWidth;
    const half = roundToDevicePixel2(7.5);
    point.x = wrap49(point.x + half, width) - half;
    return { hint, point };
  },
  createVirtualCursor(ctx) {
    const doc = dom48.getDoc(ctx);
    const el = doc.createElement("div");
    el.className = "scrubber--cursor";
    el.id = dom48.getCursorId(ctx);
    Object.assign(el.style, {
      width: "15px",
      height: "15px",
      position: "fixed",
      pointerEvents: "none",
      left: "0px",
      top: "0px",
      zIndex: MAX_Z_INDEX,
      transform: ctx.scrubberCursorPoint ? `translate3d(${ctx.scrubberCursorPoint.x}px, ${ctx.scrubberCursorPoint.y}px, 0px)` : void 0,
      willChange: "transform"
    });
    el.innerHTML = `
        <svg width="46" height="15" style="left: -15.5px; position: absolute; top: 0; filter: drop-shadow(rgba(0, 0, 0, 0.4) 0px 1px 1.1px);">
          <g transform="translate(2 3)">
            <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z" style="stroke-width: 2px; stroke: white;"></path>
            <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z"></path>
          </g>
        </svg>`;
    doc.body.appendChild(el);
  }
});
function connect13(state2, send, normalize2) {
  const focused = state2.hasTag("focus");
  const disabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  const empty2 = state2.context.isValueEmpty;
  const invalid = state2.context.isOutOfRange || !!state2.context.invalid;
  const isIncrementDisabled = disabled || !state2.context.canIncrement || readOnly;
  const isDecrementDisabled = disabled || !state2.context.canDecrement || readOnly;
  const translations = state2.context.translations;
  return {
    focused,
    invalid,
    empty: empty2,
    value: state2.context.formattedValue,
    valueAsNumber: state2.context.valueAsNumber,
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    clearValue() {
      send("VALUE.CLEAR");
    },
    increment() {
      send("VALUE.INCREMENT");
    },
    decrement() {
      send("VALUE.DECREMENT");
    },
    setToMax() {
      send({ type: "VALUE.SET", value: state2.context.max });
    },
    setToMin() {
      send({ type: "VALUE.SET", value: state2.context.min });
    },
    focus() {
      var _a7;
      (_a7 = dom48.getInputEl(state2.context)) == null ? void 0 : _a7.focus();
    },
    getRootProps() {
      return normalize2.element({
        id: dom48.getRootId(state2.context),
        ...parts50.root.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid)
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts50.label.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid),
        id: dom48.getLabelId(state2.context),
        htmlFor: dom48.getInputId(state2.context)
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts50.control.attrs,
        dir: state2.context.dir,
        role: "group",
        "aria-disabled": disabled,
        "data-focus": dataAttr(focused),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "aria-invalid": ariaAttr(state2.context.invalid)
      });
    },
    getValueTextProps() {
      return normalize2.element({
        ...parts50.valueText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused)
      });
    },
    getInputProps() {
      return normalize2.input({
        ...parts50.input.attrs,
        dir: state2.context.dir,
        name: state2.context.name,
        form: state2.context.form,
        id: dom48.getInputId(state2.context),
        role: "spinbutton",
        defaultValue: state2.context.formattedValue,
        pattern: state2.context.pattern,
        inputMode: state2.context.inputMode,
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        disabled,
        "data-disabled": dataAttr(disabled),
        readOnly: state2.context.readOnly,
        required: state2.context.required,
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false",
        type: "text",
        "aria-roledescription": "numberfield",
        "aria-valuemin": state2.context.min,
        "aria-valuemax": state2.context.max,
        "aria-valuenow": Number.isNaN(state2.context.valueAsNumber) ? void 0 : state2.context.valueAsNumber,
        "aria-valuetext": state2.context.valueText,
        onFocus() {
          send("INPUT.FOCUS");
        },
        onBlur() {
          send("INPUT.BLUR");
        },
        onChange(event) {
          send({ type: "INPUT.CHANGE", target: event.currentTarget, hint: "set" });
        },
        onBeforeInput(event) {
          try {
            const { selectionStart, selectionEnd, value } = event.currentTarget;
            const nextValue = value.slice(0, selectionStart) + (event.data ?? "") + value.slice(selectionEnd);
            const isValid = state2.context.parser.isValidPartialNumber(nextValue);
            if (!isValid) {
              event.preventDefault();
            }
          } catch {
          }
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (readOnly) return;
          if (isComposingEvent(event)) return;
          const step = getEventStep2(event) * state2.context.step;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "INPUT.ARROW_UP", step });
              event.preventDefault();
            },
            ArrowDown() {
              send({ type: "INPUT.ARROW_DOWN", step });
              event.preventDefault();
            },
            Home() {
              if (isModifierKey2(event)) return;
              send("INPUT.HOME");
              event.preventDefault();
            },
            End() {
              if (isModifierKey2(event)) return;
              send("INPUT.END");
              event.preventDefault();
            },
            Enter() {
              send("INPUT.ENTER");
            }
          };
          const exec21 = keyMap2[event.key];
          exec21 == null ? void 0 : exec21(event);
        }
      });
    },
    getDecrementTriggerProps() {
      return normalize2.button({
        ...parts50.decrementTrigger.attrs,
        dir: state2.context.dir,
        id: dom48.getDecrementTriggerId(state2.context),
        disabled: isDecrementDisabled,
        "data-disabled": dataAttr(isDecrementDisabled),
        "aria-label": translations.decrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": dom48.getInputId(state2.context),
        onPointerDown(event) {
          var _a7;
          if (isDecrementDisabled || !isLeftClick2(event)) return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "decrement", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            (_a7 = event.currentTarget) == null ? void 0 : _a7.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement", pointerType: event.pointerType });
        },
        onPointerLeave() {
          if (isDecrementDisabled) return;
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement" });
        }
      });
    },
    getIncrementTriggerProps() {
      return normalize2.button({
        ...parts50.incrementTrigger.attrs,
        dir: state2.context.dir,
        id: dom48.getIncrementTriggerId(state2.context),
        disabled: isIncrementDisabled,
        "data-disabled": dataAttr(isIncrementDisabled),
        "aria-label": translations.incrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": dom48.getInputId(state2.context),
        onPointerDown(event) {
          var _a7;
          if (isIncrementDisabled || !isLeftClick2(event)) return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "increment", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            (_a7 = event.currentTarget) == null ? void 0 : _a7.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        },
        onPointerLeave(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        }
      });
    },
    getScrubberProps() {
      return normalize2.element({
        ...parts50.scrubber.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        id: dom48.getScrubberId(state2.context),
        role: "presentation",
        onMouseDown(event) {
          if (disabled) return;
          const point = getEventPoint2(event);
          point.x = point.x - roundToDevicePixel2(7.5);
          point.y = point.y - roundToDevicePixel2(7.5);
          send({ type: "SCRUBBER.PRESS_DOWN", point });
          event.preventDefault();
        },
        style: {
          cursor: disabled ? void 0 : "ew-resize"
        }
      });
    }
  };
}
function recordCursor(inputEl) {
  if (inputEl.ownerDocument.activeElement !== inputEl) return;
  try {
    const { selectionStart: start, selectionEnd: end, value } = inputEl;
    const beforeTxt = value.substring(0, start);
    const afterTxt = value.substring(end);
    return {
      start,
      end,
      value,
      beforeTxt,
      afterTxt
    };
  } catch {
  }
}
function restoreCursor(inputEl, selection) {
  if (inputEl.ownerDocument.activeElement !== inputEl) return;
  if (!selection) {
    inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
    return;
  }
  try {
    const { value } = inputEl;
    const { beforeTxt = "", afterTxt = "", start } = selection;
    let startPos = value.length;
    if (value.endsWith(afterTxt)) {
      startPos = value.length - afterTxt.length;
    } else if (value.startsWith(beforeTxt)) {
      startPos = beforeTxt.length;
    } else if (start != null) {
      const beforeLastChar = beforeTxt[start - 1];
      const newIndex = value.indexOf(beforeLastChar, start - 1);
      if (newIndex !== -1) {
        startPos = newIndex + 1;
      }
    }
    inputEl.setSelectionRange(startPos, startPos);
  } catch {
  }
}
var createFormatter = (locale, options = {}) => {
  return ref35(new Intl.NumberFormat(locale, options));
};
var createParser = (locale, options = {}) => {
  return ref35(new $6c7bd7858deea686$export$cd11ab140839f11d(locale, options));
};
var parseValue = (ctx, value) => {
  if (!ctx.formatOptions) return parseFloat(value);
  return ctx.parser.parse(String(value));
};
var formatValue = (ctx, value) => {
  if (Number.isNaN(value)) return "";
  if (!ctx.formatOptions) return value.toString();
  return ctx.formatter.format(value);
};
var { not: not40, and: and40 } = guards20;
function machine13(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "number-input",
      initial: "idle",
      context: {
        dir: "ltr",
        locale: "en-US",
        focusInputOnChange: true,
        clampValueOnBlur: true,
        allowOverflow: false,
        inputMode: "decimal",
        pattern: "[0-9]*(.[0-9]+)?",
        value: "",
        step: 1,
        min: Number.MIN_SAFE_INTEGER,
        max: Number.MAX_SAFE_INTEGER,
        invalid: false,
        spinOnPress: true,
        disabled: false,
        readOnly: false,
        ...ctx,
        hint: null,
        scrubberCursorPoint: null,
        fieldsetDisabled: false,
        formatter: createFormatter(ctx.locale || "en-US", ctx.formatOptions),
        parser: createParser(ctx.locale || "en-US", ctx.formatOptions),
        translations: {
          incrementLabel: "increment value",
          decrementLabel: "decrease value",
          ...ctx.translations
        }
      },
      computed: {
        isRtl: (ctx2) => ctx2.dir === "rtl",
        valueAsNumber: (ctx2) => parseValue(ctx2, ctx2.value),
        formattedValue: (ctx2) => formatValue(ctx2, ctx2.valueAsNumber),
        isAtMin: (ctx2) => isAtMin2(ctx2.valueAsNumber, ctx2),
        isAtMax: (ctx2) => isAtMax2(ctx2.valueAsNumber, ctx2),
        isOutOfRange: (ctx2) => !isWithinRange2(ctx2.valueAsNumber, ctx2),
        isValueEmpty: (ctx2) => ctx2.value === "",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        canIncrement: (ctx2) => ctx2.allowOverflow || !ctx2.isAtMax,
        canDecrement: (ctx2) => ctx2.allowOverflow || !ctx2.isAtMin,
        valueText: (ctx2) => {
          var _a7, _b6;
          return (_b6 = (_a7 = ctx2.translations).valueText) == null ? void 0 : _b6.call(_a7, ctx2.value);
        }
      },
      watch: {
        formatOptions: ["setFormatterAndParser", "syncInputElement"],
        locale: ["setFormatterAndParser", "syncInputElement"],
        value: ["syncInputElement"],
        isOutOfRange: ["invokeOnInvalid"],
        scrubberCursorPoint: ["setVirtualCursorPosition"]
      },
      activities: ["trackFormControl"],
      on: {
        "VALUE.SET": {
          actions: ["setRawValue", "setHintToSet"]
        },
        "VALUE.CLEAR": {
          actions: ["clearValue"]
        },
        "VALUE.INCREMENT": {
          actions: ["increment"]
        },
        "VALUE.DECREMENT": {
          actions: ["decrement"]
        }
      },
      states: {
        idle: {
          on: {
            "TRIGGER.PRESS_DOWN": [
              { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
              {
                target: "before:spin",
                actions: ["focusInput", "invokeOnFocus", "setHint"]
              }
            ],
            "SCRUBBER.PRESS_DOWN": {
              target: "scrubbing",
              actions: ["focusInput", "invokeOnFocus", "setHint", "setCursorPoint"]
            },
            "INPUT.FOCUS": {
              target: "focused",
              actions: ["focusInput", "invokeOnFocus"]
            }
          }
        },
        focused: {
          tags: "focus",
          activities: "attachWheelListener",
          on: {
            "TRIGGER.PRESS_DOWN": [
              { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
              { target: "before:spin", actions: ["focusInput", "setHint"] }
            ],
            "SCRUBBER.PRESS_DOWN": {
              target: "scrubbing",
              actions: ["focusInput", "setHint", "setCursorPoint"]
            },
            "INPUT.ARROW_UP": {
              actions: "increment"
            },
            "INPUT.ARROW_DOWN": {
              actions: "decrement"
            },
            "INPUT.HOME": {
              actions: "decrementToMin"
            },
            "INPUT.END": {
              actions: "incrementToMax"
            },
            "INPUT.CHANGE": {
              actions: ["setValue", "setHint"]
            },
            "INPUT.BLUR": [
              {
                guard: and40("clampValueOnBlur", not40("isInRange")),
                target: "idle",
                actions: ["setClampedValue", "clearHint", "invokeOnBlur"]
              },
              {
                target: "idle",
                actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
              }
            ],
            "INPUT.ENTER": {
              actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
            }
          }
        },
        "before:spin": {
          tags: "focus",
          activities: "trackButtonDisabled",
          entry: choose3([
            { guard: "isIncrementHint", actions: "increment" },
            { guard: "isDecrementHint", actions: "decrement" }
          ]),
          after: {
            CHANGE_DELAY: {
              target: "spinning",
              guard: and40("isInRange", "spinOnPress")
            }
          },
          on: {
            "TRIGGER.PRESS_UP": [
              { guard: "isTouchPointer", target: "focused", actions: "clearHint" },
              { target: "focused", actions: ["focusInput", "clearHint"] }
            ]
          }
        },
        spinning: {
          tags: "focus",
          activities: "trackButtonDisabled",
          every: [
            {
              delay: "CHANGE_INTERVAL",
              guard: and40(not40("isAtMin"), "isIncrementHint"),
              actions: "increment"
            },
            {
              delay: "CHANGE_INTERVAL",
              guard: and40(not40("isAtMax"), "isDecrementHint"),
              actions: "decrement"
            }
          ],
          on: {
            "TRIGGER.PRESS_UP": {
              target: "focused",
              actions: ["focusInput", "clearHint"]
            }
          }
        },
        scrubbing: {
          tags: "focus",
          activities: ["activatePointerLock", "trackMousemove", "setupVirtualCursor", "preventTextSelection"],
          on: {
            "SCRUBBER.POINTER_UP": {
              target: "focused",
              actions: ["focusInput", "clearCursorPoint"]
            },
            "SCRUBBER.POINTER_MOVE": [
              {
                guard: "isIncrementHint",
                actions: ["increment", "setCursorPoint"]
              },
              {
                guard: "isDecrementHint",
                actions: ["decrement", "setCursorPoint"]
              }
            ]
          }
        }
      }
    },
    {
      delays: {
        CHANGE_INTERVAL: 50,
        CHANGE_DELAY: 300
      },
      guards: {
        clampValueOnBlur: (ctx2) => ctx2.clampValueOnBlur,
        isAtMin: (ctx2) => ctx2.isAtMin,
        spinOnPress: (ctx2) => !!ctx2.spinOnPress,
        isAtMax: (ctx2) => ctx2.isAtMax,
        isInRange: (ctx2) => !ctx2.isOutOfRange,
        isDecrementHint: (ctx2, evt) => (evt.hint ?? ctx2.hint) === "decrement",
        isIncrementHint: (ctx2, evt) => (evt.hint ?? ctx2.hint) === "increment",
        isTouchPointer: (_ctx, evt) => evt.pointerType === "touch"
      },
      activities: {
        trackFormControl(ctx2, _evt, { initialContext }) {
          const inputEl = dom48.getInputEl(ctx2);
          return trackFormControl2(inputEl, {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set8.value(ctx2, initialContext.value);
            }
          });
        },
        setupVirtualCursor(ctx2) {
          return dom48.setupVirtualCursor(ctx2);
        },
        preventTextSelection(ctx2) {
          return dom48.preventTextSelection(ctx2);
        },
        trackButtonDisabled(ctx2, _evt, { send }) {
          const btn = dom48.getPressedTriggerEl(ctx2, ctx2.hint);
          return observeAttributes(btn, {
            attributes: ["disabled"],
            callback() {
              send({ type: "TRIGGER.PRESS_UP", src: "attr" });
            }
          });
        },
        attachWheelListener(ctx2, _evt, { send }) {
          const inputEl = dom48.getInputEl(ctx2);
          if (!inputEl || !dom48.isActiveElement(ctx2, inputEl) || !ctx2.allowMouseWheel) return;
          function onWheel(event) {
            event.preventDefault();
            const dir = Math.sign(event.deltaY) * -1;
            if (dir === 1) {
              send("VALUE.INCREMENT");
            } else if (dir === -1) {
              send("VALUE.DECREMENT");
            }
          }
          return addDomEvent2(inputEl, "wheel", onWheel, { passive: false });
        },
        activatePointerLock(ctx2) {
          if (isSafari()) return;
          return requestPointerLock2(dom48.getDoc(ctx2));
        },
        trackMousemove(ctx2, _evt, { send }) {
          const doc = dom48.getDoc(ctx2);
          function onMousemove(event) {
            if (!ctx2.scrubberCursorPoint) return;
            const value = dom48.getMousementValue(ctx2, event);
            if (!value.hint) return;
            send({
              type: "SCRUBBER.POINTER_MOVE",
              hint: value.hint,
              point: value.point
            });
          }
          function onMouseup() {
            send("SCRUBBER.POINTER_UP");
          }
          return callAll4(
            addDomEvent2(doc, "mousemove", onMousemove, false),
            addDomEvent2(doc, "mouseup", onMouseup, false)
          );
        }
      },
      actions: {
        focusInput(ctx2) {
          if (!ctx2.focusInputOnChange) return;
          const inputEl = dom48.getInputEl(ctx2);
          if (dom48.isActiveElement(ctx2, inputEl)) return;
          raf(() => inputEl == null ? void 0 : inputEl.focus({ preventScroll: true }));
        },
        increment(ctx2, evt) {
          const nextValue = increment2(ctx2.valueAsNumber, evt.step ?? ctx2.step);
          const value = formatValue(ctx2, clamp5(nextValue, ctx2));
          set8.value(ctx2, value);
        },
        decrement(ctx2, evt) {
          const nextValue = decrement2(ctx2.valueAsNumber, evt.step ?? ctx2.step);
          const value = formatValue(ctx2, clamp5(nextValue, ctx2));
          set8.value(ctx2, value);
        },
        setClampedValue(ctx2) {
          const nextValue = clamp5(ctx2.valueAsNumber, ctx2);
          set8.value(ctx2, formatValue(ctx2, nextValue));
        },
        setRawValue(ctx2, evt) {
          const parsedValue = parseValue(ctx2, evt.value);
          const value = formatValue(ctx2, clamp5(parsedValue, ctx2));
          set8.value(ctx2, value);
        },
        setValue(ctx2, evt) {
          var _a7;
          const value = ((_a7 = evt.target) == null ? void 0 : _a7.value) ?? evt.value;
          set8.value(ctx2, value);
        },
        clearValue(ctx2) {
          set8.value(ctx2, "");
        },
        incrementToMax(ctx2) {
          const value = formatValue(ctx2, ctx2.max);
          set8.value(ctx2, value);
        },
        decrementToMin(ctx2) {
          const value = formatValue(ctx2, ctx2.min);
          set8.value(ctx2, value);
        },
        setHint(ctx2, evt) {
          ctx2.hint = evt.hint;
        },
        clearHint(ctx2) {
          ctx2.hint = null;
        },
        setHintToSet(ctx2) {
          ctx2.hint = "set";
        },
        invokeOnFocus(ctx2) {
          var _a7;
          (_a7 = ctx2.onFocusChange) == null ? void 0 : _a7.call(ctx2, {
            focused: true,
            value: ctx2.formattedValue,
            valueAsNumber: ctx2.valueAsNumber
          });
        },
        invokeOnBlur(ctx2) {
          var _a7;
          (_a7 = ctx2.onFocusChange) == null ? void 0 : _a7.call(ctx2, {
            focused: false,
            value: ctx2.formattedValue,
            valueAsNumber: ctx2.valueAsNumber
          });
        },
        invokeOnInvalid(ctx2) {
          var _a7;
          if (!ctx2.isOutOfRange) return;
          const reason = ctx2.valueAsNumber > ctx2.max ? "rangeOverflow" : "rangeUnderflow";
          (_a7 = ctx2.onValueInvalid) == null ? void 0 : _a7.call(ctx2, {
            reason,
            value: ctx2.formattedValue,
            valueAsNumber: ctx2.valueAsNumber
          });
        },
        syncInputElement(ctx2, evt) {
          const value = evt.type.endsWith("CHANGE") ? ctx2.value : ctx2.formattedValue;
          sync2.input(ctx2, value);
        },
        setFormattedValue(ctx2) {
          set8.value(ctx2, ctx2.formattedValue);
        },
        setCursorPoint(ctx2, evt) {
          ctx2.scrubberCursorPoint = evt.point;
        },
        clearCursorPoint(ctx2) {
          ctx2.scrubberCursorPoint = null;
        },
        setVirtualCursorPosition(ctx2) {
          const cursorEl = dom48.getCursorEl(ctx2);
          if (!cursorEl || !ctx2.scrubberCursorPoint) return;
          const { x, y } = ctx2.scrubberCursorPoint;
          cursorEl.style.transform = `translate3d(${x}px, ${y}px, 0px)`;
        },
        setFormatterAndParser(ctx2) {
          if (!ctx2.locale) return;
          ctx2.formatter = createFormatter(ctx2.locale, ctx2.formatOptions);
          ctx2.parser = createParser(ctx2.locale, ctx2.formatOptions);
        }
      },
      compareFns: {
        formatOptions: (a, b) => isEqual3(a, b),
        scrubberCursorPoint: (a, b) => isEqual3(a, b)
      }
    }
  );
}
var sync2 = {
  input(ctx, value) {
    const inputEl = dom48.getInputEl(ctx);
    if (!inputEl) return;
    const sel = recordCursor(inputEl);
    raf(() => {
      dom48.setValue(inputEl, value);
      restoreCursor(inputEl, sel);
    });
  }
};
var invoke5 = {
  onChange: (ctx) => {
    var _a7;
    (_a7 = ctx.onValueChange) == null ? void 0 : _a7.call(ctx, {
      value: ctx.value,
      valueAsNumber: ctx.valueAsNumber
    });
  }
};
var set8 = {
  value: (ctx, value) => {
    if (isEqual3(ctx.value, value)) return;
    ctx.value = value;
    invoke5.onChange(ctx);
  }
};

// node_modules/@ark-ui/react/dist/components/number-input/use-number-input.js
var import_react310 = __toESM(require_react(), 1);
var useNumberInput = (props52 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react310.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      input: field == null ? void 0 : field.ids.control
    },
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    invalid: field == null ? void 0 : field.invalid,
    dir,
    getRootNode: getRootNode2,
    value: props52.defaultValue,
    ...props52
  };
  const context = {
    ...initialContext,
    value: props52.value,
    onValueChange: useEvent(props52.onValueChange, { sync: true }),
    onValueInvalid: useEvent(props52.onValueInvalid),
    onFocusChange: useEvent(props52.onFocusChange)
  };
  const [state2, send] = useMachine(machine13(initialContext), { context });
  return connect13(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/number-input/number-input-root.js
var NumberInputRoot = (0, import_react312.forwardRef)((props52, ref36) => {
  const [useNumberInputProps, localProps] = createSplitProps3()(props52, [
    "allowMouseWheel",
    "allowOverflow",
    "clampValueOnBlur",
    "defaultValue",
    "disabled",
    "focusInputOnChange",
    "form",
    "formatOptions",
    "id",
    "ids",
    "inputMode",
    "invalid",
    "locale",
    "max",
    "min",
    "name",
    "onFocusChange",
    "onValueChange",
    "onValueInvalid",
    "pattern",
    "readOnly",
    "required",
    "spinOnPress",
    "step",
    "translations",
    "value"
  ]);
  const numberInput = useNumberInput(useNumberInputProps);
  const mergedProps = mergeProps3(numberInput.getRootProps(), localProps);
  return (0, import_jsx_runtime160.jsx)(NumberInputProvider, { value: numberInput, children: (0, import_jsx_runtime160.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
});
NumberInputRoot.displayName = "NumberInputRoot";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-root-provider.js
var import_jsx_runtime161 = __toESM(require_jsx_runtime(), 1);
var import_react314 = __toESM(require_react(), 1);
var NumberInputRootProvider = (0, import_react314.forwardRef)(
  (props52, ref36) => {
    const [{ value: numberInput }, localProps] = createSplitProps3()(props52, [
      "value"
    ]);
    const mergedProps = mergeProps3(numberInput.getRootProps(), localProps);
    return (0, import_jsx_runtime161.jsx)(NumberInputProvider, { value: numberInput, children: (0, import_jsx_runtime161.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
  }
);
NumberInputRootProvider.displayName = "NumberInputRootProvider";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-scrubber.js
var import_jsx_runtime162 = __toESM(require_jsx_runtime(), 1);
var import_react316 = __toESM(require_react(), 1);
var NumberInputScrubber = (0, import_react316.forwardRef)(
  (props52, ref36) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps3(numberInput.getScrubberProps(), props52);
    return (0, import_jsx_runtime162.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
NumberInputScrubber.displayName = "NumberInputScrubber";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-value-text.js
var import_jsx_runtime163 = __toESM(require_jsx_runtime(), 1);
var import_react318 = __toESM(require_react(), 1);
var NumberInputValueText = (0, import_react318.forwardRef)(
  (props52, ref36) => {
    const { children, ...localProps } = props52;
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps3(numberInput.getValueTextProps(), localProps);
    return (0, import_jsx_runtime163.jsx)(ark.span, { ...mergedProps, ref: ref36, children: children || numberInput.value });
  }
);
NumberInputValueText.displayName = "NumberInputValueText";

// node_modules/@ark-ui/react/dist/components/number-input/number-input.js
var number_input_exports = {};
__export(number_input_exports, {
  Context: () => NumberInputContext,
  Control: () => NumberInputControl,
  DecrementTrigger: () => NumberInputDecrementTrigger,
  IncrementTrigger: () => NumberInputIncrementTrigger,
  Input: () => NumberInputInput,
  Label: () => NumberInputLabel,
  Root: () => NumberInputRoot,
  RootProvider: () => NumberInputRootProvider,
  Scrubber: () => NumberInputScrubber,
  ValueText: () => NumberInputValueText
});

// node_modules/@chakra-ui/react/dist/esm/components/number-input/number-input.js
var {
  withProvider: withProvider19,
  withContext: withContext32,
  useStyles: useNumberInputStyles,
  PropsProvider: PropsProvider31
} = createSlotRecipeContext({ key: "numberInput" });
var NumberInputRootProvider2 = withProvider19(number_input_exports.RootProvider, "root", { forwardAsChild: true });
var NumberInputRoot2 = withProvider19(number_input_exports.Root, "root", { forwardAsChild: true });
var NumberInputPropsProvider = PropsProvider31;
var NumberInputControl2 = withContext32(number_input_exports.Control, "control", { forwardAsChild: true });
var NumberInputLabel2 = withContext32(number_input_exports.Label, "label", { forwardAsChild: true });
var NumberInputInput2 = withContext32(number_input_exports.Input, "input", { forwardAsChild: true });
var NumberInputIncrementTrigger2 = withContext32(number_input_exports.IncrementTrigger, "incrementTrigger", {
  forwardAsChild: true,
  defaultProps: { children: (0, import_jsx_runtime164.jsx)(ChevronUpIcon, {}) }
});
var NumberInputDecrementTrigger2 = withContext32(number_input_exports.DecrementTrigger, "decrementTrigger", {
  forwardAsChild: true,
  defaultProps: { children: (0, import_jsx_runtime164.jsx)(ChevronDownIcon, {}) }
});
var NumberInputScrubber2 = withContext32(number_input_exports.Scrubber, "scrubber", { forwardAsChild: true });
var NumberInputValueText2 = withContext32(number_input_exports.ValueText, "valueText", { forwardAsChild: true });
var NumberInputContext2 = number_input_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/number-input/namespace.js
var namespace_exports24 = {};
__export(namespace_exports24, {
  Context: () => NumberInputContext2,
  Control: () => NumberInputControl2,
  DecrementTrigger: () => NumberInputDecrementTrigger2,
  IncrementTrigger: () => NumberInputIncrementTrigger2,
  Input: () => NumberInputInput2,
  Label: () => NumberInputLabel2,
  PropsProvider: () => NumberInputPropsProvider,
  Root: () => NumberInputRoot2,
  RootProvider: () => NumberInputRootProvider2,
  Scrubber: () => NumberInputScrubber2,
  ValueText: () => NumberInputValueText2
});

// node_modules/@ark-ui/react/dist/components/pagination/use-pagination-context.js
var [PaginationProvider, usePaginationContext] = createContext({
  name: "PaginationContext",
  hookName: "usePaginationContext",
  providerName: "<PaginationProvider />"
});

// node_modules/@ark-ui/react/dist/components/pagination/pagination-context.js
var PaginationContext = (props52) => props52.children(usePaginationContext());

// node_modules/@ark-ui/react/dist/components/pagination/pagination-ellipsis.js
var import_jsx_runtime165 = __toESM(require_jsx_runtime(), 1);
var import_react320 = __toESM(require_react(), 1);
var PaginationEllipsis = (0, import_react320.forwardRef)(
  (props52, ref36) => {
    const [ellipsisProps3, localProps] = createSplitProps3()(props52, ["index"]);
    const pagination = usePaginationContext();
    const mergedProps = mergeProps3(pagination.getEllipsisProps(ellipsisProps3), localProps);
    return (0, import_jsx_runtime165.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
PaginationEllipsis.displayName = "PaginationEllipsis";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-item.js
var import_jsx_runtime166 = __toESM(require_jsx_runtime(), 1);
var import_react322 = __toESM(require_react(), 1);
var PaginationItem = (0, import_react322.forwardRef)((props52, ref36) => {
  const [itemProps17, localProps] = createSplitProps3()(props52, ["value", "type"]);
  const pagination = usePaginationContext();
  const mergedProps = mergeProps3(pagination.getItemProps(itemProps17), localProps);
  return (0, import_jsx_runtime166.jsx)(ark.button, { ...mergedProps, ref: ref36 });
});
PaginationItem.displayName = "PaginationItem";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-next-trigger.js
var import_jsx_runtime167 = __toESM(require_jsx_runtime(), 1);
var import_react324 = __toESM(require_react(), 1);
var PaginationNextTrigger = (0, import_react324.forwardRef)(
  (props52, ref36) => {
    const pagination = usePaginationContext();
    const mergedProps = mergeProps3(pagination.getNextTriggerProps(), props52);
    return (0, import_jsx_runtime167.jsx)(ark.button, { ...mergedProps, ref: ref36 });
  }
);
PaginationNextTrigger.displayName = "PaginationNextTrigger";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-prev-trigger.js
var import_jsx_runtime168 = __toESM(require_jsx_runtime(), 1);
var import_react326 = __toESM(require_react(), 1);
var PaginationPrevTrigger = (0, import_react326.forwardRef)(
  (props52, ref36) => {
    const pagination = usePaginationContext();
    const mergedProps = mergeProps3(pagination.getPrevTriggerProps(), props52);
    return (0, import_jsx_runtime168.jsx)(ark.button, { ...mergedProps, ref: ref36 });
  }
);
PaginationPrevTrigger.displayName = "PaginationPrevTrigger";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-root.js
var import_jsx_runtime169 = __toESM(require_jsx_runtime(), 1);
var import_react330 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/node_modules/@zag-js/pagination/dist/index.mjs
var anatomy56 = createAnatomy2("pagination").parts("root", "item", "ellipsis", "prevTrigger", "nextTrigger");
var parts51 = anatomy56.build();
var dom49 = createScope({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `pagination:${ctx.id}`;
  },
  getPrevTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.prevTrigger) ?? `pagination:${ctx.id}:prev`;
  },
  getNextTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.nextTrigger) ?? `pagination:${ctx.id}:next`;
  },
  getEllipsisId: (ctx, index) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.ellipsis) == null ? void 0 : _b6.call(_a7, index)) ?? `pagination:${ctx.id}:ellipsis:${index}`;
  },
  getItemId: (ctx, page) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.item) == null ? void 0 : _b6.call(_a7, page)) ?? `pagination:${ctx.id}:item:${page}`;
  }
});
var range = (start, end) => {
  let length2 = end - start + 1;
  return Array.from({ length: length2 }, (_, idx) => idx + start);
};
var transform = (items) => {
  return items.map((value) => {
    if (typeof value === "number") return { type: "page", value };
    return { type: "ellipsis" };
  });
};
var ELLIPSIS = "ellipsis";
var getRange = (ctx) => {
  const totalPageNumbers = Math.min(2 * ctx.siblingCount + 5, ctx.totalPages);
  const firstPageIndex = 1;
  const lastPageIndex = ctx.totalPages;
  const leftSiblingIndex = Math.max(ctx.page - ctx.siblingCount, firstPageIndex);
  const rightSiblingIndex = Math.min(ctx.page + ctx.siblingCount, lastPageIndex);
  const showLeftEllipsis = leftSiblingIndex > firstPageIndex + 1;
  const showRightEllipsis = rightSiblingIndex < lastPageIndex - 1;
  const itemCount = totalPageNumbers - 2;
  if (!showLeftEllipsis && showRightEllipsis) {
    const leftRange = range(1, itemCount);
    return [...leftRange, ELLIPSIS, lastPageIndex];
  }
  if (showLeftEllipsis && !showRightEllipsis) {
    const rightRange = range(lastPageIndex - itemCount + 1, lastPageIndex);
    return [firstPageIndex, ELLIPSIS, ...rightRange];
  }
  if (showLeftEllipsis && showRightEllipsis) {
    const middleRange = range(leftSiblingIndex, rightSiblingIndex);
    return [firstPageIndex, ELLIPSIS, ...middleRange, ELLIPSIS, lastPageIndex];
  }
  const fullRange = range(firstPageIndex, lastPageIndex);
  return fullRange;
};
var getTransformedRange = (ctx) => transform(getRange(ctx));
function connect14(state2, send, normalize2) {
  const totalPages = state2.context.totalPages;
  const page = state2.context.page;
  const translations = state2.context.translations;
  const count = state2.context.count;
  const previousPage = state2.context.previousPage;
  const nextPage = state2.context.nextPage;
  const pageRange = state2.context.pageRange;
  const type = state2.context.type;
  const isButton = type === "button";
  const isFirstPage = page === 1;
  const isLastPage = page === totalPages;
  const pages = getTransformedRange(state2.context);
  return {
    count,
    page,
    pageSize: state2.context.pageSize,
    totalPages,
    pages,
    previousPage,
    nextPage,
    pageRange,
    slice(data) {
      return data.slice(pageRange.start, pageRange.end);
    },
    setCount(count2) {
      send({ type: "SET_COUNT", count: count2 });
    },
    setPageSize(size4) {
      send({ type: "SET_PAGE_SIZE", size: size4 });
    },
    setPage(page2) {
      send({ type: "SET_PAGE", page: page2 });
    },
    goToNextPage() {
      send({ type: "NEXT_PAGE" });
    },
    goToPrevPage() {
      send({ type: "PREVIOUS_PAGE" });
    },
    goToFirstPage() {
      send({ type: "FIRST_PAGE" });
    },
    goToLastPage() {
      send({ type: "LAST_PAGE" });
    },
    getRootProps() {
      return normalize2.element({
        id: dom49.getRootId(state2.context),
        ...parts51.root.attrs,
        dir: state2.context.dir,
        "aria-label": translations.rootLabel
      });
    },
    getEllipsisProps(props210) {
      return normalize2.element({
        id: dom49.getEllipsisId(state2.context, props210.index),
        ...parts51.ellipsis.attrs,
        dir: state2.context.dir
      });
    },
    getItemProps(props210) {
      var _a7;
      const index = props210.value;
      const isCurrentPage = index === state2.context.page;
      return normalize2.element({
        id: dom49.getItemId(state2.context, index),
        ...parts51.item.attrs,
        dir: state2.context.dir,
        "data-index": index,
        "data-selected": dataAttr(isCurrentPage),
        "aria-current": isCurrentPage ? "page" : void 0,
        "aria-label": (_a7 = translations.itemLabel) == null ? void 0 : _a7.call(translations, { page: index, totalPages }),
        onClick() {
          send({ type: "SET_PAGE", page: index });
        },
        ...isButton && { type: "button" }
      });
    },
    getPrevTriggerProps() {
      return normalize2.element({
        id: dom49.getPrevTriggerId(state2.context),
        ...parts51.prevTrigger.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(isFirstPage),
        "aria-label": translations.prevTriggerLabel,
        onClick() {
          send({ type: "PREVIOUS_PAGE" });
        },
        ...isButton && { disabled: isFirstPage, type: "button" }
      });
    },
    getNextTriggerProps() {
      return normalize2.element({
        id: dom49.getNextTriggerId(state2.context),
        ...parts51.nextTrigger.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(isLastPage),
        "aria-label": translations.nextTriggerLabel,
        onClick() {
          send({ type: "NEXT_PAGE" });
        },
        ...isButton && { disabled: isLastPage, type: "button" }
      });
    }
  };
}
var defaultTranslations = {
  rootLabel: "pagination",
  prevTriggerLabel: "previous page",
  nextTriggerLabel: "next page",
  itemLabel({ page, totalPages }) {
    const isLastPage = totalPages > 1 && page === totalPages;
    return `${isLastPage ? "last page, " : ""}page ${page}`;
  }
};
function machine14(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "pagination",
      initial: "idle",
      context: {
        pageSize: 10,
        siblingCount: 1,
        page: 1,
        type: "button",
        translations: {
          ...defaultTranslations,
          ...ctx.translations
        },
        ...ctx
      },
      watch: {
        pageSize: ["setPageIfNeeded"]
      },
      computed: {
        totalPages: (ctx2) => Math.ceil(ctx2.count / ctx2.pageSize),
        previousPage: (ctx2) => ctx2.page === 1 ? null : ctx2.page - 1,
        nextPage: (ctx2) => ctx2.page === ctx2.totalPages ? null : ctx2.page + 1,
        pageRange: (ctx2) => {
          const start = (ctx2.page - 1) * ctx2.pageSize;
          const end = start + ctx2.pageSize;
          return { start, end };
        },
        isValidPage: (ctx2) => ctx2.page >= 1 && ctx2.page <= ctx2.totalPages
      },
      on: {
        SET_COUNT: [
          {
            guard: "isValidCount",
            actions: ["setCount", "goToFirstPage"]
          },
          {
            actions: "setCount"
          }
        ],
        SET_PAGE: {
          guard: "isValidPage",
          actions: "setPage"
        },
        SET_PAGE_SIZE: {
          actions: "setPageSize"
        },
        FIRST_PAGE: {
          actions: "goToFirstPage"
        },
        LAST_PAGE: {
          actions: "goToLastPage"
        },
        PREVIOUS_PAGE: {
          guard: "canGoToPrevPage",
          actions: "goToPrevPage"
        },
        NEXT_PAGE: {
          guard: "canGoToNextPage",
          actions: "goToNextPage"
        }
      },
      states: {
        idle: {}
      }
    },
    {
      guards: {
        isValidPage: (ctx2, evt) => evt.page >= 1 && evt.page <= ctx2.totalPages,
        isValidCount: (ctx2, evt) => ctx2.page > evt.count,
        canGoToNextPage: (ctx2) => ctx2.page < ctx2.totalPages,
        canGoToPrevPage: (ctx2) => ctx2.page > 1
      },
      actions: {
        setCount(ctx2, evt) {
          ctx2.count = evt.count;
        },
        setPage(ctx2, evt) {
          set9.page(ctx2, evt.page);
        },
        setPageSize(ctx2, evt) {
          set9.pageSize(ctx2, evt.size);
        },
        goToFirstPage(ctx2) {
          set9.page(ctx2, 1);
        },
        goToLastPage(ctx2) {
          set9.page(ctx2, ctx2.totalPages);
        },
        goToPrevPage(ctx2) {
          set9.page(ctx2, ctx2.page - 1);
        },
        goToNextPage(ctx2) {
          set9.page(ctx2, ctx2.page + 1);
        },
        setPageIfNeeded(ctx2, _evt) {
          if (ctx2.isValidPage) return;
          set9.page(ctx2, 1);
        }
      }
    }
  );
}
var clampPage = (page, totalPages) => Math.min(Math.max(page, 1), totalPages);
var set9 = {
  pageSize: (ctx, value) => {
    var _a7;
    if (isEqual3(ctx.pageSize, value)) return;
    ctx.pageSize = value;
    (_a7 = ctx.onPageSizeChange) == null ? void 0 : _a7.call(ctx, { pageSize: ctx.pageSize });
  },
  page: (ctx, value) => {
    var _a7;
    if (isEqual3(ctx.page, value)) return;
    ctx.page = clampPage(value, ctx.totalPages);
    (_a7 = ctx.onPageChange) == null ? void 0 : _a7.call(ctx, { page: ctx.page, pageSize: ctx.pageSize });
  }
};
var props42 = createProps30()([
  "count",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onPageChange",
  "onPageSizeChange",
  "page",
  "pageSize",
  "siblingCount",
  "translations",
  "type"
]);
var splitProps42 = createSplitProps2(props42);
var itemProps13 = createProps30()(["value", "type"]);
var splitItemProps13 = createSplitProps2(itemProps13);
var ellipsisProps2 = createProps30()(["index"]);
var splitEllipsisProps2 = createSplitProps2(ellipsisProps2);

// node_modules/@ark-ui/react/dist/components/pagination/use-pagination.js
var import_react328 = __toESM(require_react(), 1);
var usePagination = (props52) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react328.useId)(),
    dir,
    getRootNode: getRootNode2,
    page: props52.defaultPage,
    ...props52
  };
  const context = {
    ...initialContext,
    page: props52.page,
    onPageChange: useEvent(props52.onPageChange, { sync: true })
  };
  const [state2, send] = useMachine(machine14(initialContext), { context });
  return connect14(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/pagination/pagination-root.js
var PaginationRoot = (0, import_react330.forwardRef)((props52, ref36) => {
  const [paginationProps, localProps] = createSplitProps3()(props52, [
    "count",
    "defaultPage",
    "id",
    "ids",
    "onPageChange",
    "onPageSizeChange",
    "page",
    "pageSize",
    "siblingCount",
    "translations",
    "type"
  ]);
  const pagination = usePagination(paginationProps);
  const mergedProps = mergeProps3(pagination.getRootProps(), localProps);
  return (0, import_jsx_runtime169.jsx)(PaginationProvider, { value: pagination, children: (0, import_jsx_runtime169.jsx)(ark.nav, { ...mergedProps, ref: ref36 }) });
});
PaginationRoot.displayName = "PaginationRoot";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-root-provider.js
var import_jsx_runtime170 = __toESM(require_jsx_runtime(), 1);
var import_react332 = __toESM(require_react(), 1);
var PaginationRootProvider = (0, import_react332.forwardRef)(
  (props52, ref36) => {
    const [{ value: pagination }, localProps] = createSplitProps3()(props52, [
      "value"
    ]);
    const mergedProps = mergeProps3(pagination.getRootProps(), localProps);
    return (0, import_jsx_runtime170.jsx)(PaginationProvider, { value: pagination, children: (0, import_jsx_runtime170.jsx)(ark.nav, { ...mergedProps, ref: ref36 }) });
  }
);
PaginationRootProvider.displayName = "PaginationRootProvider";

// node_modules/@ark-ui/react/dist/components/pagination/pagination.js
var pagination_exports = {};
__export(pagination_exports, {
  Context: () => PaginationContext,
  Ellipsis: () => PaginationEllipsis,
  Item: () => PaginationItem,
  NextTrigger: () => PaginationNextTrigger,
  PrevTrigger: () => PaginationPrevTrigger,
  Root: () => PaginationRoot,
  RootProvider: () => PaginationRootProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/pagination/pagination.js
var {
  withProvider: withProvider20,
  withContext: withContext33,
  useStyles: usePaginationStyles,
  PropsProvider: PropsProvider32
} = createSlotRecipeContext({ key: "pagination" });
var PaginationRootProvider2 = withProvider20(pagination_exports.RootProvider, "root", {
  forwardAsChild: true,
  forwardProps: ["page"]
});
var PaginationRoot2 = withProvider20(
  pagination_exports.Root,
  "root",
  { forwardAsChild: true, forwardProps: ["page"] }
);
var PaginationPropsProvider = PropsProvider32;
var PaginationEllipsis2 = withContext33(pagination_exports.Ellipsis, "ellipsis", { forwardAsChild: true });
var PaginationItem2 = withContext33(pagination_exports.Item, "item", { forwardAsChild: true });
var PaginationNextTrigger2 = withContext33(pagination_exports.NextTrigger, "nextTrigger", { forwardAsChild: true });
var PaginationPrevTrigger2 = withContext33(pagination_exports.PrevTrigger, "prevTrigger", { forwardAsChild: true });
var PaginationContext2 = pagination_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/pagination/namespace.js
var namespace_exports25 = {};
__export(namespace_exports25, {
  Context: () => PaginationContext2,
  Ellipsis: () => PaginationEllipsis2,
  Item: () => PaginationItem2,
  NextTrigger: () => PaginationNextTrigger2,
  PrevTrigger: () => PaginationPrevTrigger2,
  PropsProvider: () => PaginationPropsProvider,
  Root: () => PaginationRoot2,
  RootProvider: () => PaginationRootProvider2
});

// node_modules/@ark-ui/react/dist/components/pin-input/use-pin-input-context.js
var [PinInputProvider, usePinInputContext] = createContext({
  name: "PinInputContext",
  hookName: "usePinInputContext",
  providerName: "<PinInputProvider />"
});

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-context.js
var PinInputContext = (props52) => props52.children(usePinInputContext());

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-control.js
var import_jsx_runtime171 = __toESM(require_jsx_runtime(), 1);
var import_react334 = __toESM(require_react(), 1);
var PinInputControl = (0, import_react334.forwardRef)((props52, ref36) => {
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps3(pinInput.getControlProps(), props52);
  return (0, import_jsx_runtime171.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
PinInputControl.displayName = "PinInputControl";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-hidden-input.js
var import_jsx_runtime172 = __toESM(require_jsx_runtime(), 1);
var import_react336 = __toESM(require_react(), 1);
var PinInputHiddenInput = (0, import_react336.forwardRef)(
  (props52, ref36) => {
    const pinInput = usePinInputContext();
    const mergedProps = mergeProps3(pinInput.getHiddenInputProps(), props52);
    const field = useFieldContext();
    return (0, import_jsx_runtime172.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref36 });
  }
);
PinInputHiddenInput.displayName = "PinInputHiddenInput";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-input.js
var import_jsx_runtime173 = __toESM(require_jsx_runtime(), 1);
var import_react338 = __toESM(require_react(), 1);
var PinInputInput = (0, import_react338.forwardRef)((props52, ref36) => {
  const [inputProps3, localProps] = createSplitProps3()(props52, ["index"]);
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps3(pinInput.getInputProps(inputProps3), localProps);
  return (0, import_jsx_runtime173.jsx)(ark.input, { ...mergedProps, ref: ref36 });
});
PinInputInput.displayName = "PinInputInput";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-label.js
var import_jsx_runtime174 = __toESM(require_jsx_runtime(), 1);
var import_react340 = __toESM(require_react(), 1);
var PinInputLabel = (0, import_react340.forwardRef)((props52, ref36) => {
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps3(pinInput.getLabelProps(), props52);
  return (0, import_jsx_runtime174.jsx)(ark.label, { ...mergedProps, ref: ref36 });
});
PinInputLabel.displayName = "PinInputLabel";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-root.js
var import_jsx_runtime175 = __toESM(require_jsx_runtime(), 1);
var import_react344 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/node_modules/@zag-js/pin-input/dist/index.mjs
var anatomy57 = createAnatomy2("pinInput").parts("root", "label", "input", "control");
var parts52 = anatomy57.build();
var dom50 = createScope({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `pin-input:${ctx.id}`;
  },
  getInputId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.input) == null ? void 0 : _b6.call(_a7, id)) ?? `pin-input:${ctx.id}:${id}`;
  },
  getHiddenInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.hiddenInput) ?? `pin-input:${ctx.id}:hidden`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `pin-input:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `pin-input:${ctx.id}:control`;
  },
  getRootEl: (ctx) => dom50.getById(ctx, dom50.getRootId(ctx)),
  getInputEls: (ctx) => {
    const ownerId = CSS.escape(dom50.getRootId(ctx));
    const selector = `input[data-ownedby=${ownerId}]`;
    return queryAll(dom50.getRootEl(ctx), selector);
  },
  getInputEl: (ctx, id) => dom50.getById(ctx, dom50.getInputId(ctx, id)),
  getFocusedInputEl: (ctx) => dom50.getInputEls(ctx)[ctx.focusedIndex],
  getFirstInputEl: (ctx) => dom50.getInputEls(ctx)[0],
  getHiddenInputEl: (ctx) => dom50.getById(ctx, dom50.getHiddenInputId(ctx))
});
var REGEX = {
  numeric: /^[0-9]+$/,
  alphabetic: /^[A-Za-z]+$/,
  alphanumeric: /^[a-zA-Z0-9]+$/i
};
function isValidType(ctx, value) {
  var _a7;
  if (!ctx.type) return true;
  return !!((_a7 = REGEX[ctx.type]) == null ? void 0 : _a7.test(value));
}
function isValidValue(ctx, value) {
  if (!ctx.pattern) return isValidType(ctx, value);
  const regex = new RegExp(ctx.pattern, "g");
  return regex.test(value);
}
function connect15(state2, send, normalize2) {
  const complete = state2.context.isValueComplete;
  const invalid = state2.context.invalid;
  const focusedIndex = state2.context.focusedIndex;
  const translations = state2.context.translations;
  function focus() {
    var _a7;
    (_a7 = dom50.getFirstInputEl(state2.context)) == null ? void 0 : _a7.focus();
  }
  return {
    focus,
    value: state2.context.value,
    valueAsString: state2.context.valueAsString,
    complete,
    setValue(value) {
      if (!Array.isArray(value)) {
        invariant3("[pin-input/setValue] value must be an array");
      }
      send({ type: "VALUE.SET", value });
    },
    clearValue() {
      send({ type: "VALUE.CLEAR" });
    },
    setValueAtIndex(index, value) {
      send({ type: "VALUE.SET", value, index });
    },
    getRootProps() {
      return normalize2.element({
        dir: state2.context.dir,
        ...parts52.root.attrs,
        id: dom50.getRootId(state2.context),
        "data-invalid": dataAttr(invalid),
        "data-disabled": dataAttr(state2.context.disabled),
        "data-complete": dataAttr(complete),
        "data-readonly": dataAttr(state2.context.readOnly)
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts52.label.attrs,
        dir: state2.context.dir,
        htmlFor: dom50.getHiddenInputId(state2.context),
        id: dom50.getLabelId(state2.context),
        "data-invalid": dataAttr(invalid),
        "data-disabled": dataAttr(state2.context.disabled),
        "data-complete": dataAttr(complete),
        "data-readonly": dataAttr(state2.context.readOnly),
        onClick(event) {
          event.preventDefault();
          focus();
        }
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        "aria-hidden": true,
        type: "text",
        tabIndex: -1,
        id: dom50.getHiddenInputId(state2.context),
        readOnly: state2.context.readOnly,
        disabled: state2.context.disabled,
        required: state2.context.required,
        name: state2.context.name,
        form: state2.context.form,
        style: visuallyHiddenStyle,
        maxLength: state2.context.valueLength,
        defaultValue: state2.context.valueAsString
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts52.control.attrs,
        dir: state2.context.dir,
        id: dom50.getControlId(state2.context)
      });
    },
    getInputProps(props52) {
      const { index } = props52;
      const inputType = state2.context.type === "numeric" ? "tel" : "text";
      return normalize2.input({
        ...parts52.input.attrs,
        dir: state2.context.dir,
        disabled: state2.context.disabled,
        "data-disabled": dataAttr(state2.context.disabled),
        "data-complete": dataAttr(complete),
        id: dom50.getInputId(state2.context, index.toString()),
        "data-ownedby": dom50.getRootId(state2.context),
        "aria-label": translations.inputLabel(index, state2.context.valueLength),
        inputMode: state2.context.otp || state2.context.type === "numeric" ? "numeric" : "text",
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        type: state2.context.mask ? "password" : inputType,
        defaultValue: state2.context.value[index] || "",
        readOnly: state2.context.readOnly,
        autoCapitalize: "none",
        autoComplete: state2.context.otp ? "one-time-code" : "off",
        placeholder: focusedIndex === index ? "" : state2.context.placeholder,
        onBeforeInput(event) {
          try {
            const value = getBeforeInputValue(event);
            const isValid = isValidValue(state2.context, value);
            if (!isValid) {
              send({ type: "VALUE.INVALID", value });
              event.preventDefault();
            }
            if (value.length > 2) {
              event.currentTarget.setSelectionRange(0, 1, "forward");
            }
          } catch {
          }
        },
        onChange(event) {
          const evt = getNativeEvent2(event);
          const { value } = event.currentTarget;
          if (evt.inputType === "insertFromPaste" || value.length > 2) {
            send({ type: "INPUT.PASTE", value });
            event.currentTarget.value = value[0];
            event.preventDefault();
            return;
          }
          if (evt.inputType === "deleteContentBackward") {
            send("INPUT.BACKSPACE");
            return;
          }
          send({ type: "INPUT.CHANGE", value, index });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          if (isModifierKey2(event)) return;
          const keyMap2 = {
            Backspace() {
              send("INPUT.BACKSPACE");
            },
            Delete() {
              send("INPUT.DELETE");
            },
            ArrowLeft() {
              send("INPUT.ARROW_LEFT");
            },
            ArrowRight() {
              send("INPUT.ARROW_RIGHT");
            },
            Enter() {
              send("INPUT.ENTER");
            }
          };
          const exec21 = keyMap2[getEventKey2(event, state2.context)];
          if (exec21) {
            exec21(event);
            event.preventDefault();
          }
        },
        onFocus() {
          send({ type: "INPUT.FOCUS", index });
        },
        onBlur() {
          send({ type: "INPUT.BLUR", index });
        }
      });
    }
  };
}
function machine15(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "pin-input",
      initial: "idle",
      context: {
        value: [],
        placeholder: "○",
        otp: false,
        type: "numeric",
        ...ctx,
        focusedIndex: -1,
        translations: {
          inputLabel: (index, length2) => `pin code ${index + 1} of ${length2}`,
          ...ctx.translations
        }
      },
      computed: {
        valueLength: (ctx2) => ctx2.value.length,
        filledValueLength: (ctx2) => ctx2.value.filter((v) => (v == null ? void 0 : v.trim()) !== "").length,
        isValueComplete: (ctx2) => ctx2.valueLength === ctx2.filledValueLength,
        valueAsString: (ctx2) => ctx2.value.join(""),
        focusedValue: (ctx2) => ctx2.value[ctx2.focusedIndex] || ""
      },
      entry: choose3([
        {
          guard: "autoFocus",
          actions: ["setupValue", "setFocusIndexToFirst"]
        },
        { actions: ["setupValue"] }
      ]),
      watch: {
        focusedIndex: ["focusInput", "selectInputIfNeeded"],
        value: ["syncInputElements"],
        isValueComplete: ["invokeOnComplete", "blurFocusedInputIfNeeded"]
      },
      on: {
        "VALUE.SET": [
          {
            guard: "hasIndex",
            actions: ["setValueAtIndex"]
          },
          { actions: ["setValue"] }
        ],
        "VALUE.CLEAR": {
          actions: ["clearValue", "setFocusIndexToFirst"]
        }
      },
      states: {
        idle: {
          on: {
            "INPUT.FOCUS": {
              target: "focused",
              actions: "setFocusedIndex"
            }
          }
        },
        focused: {
          on: {
            "INPUT.CHANGE": [
              {
                guard: "isFinalValue",
                actions: ["setFocusedValue", "syncInputValue"]
              },
              {
                actions: ["setFocusedValue", "setNextFocusedIndex", "syncInputValue"]
              }
            ],
            "INPUT.PASTE": {
              actions: ["setPastedValue", "setLastValueFocusIndex"]
            },
            "INPUT.BLUR": {
              target: "idle",
              actions: "clearFocusedIndex"
            },
            "INPUT.DELETE": {
              guard: "hasValue",
              actions: "clearFocusedValue"
            },
            "INPUT.ARROW_LEFT": {
              actions: "setPrevFocusedIndex"
            },
            "INPUT.ARROW_RIGHT": {
              actions: "setNextFocusedIndex"
            },
            "INPUT.BACKSPACE": [
              {
                guard: "hasValue",
                actions: ["clearFocusedValue"]
              },
              {
                actions: ["setPrevFocusedIndex", "clearFocusedValue"]
              }
            ],
            "INPUT.ENTER": {
              guard: "isValueComplete",
              actions: "requestFormSubmit"
            },
            "VALUE.INVALID": {
              actions: "invokeOnInvalid"
            }
          }
        }
      }
    },
    {
      guards: {
        autoFocus: (ctx2) => !!ctx2.autoFocus,
        isValueEmpty: (_ctx, evt) => evt.value === "",
        hasValue: (ctx2) => ctx2.value[ctx2.focusedIndex] !== "",
        isValueComplete: (ctx2) => ctx2.isValueComplete,
        isFinalValue: (ctx2) => ctx2.filledValueLength + 1 === ctx2.valueLength && ctx2.value.findIndex((v) => v.trim() === "") === ctx2.focusedIndex,
        hasIndex: (_ctx, evt) => evt.index !== void 0,
        isDisabled: (ctx2) => !!ctx2.disabled
      },
      actions: {
        setupValue(ctx2) {
          if (ctx2.value.length) return;
          const inputEls = dom50.getInputEls(ctx2);
          const emptyValues = Array.from({ length: inputEls.length }).fill("");
          assignValue(ctx2, emptyValues);
        },
        focusInput(ctx2) {
          var _a7;
          if (ctx2.focusedIndex === -1) return;
          (_a7 = dom50.getFocusedInputEl(ctx2)) == null ? void 0 : _a7.focus({ preventScroll: true });
        },
        selectInputIfNeeded(ctx2) {
          if (!ctx2.selectOnFocus || ctx2.focusedIndex === -1) return;
          raf(() => {
            var _a7;
            (_a7 = dom50.getFocusedInputEl(ctx2)) == null ? void 0 : _a7.select();
          });
        },
        invokeOnComplete(ctx2) {
          var _a7;
          if (!ctx2.isValueComplete) return;
          (_a7 = ctx2.onValueComplete) == null ? void 0 : _a7.call(ctx2, {
            value: Array.from(ctx2.value),
            valueAsString: ctx2.valueAsString
          });
        },
        invokeOnInvalid(ctx2, evt) {
          var _a7;
          (_a7 = ctx2.onValueInvalid) == null ? void 0 : _a7.call(ctx2, {
            value: evt.value,
            index: ctx2.focusedIndex
          });
        },
        clearFocusedIndex(ctx2) {
          ctx2.focusedIndex = -1;
        },
        setFocusedIndex(ctx2, evt) {
          ctx2.focusedIndex = evt.index;
        },
        setValue(ctx2, evt) {
          set10.value(ctx2, evt.value);
        },
        setFocusedValue(ctx2, evt) {
          const nextValue = getNextValue(ctx2.focusedValue, evt.value);
          set10.valueAtIndex(ctx2, ctx2.focusedIndex, nextValue);
        },
        revertInputValue(ctx2) {
          const inputEl = dom50.getFocusedInputEl(ctx2);
          dom50.setValue(inputEl, ctx2.focusedValue);
        },
        syncInputValue(ctx2, evt) {
          const inputEl = dom50.getInputEl(ctx2, evt.index.toString());
          dom50.setValue(inputEl, ctx2.value[evt.index]);
        },
        syncInputElements(ctx2) {
          const inputEls = dom50.getInputEls(ctx2);
          inputEls.forEach((inputEl, index) => {
            dom50.setValue(inputEl, ctx2.value[index]);
          });
        },
        setPastedValue(ctx2, evt) {
          raf(() => {
            const startIndex = Math.min(ctx2.focusedIndex, ctx2.filledValueLength);
            const left = startIndex > 0 ? ctx2.valueAsString.substring(0, ctx2.focusedIndex) : "";
            const right = evt.value.substring(0, ctx2.valueLength - startIndex);
            const value = left + right;
            set10.value(ctx2, value.split(""));
          });
        },
        setValueAtIndex(ctx2, evt) {
          const nextValue = getNextValue(ctx2.focusedValue, evt.value);
          set10.valueAtIndex(ctx2, evt.index, nextValue);
        },
        clearValue(ctx2) {
          const nextValue = Array.from({ length: ctx2.valueLength }).fill("");
          set10.value(ctx2, nextValue);
        },
        clearFocusedValue(ctx2) {
          set10.valueAtIndex(ctx2, ctx2.focusedIndex, "");
        },
        setFocusIndexToFirst(ctx2) {
          ctx2.focusedIndex = 0;
        },
        setNextFocusedIndex(ctx2) {
          ctx2.focusedIndex = Math.min(ctx2.focusedIndex + 1, ctx2.valueLength - 1);
        },
        setPrevFocusedIndex(ctx2) {
          ctx2.focusedIndex = Math.max(ctx2.focusedIndex - 1, 0);
        },
        setLastValueFocusIndex(ctx2) {
          raf(() => {
            ctx2.focusedIndex = Math.min(ctx2.filledValueLength, ctx2.valueLength - 1);
          });
        },
        blurFocusedInputIfNeeded(ctx2) {
          if (!ctx2.blurOnComplete) return;
          raf(() => {
            var _a7;
            (_a7 = dom50.getFocusedInputEl(ctx2)) == null ? void 0 : _a7.blur();
          });
        },
        requestFormSubmit(ctx2) {
          var _a7;
          if (!ctx2.name || !ctx2.isValueComplete) return;
          const inputEl = dom50.getHiddenInputEl(ctx2);
          (_a7 = inputEl == null ? void 0 : inputEl.form) == null ? void 0 : _a7.requestSubmit();
        }
      }
    }
  );
}
function assignValue(ctx, value) {
  const arr = Array.isArray(value) ? value : value.split("").filter(Boolean);
  arr.forEach((value2, index) => {
    ctx.value[index] = value2;
  });
}
function getNextValue(current, next3) {
  let nextValue = next3;
  if (current[0] === next3[0]) nextValue = next3[1];
  else if (current[0] === next3[1]) nextValue = next3[0];
  return nextValue.split("")[nextValue.length - 1];
}
var invoke6 = {
  change(ctx) {
    var _a7;
    (_a7 = ctx.onValueChange) == null ? void 0 : _a7.call(ctx, {
      value: Array.from(ctx.value),
      valueAsString: ctx.valueAsString
    });
    const inputEl = dom50.getHiddenInputEl(ctx);
    dispatchInputValueEvent2(inputEl, { value: ctx.valueAsString });
  }
};
var set10 = {
  value(ctx, value) {
    if (isEqual3(ctx.value, value)) return;
    assignValue(ctx, value);
    invoke6.change(ctx);
  },
  valueAtIndex(ctx, index, value) {
    if (isEqual3(ctx.value[index], value)) return;
    ctx.value[index] = value;
    invoke6.change(ctx);
  }
};

// node_modules/@ark-ui/react/dist/components/pin-input/use-pin-input.js
var import_react342 = __toESM(require_react(), 1);
var usePinInput = (props52 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react342.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    invalid: field == null ? void 0 : field.invalid,
    dir,
    getRootNode: getRootNode2,
    value: props52.defaultValue,
    ...props52
  };
  const context = {
    ...initialContext,
    value: props52.value,
    onValueChange: useEvent(props52.onValueChange, { sync: true }),
    onValueComplete: useEvent(props52.onValueComplete),
    onValueInvalid: useEvent(props52.onValueInvalid)
  };
  const [state2, send] = useMachine(machine15(initialContext), { context });
  return connect15(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-root.js
var PinInputRoot = (0, import_react344.forwardRef)((props52, ref36) => {
  const [usePinInputProps, localProps] = createSplitProps3()(props52, [
    "autoFocus",
    "blurOnComplete",
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "mask",
    "name",
    "onValueChange",
    "onValueComplete",
    "onValueInvalid",
    "otp",
    "pattern",
    "placeholder",
    "readOnly",
    "required",
    "selectOnFocus",
    "translations",
    "type",
    "value"
  ]);
  const pinInput = usePinInput(usePinInputProps);
  const mergedProps = mergeProps3(pinInput.getRootProps(), localProps);
  return (0, import_jsx_runtime175.jsx)(PinInputProvider, { value: pinInput, children: (0, import_jsx_runtime175.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
});
PinInputRoot.displayName = "PinInputRoot";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-root-provider.js
var import_jsx_runtime176 = __toESM(require_jsx_runtime(), 1);
var import_react346 = __toESM(require_react(), 1);
var PinInputRootProvider = (0, import_react346.forwardRef)(
  (props52, ref36) => {
    const [{ value: pinInput }, localProps] = createSplitProps3()(props52, [
      "value"
    ]);
    const mergedProps = mergeProps3(pinInput.getRootProps(), localProps);
    return (0, import_jsx_runtime176.jsx)(PinInputProvider, { value: pinInput, children: (0, import_jsx_runtime176.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
  }
);
PinInputRootProvider.displayName = "PinInputRootProvider";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input.js
var pin_input_exports = {};
__export(pin_input_exports, {
  Context: () => PinInputContext,
  Control: () => PinInputControl,
  HiddenInput: () => PinInputHiddenInput,
  Input: () => PinInputInput,
  Label: () => PinInputLabel,
  Root: () => PinInputRoot,
  RootProvider: () => PinInputRootProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/pin-input/pin-input.js
var {
  withProvider: withProvider21,
  withContext: withContext34,
  useStyles: usePinInputStyles,
  PropsProvider: PropsProvider33
} = createSlotRecipeContext({ key: "pinInput" });
var PinInputRootProvider2 = withProvider21(pin_input_exports.RootProvider, "root", { forwardAsChild: true });
var PinInputRoot2 = withProvider21(
  pin_input_exports.Root,
  "root",
  { forwardProps: ["mask"], forwardAsChild: true }
);
var PinInputPropsProvider = PropsProvider33;
var PinInputControl2 = withContext34(pin_input_exports.Control, "control", { forwardAsChild: true });
var PinInputInput2 = withContext34(
  pin_input_exports.Input,
  "input",
  { forwardAsChild: true }
);
var PinInputLabel2 = withContext34(
  pin_input_exports.Label,
  "label",
  { forwardAsChild: true }
);
var PinInputContext2 = pin_input_exports.Context;
var PinInputHiddenInput2 = pin_input_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/pin-input/namespace.js
var namespace_exports26 = {};
__export(namespace_exports26, {
  Context: () => PinInputContext2,
  Control: () => PinInputControl2,
  HiddenInput: () => PinInputHiddenInput2,
  Input: () => PinInputInput2,
  Label: () => PinInputLabel2,
  PropsProvider: () => PinInputPropsProvider,
  Root: () => PinInputRoot2,
  RootProvider: () => PinInputRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/popover/popover.js
var {
  withRootProvider: withRootProvider6,
  withContext: withContext35,
  useStyles: usePopoverStyles,
  PropsProvider: PropsProvider34
} = createSlotRecipeContext({ key: "popover" });
var PopoverRootProvider2 = withRootProvider6(
  popover_exports.RootProvider
);
var PopoverRoot2 = withRootProvider6(popover_exports.Root);
var PopoverPropsProvider = PropsProvider34;
var PopoverTrigger2 = withContext35(popover_exports.Trigger, "trigger", { forwardAsChild: true });
var PopoverPositioner2 = withContext35(popover_exports.Positioner, "positioner", { forwardAsChild: true });
var PopoverContent2 = withContext35(
  popover_exports.Content,
  "content",
  { forwardAsChild: true }
);
var PopoverArrow2 = withContext35(
  popover_exports.Arrow,
  "arrow",
  { forwardAsChild: true }
);
var PopoverArrowTip2 = withContext35(popover_exports.ArrowTip, "arrowTip", { forwardAsChild: true });
var PopoverCloseTrigger2 = withContext35(popover_exports.CloseTrigger, "closeTrigger", { forwardAsChild: true });
var PopoverIndicator2 = withContext35(popover_exports.Indicator, "indicator", { forwardAsChild: true });
var PopoverTitle2 = withContext35(
  popover_exports.Title,
  "title",
  { forwardAsChild: true }
);
var PopoverDescription2 = withContext35(popover_exports.Description, "description", { forwardAsChild: true });
var PopoverFooter = withContext35(
  "footer",
  "footer"
);
var PopoverHeader = withContext35(
  "header",
  "header"
);
var PopoverBody = withContext35(
  "div",
  "body"
);
var PopoverAnchor2 = withContext35(
  popover_exports.Anchor,
  void 0,
  { forwardAsChild: true }
);
var PopoverContext2 = popover_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/popover/namespace.js
var namespace_exports27 = {};
__export(namespace_exports27, {
  Anchor: () => PopoverAnchor2,
  Arrow: () => PopoverArrow2,
  ArrowTip: () => PopoverArrowTip2,
  Body: () => PopoverBody,
  CloseTrigger: () => PopoverCloseTrigger2,
  Content: () => PopoverContent2,
  Context: () => PopoverContext2,
  Description: () => PopoverDescription2,
  Footer: () => PopoverFooter,
  Header: () => PopoverHeader,
  Positioner: () => PopoverPositioner2,
  PropsProvider: () => PopoverPropsProvider,
  Root: () => PopoverRoot2,
  RootProvider: () => PopoverRootProvider2,
  Title: () => PopoverTitle2,
  Trigger: () => PopoverTrigger2,
  usePopoverStyles: () => usePopoverStyles
});

// node_modules/@ark-ui/react/dist/components/portal/portal.js
var import_jsx_runtime177 = __toESM(require_jsx_runtime(), 1);
var import_react347 = __toESM(require_react(), 1);
var import_react_dom2 = __toESM(require_react_dom(), 1);
var Portal = (props52) => {
  var _a7;
  const { children, disabled } = props52;
  const [container, setContainer] = (0, import_react347.useState)((_a7 = props52.container) == null ? void 0 : _a7.current);
  const isServer = (0, import_react347.useSyncExternalStore)(
    subscribe36,
    () => false,
    () => true
  );
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  (0, import_react347.useEffect)(() => {
    setContainer(() => {
      var _a8;
      return (_a8 = props52.container) == null ? void 0 : _a8.current;
    });
  }, [props52.container]);
  if (isServer || disabled) return (0, import_jsx_runtime177.jsx)(import_jsx_runtime177.Fragment, { children });
  const mountNode = container ?? getPortalNode(getRootNode2);
  return (0, import_jsx_runtime177.jsx)(import_jsx_runtime177.Fragment, { children: import_react347.Children.map(children, (child) => (0, import_react_dom2.createPortal)(child, mountNode)) });
};
var getPortalNode = (cb) => {
  const node2 = cb == null ? void 0 : cb();
  const rootNode = node2.getRootNode();
  if (isShadowRoot(rootNode)) return rootNode;
  return getDocument(node2).body;
};
var subscribe36 = () => () => {
};

// node_modules/@ark-ui/react/dist/components/progress/progress-circle.js
var import_jsx_runtime178 = __toESM(require_jsx_runtime(), 1);
var import_react349 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/progress/use-progress-context.js
var [ProgressProvider, useProgressContext] = createContext({
  name: "ProgressContext",
  hookName: "useProgressContext",
  providerName: "<ProgressProvider />"
});

// node_modules/@ark-ui/react/dist/components/progress/progress-circle.js
var ProgressCircle = (0, import_react349.forwardRef)((props52, ref36) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps3(progress.getCircleProps(), props52);
  return (0, import_jsx_runtime178.jsx)(ark.svg, { ref: ref36, ...mergedProps });
});
ProgressCircle.displayName = "ProgressCircle";

// node_modules/@ark-ui/react/dist/components/progress/progress-circle-range.js
var import_jsx_runtime179 = __toESM(require_jsx_runtime(), 1);
var import_react351 = __toESM(require_react(), 1);
var ProgressCircleRange = (0, import_react351.forwardRef)(
  (props52, ref36) => {
    const progress = useProgressContext();
    const mergedProps = mergeProps3(progress.getCircleRangeProps(), props52);
    return (0, import_jsx_runtime179.jsx)(ark.circle, { ref: ref36, ...mergedProps });
  }
);
ProgressCircleRange.displayName = "ProgressCircleRange";

// node_modules/@ark-ui/react/dist/components/progress/progress-circle-track.js
var import_jsx_runtime180 = __toESM(require_jsx_runtime(), 1);
var import_react353 = __toESM(require_react(), 1);
var ProgressCircleTrack = (0, import_react353.forwardRef)(
  (props52, ref36) => {
    const progress = useProgressContext();
    const mergedProps = mergeProps3(progress.getCircleTrackProps(), props52);
    return (0, import_jsx_runtime180.jsx)(ark.circle, { ref: ref36, ...mergedProps });
  }
);
ProgressCircleTrack.displayName = "ProgressCircleTrack";

// node_modules/@ark-ui/react/dist/components/progress/progress-context.js
var ProgressContext = (props52) => props52.children(useProgressContext());

// node_modules/@ark-ui/react/dist/components/progress/progress-label.js
var import_jsx_runtime181 = __toESM(require_jsx_runtime(), 1);
var import_react355 = __toESM(require_react(), 1);
var ProgressLabel = (0, import_react355.forwardRef)((props52, ref36) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps3(progress.getLabelProps(), props52);
  return (0, import_jsx_runtime181.jsx)(ark.label, { ...mergedProps, ref: ref36 });
});
ProgressLabel.displayName = "ProgressLabel";

// node_modules/@ark-ui/react/dist/components/progress/progress-range.js
var import_jsx_runtime182 = __toESM(require_jsx_runtime(), 1);
var import_react357 = __toESM(require_react(), 1);
var ProgressRange = (0, import_react357.forwardRef)((props52, ref36) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps3(progress.getRangeProps(), props52);
  return (0, import_jsx_runtime182.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
ProgressRange.displayName = "ProgressRange";

// node_modules/@ark-ui/react/dist/components/progress/progress-root.js
var import_jsx_runtime183 = __toESM(require_jsx_runtime(), 1);
var import_react361 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/node_modules/@zag-js/progress/dist/index.mjs
var anatomy58 = createAnatomy2("progress").parts(
  "root",
  "label",
  "track",
  "range",
  "valueText",
  "view",
  "circle",
  "circleTrack",
  "circleRange"
);
var parts53 = anatomy58.build();
var dom51 = createScope({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `progress-${ctx.id}`;
  },
  getTrackId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.track) ?? `progress-${ctx.id}-track`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `progress-${ctx.id}-label`;
  },
  getCircleId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.circle) ?? `progress-${ctx.id}-circle`;
  }
});
function connect16(state2, send, normalize2) {
  const percent = state2.context.percent;
  const percentAsString = state2.context.isIndeterminate ? "" : `${percent}%`;
  const max4 = state2.context.max;
  const min4 = state2.context.min;
  const orientation = state2.context.orientation;
  const translations = state2.context.translations;
  const indeterminate = state2.context.isIndeterminate;
  const value = state2.context.value;
  const valueAsString = translations.value({ value, max: max4, percent, min: min4 });
  const progressState = getProgressState(value, max4);
  const progressbarProps = {
    role: "progressbar",
    "aria-label": valueAsString,
    "data-max": max4,
    "aria-valuemin": min4,
    "aria-valuemax": max4,
    "aria-valuenow": value ?? void 0,
    "data-orientation": orientation,
    "data-state": progressState
  };
  const circleProps = getCircleProps(state2.context);
  return {
    value,
    valueAsString,
    min: min4,
    max: max4,
    percent,
    percentAsString,
    indeterminate,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    setToMax() {
      send({ type: "VALUE.SET", value: max4 });
    },
    setToMin() {
      send({ type: "VALUE.SET", value: min4 });
    },
    getRootProps() {
      return normalize2.element({
        dir: state2.context.dir,
        ...parts53.root.attrs,
        id: dom51.getRootId(state2.context),
        "data-max": max4,
        "data-value": value ?? void 0,
        "data-state": progressState,
        "data-orientation": orientation,
        style: {
          "--percent": indeterminate ? void 0 : percent
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        dir: state2.context.dir,
        id: dom51.getLabelId(state2.context),
        ...parts53.label.attrs,
        "data-orientation": orientation
      });
    },
    getValueTextProps() {
      return normalize2.element({
        dir: state2.context.dir,
        "aria-live": "polite",
        ...parts53.valueText.attrs
      });
    },
    getTrackProps() {
      return normalize2.element({
        dir: state2.context.dir,
        id: dom51.getTrackId(state2.context),
        ...parts53.track.attrs,
        ...progressbarProps
      });
    },
    getRangeProps() {
      return normalize2.element({
        dir: state2.context.dir,
        ...parts53.range.attrs,
        "data-orientation": orientation,
        "data-state": progressState,
        style: {
          [state2.context.isHorizontal ? "width" : "height"]: indeterminate ? void 0 : `${percent}%`
        }
      });
    },
    getCircleProps() {
      return normalize2.element({
        dir: state2.context.dir,
        id: dom51.getCircleId(state2.context),
        ...parts53.circle.attrs,
        ...progressbarProps,
        ...circleProps.root
      });
    },
    getCircleTrackProps() {
      return normalize2.element({
        dir: state2.context.dir,
        "data-orientation": orientation,
        ...parts53.circleTrack.attrs,
        ...circleProps.track
      });
    },
    getCircleRangeProps() {
      return normalize2.element({
        dir: state2.context.dir,
        ...parts53.circleRange.attrs,
        ...circleProps.range,
        "data-state": progressState
      });
    },
    getViewProps(props210) {
      return normalize2.element({
        dir: state2.context.dir,
        ...parts53.view.attrs,
        "data-state": props210.state,
        hidden: props210.state !== progressState
      });
    }
  };
}
function getProgressState(value, maxValue2) {
  return value == null ? "indeterminate" : value === maxValue2 ? "complete" : "loading";
}
function getCircleProps(ctx) {
  const circleProps = {
    style: {
      "--radius": "calc(var(--size) / 2 - var(--thickness) / 2)",
      cx: "calc(var(--size) / 2)",
      cy: "calc(var(--size) / 2)",
      r: "var(--radius)",
      fill: "transparent",
      strokeWidth: "var(--thickness)"
    }
  };
  return {
    root: {
      style: {
        width: "var(--size)",
        height: "var(--size)"
      }
    },
    track: circleProps,
    range: {
      opacity: ctx.value === 0 ? 0 : void 0,
      style: {
        ...circleProps.style,
        "--percent": ctx.percent,
        "--circumference": `calc(2 * 3.14159 * var(--radius))`,
        "--offset": `calc(var(--circumference) * (100 - var(--percent)) / 100)`,
        strokeDashoffset: `calc(var(--circumference) * ((100 - var(--percent)) / 100))`,
        strokeDasharray: ctx.isIndeterminate ? void 0 : `var(--circumference)`,
        transformOrigin: "center",
        transform: "rotate(-90deg)"
      }
    }
  };
}
function midValue(min4, max4) {
  return min4 + (max4 - min4) / 2;
}
function machine16(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "progress",
      initial: "idle",
      context: {
        max: ctx.max ?? 100,
        min: ctx.min ?? 0,
        value: midValue(ctx.min ?? 0, ctx.max ?? 100),
        orientation: "horizontal",
        translations: {
          value: ({ percent }) => percent === -1 ? "loading..." : `${percent} percent`,
          ...ctx.translations
        },
        ...ctx
      },
      created: ["validateContext"],
      computed: {
        isIndeterminate: (ctx2) => ctx2.value === null,
        percent(ctx2) {
          if (!isNumber3(ctx2.value)) return -1;
          return Math.round((ctx2.value - ctx2.min) / (ctx2.max - ctx2.min) * 100);
        },
        isAtMax: (ctx2) => ctx2.value === ctx2.max,
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        isRtl: (ctx2) => ctx2.dir === "rtl"
      },
      states: {
        idle: {
          on: {
            "VALUE.SET": {
              actions: ["setValue"]
            }
          }
        }
      }
    },
    {
      actions: {
        setValue: (ctx2, evt) => {
          ctx2.value = evt.value === null ? null : Math.max(0, Math.min(evt.value, ctx2.max));
        },
        validateContext: (ctx2) => {
          if (ctx2.value == null) return;
          if (!isValidNumber(ctx2.max)) {
            throw new Error(`[progress] The max value passed \`${ctx2.max}\` is not a valid number`);
          }
          if (!isValidMax(ctx2.value, ctx2.max)) {
            throw new Error(`[progress] The value passed \`${ctx2.value}\` exceeds the max value \`${ctx2.max}\``);
          }
          if (!isValidMin(ctx2.value, ctx2.min)) {
            throw new Error(`[progress] The value passed \`${ctx2.value}\` exceeds the min value \`${ctx2.min}\``);
          }
        }
      }
    }
  );
}
function isValidNumber(max4) {
  return isNumber3(max4) && !isNaN(max4);
}
function isValidMax(value, max4) {
  return isValidNumber(value) && value <= max4;
}
function isValidMin(value, min4) {
  return isValidNumber(value) && value >= min4;
}
var props43 = createProps30()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "max",
  "min",
  "orientation",
  "translations",
  "value"
]);
var splitProps43 = createSplitProps2(props43);

// node_modules/@ark-ui/react/dist/components/progress/use-progress.js
var import_react359 = __toESM(require_react(), 1);
var useProgress = (props52 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react359.useId)(),
    dir,
    getRootNode: getRootNode2,
    ...props52
  };
  const context = {
    ...initialContext,
    value: props52.value
  };
  const [state2, send] = useMachine(machine16(initialContext), { context });
  return connect16(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/progress/progress-root.js
var ProgressRoot = (0, import_react361.forwardRef)((props52, ref36) => {
  const [progressProps, localProps] = createSplitProps3()(props52, [
    "id",
    "ids",
    "max",
    "min",
    "orientation",
    "translations",
    "value"
  ]);
  const progress = useProgress(progressProps);
  const mergedProps = mergeProps3(progress.getRootProps(), localProps);
  return (0, import_jsx_runtime183.jsx)(ProgressProvider, { value: progress, children: (0, import_jsx_runtime183.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
});
ProgressRoot.displayName = "ProgressRoot";

// node_modules/@ark-ui/react/dist/components/progress/progress-root-provider.js
var import_jsx_runtime184 = __toESM(require_jsx_runtime(), 1);
var import_react363 = __toESM(require_react(), 1);
var ProgressRootProvider = (0, import_react363.forwardRef)(
  (props52, ref36) => {
    const [{ value: progress }, localProps] = createSplitProps3()(props52, [
      "value"
    ]);
    const mergedProps = mergeProps3(progress.getRootProps(), localProps);
    return (0, import_jsx_runtime184.jsx)(ProgressProvider, { value: progress, children: (0, import_jsx_runtime184.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
  }
);
ProgressRootProvider.displayName = "ProgressRootProvider";

// node_modules/@ark-ui/react/dist/components/progress/progress-track.js
var import_jsx_runtime185 = __toESM(require_jsx_runtime(), 1);
var import_react365 = __toESM(require_react(), 1);
var ProgressTrack = (0, import_react365.forwardRef)((props52, ref36) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps3(progress.getTrackProps(), props52);
  return (0, import_jsx_runtime185.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
ProgressTrack.displayName = "ProgressTrack";

// node_modules/@ark-ui/react/dist/components/progress/progress-value-text.js
var import_jsx_runtime186 = __toESM(require_jsx_runtime(), 1);
var import_react367 = __toESM(require_react(), 1);
var ProgressValueText = (0, import_react367.forwardRef)(
  (props52, ref36) => {
    const { children, ...rest } = props52;
    const progress = useProgressContext();
    const mergedProps = mergeProps3(progress.getValueTextProps(), rest);
    return (0, import_jsx_runtime186.jsx)(ark.span, { ...mergedProps, ref: ref36, children: children || progress.percentAsString });
  }
);
ProgressValueText.displayName = "ProgressValueText";

// node_modules/@ark-ui/react/dist/components/progress/progress-view.js
var import_jsx_runtime187 = __toESM(require_jsx_runtime(), 1);
var import_react369 = __toESM(require_react(), 1);
var ProgressView = (0, import_react369.forwardRef)((props52, ref36) => {
  const [viewProps3, localProps] = createSplitProps3()(props52, ["state"]);
  const progress = useProgressContext();
  const mergedProps = mergeProps3(progress.getViewProps(viewProps3), localProps);
  return (0, import_jsx_runtime187.jsx)(ark.span, { ...mergedProps, ref: ref36 });
});
ProgressView.displayName = "ProgressView";

// node_modules/@ark-ui/react/dist/components/progress/progress.js
var progress_exports = {};
__export(progress_exports, {
  Circle: () => ProgressCircle,
  CircleRange: () => ProgressCircleRange,
  CircleTrack: () => ProgressCircleTrack,
  Context: () => ProgressContext,
  Label: () => ProgressLabel,
  Range: () => ProgressRange,
  Root: () => ProgressRoot,
  RootProvider: () => ProgressRootProvider,
  Track: () => ProgressTrack,
  ValueText: () => ProgressValueText,
  View: () => ProgressView
});

// node_modules/@chakra-ui/react/dist/esm/components/progress/progress.js
var {
  withProvider: withProvider22,
  withContext: withContext36,
  useStyles: useProgressStyles,
  PropsProvider: PropsProvider35
} = createSlotRecipeContext({ key: "progress" });
var ProgressRootProvider2 = withProvider22(progress_exports.RootProvider, "root", { forwardAsChild: true });
var ProgressRoot2 = withProvider22(
  progress_exports.Root,
  "root"
);
var ProgressPropsProvider = PropsProvider35;
var ProgressLabel2 = withContext36(
  progress_exports.Label,
  "label",
  { forwardAsChild: true }
);
var ProgressTrack2 = withContext36(
  progress_exports.Track,
  "track",
  { forwardAsChild: true }
);
var ProgressRange2 = withContext36(
  progress_exports.Range,
  "range",
  { forwardAsChild: true }
);
var ProgressValueText2 = withContext36(progress_exports.ValueText, "valueText", { forwardAsChild: true });
var ProgressContext2 = progress_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/progress/namespace.js
var namespace_exports28 = {};
__export(namespace_exports28, {
  Context: () => ProgressContext2,
  Label: () => ProgressLabel2,
  PropsProvider: () => ProgressPropsProvider,
  Range: () => ProgressRange2,
  Root: () => ProgressRoot2,
  RootProvider: () => ProgressRootProvider2,
  Track: () => ProgressTrack2,
  ValueText: () => ProgressValueText2
});

// node_modules/@chakra-ui/react/dist/esm/components/progress-circle/progress-circle.js
var {
  withProvider: withProvider23,
  withContext: withContext37,
  useStyles: useProgressCircleStyles,
  PropsProvider: PropsProvider36
} = createSlotRecipeContext({ key: "progressCircle" });
var ProgressCircleRootProvider = withProvider23(progress_exports.RootProvider, "root", { forwardAsChild: true });
var ProgressCircleRoot = withProvider23(progress_exports.Root, "root", { forwardAsChild: true });
var ProgressCirclePropsProvider = PropsProvider36;
var ProgressCircleLabel = withContext37(progress_exports.Label, "label", { forwardAsChild: true });
var ProgressCircleCircle = withContext37(progress_exports.Circle, "circle", { forwardAsChild: true });
var ProgressCircleTrack2 = withContext37(progress_exports.CircleTrack, "circleTrack", { forwardAsChild: true });
var ProgressCircleRange2 = withContext37(progress_exports.CircleRange, "circleRange", { forwardAsChild: true });
var ProgressCircleValueText = withContext37(progress_exports.ValueText, "valueText", { forwardAsChild: true });
var ProgressCircleContext = progress_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/progress-circle/namespace.js
var namespace_exports29 = {};
__export(namespace_exports29, {
  Circle: () => ProgressCircleCircle,
  Label: () => ProgressCircleLabel,
  PropsProvider: () => ProgressCirclePropsProvider,
  Range: () => ProgressCircleRange2,
  Root: () => ProgressCircleRoot,
  RootProvider: () => ProgressCircleRootProvider,
  Track: () => ProgressCircleTrack2,
  ValueText: () => ProgressCircleValueText
});

// node_modules/@chakra-ui/react/dist/esm/components/radio-card/radio-card.js
var import_jsx_runtime197 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group-context.js
var [RadioGroupProvider, useRadioGroupContext] = createContext({
  name: "RadioGroupContext",
  hookName: "useRadioGroupContext",
  providerName: "<RadioGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-context.js
var RadioGroupContext = (props52) => props52.children(useRadioGroupContext());

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-indicator.js
var import_jsx_runtime188 = __toESM(require_jsx_runtime(), 1);
var import_react371 = __toESM(require_react(), 1);
var RadioGroupIndicator = (0, import_react371.forwardRef)(
  (props52, ref36) => {
    const radioGroup = useRadioGroupContext();
    const mergedProps = mergeProps3(radioGroup.getIndicatorProps(), props52);
    return (0, import_jsx_runtime188.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
RadioGroupIndicator.displayName = "RadioGroupIndicator";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item.js
var import_jsx_runtime189 = __toESM(require_jsx_runtime(), 1);
var import_react373 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group-item-context.js
var [RadioGroupItemProvider, useRadioGroupItemContext] = createContext({
  name: "RadioGroupItemContext",
  hookName: "useRadioGroupItemContext",
  providerName: "<RadioGroupItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group-item-props-context.js
var [RadioGroupItemPropsProvider, useRadioGroupItemPropsContext] = createContext({
  name: "RadioGroupItemPropsContext",
  hookName: "useRadioGroupItemPropsContext",
  providerName: "<RadioGroupItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item.js
var RadioGroupItem = (0, import_react373.forwardRef)((props52, ref36) => {
  const [itemProps17, localProps] = createSplitProps3()(props52, [
    "value",
    "disabled",
    "invalid"
  ]);
  const radioGroup = useRadioGroupContext();
  const mergedProps = mergeProps3(radioGroup.getItemProps(itemProps17), localProps);
  const itemState = radioGroup.getItemState(itemProps17);
  return (0, import_jsx_runtime189.jsx)(RadioGroupItemProvider, { value: itemState, children: (0, import_jsx_runtime189.jsx)(RadioGroupItemPropsProvider, { value: itemProps17, children: (0, import_jsx_runtime189.jsx)(ark.label, { ...mergedProps, ref: ref36 }) }) });
});
RadioGroupItem.displayName = "RadioGroupItem";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-context.js
var RadioGroupItemContext = (props52) => props52.children(useRadioGroupItemContext());

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-control.js
var import_jsx_runtime190 = __toESM(require_jsx_runtime(), 1);
var import_react375 = __toESM(require_react(), 1);
var RadioGroupItemControl = (0, import_react375.forwardRef)(
  (props52, ref36) => {
    const radioGroup = useRadioGroupContext();
    const itemProps17 = useRadioGroupItemPropsContext();
    const mergedProps = mergeProps3(radioGroup.getItemControlProps(itemProps17), props52);
    return (0, import_jsx_runtime190.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
RadioGroupItemControl.displayName = "RadioGroupItemControl";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-hidden-input.js
var import_jsx_runtime191 = __toESM(require_jsx_runtime(), 1);
var import_react377 = __toESM(require_react(), 1);
var RadioGroupItemHiddenInput = (0, import_react377.forwardRef)((props52, ref36) => {
  const radioGroup = useRadioGroupContext();
  const itemProps17 = useRadioGroupItemPropsContext();
  const mergedProps = mergeProps3(radioGroup.getItemHiddenInputProps(itemProps17), props52);
  return (0, import_jsx_runtime191.jsx)(ark.input, { ...mergedProps, ref: ref36 });
});
RadioGroupItemHiddenInput.displayName = "RadioGroupItemHiddenInput";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-text.js
var import_jsx_runtime192 = __toESM(require_jsx_runtime(), 1);
var import_react379 = __toESM(require_react(), 1);
var RadioGroupItemText = (0, import_react379.forwardRef)(
  (props52, ref36) => {
    const radioGroup = useRadioGroupContext();
    const itemProps17 = useRadioGroupItemPropsContext();
    const mergedProps = mergeProps3(radioGroup.getItemTextProps(itemProps17), props52);
    return (0, import_jsx_runtime192.jsx)(ark.span, { ...mergedProps, ref: ref36 });
  }
);
RadioGroupItemText.displayName = "RadioGroupItemText";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-label.js
var import_jsx_runtime193 = __toESM(require_jsx_runtime(), 1);
var import_react381 = __toESM(require_react(), 1);
var RadioGroupLabel = (0, import_react381.forwardRef)((props52, ref36) => {
  const radioGroup = useRadioGroupContext();
  const mergedProps = mergeProps3(radioGroup.getLabelProps(), props52);
  return (0, import_jsx_runtime193.jsx)(ark.label, { ...mergedProps, ref: ref36 });
});
RadioGroupLabel.displayName = "RadioGroupLabel";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-root.js
var import_jsx_runtime194 = __toESM(require_jsx_runtime(), 1);
var import_react385 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/node_modules/@zag-js/element-rect/dist/index.mjs
var rafId;
var observedElements = /* @__PURE__ */ new Map();
var getRectFn = (el) => el.getBoundingClientRect();
function trackElementRect2(el, options) {
  const { scope = "rect", getRect = getRectFn, onChange } = options;
  const loop = getLoopFn({ scope, getRect });
  const data = observedElements.get(el);
  if (!data) {
    observedElements.set(el, {
      rect: {},
      callbacks: [onChange]
    });
    if (observedElements.size === 1) {
      rafId = requestAnimationFrame(loop);
    }
  } else {
    data.callbacks.push(onChange);
    onChange(getRect(el));
  }
  return function unobserve() {
    const data2 = observedElements.get(el);
    if (!data2) return;
    const index = data2.callbacks.indexOf(onChange);
    if (index > -1) {
      data2.callbacks.splice(index, 1);
    }
    if (data2.callbacks.length === 0) {
      observedElements.delete(el);
      if (observedElements.size === 0) {
        cancelAnimationFrame(rafId);
      }
    }
  };
}
function getLoopFn(options) {
  const { scope, getRect } = options;
  const isEqual6 = getEqualityFn(scope);
  return function loop() {
    const changedRectsData = [];
    observedElements.forEach((data, element) => {
      const newRect = getRect(element);
      if (!isEqual6(data.rect, newRect)) {
        data.rect = newRect;
        changedRectsData.push(data);
      }
    });
    changedRectsData.forEach((data) => {
      data.callbacks.forEach((callback) => callback(data.rect));
    });
    rafId = requestAnimationFrame(loop);
  };
}
var isEqualSize = (a, b) => a.width === b.width && a.height === b.height;
var isEqualPosition = (a, b) => a.top === b.top && a.left === b.left;
var isEqualRect = (a, b) => isEqualSize(a, b) && isEqualPosition(a, b);
function getEqualityFn(scope) {
  if (scope === "size") return isEqualSize;
  if (scope === "position") return isEqualPosition;
  return isEqualRect;
}

// node_modules/@ark-ui/react/node_modules/@zag-js/radio-group/dist/index.mjs
var anatomy59 = createAnatomy2("radio-group").parts(
  "root",
  "label",
  "item",
  "itemText",
  "itemControl",
  "indicator"
);
var parts54 = anatomy59.build();
var dom52 = createScope({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `radio-group:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `radio-group:${ctx.id}:label`;
  },
  getItemId: (ctx, value) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.item) == null ? void 0 : _b6.call(_a7, value)) ?? `radio-group:${ctx.id}:radio:${value}`;
  },
  getItemHiddenInputId: (ctx, value) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemHiddenInput) == null ? void 0 : _b6.call(_a7, value)) ?? `radio-group:${ctx.id}:radio:input:${value}`;
  },
  getItemControlId: (ctx, value) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemControl) == null ? void 0 : _b6.call(_a7, value)) ?? `radio-group:${ctx.id}:radio:control:${value}`;
  },
  getItemLabelId: (ctx, value) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemLabel) == null ? void 0 : _b6.call(_a7, value)) ?? `radio-group:${ctx.id}:radio:label:${value}`;
  },
  getIndicatorId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.indicator) ?? `radio-group:${ctx.id}:indicator`;
  },
  getRootEl: (ctx) => dom52.getById(ctx, dom52.getRootId(ctx)),
  getItemHiddenInputEl: (ctx, value) => dom52.getById(ctx, dom52.getItemHiddenInputId(ctx, value)),
  getIndicatorEl: (ctx) => dom52.getById(ctx, dom52.getIndicatorId(ctx)),
  getFirstEnabledInputEl: (ctx) => {
    var _a7;
    return (_a7 = dom52.getRootEl(ctx)) == null ? void 0 : _a7.querySelector("input:not(:disabled)");
  },
  getFirstEnabledAndCheckedInputEl: (ctx) => {
    var _a7;
    return (_a7 = dom52.getRootEl(ctx)) == null ? void 0 : _a7.querySelector("input:not(:disabled):checked");
  },
  getInputEls: (ctx) => {
    const ownerId = CSS.escape(dom52.getRootId(ctx));
    const selector = `input[type=radio][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom52.getRootEl(ctx), selector);
  },
  getActiveRadioEl: (ctx) => {
    if (!ctx.value) return;
    return dom52.getById(ctx, dom52.getItemId(ctx, ctx.value));
  },
  getOffsetRect: (el) => ({
    left: (el == null ? void 0 : el.offsetLeft) ?? 0,
    top: (el == null ? void 0 : el.offsetTop) ?? 0,
    width: (el == null ? void 0 : el.offsetWidth) ?? 0,
    height: (el == null ? void 0 : el.offsetHeight) ?? 0
  }),
  getRectById: (ctx, id) => {
    const radioEl = dom52.getById(ctx, dom52.getItemId(ctx, id));
    if (!radioEl) return;
    return dom52.resolveRect(dom52.getOffsetRect(radioEl));
  },
  resolveRect: (rect) => ({
    width: `${rect.width}px`,
    height: `${rect.height}px`,
    left: `${rect.left}px`,
    top: `${rect.top}px`
  })
});
function connect17(state2, send, normalize2) {
  const groupDisabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  function getItemState(props210) {
    return {
      invalid: !!props210.invalid,
      disabled: !!props210.disabled || groupDisabled,
      checked: state2.context.value === props210.value,
      focused: state2.context.focusedValue === props210.value,
      hovered: state2.context.hoveredValue === props210.value,
      active: state2.context.activeValue === props210.value
    };
  }
  function getItemDataAttrs(props210) {
    const radioState = getItemState(props210);
    return {
      "data-focus": dataAttr(radioState.focused),
      "data-focus-visible": dataAttr(radioState.focused && state2.context.focusVisible),
      "data-disabled": dataAttr(radioState.disabled),
      "data-readonly": dataAttr(readOnly),
      "data-state": radioState.checked ? "checked" : "unchecked",
      "data-hover": dataAttr(radioState.hovered),
      "data-invalid": dataAttr(radioState.invalid),
      "data-orientation": state2.context.orientation,
      "data-ssr": dataAttr(state2.context.ssr)
    };
  }
  const focus = () => {
    const firstEnabledAndCheckedInput = dom52.getFirstEnabledAndCheckedInputEl(state2.context);
    if (firstEnabledAndCheckedInput) {
      firstEnabledAndCheckedInput.focus();
      return;
    }
    const firstEnabledInput = dom52.getFirstEnabledInputEl(state2.context);
    firstEnabledInput == null ? void 0 : firstEnabledInput.focus();
  };
  return {
    focus,
    value: state2.context.value,
    setValue(value) {
      send({ type: "SET_VALUE", value, isTrusted: false });
    },
    clearValue() {
      send({ type: "SET_VALUE", value: null, isTrusted: false });
    },
    getRootProps() {
      return normalize2.element({
        ...parts54.root.attrs,
        role: "radiogroup",
        id: dom52.getRootId(state2.context),
        "aria-labelledby": dom52.getLabelId(state2.context),
        "data-orientation": state2.context.orientation,
        "data-disabled": dataAttr(groupDisabled),
        "aria-orientation": state2.context.orientation,
        dir: state2.context.dir,
        style: {
          position: "relative"
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        ...parts54.label.attrs,
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        "data-disabled": dataAttr(groupDisabled),
        id: dom52.getLabelId(state2.context),
        onClick: focus
      });
    },
    getItemState,
    getItemProps(props210) {
      const itemState = getItemState(props210);
      return normalize2.label({
        ...parts54.item.attrs,
        dir: state2.context.dir,
        id: dom52.getItemId(state2.context, props210.value),
        htmlFor: dom52.getItemHiddenInputId(state2.context, props210.value),
        ...getItemDataAttrs(props210),
        onPointerMove() {
          if (itemState.disabled) return;
          if (itemState.hovered) return;
          send({ type: "SET_HOVERED", value: props210.value, hovered: true });
        },
        onPointerLeave() {
          if (itemState.disabled) return;
          send({ type: "SET_HOVERED", value: null });
        },
        onPointerDown(event) {
          if (itemState.disabled) return;
          if (itemState.focused && event.pointerType === "mouse") {
            event.preventDefault();
          }
          send({ type: "SET_ACTIVE", value: props210.value, active: true });
        },
        onPointerUp() {
          if (itemState.disabled) return;
          send({ type: "SET_ACTIVE", value: null });
        }
      });
    },
    getItemTextProps(props210) {
      return normalize2.element({
        ...parts54.itemText.attrs,
        dir: state2.context.dir,
        id: dom52.getItemLabelId(state2.context, props210.value),
        ...getItemDataAttrs(props210)
      });
    },
    getItemControlProps(props210) {
      const controlState = getItemState(props210);
      return normalize2.element({
        ...parts54.itemControl.attrs,
        dir: state2.context.dir,
        id: dom52.getItemControlId(state2.context, props210.value),
        "data-active": dataAttr(controlState.active),
        "aria-hidden": true,
        ...getItemDataAttrs(props210)
      });
    },
    getItemHiddenInputProps(props210) {
      const inputState = getItemState(props210);
      return normalize2.input({
        "data-ownedby": dom52.getRootId(state2.context),
        id: dom52.getItemHiddenInputId(state2.context, props210.value),
        type: "radio",
        name: state2.context.name || state2.context.id,
        form: state2.context.form,
        value: props210.value,
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          if (event.currentTarget.checked) {
            send({ type: "SET_VALUE", value: props210.value, isTrusted: true });
          }
        },
        onBlur() {
          send({ type: "SET_FOCUSED", value: null, focused: false, focusVisible: false });
        },
        onFocus() {
          const focusVisible = isFocusVisible();
          send({ type: "SET_FOCUSED", value: props210.value, focused: true, focusVisible });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: props210.value, active: true });
          }
        },
        onKeyUp(event) {
          if (event.defaultPrevented) return;
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: null });
          }
        },
        disabled: inputState.disabled,
        defaultChecked: inputState.checked,
        style: visuallyHiddenStyle
      });
    },
    getIndicatorProps() {
      var _a7, _b6, _c5, _d5;
      return normalize2.element({
        id: dom52.getIndicatorId(state2.context),
        ...parts54.indicator.attrs,
        dir: state2.context.dir,
        hidden: state2.context.value == null,
        "data-disabled": dataAttr(groupDisabled),
        "data-orientation": state2.context.orientation,
        style: {
          "--transition-property": "left, top, width, height",
          "--left": (_a7 = state2.context.indicatorRect) == null ? void 0 : _a7.left,
          "--top": (_b6 = state2.context.indicatorRect) == null ? void 0 : _b6.top,
          "--width": (_c5 = state2.context.indicatorRect) == null ? void 0 : _c5.width,
          "--height": (_d5 = state2.context.indicatorRect) == null ? void 0 : _d5.height,
          position: "absolute",
          willChange: "var(--transition-property)",
          transitionProperty: "var(--transition-property)",
          transitionDuration: state2.context.canIndicatorTransition ? "var(--transition-duration, 150ms)" : "0ms",
          transitionTimingFunction: "var(--transition-timing-function)",
          [state2.context.orientation === "horizontal" ? "left" : "top"]: state2.context.orientation === "horizontal" ? "var(--left)" : "var(--top)"
        }
      });
    }
  };
}
var { not: not41 } = guards20;
function machine17(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "radio",
      initial: "idle",
      context: {
        value: null,
        activeValue: null,
        focusedValue: null,
        hoveredValue: null,
        disabled: false,
        orientation: "vertical",
        ...ctx,
        indicatorRect: {},
        canIndicatorTransition: false,
        fieldsetDisabled: false,
        focusVisible: false,
        ssr: true
      },
      computed: {
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled
      },
      entry: ["syncIndicatorRect", "syncSsr"],
      exit: ["cleanupObserver"],
      activities: ["trackFormControlState", "trackFocusVisible"],
      watch: {
        value: ["setIndicatorTransition", "syncIndicatorRect", "syncInputElements"]
      },
      on: {
        SET_VALUE: [
          {
            guard: not41("isTrusted"),
            actions: ["setValue", "dispatchChangeEvent"]
          },
          {
            actions: ["setValue"]
          }
        ],
        SET_HOVERED: {
          actions: "setHovered"
        },
        SET_ACTIVE: {
          actions: "setActive"
        },
        SET_FOCUSED: {
          actions: "setFocused"
        }
      },
      states: {
        idle: {}
      }
    },
    {
      guards: {
        isTrusted: (_ctx, evt) => !!evt.isTrusted
      },
      activities: {
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl2(dom52.getRootEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "SET_VALUE", value: initialContext.value });
            }
          });
        },
        trackFocusVisible(ctx2) {
          return trackFocusVisible2({ root: dom52.getRootNode(ctx2) });
        }
      },
      actions: {
        setValue(ctx2, evt) {
          set11.value(ctx2, evt.value);
        },
        setHovered(ctx2, evt) {
          ctx2.hoveredValue = evt.value;
        },
        setActive(ctx2, evt) {
          ctx2.activeValue = evt.value;
        },
        setFocused(ctx2, evt) {
          ctx2.focusedValue = evt.value;
          ctx2.focusVisible = evt.focusVisible;
        },
        syncInputElements(ctx2) {
          const inputs = dom52.getInputEls(ctx2);
          inputs.forEach((input) => {
            input.checked = input.value === ctx2.value;
          });
        },
        setIndicatorTransition(ctx2) {
          ctx2.canIndicatorTransition = isString23(ctx2.value);
        },
        cleanupObserver(ctx2) {
          var _a7;
          (_a7 = ctx2.indicatorCleanup) == null ? void 0 : _a7.call(ctx2);
        },
        syncSsr(ctx2) {
          ctx2.ssr = false;
        },
        syncIndicatorRect(ctx2) {
          var _a7;
          (_a7 = ctx2.indicatorCleanup) == null ? void 0 : _a7.call(ctx2);
          if (!dom52.getIndicatorEl(ctx2)) return;
          const value = ctx2.value;
          const radioEl = dom52.getActiveRadioEl(ctx2);
          if (value == null || !radioEl) {
            ctx2.indicatorRect = {};
            return;
          }
          ctx2.indicatorCleanup = trackElementRect2(radioEl, {
            getRect(el) {
              return dom52.getOffsetRect(el);
            },
            onChange(rect) {
              ctx2.indicatorRect = dom52.resolveRect(rect);
              nextTick(() => {
                ctx2.canIndicatorTransition = false;
              });
            }
          });
        },
        dispatchChangeEvent(ctx2) {
          const inputEls = dom52.getInputEls(ctx2);
          inputEls.forEach((inputEl) => {
            const checked = inputEl.value === ctx2.value;
            if (checked === inputEl.checked) return;
            dispatchInputCheckedEvent2(inputEl, { checked });
          });
        }
      }
    }
  );
}
var invoke7 = {
  change: (ctx) => {
    var _a7;
    if (ctx.value == null) return;
    (_a7 = ctx.onValueChange) == null ? void 0 : _a7.call(ctx, { value: ctx.value });
  }
};
var set11 = {
  value: (ctx, value) => {
    if (isEqual3(ctx.value, value)) return;
    ctx.value = value;
    invoke7.change(ctx);
  }
};
var props44 = createProps30()([
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onValueChange",
  "orientation",
  "readOnly",
  "value"
]);
var splitProps44 = createSplitProps2(props44);
var itemProps14 = createProps30()(["value", "disabled", "invalid"]);
var splitItemProps14 = createSplitProps2(itemProps14);

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group.js
var import_react383 = __toESM(require_react(), 1);
var useRadioGroup = (props52 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react383.useId)(),
    dir,
    getRootNode: getRootNode2,
    value: props52.defaultValue,
    ...props52
  };
  const context = {
    ...initialContext,
    value: props52.value,
    onValueChange: useEvent(props52.onValueChange, { sync: true })
  };
  const [state2, send] = useMachine(machine17(initialContext), {
    context
  });
  return connect17(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-root.js
var RadioGroupRoot = (0, import_react385.forwardRef)((props52, ref36) => {
  const [useRadioGroupProps, localProps] = createSplitProps3()(props52, [
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "name",
    "onValueChange",
    "orientation",
    "readOnly",
    "value"
  ]);
  const radioGroup = useRadioGroup(useRadioGroupProps);
  const mergedProps = mergeProps3(radioGroup.getRootProps(), localProps);
  return (0, import_jsx_runtime194.jsx)(RadioGroupProvider, { value: radioGroup, children: (0, import_jsx_runtime194.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
});
RadioGroupRoot.displayName = "RadioGroupRoot";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-root-provider.js
var import_jsx_runtime195 = __toESM(require_jsx_runtime(), 1);
var import_react387 = __toESM(require_react(), 1);
var RadioGroupRootProvider = (0, import_react387.forwardRef)(
  (props52, ref36) => {
    const [{ value: radioGroup }, localProps] = createSplitProps3()(props52, [
      "value"
    ]);
    const mergedProps = mergeProps3(radioGroup.getRootProps(), localProps);
    return (0, import_jsx_runtime195.jsx)(RadioGroupProvider, { value: radioGroup, children: (0, import_jsx_runtime195.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
  }
);
RadioGroupRootProvider.displayName = "RadioGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group.js
var radio_group_exports = {};
__export(radio_group_exports, {
  Context: () => RadioGroupContext,
  Indicator: () => RadioGroupIndicator,
  Item: () => RadioGroupItem,
  ItemContext: () => RadioGroupItemContext,
  ItemControl: () => RadioGroupItemControl,
  ItemHiddenInput: () => RadioGroupItemHiddenInput,
  ItemText: () => RadioGroupItemText,
  Label: () => RadioGroupLabel,
  Root: () => RadioGroupRoot,
  RootProvider: () => RadioGroupRootProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/radio-card/radio-card.js
var import_react389 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/radiomark/radiomark.js
var import_jsx_runtime196 = __toESM(require_jsx_runtime(), 1);
var import_react388 = __toESM(require_react(), 1);
var Radiomark = (0, import_react388.forwardRef)(
  function Radiomark2(props52, ref36) {
    const recipe = useRecipe({ key: "radiomark", recipe: props52.recipe });
    const [variantProps, restProps] = recipe.splitVariantProps(props52);
    const { checked, disabled, unstyled, children, ...rest } = restProps;
    const styles = unstyled ? EMPTY_STYLES : recipe(variantProps);
    const sharedProps = {
      ref: ref36,
      "data-checked": dataAttr31(checked),
      "data-disabled": dataAttr31(disabled),
      ...rest,
      css: [styles, props52.css]
    };
    return (0, import_jsx_runtime196.jsx)(chakra.span, { ...sharedProps, children: checked && (0, import_jsx_runtime196.jsx)("span", { className: "dot" }) });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/radio-card/radio-card.js
var {
  withProvider: withProvider24,
  withContext: withContext38,
  useStyles: useRadioCardStyles,
  PropsProvider: PropsProvider37
} = createSlotRecipeContext({ key: "radioCard" });
var RadioCardRootProvider = withProvider24(radio_group_exports.RootProvider, "root", { forwardAsChild: true });
var RadioCardRoot = withProvider24(
  radio_group_exports.Root,
  "root",
  { forwardAsChild: true }
);
var RadioCardPropsProvider = PropsProvider37;
var RadioCardLabel = withContext38(
  radio_group_exports.Label,
  "label",
  { forwardAsChild: true }
);
var RadioCardItem = withContext38(
  radio_group_exports.Item,
  "item",
  { forwardAsChild: true }
);
var RadioCardItemText = withContext38(radio_group_exports.ItemText, "itemText", { forwardAsChild: true });
var RadioCardItemDescription = withContext38("div", "itemDescription", { forwardAsChild: true });
var RadioCardItemControl = withContext38(radio_group_exports.ItemControl, "itemControl", { forwardAsChild: true });
var RadioCardItemContent = withContext38("div", "itemContent");
var RadioCardItemAddon = withContext38("div", "itemAddon");
var RadioCardItemIndicator = (0, import_react389.forwardRef)(function RadioGroupItemIndicator(props52, ref36) {
  const { checked, ...rest } = props52;
  const styles = useRadioCardStyles();
  const itemContext = useRadioGroupItemContext();
  if (checked && itemContext.checked) {
    return (0, import_jsx_runtime197.jsx)(
      chakra.span,
      {
        ref: ref36,
        asChild: true,
        ...rest,
        css: [styles["itemIndicator"], props52.css],
        children: checked
      }
    );
  }
  return (0, import_jsx_runtime197.jsx)(
    Radiomark,
    {
      ref: ref36,
      unstyled: true,
      ...props52,
      checked: itemContext.checked,
      disabled: itemContext.disabled,
      css: [styles["itemIndicator"], props52.css]
    }
  );
});
var RadioCardContext = radio_group_exports.Context;
var RadioCardItemContext = radio_group_exports.ItemContext;
var RadioCardItemHiddenInput = radio_group_exports.ItemHiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/radio-card/namespace.js
var namespace_exports30 = {};
__export(namespace_exports30, {
  Context: () => RadioCardContext,
  Item: () => RadioCardItem,
  ItemAddon: () => RadioCardItemAddon,
  ItemContent: () => RadioCardItemContent,
  ItemContext: () => RadioCardItemContext,
  ItemControl: () => RadioCardItemControl,
  ItemDescription: () => RadioCardItemDescription,
  ItemHiddenInput: () => RadioCardItemHiddenInput,
  ItemIndicator: () => RadioCardItemIndicator,
  ItemText: () => RadioCardItemText,
  Label: () => RadioCardLabel,
  PropsProvider: () => RadioCardPropsProvider,
  Root: () => RadioCardRoot,
  RootProvider: () => RadioCardRootProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/radio-group/radio-group.js
var import_jsx_runtime198 = __toESM(require_jsx_runtime(), 1);
var import_react390 = __toESM(require_react(), 1);
var {
  withProvider: withProvider25,
  withContext: withContext39,
  useStyles: useRadioGroupStyles,
  PropsProvider: PropsProvider38
} = createSlotRecipeContext({ key: "radioGroup" });
var RadioGroupRootProvider2 = withProvider25(radio_group_exports.RootProvider, "root", { forwardAsChild: true });
var RadioGroupRoot2 = withProvider25(
  radio_group_exports.Root,
  "root",
  { forwardAsChild: true }
);
var RadioGroupPropsProvider = PropsProvider38;
var RadioGroupLabel2 = withContext39(radio_group_exports.Label, "label", { forwardAsChild: true });
var RadioGroupItem2 = withContext39(
  radio_group_exports.Item,
  "item",
  { forwardAsChild: true }
);
var RadioGroupItemText2 = withContext39(radio_group_exports.ItemText, "itemText", { forwardAsChild: true });
var RadioGroupItemControl2 = withContext39(radio_group_exports.ItemControl, "itemControl", { forwardAsChild: true });
var RadioGroupItemIndicator2 = (0, import_react390.forwardRef)(function RadioGroupItemIndicator22(props52, ref36) {
  const styles = useRadioGroupStyles();
  return (0, import_jsx_runtime198.jsx)(radio_group_exports.ItemContext, { children: (itemState) => (0, import_jsx_runtime198.jsx)(radio_group_exports.ItemControl, { asChild: true, children: (0, import_jsx_runtime198.jsx)(
    Radiomark,
    {
      ref: ref36,
      unstyled: true,
      ...props52,
      checked: itemState.checked,
      disabled: itemState.disabled,
      css: [styles["itemControl"], props52.css]
    }
  ) }) });
});
var RadioGroupContext2 = radio_group_exports.Context;
var RadioGroupItemContext2 = radio_group_exports.ItemContext;
var RadioGroupItemHiddenInput2 = radio_group_exports.ItemHiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/radio-group/namespace.js
var namespace_exports31 = {};
__export(namespace_exports31, {
  Context: () => RadioGroupContext2,
  Item: () => RadioGroupItem2,
  ItemContext: () => RadioGroupItemContext2,
  ItemControl: () => RadioGroupItemControl2,
  ItemHiddenInput: () => RadioGroupItemHiddenInput2,
  ItemIndicator: () => RadioGroupItemIndicator2,
  ItemText: () => RadioGroupItemText2,
  Label: () => RadioGroupLabel2,
  PropsProvider: () => RadioGroupPropsProvider,
  Root: () => RadioGroupRoot2,
  RootProvider: () => RadioGroupRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/rating-group/rating-group.js
var import_jsx_runtime205 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/rating-group/use-rating-group-context.js
var [RatingGroupProvider, useRatingGroupContext] = createContext({
  name: "RatingGroupContext",
  hookName: "useRatingGroupContext",
  providerName: "<RatingGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-context.js
var RatingGroupContext = (props52) => props52.children(useRatingGroupContext());

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-control.js
var import_jsx_runtime199 = __toESM(require_jsx_runtime(), 1);
var import_react392 = __toESM(require_react(), 1);
var RatingGroupControl = (0, import_react392.forwardRef)(
  (props52, ref36) => {
    const ratingGroup = useRatingGroupContext();
    const mergedProps = mergeProps3(ratingGroup.getControlProps(), props52);
    return (0, import_jsx_runtime199.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
RatingGroupControl.displayName = "RatingGroupControl";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-hidden-input.js
var import_jsx_runtime200 = __toESM(require_jsx_runtime(), 1);
var import_react394 = __toESM(require_react(), 1);
var RatingGroupHiddenInput = (0, import_react394.forwardRef)(
  (props52, ref36) => {
    const ratingGroup = useRatingGroupContext();
    const mergedProps = mergeProps3(ratingGroup.getHiddenInputProps(), props52);
    const field = useFieldContext();
    return (0, import_jsx_runtime200.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref36 });
  }
);
RatingGroupHiddenInput.displayName = "RatingGroupHiddenInput";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-item.js
var import_jsx_runtime201 = __toESM(require_jsx_runtime(), 1);
var import_react396 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/rating-group/use-rating-group-item-context.js
var [RatingGroupItemProvider, useRatingGroupItemContext] = createContext({
  name: "RatingGroupItemContext",
  hookName: "useRatingGroupItemContext",
  providerName: "<RatingGroupItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-item.js
var RatingGroupItem = (0, import_react396.forwardRef)((props52, ref36) => {
  const [itemProps17, localProps] = createSplitProps3()(props52, ["index"]);
  const ratingGroup = useRatingGroupContext();
  const mergedProps = mergeProps3(ratingGroup.getItemProps(itemProps17), localProps);
  const itemState = ratingGroup.getItemState(itemProps17);
  return (0, import_jsx_runtime201.jsx)(RatingGroupItemProvider, { value: itemState, children: (0, import_jsx_runtime201.jsx)(ark.span, { ...mergedProps, ref: ref36 }) });
});
RatingGroupItem.displayName = "RatingGroupItem";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-item-context.js
var RatingGroupItemContext = (props52) => props52.children(useRatingGroupItemContext());

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-label.js
var import_jsx_runtime202 = __toESM(require_jsx_runtime(), 1);
var import_react398 = __toESM(require_react(), 1);
var RatingGroupLabel = (0, import_react398.forwardRef)(
  (props52, ref36) => {
    const ratingGroup = useRatingGroupContext();
    const mergedProps = mergeProps3(ratingGroup.getLabelProps(), props52);
    return (0, import_jsx_runtime202.jsx)(ark.label, { ...mergedProps, ref: ref36 });
  }
);
RatingGroupLabel.displayName = "RatingGroupLabel";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-root.js
var import_jsx_runtime203 = __toESM(require_jsx_runtime(), 1);
var import_react402 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/node_modules/@zag-js/rating-group/dist/index.mjs
var anatomy60 = createAnatomy2("rating-group").parts("root", "label", "item", "control");
var parts55 = anatomy60.build();
var dom53 = createScope({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `rating:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `rating:${ctx.id}:label`;
  },
  getHiddenInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.hiddenInput) ?? `rating:${ctx.id}:input`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `rating:${ctx.id}:control`;
  },
  getItemId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.item) == null ? void 0 : _b6.call(_a7, id)) ?? `rating:${ctx.id}:item:${id}`;
  },
  getRootEl: (ctx) => dom53.getById(ctx, dom53.getRootId(ctx)),
  getControlEl: (ctx) => dom53.getById(ctx, dom53.getControlId(ctx)),
  getRadioEl: (ctx, value = ctx.value) => {
    const selector = `[role=radio][aria-posinset='${Math.ceil(value)}']`;
    return query(dom53.getControlEl(ctx), selector);
  },
  getHiddenInputEl: (ctx) => dom53.getById(ctx, dom53.getHiddenInputId(ctx)),
  dispatchChangeEvent: (ctx) => {
    const inputEl = dom53.getHiddenInputEl(ctx);
    if (!inputEl) return;
    dispatchInputValueEvent2(inputEl, { value: ctx.value });
  }
});
function connect18(state2, send, normalize2) {
  const interactive = state2.context.isInteractive;
  const disabled = state2.context.isDisabled;
  const value = state2.context.value;
  const hoveredValue = state2.context.hoveredValue;
  const translations = state2.context.translations;
  function getItemState(props210) {
    const value2 = state2.context.isHovering ? state2.context.hoveredValue : state2.context.value;
    const equal = Math.ceil(value2) === props210.index;
    const highlighted = props210.index <= value2 || equal;
    const half = equal && Math.abs(value2 - props210.index) === 0.5;
    return {
      highlighted,
      half,
      checked: equal || state2.context.value === -1 && props210.index === 1
    };
  }
  return {
    hovering: state2.context.isHovering,
    value,
    hoveredValue,
    count: state2.context.count,
    items: Array.from({ length: state2.context.count }).map((_, index) => index + 1),
    setValue(value2) {
      send({ type: "SET_VALUE", value: value2 });
    },
    clearValue() {
      send("CLEAR_VALUE");
    },
    getRootProps() {
      return normalize2.element({
        ...parts55.root.attrs,
        dir: state2.context.dir,
        id: dom53.getRootId(state2.context)
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        name: state2.context.name,
        form: state2.context.form,
        type: "text",
        hidden: true,
        disabled,
        readOnly: state2.context.readOnly,
        required: state2.context.required,
        id: dom53.getHiddenInputId(state2.context),
        defaultValue: state2.context.value
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts55.label.attrs,
        dir: state2.context.dir,
        id: dom53.getLabelId(state2.context),
        "data-disabled": dataAttr(disabled),
        htmlFor: dom53.getHiddenInputId(state2.context),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          event.preventDefault();
          const radioEl = dom53.getRadioEl(state2.context, 1);
          radioEl == null ? void 0 : radioEl.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize2.element({
        id: dom53.getControlId(state2.context),
        ...parts55.control.attrs,
        dir: state2.context.dir,
        role: "radiogroup",
        "aria-orientation": "horizontal",
        "aria-labelledby": dom53.getLabelId(state2.context),
        "aria-readonly": ariaAttr(state2.context.readOnly),
        "data-readonly": dataAttr(state2.context.readOnly),
        tabIndex: state2.context.readOnly ? 0 : -1,
        "data-disabled": dataAttr(disabled),
        onPointerMove(event) {
          if (!interactive) return;
          if (event.pointerType === "touch") return;
          send("GROUP_POINTER_OVER");
        },
        onPointerLeave(event) {
          if (!interactive) return;
          if (event.pointerType === "touch") return;
          send("GROUP_POINTER_LEAVE");
        }
      });
    },
    getItemState,
    getItemProps(props210) {
      const { index } = props210;
      const itemState = getItemState(props210);
      const valueText = translations.ratingValueText(index);
      return normalize2.element({
        ...parts55.item.attrs,
        dir: state2.context.dir,
        id: dom53.getItemId(state2.context, index.toString()),
        role: "radio",
        tabIndex: disabled ? void 0 : itemState.checked ? 0 : -1,
        "aria-roledescription": "rating",
        "aria-label": valueText,
        "aria-disabled": disabled,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        "aria-setsize": state2.context.count,
        "aria-checked": itemState.checked,
        "data-checked": dataAttr(itemState.checked),
        "aria-posinset": index,
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-half": dataAttr(itemState.half),
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick2(event)) return;
          event.preventDefault();
        },
        onPointerMove(event) {
          if (!interactive) return;
          const point = getEventPoint2(event);
          const relativePoint = getRelativePoint2(point, event.currentTarget);
          const percentX = relativePoint.getPercentValue({
            orientation: "horizontal",
            dir: state2.context.dir
          });
          const isMidway = percentX < 0.5;
          send({ type: "POINTER_OVER", index, isMidway });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const keyMap2 = {
            ArrowLeft() {
              send("ARROW_LEFT");
            },
            ArrowRight() {
              send("ARROW_RIGHT");
            },
            ArrowUp() {
              send("ARROW_LEFT");
            },
            ArrowDown() {
              send("ARROW_RIGHT");
            },
            Space() {
              send({ type: "SPACE", value: index });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = getEventKey2(event, state2.context);
          const exec21 = keyMap2[key];
          if (exec21) {
            event.preventDefault();
            exec21(event);
          }
        },
        onClick() {
          if (!interactive) return;
          send({ type: "CLICK", value: index });
        },
        onFocus() {
          if (!interactive) return;
          send("FOCUS");
        },
        onBlur() {
          if (!interactive) return;
          send("BLUR");
        }
      });
    }
  };
}
function machine18(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "rating",
      initial: "idle",
      context: {
        name: "rating",
        count: 5,
        dir: "ltr",
        value: -1,
        readOnly: false,
        disabled: false,
        ...ctx,
        hoveredValue: -1,
        fieldsetDisabled: false,
        translations: {
          ratingValueText: (index) => `${index} stars`,
          ...ctx.translations
        }
      },
      created: ["roundValueIfNeeded"],
      watch: {
        allowHalf: ["roundValueIfNeeded"]
      },
      computed: {
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.isDisabled || ctx2.readOnly),
        isHovering: (ctx2) => ctx2.hoveredValue > -1
      },
      activities: ["trackFormControlState"],
      on: {
        SET_VALUE: {
          actions: ["setValue"]
        },
        CLEAR_VALUE: {
          actions: ["clearValue"]
        }
      },
      states: {
        idle: {
          entry: "clearHoveredValue",
          on: {
            GROUP_POINTER_OVER: "hover",
            FOCUS: "focus",
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            }
          }
        },
        focus: {
          on: {
            POINTER_OVER: {
              actions: "setHoveredValue"
            },
            GROUP_POINTER_LEAVE: {
              actions: "clearHoveredValue"
            },
            BLUR: "idle",
            SPACE: {
              guard: "isValueEmpty",
              actions: ["setValue"]
            },
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            },
            ARROW_LEFT: {
              actions: ["setPrevValue", "focusActiveRadio"]
            },
            ARROW_RIGHT: {
              actions: ["setNextValue", "focusActiveRadio"]
            },
            HOME: {
              actions: ["setValueToMin", "focusActiveRadio"]
            },
            END: {
              actions: ["setValueToMax", "focusActiveRadio"]
            }
          }
        },
        hover: {
          on: {
            POINTER_OVER: {
              actions: "setHoveredValue"
            },
            GROUP_POINTER_LEAVE: [
              {
                guard: "isRadioFocused",
                target: "focus",
                actions: "clearHoveredValue"
              },
              {
                target: "idle",
                actions: "clearHoveredValue"
              }
            ],
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            }
          }
        }
      }
    },
    {
      guards: {
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly),
        isHoveredValueEmpty: (ctx2) => ctx2.hoveredValue === -1,
        isValueEmpty: (ctx2) => ctx2.value <= 0,
        isRadioFocused: (ctx2) => {
          var _a7;
          return !!((_a7 = dom53.getControlEl(ctx2)) == null ? void 0 : _a7.contains(dom53.getActiveElement(ctx2)));
        }
      },
      activities: {
        trackFormControlState(ctx2, _evt, { initialContext }) {
          return trackFormControl2(dom53.getHiddenInputEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set12.value(ctx2, initialContext.value);
            }
          });
        }
      },
      actions: {
        clearHoveredValue(ctx2) {
          set12.hoveredValue(ctx2, -1);
        },
        focusActiveRadio(ctx2) {
          raf(() => {
            var _a7;
            return (_a7 = dom53.getRadioEl(ctx2)) == null ? void 0 : _a7.focus();
          });
        },
        setPrevValue(ctx2) {
          const factor = ctx2.allowHalf ? 0.5 : 1;
          set12.value(ctx2, Math.max(0, ctx2.value - factor));
        },
        setNextValue(ctx2) {
          const factor = ctx2.allowHalf ? 0.5 : 1;
          const value = ctx2.value === -1 ? 0 : ctx2.value;
          set12.value(ctx2, Math.min(ctx2.count, value + factor));
        },
        setValueToMin(ctx2) {
          set12.value(ctx2, 1);
        },
        setValueToMax(ctx2) {
          set12.value(ctx2, ctx2.count);
        },
        setValue(ctx2, evt) {
          const value = ctx2.hoveredValue === -1 ? evt.value : ctx2.hoveredValue;
          set12.value(ctx2, value);
        },
        clearValue(ctx2) {
          set12.value(ctx2, -1);
        },
        setHoveredValue(ctx2, evt) {
          const half = ctx2.allowHalf && evt.isMidway;
          const factor = half ? 0.5 : 0;
          set12.hoveredValue(ctx2, evt.index - factor);
        },
        roundValueIfNeeded(ctx2) {
          if (ctx2.allowHalf) return;
          ctx2.value = Math.round(ctx2.value);
        }
      }
    }
  );
}
var invoke8 = {
  change: (ctx) => {
    var _a7;
    (_a7 = ctx.onValueChange) == null ? void 0 : _a7.call(ctx, { value: ctx.value });
    dom53.dispatchChangeEvent(ctx);
  },
  hoverChange: (ctx) => {
    var _a7;
    (_a7 = ctx.onHoverChange) == null ? void 0 : _a7.call(ctx, { hoveredValue: ctx.hoveredValue });
  }
};
var set12 = {
  value: (ctx, value) => {
    if (isEqual3(ctx.value, value)) return;
    ctx.value = value;
    invoke8.change(ctx);
  },
  hoveredValue: (ctx, value) => {
    if (isEqual3(ctx.hoveredValue, value)) return;
    ctx.hoveredValue = value;
    invoke8.hoverChange(ctx);
  }
};
var props45 = createProps30()([
  "allowHalf",
  "autoFocus",
  "count",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onHoverChange",
  "onValueChange",
  "required",
  "readOnly",
  "translations",
  "value"
]);
var splitProps45 = createSplitProps2(props45);
var itemProps15 = createProps30()(["index"]);
var splitItemProps15 = createSplitProps2(itemProps15);

// node_modules/@ark-ui/react/dist/components/rating-group/use-rating-group.js
var import_react400 = __toESM(require_react(), 1);
var useRatingGroup = (props52 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react400.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    getRootNode: getRootNode2,
    value: props52.defaultValue,
    ...props52
  };
  const context = {
    ...initialContext,
    value: props52.value,
    onValueChange: useEvent(props52.onValueChange, { sync: true }),
    onHoverChange: useEvent(props52.onHoverChange)
  };
  const [state2, send] = useMachine(machine18(initialContext), {
    context
  });
  return connect18(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-root.js
var RatingGroupRoot = (0, import_react402.forwardRef)((props52, ref36) => {
  const [useRatingProps, localProps] = createSplitProps3()(props52, [
    "allowHalf",
    "autoFocus",
    "count",
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "name",
    "onHoverChange",
    "onValueChange",
    "readOnly",
    "required",
    "translations",
    "value"
  ]);
  const ratingGroup = useRatingGroup(useRatingProps);
  const mergedProps = mergeProps3(ratingGroup.getRootProps(), localProps);
  return (0, import_jsx_runtime203.jsx)(RatingGroupProvider, { value: ratingGroup, children: (0, import_jsx_runtime203.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
});
RatingGroupRoot.displayName = "RatingGroupRoot";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-root-provider.js
var import_jsx_runtime204 = __toESM(require_jsx_runtime(), 1);
var import_react404 = __toESM(require_react(), 1);
var RatingGroupRootProvider = (0, import_react404.forwardRef)(
  (props52, ref36) => {
    const [{ value: ratingGroup }, localProps] = createSplitProps3()(props52, [
      "value"
    ]);
    const mergedProps = mergeProps3(ratingGroup.getRootProps(), localProps);
    return (0, import_jsx_runtime204.jsx)(RatingGroupProvider, { value: ratingGroup, children: (0, import_jsx_runtime204.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
  }
);
RatingGroupRootProvider.displayName = "RatingGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group.js
var rating_group_exports = {};
__export(rating_group_exports, {
  Context: () => RatingGroupContext,
  Control: () => RatingGroupControl,
  HiddenInput: () => RatingGroupHiddenInput,
  Item: () => RatingGroupItem,
  ItemContext: () => RatingGroupItemContext,
  Label: () => RatingGroupLabel,
  Root: () => RatingGroupRoot,
  RootProvider: () => RatingGroupRootProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/rating-group/rating-group.js
var import_react405 = __toESM(require_react(), 1);
var {
  withProvider: withProvider26,
  withContext: withContext40,
  useStyles: useRatingGroupStyles,
  PropsProvider: PropsProvider39
} = createSlotRecipeContext({ key: "ratingGroup" });
var RatingGroupRootProvider2 = withProvider26(rating_group_exports.RootProvider, "root", { forwardAsChild: true });
var RatingGroupRoot2 = withProvider26(rating_group_exports.Root, "root", { forwardAsChild: true });
var RatingGroupPropsProvider = PropsProvider39;
var RatingGroupLabel2 = withContext40(rating_group_exports.Label, "label", { forwardAsChild: true });
var RatingGroupControl2 = withContext40(rating_group_exports.Control, "control", { forwardAsChild: true });
var RatingGroupItem2 = withContext40(rating_group_exports.Item, "item", { forwardAsChild: true });
function cloneIcon(icon, type) {
  if (!(0, import_react405.isValidElement)(icon)) return null;
  const props52 = { [`data-${type}`]: "", "aria-hidden": "" };
  return (0, import_react405.cloneElement)(icon, props52);
}
var RatingGroupItemIndicator = (0, import_react405.forwardRef)(function RatingGroupItemIndicator2(props52, ref36) {
  const { icon = (0, import_jsx_runtime205.jsx)(StarIcon, {}), ...rest } = props52;
  const styles = useRatingGroupStyles();
  const itemState = useRatingGroupItemContext();
  return (0, import_jsx_runtime205.jsxs)(
    chakra.span,
    {
      ...rest,
      "data-highlighted": itemState.highlighted ? "" : void 0,
      "data-checked": itemState.checked ? "" : void 0,
      "data-half": itemState.half ? "" : void 0,
      css: [styles.itemIndicator, props52.css],
      ref: ref36,
      children: [
        cloneIcon(icon, "bg"),
        cloneIcon(icon, "fg")
      ]
    }
  );
});
var RatingGroupContext2 = rating_group_exports.Context;
var RatingGroupItemContext2 = rating_group_exports.ItemContext;
var RatingGroupHiddenInput2 = rating_group_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/rating-group/namespace.js
var namespace_exports32 = {};
__export(namespace_exports32, {
  Context: () => RatingGroupContext2,
  Control: () => RatingGroupControl2,
  HiddenInput: () => RatingGroupHiddenInput2,
  Item: () => RatingGroupItem2,
  ItemContext: () => RatingGroupItemContext2,
  ItemIndicator: () => RatingGroupItemIndicator,
  Label: () => RatingGroupLabel2,
  PropsProvider: () => RatingGroupPropsProvider,
  Root: () => RatingGroupRoot2,
  RootProvider: () => RatingGroupRootProvider2,
  useRatingGroupStyles: () => useRatingGroupStyles
});

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group-context.js
var [SegmentGroupProvider, useSegmentGroupContext] = createContext(
  {
    name: "SegmentGroupContext",
    hookName: "useSegmentGroupContext",
    providerName: "<SegmentGroupProvider />"
  }
);

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-context.js
var SegmentGroupContext = (props52) => props52.children(useSegmentGroupContext());

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-indicator.js
var import_jsx_runtime206 = __toESM(require_jsx_runtime(), 1);
var import_react407 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group.anatomy.js
var segmentGroupAnatomy2 = anatomy59.rename("segment-group");
var parts56 = segmentGroupAnatomy2.build();

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-indicator.js
var SegmentGroupIndicator = (0, import_react407.forwardRef)(
  (props52, ref36) => {
    const segmentGroup = useSegmentGroupContext();
    const mergedProps = mergeProps3(
      segmentGroup.getIndicatorProps(),
      parts56.indicator.attrs,
      props52
    );
    return (0, import_jsx_runtime206.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
SegmentGroupIndicator.displayName = "SegmentGroupIndicator";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item.js
var import_jsx_runtime207 = __toESM(require_jsx_runtime(), 1);
var import_react409 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group-item-context.js
var [SegmentGroupItemProvider, useSegmentGroupItemContext] = createContext({
  name: "SegmentGroupItemContext",
  hookName: "useSegmentGroupItemContext",
  providerName: "<SegmentGroupItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group-item-props-context.js
var [SegmentGroupItemPropsProvider, useSegmentGroupItemPropsContext] = createContext({
  name: "SegmentGroupItemPropsContext",
  hookName: "useSegmentGroupItemPropsContext",
  providerName: "<SegmentGroupItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item.js
var SegmentGroupItem = (0, import_react409.forwardRef)(
  (props52, ref36) => {
    const [itemProps17, localProps] = createSplitProps3()(props52, [
      "value",
      "disabled",
      "invalid"
    ]);
    const segmentGroup = useSegmentGroupContext();
    const mergedProps = mergeProps3(
      segmentGroup.getItemProps(itemProps17),
      parts56.item.attrs,
      localProps
    );
    const itemState = segmentGroup.getItemState(itemProps17);
    return (0, import_jsx_runtime207.jsx)(SegmentGroupItemPropsProvider, { value: itemProps17, children: (0, import_jsx_runtime207.jsx)(SegmentGroupItemProvider, { value: itemState, children: (0, import_jsx_runtime207.jsx)(ark.label, { ...mergedProps, ref: ref36 }) }) });
  }
);
SegmentGroupItem.displayName = "SegmentGroupItem";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-context.js
var SegmentGroupItemContext = (props52) => props52.children(useSegmentGroupItemContext());

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-control.js
var import_jsx_runtime208 = __toESM(require_jsx_runtime(), 1);
var import_react411 = __toESM(require_react(), 1);
var SegmentGroupItemControl = (0, import_react411.forwardRef)(
  (props52, ref36) => {
    const segmentGroup = useSegmentGroupContext();
    const itemProps17 = useSegmentGroupItemPropsContext();
    const mergedProps = mergeProps3(
      segmentGroup.getItemControlProps(itemProps17),
      parts56.itemControl.attrs,
      props52
    );
    return (0, import_jsx_runtime208.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
SegmentGroupItemControl.displayName = "SegmentGroupItemControl";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-hidden-input.js
var import_jsx_runtime209 = __toESM(require_jsx_runtime(), 1);
var import_react413 = __toESM(require_react(), 1);
var SegmentGroupItemHiddenInput = (0, import_react413.forwardRef)((props52, ref36) => {
  const segmentGroup = useSegmentGroupContext();
  const itemProps17 = useSegmentGroupItemPropsContext();
  const mergedProps = mergeProps3(segmentGroup.getItemHiddenInputProps(itemProps17), props52);
  return (0, import_jsx_runtime209.jsx)(ark.input, { ...mergedProps, ref: ref36 });
});
SegmentGroupItemHiddenInput.displayName = "SegmentGroupItemHiddenInput";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-text.js
var import_jsx_runtime210 = __toESM(require_jsx_runtime(), 1);
var import_react415 = __toESM(require_react(), 1);
var SegmentGroupItemText = (0, import_react415.forwardRef)(
  (props52, ref36) => {
    const segmentGroup = useSegmentGroupContext();
    const itemProps17 = useSegmentGroupItemPropsContext();
    const mergedProps = mergeProps3(
      segmentGroup.getItemTextProps(itemProps17),
      parts56.itemText.attrs,
      props52
    );
    return (0, import_jsx_runtime210.jsx)(ark.span, { ...mergedProps, ref: ref36 });
  }
);
SegmentGroupItemText.displayName = "SegmentGroupItemText";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-label.js
var import_jsx_runtime211 = __toESM(require_jsx_runtime(), 1);
var import_react417 = __toESM(require_react(), 1);
var SegmentGroupLabel = (0, import_react417.forwardRef)(
  (props52, ref36) => {
    const segmentGroup = useSegmentGroupContext();
    const mergedProps = mergeProps3(
      segmentGroup.getLabelProps(),
      parts56.label.attrs,
      props52
    );
    return (0, import_jsx_runtime211.jsx)(ark.label, { ...mergedProps, ref: ref36 });
  }
);
SegmentGroupLabel.displayName = "SegmentGroupLabel";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-root.js
var import_jsx_runtime212 = __toESM(require_jsx_runtime(), 1);
var import_react421 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group.js
var import_react419 = __toESM(require_react(), 1);
var useSegmentGroup = (props52 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react419.useId)(),
    dir,
    getRootNode: getRootNode2,
    value: props52.defaultValue,
    ...props52
  };
  const context = {
    ...initialContext,
    value: props52.value,
    onValueChange: useEvent(props52.onValueChange, { sync: true })
  };
  const [state2, send] = useMachine(machine17(initialContext), {
    context
  });
  return connect17(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-root.js
var SegmentGroupRoot = (0, import_react421.forwardRef)((props52, ref36) => {
  const [useSegmentGroupProps, localProps] = createSplitProps3()(props52, [
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "name",
    "onValueChange",
    "orientation",
    "readOnly",
    "value"
  ]);
  const segmentGroup = useSegmentGroup(useSegmentGroupProps);
  const mergedProps = mergeProps3(
    segmentGroup.getRootProps(),
    parts56.root.attrs,
    localProps
  );
  return (0, import_jsx_runtime212.jsx)(SegmentGroupProvider, { value: segmentGroup, children: (0, import_jsx_runtime212.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
});
SegmentGroupRoot.displayName = "SegmentGroupRoot";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-root-provider.js
var import_jsx_runtime213 = __toESM(require_jsx_runtime(), 1);
var import_react423 = __toESM(require_react(), 1);
var SegmentGroupRootProvider = (0, import_react423.forwardRef)(
  (props52, ref36) => {
    const [{ value: segmentGroup }, localProps] = createSplitProps3()(props52, [
      "value"
    ]);
    const mergedProps = mergeProps3(
      segmentGroup.getRootProps(),
      parts56.root.attrs,
      localProps
    );
    return (0, import_jsx_runtime213.jsx)(SegmentGroupProvider, { value: segmentGroup, children: (0, import_jsx_runtime213.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
  }
);
SegmentGroupRootProvider.displayName = "SegmentGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group.js
var segment_group_exports = {};
__export(segment_group_exports, {
  Context: () => SegmentGroupContext,
  Indicator: () => SegmentGroupIndicator,
  Item: () => SegmentGroupItem,
  ItemContext: () => SegmentGroupItemContext,
  ItemControl: () => SegmentGroupItemControl,
  ItemHiddenInput: () => SegmentGroupItemHiddenInput,
  ItemText: () => SegmentGroupItemText,
  Label: () => SegmentGroupLabel,
  Root: () => SegmentGroupRoot,
  RootProvider: () => SegmentGroupRootProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/segment-group/segment-group.js
var {
  withProvider: withProvider27,
  withContext: withContext41,
  useStyles: useSegmentGroupStyles,
  PropsProvider: PropsProvider40
} = createSlotRecipeContext({ key: "segmentGroup" });
var SegmentGroupRootProvider2 = withProvider27(segment_group_exports.RootProvider, "root", { forwardAsChild: true });
var SegmentGroupRoot2 = withProvider27(segment_group_exports.Root, "root", { forwardAsChild: true });
var SegmentGroupPropsProvider = PropsProvider40;
var SegmentGroupItem2 = withContext41(segment_group_exports.Item, "item", { forwardAsChild: true });
var SegmentGroupItemText2 = withContext41(segment_group_exports.ItemText, "itemText", { forwardAsChild: true });
var SegmentGroupIndicator2 = withContext41(segment_group_exports.Indicator, "indicator", { forwardAsChild: true });
var SegmentGroupItemHiddenInput2 = segment_group_exports.ItemHiddenInput;
var SegmentGroupContext2 = segment_group_exports.Context;
var SegmentGroupItemContext2 = segment_group_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/segment-group/namespace.js
var namespace_exports33 = {};
__export(namespace_exports33, {
  Context: () => SegmentGroupContext2,
  Indicator: () => SegmentGroupIndicator2,
  Item: () => SegmentGroupItem2,
  ItemContext: () => SegmentGroupItemContext2,
  ItemHiddenInput: () => SegmentGroupItemHiddenInput2,
  ItemText: () => SegmentGroupItemText2,
  PropsProvider: () => SegmentGroupPropsProvider,
  Root: () => SegmentGroupRoot2,
  RootProvider: () => SegmentGroupRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/select/select.js
var import_jsx_runtime231 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/select/select-clear-trigger.js
var import_jsx_runtime214 = __toESM(require_jsx_runtime(), 1);
var import_react425 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/select/use-select-context.js
var [SelectProvider, useSelectContext] = createContext({
  name: "SelectContext",
  hookName: "useSelectContext",
  providerName: "<SelectProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/select-clear-trigger.js
var SelectClearTrigger = (0, import_react425.forwardRef)(
  (props52, ref36) => {
    const select = useSelectContext();
    const mergedProps = mergeProps3(select.getClearTriggerProps(), props52);
    return (0, import_jsx_runtime214.jsx)(ark.button, { ...mergedProps, ref: ref36 });
  }
);
SelectClearTrigger.displayName = "SelectClearTrigger";

// node_modules/@ark-ui/react/dist/components/select/select-content.js
var import_jsx_runtime215 = __toESM(require_jsx_runtime(), 1);
var import_react427 = __toESM(require_react(), 1);
var SelectContent = (0, import_react427.forwardRef)((props52, ref36) => {
  const select = useSelectContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps3(select.getContentProps(), presence.getPresenceProps(), props52);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime215.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref36) });
});
SelectContent.displayName = "SelectContent";

// node_modules/@ark-ui/react/dist/components/select/select-context.js
var SelectContext = (props52) => props52.children(useSelectContext());

// node_modules/@ark-ui/react/dist/components/select/select-control.js
var import_jsx_runtime216 = __toESM(require_jsx_runtime(), 1);
var import_react429 = __toESM(require_react(), 1);
var SelectControl = (0, import_react429.forwardRef)((props52, ref36) => {
  const select = useSelectContext();
  const mergedProps = mergeProps3(select.getControlProps(), props52);
  return (0, import_jsx_runtime216.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
SelectControl.displayName = "SelectControl";

// node_modules/@ark-ui/react/dist/components/select/select-hidden-select.js
var import_jsx_runtime217 = __toESM(require_jsx_runtime(), 1);
var import_react431 = __toESM(require_react(), 1);
var SelectHiddenSelect = (0, import_react431.forwardRef)(
  (props52, ref36) => {
    const select = useSelectContext();
    const mergedProps = mergeProps3(select.getHiddenSelectProps(), props52);
    const isValueEmpty = select.value.length === 0;
    const field = useFieldContext();
    return (0, import_jsx_runtime217.jsxs)(ark.select, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref36, children: [
      isValueEmpty && (0, import_jsx_runtime217.jsx)("option", { value: "" }),
      select.collection.items.map((item, index) => (0, import_jsx_runtime217.jsx)(
        "option",
        {
          value: select.collection.getItemValue(item) ?? "",
          disabled: select.collection.getItemDisabled(item)
        },
        index
      ))
    ] });
  }
);
SelectHiddenSelect.displayName = "SelectHiddenSelect";

// node_modules/@ark-ui/react/dist/components/select/select-indicator.js
var import_jsx_runtime218 = __toESM(require_jsx_runtime(), 1);
var import_react433 = __toESM(require_react(), 1);
var SelectIndicator = (0, import_react433.forwardRef)((props52, ref36) => {
  const select = useSelectContext();
  const mergedProps = mergeProps3(select.getIndicatorProps(), props52);
  return (0, import_jsx_runtime218.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
SelectIndicator.displayName = "SelectIndicator";

// node_modules/@ark-ui/react/dist/components/select/select-item.js
var import_jsx_runtime219 = __toESM(require_jsx_runtime(), 1);
var import_react435 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/select/use-select-item-context.js
var [SelectItemProvider, useSelectItemContext] = createContext({
  name: "SelectItemContext",
  hookName: "useSelectItemContext",
  providerName: "<SelectItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/use-select-item-props-context.js
var [SelectItemPropsProvider, useSelectItemPropsContext] = createContext({
  name: "SelectItemPropsContext",
  hookName: "useSelectItemPropsContext",
  providerName: "<SelectItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/select-item.js
var SelectItem = (0, import_react435.forwardRef)((props52, ref36) => {
  const [itemProps17, localProps] = createSplitProps3()(props52, ["item", "persistFocus"]);
  const select = useSelectContext();
  const mergedProps = mergeProps3(select.getItemProps(itemProps17), localProps);
  const itemState = select.getItemState(itemProps17);
  return (0, import_jsx_runtime219.jsx)(SelectItemPropsProvider, { value: itemProps17, children: (0, import_jsx_runtime219.jsx)(SelectItemProvider, { value: itemState, children: (0, import_jsx_runtime219.jsx)(ark.div, { ...mergedProps, ref: ref36 }) }) });
});
SelectItem.displayName = "SelectItem";

// node_modules/@ark-ui/react/dist/components/select/select-item-context.js
var SelectItemContext = (props52) => props52.children(useSelectItemContext());

// node_modules/@ark-ui/react/dist/components/select/select-item-group.js
var import_jsx_runtime220 = __toESM(require_jsx_runtime(), 1);
var import_react437 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/select/use-select-item-group-props.js
var [SelectItemGroupPropsProvider, useSelectItemGroupPropsContext] = createContext({
  name: "SelectItemGroupPropsContext",
  hookName: "useSelectItemGroupPropsContext",
  providerName: "<SelectItemGroupPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/select-item-group.js
var SelectItemGroup = (0, import_react437.forwardRef)((props52, ref36) => {
  const id = (0, import_react437.useId)();
  const [_itemGroupProps, localProps] = createSplitProps3()(props52, ["id"]);
  const itemGroupProps5 = { id, ..._itemGroupProps };
  const select = useSelectContext();
  const mergedProps = mergeProps3(select.getItemGroupProps(itemGroupProps5), localProps);
  return (0, import_jsx_runtime220.jsx)(SelectItemGroupPropsProvider, { value: itemGroupProps5, children: (0, import_jsx_runtime220.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
});
SelectItemGroup.displayName = "SelectItemGroup";

// node_modules/@ark-ui/react/dist/components/select/select-item-group-label.js
var import_jsx_runtime221 = __toESM(require_jsx_runtime(), 1);
var import_react439 = __toESM(require_react(), 1);
var SelectItemGroupLabel = (0, import_react439.forwardRef)(
  (props52, ref36) => {
    const select = useSelectContext();
    const itemGroupProps5 = useSelectItemGroupPropsContext();
    const mergedProps = mergeProps3(
      select.getItemGroupLabelProps({ htmlFor: itemGroupProps5.id }),
      props52
    );
    return (0, import_jsx_runtime221.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
SelectItemGroupLabel.displayName = "SelectItemGroupLabel";

// node_modules/@ark-ui/react/dist/components/select/select-item-indicator.js
var import_jsx_runtime222 = __toESM(require_jsx_runtime(), 1);
var import_react441 = __toESM(require_react(), 1);
var SelectItemIndicator = (0, import_react441.forwardRef)(
  (props52, ref36) => {
    const select = useSelectContext();
    const itemProps17 = useSelectItemPropsContext();
    const mergedProps = mergeProps3(select.getItemIndicatorProps(itemProps17), props52);
    return (0, import_jsx_runtime222.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
SelectItemIndicator.displayName = "SelectItemIndicator";

// node_modules/@ark-ui/react/dist/components/select/select-item-text.js
var import_jsx_runtime223 = __toESM(require_jsx_runtime(), 1);
var import_react443 = __toESM(require_react(), 1);
var SelectItemText = (0, import_react443.forwardRef)((props52, ref36) => {
  const select = useSelectContext();
  const itemProps17 = useSelectItemPropsContext();
  const mergedProps = mergeProps3(select.getItemTextProps(itemProps17), props52);
  return (0, import_jsx_runtime223.jsx)(ark.span, { ...mergedProps, ref: ref36 });
});
SelectItemText.displayName = "SelectItemText";

// node_modules/@ark-ui/react/dist/components/select/select-label.js
var import_jsx_runtime224 = __toESM(require_jsx_runtime(), 1);
var import_react445 = __toESM(require_react(), 1);
var SelectLabel = (0, import_react445.forwardRef)((props52, ref36) => {
  const select = useSelectContext();
  const mergedProps = mergeProps3(select.getLabelProps(), props52);
  return (0, import_jsx_runtime224.jsx)(ark.label, { ...mergedProps, ref: ref36 });
});
SelectLabel.displayName = "SelectLabel";

// node_modules/@ark-ui/react/dist/components/select/select-list.js
var import_jsx_runtime225 = __toESM(require_jsx_runtime(), 1);
var import_react447 = __toESM(require_react(), 1);
var SelectList = (0, import_react447.forwardRef)((props52, ref36) => {
  const select = useSelectContext();
  const mergedProps = mergeProps3(select.getListProps(), props52);
  return (0, import_jsx_runtime225.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
SelectList.displayName = "SelectList";

// node_modules/@ark-ui/react/dist/components/select/select-positioner.js
var import_jsx_runtime226 = __toESM(require_jsx_runtime(), 1);
var import_react449 = __toESM(require_react(), 1);
var SelectPositioner = (0, import_react449.forwardRef)((props52, ref36) => {
  const select = useSelectContext();
  const mergedProps = mergeProps3(select.getPositionerProps(), props52);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime226.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
SelectPositioner.displayName = "SelectPositioner";

// node_modules/@ark-ui/react/dist/components/select/select-root.js
var import_jsx_runtime227 = __toESM(require_jsx_runtime(), 1);
var import_react453 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/node_modules/@zag-js/select/dist/index.mjs
var anatomy61 = createAnatomy2("select").parts(
  "label",
  "positioner",
  "trigger",
  "indicator",
  "clearTrigger",
  "item",
  "itemText",
  "itemIndicator",
  "itemGroup",
  "itemGroupLabel",
  "list",
  "content",
  "root",
  "control",
  "valueText"
);
var parts57 = anatomy61.build();
var collection3 = (options) => {
  return ref35(new ListCollection(options));
};
collection3.empty = () => {
  return ref35(new ListCollection({ items: [] }));
};
var dom54 = createScope({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `select:${ctx.id}`;
  },
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `select:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `select:${ctx.id}:trigger`;
  },
  getClearTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.clearTrigger) ?? `select:${ctx.id}:clear-trigger`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `select:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `select:${ctx.id}:control`;
  },
  getItemId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.item) == null ? void 0 : _b6.call(_a7, id)) ?? `select:${ctx.id}:option:${id}`;
  },
  getHiddenSelectId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.hiddenSelect) ?? `select:${ctx.id}:select`;
  },
  getPositionerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.positioner) ?? `select:${ctx.id}:positioner`;
  },
  getItemGroupId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemGroup) == null ? void 0 : _b6.call(_a7, id)) ?? `select:${ctx.id}:optgroup:${id}`;
  },
  getItemGroupLabelId: (ctx, id) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.itemGroupLabel) == null ? void 0 : _b6.call(_a7, id)) ?? `select:${ctx.id}:optgroup-label:${id}`;
  },
  getHiddenSelectEl: (ctx) => dom54.getById(ctx, dom54.getHiddenSelectId(ctx)),
  getContentEl: (ctx) => dom54.getById(ctx, dom54.getContentId(ctx)),
  getControlEl: (ctx) => dom54.getById(ctx, dom54.getControlId(ctx)),
  getTriggerEl: (ctx) => dom54.getById(ctx, dom54.getTriggerId(ctx)),
  getClearTriggerEl: (ctx) => dom54.getById(ctx, dom54.getClearTriggerId(ctx)),
  getPositionerEl: (ctx) => dom54.getById(ctx, dom54.getPositionerId(ctx)),
  getHighlightedOptionEl(ctx) {
    if (!ctx.highlightedValue) return null;
    return dom54.getById(ctx, dom54.getItemId(ctx, ctx.highlightedValue));
  }
});
function connect19(state2, send, normalize2) {
  const disabled = state2.context.isDisabled;
  const invalid = state2.context.invalid;
  const readOnly = state2.context.readOnly;
  const interactive = state2.context.isInteractive;
  const composite = state2.context.composite;
  const open = state2.hasTag("open");
  const focused = state2.matches("focused");
  const highlightedValue = state2.context.highlightedValue;
  const highlightedItem = state2.context.highlightedItem;
  const selectedItems = state2.context.selectedItems;
  const isTypingAhead = state2.context.isTypingAhead;
  const collection22 = state2.context.collection;
  const ariaActiveDescendant = highlightedValue ? dom54.getItemId(state2.context, highlightedValue) : void 0;
  function getItemState(props210) {
    const _disabled = collection22.getItemDisabled(props210.item);
    const value = collection22.getItemValue(props210.item);
    return {
      value,
      disabled: Boolean(disabled || _disabled),
      highlighted: highlightedValue === value,
      selected: state2.context.value.includes(value)
    };
  }
  const popperStyles = getPlacementStyles2({
    ...state2.context.positioning,
    placement: state2.context.currentPlacement
  });
  return {
    open,
    focused,
    empty: state2.context.value.length === 0,
    highlightedItem,
    highlightedValue,
    selectedItems,
    hasSelectedItems: state2.context.hasSelectedItems,
    value: state2.context.value,
    valueAsString: state2.context.valueAsString,
    collection: collection22,
    multiple: !!state2.context.multiple,
    disabled: !!disabled,
    setCollection(collection32) {
      send({ type: "COLLECTION.SET", value: collection32 });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    focus() {
      var _a7;
      (_a7 = dom54.getTriggerEl(state2.context)) == null ? void 0 : _a7.focus({ preventScroll: true });
    },
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    selectValue(value) {
      send({ type: "ITEM.SELECT", value });
    },
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    selectAll() {
      send({ type: "VALUE.SET", value: collection22.getValues() });
    },
    highlightValue(value) {
      send({ type: "HIGHLIGHTED_VALUE.SET", value });
    },
    clearValue(value) {
      if (value) {
        send({ type: "ITEM.CLEAR", value });
      } else {
        send({ type: "VALUE.CLEAR" });
      }
    },
    getItemState,
    getRootProps() {
      return normalize2.element({
        ...parts57.root.attrs,
        dir: state2.context.dir,
        id: dom54.getRootId(state2.context),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getLabelProps() {
      return normalize2.label({
        dir: state2.context.dir,
        id: dom54.getLabelId(state2.context),
        ...parts57.label.attrs,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        htmlFor: dom54.getHiddenSelectId(state2.context),
        onClick(event) {
          var _a7;
          if (event.defaultPrevented) return;
          if (disabled) return;
          (_a7 = dom54.getTriggerEl(state2.context)) == null ? void 0 : _a7.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts57.control.attrs,
        dir: state2.context.dir,
        id: dom54.getControlId(state2.context),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid)
      });
    },
    getValueTextProps() {
      return normalize2.element({
        ...parts57.valueText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused)
      });
    },
    getTriggerProps() {
      return normalize2.button({
        id: dom54.getTriggerId(state2.context),
        disabled,
        dir: state2.context.dir,
        type: "button",
        role: "combobox",
        "aria-controls": dom54.getContentId(state2.context),
        "aria-expanded": open,
        "aria-haspopup": "listbox",
        "data-state": open ? "open" : "closed",
        "aria-invalid": invalid,
        "aria-labelledby": dom54.getLabelId(state2.context),
        ...parts57.trigger.attrs,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        "data-placement": state2.context.currentPlacement,
        "data-placeholder-shown": dataAttr(!state2.context.hasSelectedItems),
        onClick(event) {
          if (!interactive) return;
          if (event.defaultPrevented) return;
          send({ type: "TRIGGER.CLICK" });
        },
        onFocus() {
          send("TRIGGER.FOCUS");
        },
        onBlur() {
          send("TRIGGER.BLUR");
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "TRIGGER.ARROW_UP" });
            },
            ArrowDown(event2) {
              send({ type: event2.altKey ? "OPEN" : "TRIGGER.ARROW_DOWN" });
            },
            ArrowLeft() {
              send({ type: "TRIGGER.ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "TRIGGER.ARROW_RIGHT" });
            },
            Home() {
              send({ type: "TRIGGER.HOME" });
            },
            End() {
              send({ type: "TRIGGER.END" });
            },
            Enter() {
              send({ type: "TRIGGER.ENTER" });
            },
            Space(event2) {
              if (isTypingAhead) {
                send({ type: "TRIGGER.TYPEAHEAD", key: event2.key });
              } else {
                send({ type: "TRIGGER.ENTER" });
              }
            }
          };
          const exec21 = keyMap2[getEventKey2(event, state2.context)];
          if (exec21) {
            exec21(event);
            event.preventDefault();
            return;
          }
          if (getByTypeahead.isValidEvent(event)) {
            send({ type: "TRIGGER.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        ...parts57.indicator.attrs,
        dir: state2.context.dir,
        "aria-hidden": true,
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getItemProps(props210) {
      const itemState = getItemState(props210);
      return normalize2.element({
        id: dom54.getItemId(state2.context, itemState.value),
        role: "option",
        ...parts57.item.attrs,
        dir: state2.context.dir,
        "data-value": itemState.value,
        "aria-selected": itemState.selected,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-disabled": dataAttr(itemState.disabled),
        "aria-disabled": ariaAttr(itemState.disabled),
        onPointerMove(event) {
          if (itemState.disabled || event.pointerType !== "mouse") return;
          if (itemState.value === state2.context.highlightedValue) return;
          send({ type: "ITEM.POINTER_MOVE", value: itemState.value });
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (itemState.disabled) return;
          send({ type: "ITEM.CLICK", src: "pointerup", value: itemState.value });
        },
        onPointerLeave(event) {
          if (itemState.disabled) return;
          if (props210.persistFocus) return;
          if (event.pointerType !== "mouse") return;
          const pointerMoved = state2.previousEvent.type.includes("POINTER");
          if (!pointerMoved) return;
          send({ type: "ITEM.POINTER_LEAVE" });
        }
      });
    },
    getItemTextProps(props210) {
      const itemState = getItemState(props210);
      return normalize2.element({
        ...parts57.itemText.attrs,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted)
      });
    },
    getItemIndicatorProps(props210) {
      const itemState = getItemState(props210);
      return normalize2.element({
        "aria-hidden": true,
        ...parts57.itemIndicator.attrs,
        "data-state": itemState.selected ? "checked" : "unchecked",
        hidden: !itemState.selected
      });
    },
    getItemGroupLabelProps(props210) {
      const { htmlFor } = props210;
      return normalize2.element({
        ...parts57.itemGroupLabel.attrs,
        id: dom54.getItemGroupLabelId(state2.context, htmlFor),
        role: "group",
        dir: state2.context.dir
      });
    },
    getItemGroupProps(props210) {
      const { id } = props210;
      return normalize2.element({
        ...parts57.itemGroup.attrs,
        "data-disabled": dataAttr(disabled),
        id: dom54.getItemGroupId(state2.context, id),
        "aria-labelledby": dom54.getItemGroupLabelId(state2.context, id),
        dir: state2.context.dir
      });
    },
    getClearTriggerProps() {
      return normalize2.button({
        ...parts57.clearTrigger.attrs,
        id: dom54.getClearTriggerId(state2.context),
        type: "button",
        "aria-label": "Clear value",
        "data-invalid": dataAttr(invalid),
        disabled,
        hidden: !state2.context.hasSelectedItems,
        dir: state2.context.dir,
        onClick(event) {
          if (event.defaultPrevented) return;
          send("CLEAR.CLICK");
        }
      });
    },
    getHiddenSelectProps() {
      return normalize2.select({
        name: state2.context.name,
        form: state2.context.form,
        disabled,
        multiple: state2.context.multiple,
        required: state2.context.required,
        "aria-hidden": true,
        id: dom54.getHiddenSelectId(state2.context),
        defaultValue: state2.context.multiple ? state2.context.value : state2.context.value[0],
        style: visuallyHiddenStyle,
        tabIndex: -1,
        // Some browser extensions will focus the hidden select.
        // Let's forward the focus to the trigger.
        onFocus() {
          var _a7;
          (_a7 = dom54.getTriggerEl(state2.context)) == null ? void 0 : _a7.focus({ preventScroll: true });
        },
        "aria-labelledby": dom54.getLabelId(state2.context)
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts57.positioner.attrs,
        dir: state2.context.dir,
        id: dom54.getPositionerId(state2.context),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        hidden: !open,
        dir: state2.context.dir,
        id: dom54.getContentId(state2.context),
        role: composite ? "listbox" : "dialog",
        ...parts57.content.attrs,
        "data-state": open ? "open" : "closed",
        "data-placement": state2.context.currentPlacement,
        "data-activedescendant": ariaActiveDescendant,
        "aria-activedescendant": composite ? ariaActiveDescendant : void 0,
        "aria-multiselectable": state2.context.multiple && composite ? true : void 0,
        "aria-labelledby": dom54.getLabelId(state2.context),
        tabIndex: 0,
        onKeyDown(event) {
          if (!interactive) return;
          if (!isSelfTarget(event)) return;
          if (event.key === "Tab") {
            const valid = isValidTabEvent(event);
            if (!valid) {
              event.preventDefault();
              return;
            }
          }
          const keyMap2 = {
            ArrowUp() {
              send({ type: "CONTENT.ARROW_UP" });
            },
            ArrowDown() {
              send({ type: "CONTENT.ARROW_DOWN" });
            },
            Home() {
              send({ type: "CONTENT.HOME" });
            },
            End() {
              send({ type: "CONTENT.END" });
            },
            Enter() {
              send({ type: "ITEM.CLICK", src: "keydown.enter" });
            },
            Space(event2) {
              var _a7;
              if (isTypingAhead) {
                send({ type: "CONTENT.TYPEAHEAD", key: event2.key });
              } else {
                (_a7 = keyMap2.Enter) == null ? void 0 : _a7.call(keyMap2, event2);
              }
            }
          };
          const exec21 = keyMap2[getEventKey2(event)];
          if (exec21) {
            exec21(event);
            event.preventDefault();
            return;
          }
          const target = getEventTarget(event);
          if (isEditableElement(target)) {
            return;
          }
          if (getByTypeahead.isValidEvent(event)) {
            send({ type: "CONTENT.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    },
    getListProps() {
      return normalize2.element({
        ...parts57.list.attrs,
        tabIndex: 0,
        role: !composite ? "listbox" : void 0,
        "aria-labelledby": dom54.getTriggerId(state2.context),
        "aria-activedescendant": !composite ? ariaActiveDescendant : void 0,
        "aria-multiselectable": !composite && state2.context.multiple ? true : void 0
      });
    }
  };
}
var { and: and41, not: not42, or: or26 } = guards20;
function machine19(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "select",
      context: {
        value: [],
        highlightedValue: null,
        loopFocus: false,
        closeOnSelect: !ctx.multiple,
        disabled: false,
        readOnly: false,
        composite: true,
        ...ctx,
        highlightedItem: null,
        selectedItems: [],
        valueAsString: "",
        collection: ctx.collection ?? collection3.empty(),
        typeahead: getByTypeahead.defaultOptions,
        fieldsetDisabled: false,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        }
      },
      computed: {
        hasSelectedItems: (ctx2) => ctx2.value.length > 0,
        isTypingAhead: (ctx2) => ctx2.typeahead.keysSoFar !== "",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.isDisabled || ctx2.readOnly)
      },
      initial: ctx.open ? "open" : "idle",
      created: ["syncCollection"],
      entry: ["syncSelectElement"],
      watch: {
        open: ["toggleVisibility"],
        value: ["syncSelectedItems", "syncSelectElement"],
        highlightedValue: ["syncHighlightedItem"],
        collection: ["syncCollection"]
      },
      on: {
        "HIGHLIGHTED_VALUE.SET": {
          actions: ["setHighlightedItem"]
        },
        "ITEM.SELECT": {
          actions: ["selectItem"]
        },
        "ITEM.CLEAR": {
          actions: ["clearItem"]
        },
        "VALUE.SET": {
          actions: ["setSelectedItems"]
        },
        "VALUE.CLEAR": {
          actions: ["clearSelectedItems"]
        },
        "CLEAR.CLICK": {
          actions: ["clearSelectedItems", "focusTriggerEl"]
        },
        "COLLECTION.SET": {
          actions: ["setCollection"]
        }
      },
      activities: ["trackFormControlState"],
      states: {
        idle: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": [
              {
                guard: "isTriggerClickEvent",
                target: "open",
                actions: ["setInitialFocus", "highlightFirstSelectedItem"]
              },
              {
                target: "open",
                actions: ["setInitialFocus"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus", "highlightFirstSelectedItem"]
              }
            ],
            "TRIGGER.FOCUS": {
              target: "focused"
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen"]
              }
            ]
          }
        },
        focused: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": [
              {
                guard: "isTriggerClickEvent",
                target: "open",
                actions: ["setInitialFocus", "highlightFirstSelectedItem"]
              },
              {
                guard: "isTriggerArrowUpEvent",
                target: "open",
                actions: ["setInitialFocus", "highlightComputedLastItem"]
              },
              {
                guard: or26("isTriggerArrowDownEvent", "isTriggerEnterEvent"),
                target: "open",
                actions: ["setInitialFocus", "highlightComputedFirstItem"]
              },
              {
                target: "open",
                actions: ["setInitialFocus"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen"]
              }
            ],
            "TRIGGER.BLUR": {
              target: "idle"
            },
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightFirstSelectedItem"]
              }
            ],
            "TRIGGER.ENTER": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedFirstItem"]
              }
            ],
            "TRIGGER.ARROW_UP": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedLastItem"]
              }
            ],
            "TRIGGER.ARROW_DOWN": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedFirstItem"]
              }
            ],
            "TRIGGER.ARROW_LEFT": [
              {
                guard: and41(not42("multiple"), "hasSelectedItems"),
                actions: ["selectPreviousItem"]
              },
              {
                guard: not42("multiple"),
                actions: ["selectLastItem"]
              }
            ],
            "TRIGGER.ARROW_RIGHT": [
              {
                guard: and41(not42("multiple"), "hasSelectedItems"),
                actions: ["selectNextItem"]
              },
              {
                guard: not42("multiple"),
                actions: ["selectFirstItem"]
              }
            ],
            "TRIGGER.HOME": {
              guard: not42("multiple"),
              actions: ["selectFirstItem"]
            },
            "TRIGGER.END": {
              guard: not42("multiple"),
              actions: ["selectLastItem"]
            },
            "TRIGGER.TYPEAHEAD": {
              guard: not42("multiple"),
              actions: ["selectMatchingItem"]
            }
          }
        },
        open: {
          tags: ["open"],
          exit: ["scrollContentToTop"],
          activities: ["trackDismissableElement", "computePlacement", "scrollToHighlightedItem"],
          on: {
            "CONTROLLED.CLOSE": {
              target: "focused",
              actions: ["focusTriggerEl", "clearHighlightedItem"]
            },
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "focusTriggerEl", "clearHighlightedItem"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "clearHighlightedItem"]
              }
            ],
            "ITEM.CLICK": [
              {
                guard: and41("closeOnSelect", "isOpenControlled"),
                actions: ["selectHighlightedItem", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectHighlightedItem", "invokeOnClose", "focusTriggerEl", "clearHighlightedItem"]
              },
              {
                actions: ["selectHighlightedItem"]
              }
            ],
            "CONTENT.HOME": {
              actions: ["highlightFirstItem"]
            },
            "CONTENT.END": {
              actions: ["highlightLastItem"]
            },
            "CONTENT.ARROW_DOWN": [
              {
                guard: and41("hasHighlightedItem", "loop", "isLastItemHighlighted"),
                actions: ["highlightFirstItem"]
              },
              {
                guard: "hasHighlightedItem",
                actions: ["highlightNextItem"]
              },
              {
                actions: ["highlightFirstItem"]
              }
            ],
            "CONTENT.ARROW_UP": [
              {
                guard: and41("hasHighlightedItem", "loop", "isFirstItemHighlighted"),
                actions: ["highlightLastItem"]
              },
              {
                guard: "hasHighlightedItem",
                actions: ["highlightPreviousItem"]
              },
              {
                actions: ["highlightLastItem"]
              }
            ],
            "CONTENT.TYPEAHEAD": {
              actions: ["highlightMatchingItem"]
            },
            "ITEM.POINTER_MOVE": {
              actions: ["highlightItem"]
            },
            "ITEM.POINTER_LEAVE": {
              actions: ["clearHighlightedItem"]
            },
            "POSITIONING.SET": {
              actions: ["reposition"]
            }
          }
        }
      }
    },
    {
      guards: {
        loop: (ctx2) => !!ctx2.loopFocus,
        multiple: (ctx2) => !!ctx2.multiple,
        hasSelectedItems: (ctx2) => !!ctx2.hasSelectedItems,
        hasHighlightedItem: (ctx2) => ctx2.highlightedValue != null,
        isFirstItemHighlighted: (ctx2) => ctx2.highlightedValue === ctx2.collection.firstValue,
        isLastItemHighlighted: (ctx2) => ctx2.highlightedValue === ctx2.collection.lastValue,
        closeOnSelect: (ctx2, evt) => !!(evt.closeOnSelect ?? ctx2.closeOnSelect),
        // guard assertions (for controlled mode)
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        isTriggerClickEvent: (_ctx, evt) => {
          var _a7;
          return ((_a7 = evt.previousEvent) == null ? void 0 : _a7.type) === "TRIGGER.CLICK";
        },
        isTriggerEnterEvent: (_ctx, evt) => {
          var _a7;
          return ((_a7 = evt.previousEvent) == null ? void 0 : _a7.type) === "TRIGGER.ENTER";
        },
        isTriggerArrowUpEvent: (_ctx, evt) => {
          var _a7;
          return ((_a7 = evt.previousEvent) == null ? void 0 : _a7.type) === "TRIGGER.ARROW_UP";
        },
        isTriggerArrowDownEvent: (_ctx, evt) => {
          var _a7;
          return ((_a7 = evt.previousEvent) == null ? void 0 : _a7.type) === "TRIGGER.ARROW_DOWN";
        }
      },
      activities: {
        trackFormControlState(ctx2, _evt, { initialContext }) {
          return trackFormControl2(dom54.getHiddenSelectEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set13.selectedItems(ctx2, initialContext.value);
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const contentEl = () => dom54.getContentEl(ctx2);
          let restoreFocus = true;
          return trackDismissableElement2(contentEl, {
            defer: true,
            exclude: [dom54.getTriggerEl(ctx2), dom54.getClearTriggerEl(ctx2)],
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onInteractOutside(event) {
              var _a7;
              (_a7 = ctx2.onInteractOutside) == null ? void 0 : _a7.call(ctx2, event);
              restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
            },
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside", restoreFocus });
            }
          });
        },
        computePlacement(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const triggerEl = () => dom54.getTriggerEl(ctx2);
          const positionerEl = () => dom54.getPositionerEl(ctx2);
          return getPlacement2(triggerEl, positionerEl, {
            defer: true,
            ...ctx2.positioning,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        scrollToHighlightedItem(ctx2, _evt, { getState }) {
          const exec21 = (immediate) => {
            if (ctx2.highlightedValue == null) return;
            const state2 = getState();
            if (state2.event.type.includes("POINTER")) return;
            const optionEl = dom54.getHighlightedOptionEl(ctx2);
            const contentEl2 = dom54.getContentEl(ctx2);
            if (ctx2.scrollToIndexFn) {
              const highlightedIndex = ctx2.collection.indexOf(ctx2.highlightedValue);
              ctx2.scrollToIndexFn({ index: highlightedIndex, immediate });
              return;
            }
            scrollIntoView(optionEl, { rootEl: contentEl2, block: "nearest" });
          };
          raf(() => exec21(true));
          const contentEl = () => dom54.getContentEl(ctx2);
          return observeAttributes(contentEl, {
            defer: true,
            attributes: ["data-activedescendant"],
            callback() {
              exec21(false);
            }
          });
        }
      },
      actions: {
        reposition(ctx2, evt) {
          const positionerEl = () => dom54.getPositionerEl(ctx2);
          getPlacement2(dom54.getTriggerEl(ctx2), positionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        },
        highlightPreviousItem(ctx2) {
          if (ctx2.highlightedValue == null) return;
          const value = ctx2.collection.getPreviousValue(ctx2.highlightedValue);
          set13.highlightedItem(ctx2, value);
        },
        highlightNextItem(ctx2) {
          if (ctx2.highlightedValue == null) return;
          const value = ctx2.collection.getNextValue(ctx2.highlightedValue);
          set13.highlightedItem(ctx2, value);
        },
        highlightFirstItem(ctx2) {
          const value = ctx2.collection.firstValue;
          set13.highlightedItem(ctx2, value);
        },
        highlightLastItem(ctx2) {
          const value = ctx2.collection.lastValue;
          set13.highlightedItem(ctx2, value);
        },
        setInitialFocus(ctx2) {
          raf(() => {
            const element = getInitialFocus({
              root: dom54.getContentEl(ctx2)
            });
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        focusTriggerEl(ctx2, evt) {
          var _a7;
          const restoreFocus = evt.restoreFocus ?? ((_a7 = evt.previousEvent) == null ? void 0 : _a7.restoreFocus);
          if (restoreFocus != null && !restoreFocus) return;
          raf(() => {
            const element = dom54.getTriggerEl(ctx2);
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        selectHighlightedItem(ctx2, evt) {
          let value = evt.value ?? ctx2.highlightedValue;
          if (value == null) return;
          const nullable = ctx2.deselectable && !ctx2.multiple && ctx2.value.includes(value);
          value = nullable ? null : value;
          set13.selectedItem(ctx2, value, nullable);
        },
        highlightComputedFirstItem(ctx2) {
          const value = ctx2.hasSelectedItems ? ctx2.collection.sort(ctx2.value)[0] : ctx2.collection.firstValue;
          set13.highlightedItem(ctx2, value);
        },
        highlightComputedLastItem(ctx2) {
          const value = ctx2.hasSelectedItems ? ctx2.collection.sort(ctx2.value)[0] : ctx2.collection.lastValue;
          set13.highlightedItem(ctx2, value);
        },
        highlightFirstSelectedItem(ctx2) {
          if (!ctx2.hasSelectedItems) return;
          const [value] = ctx2.collection.sort(ctx2.value);
          set13.highlightedItem(ctx2, value);
        },
        highlightItem(ctx2, evt) {
          set13.highlightedItem(ctx2, evt.value);
        },
        highlightMatchingItem(ctx2, evt) {
          const value = ctx2.collection.search(evt.key, {
            state: ctx2.typeahead,
            currentValue: ctx2.highlightedValue
          });
          if (value == null) return;
          set13.highlightedItem(ctx2, value);
        },
        setHighlightedItem(ctx2, evt) {
          set13.highlightedItem(ctx2, evt.value);
        },
        clearHighlightedItem(ctx2) {
          set13.highlightedItem(ctx2, null, true);
        },
        selectItem(ctx2, evt) {
          const nullable = ctx2.deselectable && !ctx2.multiple && ctx2.value.includes(evt.value);
          const value = nullable ? null : evt.value;
          set13.selectedItem(ctx2, value, nullable);
        },
        clearItem(ctx2, evt) {
          const value = ctx2.value.filter((v) => v !== evt.value);
          set13.selectedItems(ctx2, value);
        },
        setSelectedItems(ctx2, evt) {
          set13.selectedItems(ctx2, evt.value);
        },
        clearSelectedItems(ctx2) {
          set13.selectedItems(ctx2, []);
        },
        selectPreviousItem(ctx2) {
          const value = ctx2.collection.getPreviousValue(ctx2.value[0]);
          set13.selectedItem(ctx2, value);
        },
        selectNextItem(ctx2) {
          const value = ctx2.collection.getNextValue(ctx2.value[0]);
          set13.selectedItem(ctx2, value);
        },
        selectFirstItem(ctx2) {
          const value = ctx2.collection.firstValue;
          set13.selectedItem(ctx2, value);
        },
        selectLastItem(ctx2) {
          const value = ctx2.collection.lastValue;
          set13.selectedItem(ctx2, value);
        },
        selectMatchingItem(ctx2, evt) {
          const value = ctx2.collection.search(evt.key, {
            state: ctx2.typeahead,
            currentValue: ctx2.value[0]
          });
          if (value == null) return;
          set13.selectedItem(ctx2, value);
        },
        scrollContentToTop(ctx2) {
          var _a7;
          if (ctx2.scrollToIndexFn) {
            ctx2.scrollToIndexFn({ index: 0, immediate: true });
          } else {
            (_a7 = dom54.getContentEl(ctx2)) == null ? void 0 : _a7.scrollTo(0, 0);
          }
        },
        invokeOnOpen(ctx2) {
          var _a7;
          (_a7 = ctx2.onOpenChange) == null ? void 0 : _a7.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a7;
          (_a7 = ctx2.onOpenChange) == null ? void 0 : _a7.call(ctx2, { open: false });
        },
        syncSelectElement(ctx2) {
          const selectEl = dom54.getHiddenSelectEl(ctx2);
          if (!selectEl) return;
          if (ctx2.value.length === 0 && !ctx2.multiple) {
            selectEl.selectedIndex = -1;
            return;
          }
          for (const option of selectEl.options) {
            option.selected = ctx2.value.includes(option.value);
          }
        },
        setCollection(ctx2, evt) {
          ctx2.collection = evt.value;
        },
        syncCollection(ctx2) {
          const selectedItems = ctx2.collection.findMany(ctx2.value);
          const valueAsString = ctx2.collection.stringifyItems(selectedItems);
          ctx2.highlightedItem = ctx2.collection.find(ctx2.highlightedValue);
          ctx2.selectedItems = selectedItems;
          ctx2.valueAsString = valueAsString;
        },
        syncSelectedItems(ctx2) {
          sync3.valueChange(ctx2);
        },
        syncHighlightedItem(ctx2) {
          sync3.highlightChange(ctx2);
        }
      }
    }
  );
}
function dispatchChangeEvent(ctx) {
  raf(() => {
    const node2 = dom54.getHiddenSelectEl(ctx);
    if (!node2) return;
    const win = dom54.getWin(ctx);
    const changeEvent = new win.Event("change", { bubbles: true, composed: true });
    node2.dispatchEvent(changeEvent);
  });
}
var sync3 = {
  valueChange: (ctx) => {
    const prevSelectedItems = ctx.selectedItems;
    ctx.selectedItems = ctx.value.map((value) => {
      const foundItem = prevSelectedItems.find((item) => ctx.collection.getItemValue(item) === value);
      if (foundItem) return foundItem;
      return ctx.collection.find(value);
    });
    ctx.valueAsString = ctx.collection.stringifyItems(ctx.selectedItems);
  },
  highlightChange: (ctx) => {
    ctx.highlightedItem = ctx.collection.find(ctx.highlightedValue);
  }
};
var invoke9 = {
  valueChange: (ctx) => {
    var _a7;
    sync3.valueChange(ctx);
    (_a7 = ctx.onValueChange) == null ? void 0 : _a7.call(ctx, {
      value: Array.from(ctx.value),
      items: Array.from(ctx.selectedItems)
    });
    dispatchChangeEvent(ctx);
  },
  highlightChange: (ctx) => {
    var _a7;
    sync3.highlightChange(ctx);
    (_a7 = ctx.onHighlightChange) == null ? void 0 : _a7.call(ctx, {
      highlightedValue: ctx.highlightedValue,
      highlightedItem: ctx.highlightedItem,
      highlightedIndex: ctx.collection.indexOf(ctx.highlightedValue)
    });
  }
};
var set13 = {
  selectedItem: (ctx, value, force = false) => {
    if (isEqual3(ctx.value, value)) return;
    if (value == null && !force) return;
    if (value == null && force) {
      ctx.value = [];
      invoke9.valueChange(ctx);
      return;
    }
    ctx.value = ctx.multiple ? addOrRemove2(ctx.value, value) : [value];
    invoke9.valueChange(ctx);
  },
  selectedItems: (ctx, value) => {
    if (isEqual3(ctx.value, value)) return;
    ctx.value = value;
    invoke9.valueChange(ctx);
  },
  highlightedItem: (ctx, value, force = false) => {
    if (isEqual3(ctx.highlightedValue, value)) return;
    if (value == null && !force) return;
    ctx.highlightedValue = value ?? null;
    invoke9.highlightChange(ctx);
  }
};
var props46 = createProps30()([
  "closeOnSelect",
  "collection",
  "dir",
  "disabled",
  "deselectable",
  "form",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "invalid",
  "loopFocus",
  "multiple",
  "name",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onValueChange",
  "open.controlled",
  "open",
  "composite",
  "positioning",
  "required",
  "readOnly",
  "scrollToIndexFn",
  "value"
]);
var splitProps46 = createSplitProps2(props46);
var itemProps16 = createProps30()(["item", "persistFocus"]);
var splitItemProps16 = createSplitProps2(itemProps16);
var itemGroupProps4 = createProps30()(["id"]);
var splitItemGroupProps4 = createSplitProps2(itemGroupProps4);
var itemGroupLabelProps4 = createProps30()(["htmlFor"]);
var splitItemGroupLabelProps4 = createSplitProps2(itemGroupLabelProps4);

// node_modules/@ark-ui/react/dist/components/select/use-select.js
var import_react451 = __toESM(require_react(), 1);
var useSelect = (props52) => {
  const { collection: collection4, ...selectProps } = props52;
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react451.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenSelect: field == null ? void 0 : field.ids.control
    },
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    invalid: field == null ? void 0 : field.invalid,
    required: field == null ? void 0 : field.required,
    dir: locale.dir,
    getRootNode: environment.getRootNode,
    collection: collection4,
    open: props52.defaultOpen,
    value: props52.defaultValue,
    "open.controlled": props52.open !== void 0,
    ...selectProps
  };
  const context = (() => {
    const { collection: _, ...restProps } = initialContext;
    return {
      ...restProps,
      value: props52.value,
      onValueChange: useEvent(props52.onValueChange, { sync: true }),
      onHighlightChange: useEvent(props52.onHighlightChange),
      onOpenChange: useEvent(props52.onOpenChange)
    };
  })();
  const [state2, send, service] = useMachine(machine19(initialContext), {
    context
  });
  (0, import_react451.useEffect)(() => {
    service.setContext({ collection: collection4 });
  }, [collection4]);
  return connect19(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/select/select-root.js
var SelectImpl = (props52, ref36) => {
  const [presenceProps, selectProps] = splitPresenceProps(props52);
  const [useSelectProps, localProps] = createSplitProps3()(selectProps, [
    "closeOnSelect",
    "collection",
    "composite",
    "defaultOpen",
    "defaultValue",
    "deselectable",
    "disabled",
    "form",
    "highlightedValue",
    "id",
    "ids",
    "invalid",
    "loopFocus",
    "multiple",
    "name",
    "onFocusOutside",
    "onHighlightChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onValueChange",
    "open",
    "positioning",
    "readOnly",
    "required",
    "scrollToIndexFn",
    "value"
  ]);
  const select = useSelect(useSelectProps);
  const presence = usePresence(mergeProps3({ present: select.open }, presenceProps));
  const mergedProps = mergeProps3(select.getRootProps(), localProps);
  return (0, import_jsx_runtime227.jsx)(SelectProvider, { value: select, children: (0, import_jsx_runtime227.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime227.jsx)(ark.div, { ...mergedProps, ref: ref36 }) }) });
};
var SelectRoot = (0, import_react453.forwardRef)(SelectImpl);

// node_modules/@ark-ui/react/dist/components/select/select-root-provider.js
var import_jsx_runtime228 = __toESM(require_jsx_runtime(), 1);
var import_react455 = __toESM(require_react(), 1);
var SelectImpl2 = (props52, ref36) => {
  const [presenceProps, selectProps] = splitPresenceProps(props52);
  const [{ value: select }, localProps] = createSplitProps3()(selectProps, [
    "value"
  ]);
  const presence = usePresence(mergeProps3({ present: select.open }, presenceProps));
  const mergedProps = mergeProps3(select.getRootProps(), localProps);
  return (0, import_jsx_runtime228.jsx)(SelectProvider, { value: select, children: (0, import_jsx_runtime228.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime228.jsx)(ark.div, { ...mergedProps, ref: ref36 }) }) });
};
var SelectRootProvider = (0, import_react455.forwardRef)(SelectImpl2);

// node_modules/@ark-ui/react/dist/components/select/select-trigger.js
var import_jsx_runtime229 = __toESM(require_jsx_runtime(), 1);
var import_react457 = __toESM(require_react(), 1);
var SelectTrigger = (0, import_react457.forwardRef)((props52, ref36) => {
  const select = useSelectContext();
  const mergedProps = mergeProps3(select.getTriggerProps(), props52);
  return (0, import_jsx_runtime229.jsx)(ark.button, { ...mergedProps, ref: ref36 });
});
SelectTrigger.displayName = "SelectTrigger";

// node_modules/@ark-ui/react/dist/components/select/select-value-text.js
var import_jsx_runtime230 = __toESM(require_jsx_runtime(), 1);
var import_react459 = __toESM(require_react(), 1);
var SelectValueText = (0, import_react459.forwardRef)((props52, ref36) => {
  const { children, placeholder, ...localprops } = props52;
  const select = useSelectContext();
  const mergedProps = mergeProps3(select.getValueTextProps(), localprops);
  return (0, import_jsx_runtime230.jsx)(ark.span, { ...mergedProps, ref: ref36, children: children || select.valueAsString || placeholder });
});
SelectValueText.displayName = "SelectValueText";

// node_modules/@ark-ui/react/dist/components/select/select.js
var select_exports = {};
__export(select_exports, {
  ClearTrigger: () => SelectClearTrigger,
  Content: () => SelectContent,
  Context: () => SelectContext,
  Control: () => SelectControl,
  HiddenSelect: () => SelectHiddenSelect,
  Indicator: () => SelectIndicator,
  Item: () => SelectItem,
  ItemContext: () => SelectItemContext,
  ItemGroup: () => SelectItemGroup,
  ItemGroupLabel: () => SelectItemGroupLabel,
  ItemIndicator: () => SelectItemIndicator,
  ItemText: () => SelectItemText,
  Label: () => SelectLabel,
  List: () => SelectList,
  Positioner: () => SelectPositioner,
  Root: () => SelectRoot,
  RootProvider: () => SelectRootProvider,
  Trigger: () => SelectTrigger,
  ValueText: () => SelectValueText
});

// node_modules/@chakra-ui/react/dist/esm/components/select/select.js
var {
  withProvider: withProvider28,
  withContext: withContext42,
  useStyles: useSelectStyles,
  PropsProvider: PropsProvider41
} = createSlotRecipeContext({ key: "select" });
var SelectRootProvider2 = withProvider28(select_exports.RootProvider, "root", {
  forwardAsChild: true
});
var SelectRoot2 = withProvider28(
  select_exports.Root,
  "root",
  { forwardAsChild: true }
);
var SelectPropsProvider = PropsProvider41;
var SelectTrigger2 = withContext42(
  select_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var SelectPositioner2 = withContext42(select_exports.Positioner, "positioner", { forwardAsChild: true });
var SelectContent2 = withContext42(
  select_exports.Content,
  "content",
  { forwardAsChild: true }
);
var SelectValueText2 = withContext42(select_exports.ValueText, "valueText", { forwardAsChild: true });
var SelectClearTrigger2 = withContext42(select_exports.ClearTrigger, "clearTrigger", { forwardAsChild: true });
var SelectItemGroup2 = withContext42(select_exports.ItemGroup, "itemGroup", { forwardAsChild: true });
var SelectItemGroupLabel2 = withContext42(select_exports.ItemGroupLabel, "itemGroupLabel", { forwardAsChild: true });
var SelectItem2 = withContext42(
  select_exports.Item,
  "item",
  { forwardAsChild: true }
);
var SelectItemText2 = withContext42(
  select_exports.ItemText,
  "itemText",
  { forwardAsChild: true }
);
var SelectItemIndicator2 = withContext42(select_exports.ItemIndicator, "itemIndicator", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime231.jsx)(CheckIcon, {})
  }
});
var SelectIndicatorGroup = withContext42("div", "indicatorGroup");
var SelectIndicator2 = withContext42(select_exports.Indicator, "indicator", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime231.jsx)(ChevronDownIcon, {})
  }
});
var SelectControl2 = withContext42(
  select_exports.Control,
  "control",
  { forwardAsChild: true }
);
var SelectLabel2 = withContext42(
  select_exports.Label,
  "label",
  { forwardAsChild: true }
);
var SelectContext2 = select_exports.Context;
var SelectHiddenSelect2 = select_exports.HiddenSelect;
var SelectItemContext2 = select_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/select/namespace.js
var namespace_exports34 = {};
__export(namespace_exports34, {
  ClearTrigger: () => SelectClearTrigger2,
  Content: () => SelectContent2,
  Context: () => SelectContext2,
  Control: () => SelectControl2,
  Indicator: () => SelectIndicator2,
  IndicatorGroup: () => SelectIndicatorGroup,
  Item: () => SelectItem2,
  ItemGroup: () => SelectItemGroup2,
  ItemGroupLabel: () => SelectItemGroupLabel2,
  ItemIndicator: () => SelectItemIndicator2,
  ItemText: () => SelectItemText2,
  Label: () => SelectLabel2,
  Positioner: () => SelectPositioner2,
  PropsProvider: () => SelectPropsProvider,
  Root: () => SelectRoot2,
  Trigger: () => SelectTrigger2,
  ValueText: () => SelectValueText2
});

// node_modules/@chakra-ui/react/dist/esm/components/separator/separator.js
var { withContext: withContext43, PropsProvider: PropsProvider42 } = createRecipeContext({
  key: "separator"
});
var Separator = withContext43("span", {
  defaultProps: { role: "separator" }
});
var SeparatorPropsProvider = PropsProvider42;

// node_modules/@chakra-ui/react/dist/esm/components/show/show.js
function Show(props52) {
  const { when, fallback: fallback5, children } = props52;
  if (!when) {
    return fallback5 || null;
  }
  return typeof children === "function" ? children(when) : children;
}

// node_modules/@chakra-ui/react/dist/esm/components/skeleton/skeleton.js
var { withContext: withContext44, PropsProvider: PropsProvider43 } = createRecipeContext({
  key: "skeleton"
});
var Skeleton = withContext44("div");
var SkeletonPropsProvider = PropsProvider43;

// node_modules/@chakra-ui/react/dist/esm/components/skip-nav/skip-nav-link.js
var import_jsx_runtime232 = __toESM(require_jsx_runtime(), 1);
var import_react460 = __toESM(require_react(), 1);
var fallbackId = "chakra-skip-nav";
var SkipNavLink = (0, import_react460.forwardRef)(
  function SkipNavLink2(props52, ref36) {
    const recipe = useRecipe({ key: "skipNavLink", recipe: props52.recipe });
    const [variantProps, localProps] = recipe.splitVariantProps(props52);
    const styles = recipe(variantProps);
    localProps.id || (localProps.id = fallbackId);
    return (0, import_jsx_runtime232.jsx)(
      chakra.a,
      {
        ...localProps,
        ref: ref36,
        href: `#${localProps.id}`,
        css: [styles, props52.css]
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/skip-nav/skip-nav-content.js
var import_jsx_runtime233 = __toESM(require_jsx_runtime(), 1);
var import_react461 = __toESM(require_react(), 1);
var SkipNavContent = (0, import_react461.forwardRef)(
  function SkipNavContent2(props52, ref36) {
    const { id = fallbackId, ...rest } = props52;
    return (0, import_jsx_runtime233.jsx)(
      chakra.div,
      {
        ref: ref36,
        id,
        tabIndex: -1,
        style: { outline: 0 },
        ...rest
      }
    );
  }
);

// node_modules/@ark-ui/react/dist/components/slider/use-slider-context.js
var [SliderProvider, useSliderContext] = createContext({
  name: "SliderContext",
  hookName: "useSliderContext",
  providerName: "<SliderProvider />"
});

// node_modules/@ark-ui/react/dist/components/slider/slider-context.js
var SliderContext = (props52) => props52.children(useSliderContext());

// node_modules/@ark-ui/react/dist/components/slider/slider-control.js
var import_jsx_runtime234 = __toESM(require_jsx_runtime(), 1);
var import_react463 = __toESM(require_react(), 1);
var SliderControl = (0, import_react463.forwardRef)((props52, ref36) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps3(slider.getControlProps(), props52);
  return (0, import_jsx_runtime234.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
SliderControl.displayName = "SliderControl";

// node_modules/@ark-ui/react/dist/components/slider/slider-hidden-input.js
var import_jsx_runtime235 = __toESM(require_jsx_runtime(), 1);
var import_react465 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/slider/use-slider-thumb-props-context.js
var [SliderThumbPropsProvider, useSliderThumbPropsContext] = createContext({
  name: "SliderThumbPropsContext",
  hookName: "useSliderThumbPropsContext",
  providerName: "<SliderThumbPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/slider/slider-hidden-input.js
var SliderHiddenInput = (0, import_react465.forwardRef)(
  (props52, ref36) => {
    const slider = useSliderContext();
    const thumbProps3 = useSliderThumbPropsContext();
    const mergedProps = mergeProps3(slider.getHiddenInputProps(thumbProps3), props52);
    return (0, import_jsx_runtime235.jsx)(ark.input, { ...mergedProps, ref: ref36 });
  }
);
SliderHiddenInput.displayName = "SliderHiddenInput";

// node_modules/@ark-ui/react/dist/components/slider/slider-label.js
var import_jsx_runtime236 = __toESM(require_jsx_runtime(), 1);
var import_react467 = __toESM(require_react(), 1);
var SliderLabel = (0, import_react467.forwardRef)((props52, ref36) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps3(slider.getLabelProps(), props52);
  return (0, import_jsx_runtime236.jsx)(ark.label, { ...mergedProps, ref: ref36 });
});
SliderLabel.displayName = "SliderLabel";

// node_modules/@ark-ui/react/dist/components/slider/slider-marker.js
var import_jsx_runtime237 = __toESM(require_jsx_runtime(), 1);
var import_react469 = __toESM(require_react(), 1);
var SliderMarker = (0, import_react469.forwardRef)((props52, ref36) => {
  const [markerProps, localProps] = createSplitProps3()(props52, ["value"]);
  const slider = useSliderContext();
  const mergedProps = mergeProps3(slider.getMarkerProps(markerProps), localProps);
  return (0, import_jsx_runtime237.jsx)(ark.span, { ...mergedProps, ref: ref36 });
});
SliderMarker.displayName = "SliderMarker";

// node_modules/@ark-ui/react/dist/components/slider/slider-marker-group.js
var import_jsx_runtime238 = __toESM(require_jsx_runtime(), 1);
var import_react471 = __toESM(require_react(), 1);
var SliderMarkerGroup = (0, import_react471.forwardRef)(
  (props52, ref36) => {
    const slider = useSliderContext();
    const mergedProps = mergeProps3(slider.getMarkerGroupProps(), props52);
    return (0, import_jsx_runtime238.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
SliderMarkerGroup.displayName = "SliderMarkerGroup";

// node_modules/@ark-ui/react/dist/components/slider/slider-range.js
var import_jsx_runtime239 = __toESM(require_jsx_runtime(), 1);
var import_react473 = __toESM(require_react(), 1);
var SliderRange = (0, import_react473.forwardRef)((props52, ref36) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps3(slider.getRangeProps(), props52);
  return (0, import_jsx_runtime239.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
SliderRange.displayName = "SliderRange";

// node_modules/@ark-ui/react/dist/components/slider/slider-root.js
var import_jsx_runtime240 = __toESM(require_jsx_runtime(), 1);
var import_react477 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/node_modules/@zag-js/element-size/dist/index.mjs
function trackElementSize(element, callback) {
  if (!element) {
    callback(void 0);
    return;
  }
  callback({ width: element.offsetWidth, height: element.offsetHeight });
  const win = element.ownerDocument.defaultView ?? window;
  const observer = new win.ResizeObserver((entries) => {
    if (!Array.isArray(entries) || !entries.length) return;
    const [entry] = entries;
    let width;
    let height;
    if ("borderBoxSize" in entry) {
      const borderSizeEntry = entry["borderBoxSize"];
      const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
      width = borderSize["inlineSize"];
      height = borderSize["blockSize"];
    } else {
      width = element.offsetWidth;
      height = element.offsetHeight;
    }
    callback({ width, height });
  });
  observer.observe(element, { box: "border-box" });
  return () => observer.unobserve(element);
}
function trackElementsSize2(options) {
  const { getNodes, observeMutation = true, callback } = options;
  const cleanups2 = [];
  let firstNode = null;
  function trigger() {
    const elements = getNodes();
    firstNode = elements[0];
    const fns = elements.map(
      (element, index) => trackElementSize(element, (size4) => {
        callback(size4, index);
      })
    );
    cleanups2.push(...fns);
  }
  trigger();
  if (observeMutation) {
    const fn = trackMutation(firstNode, trigger);
    cleanups2.push(fn);
  }
  return () => {
    cleanups2.forEach((cleanup) => {
      cleanup == null ? void 0 : cleanup();
    });
  };
}
function trackMutation(el, cb) {
  var _a7;
  if (!el || !el.parentElement) return;
  const win = ((_a7 = el.ownerDocument) == null ? void 0 : _a7.defaultView) ?? window;
  const observer = new win.MutationObserver(() => {
    cb();
  });
  observer.observe(el.parentElement, { childList: true });
  return () => {
    observer.disconnect();
  };
}

// node_modules/@ark-ui/react/node_modules/@zag-js/slider/dist/index.mjs
var anatomy62 = createAnatomy2("slider").parts(
  "root",
  "label",
  "thumb",
  "valueText",
  "track",
  "range",
  "control",
  "markerGroup",
  "marker"
);
var parts58 = anatomy62.build();
function getBounds2(value) {
  const firstValue = value[0];
  const lastThumb = value[value.length - 1];
  return [firstValue, lastThumb];
}
function getRangeOffsets2(ctx) {
  const [firstPercent, lastPercent] = getBounds2(ctx.valuePercent);
  if (ctx.valuePercent.length === 1) {
    if (ctx.origin === "center") {
      const isNegative = ctx.valuePercent[0] < 50;
      const start = isNegative ? `${ctx.valuePercent[0]}%` : "50%";
      const end = isNegative ? "50%" : `${100 - ctx.valuePercent[0]}%`;
      return { start, end };
    }
    return { start: "0%", end: `${100 - lastPercent}%` };
  }
  return { start: `${firstPercent}%`, end: `${100 - lastPercent}%` };
}
function getRangeStyle2(ctx) {
  if (ctx.isVertical) {
    return {
      position: "absolute",
      bottom: "var(--slider-range-start)",
      top: "var(--slider-range-end)"
    };
  }
  return {
    position: "absolute",
    [ctx.isRtl ? "right" : "left"]: "var(--slider-range-start)",
    [ctx.isRtl ? "left" : "right"]: "var(--slider-range-end)"
  };
}
function getVerticalThumbOffset2(ctx) {
  const { height = 0 } = ctx.thumbSize ?? {};
  const getValue = getValueTransformer2([ctx.min, ctx.max], [-height / 2, height / 2]);
  return parseFloat(getValue(ctx.value).toFixed(2));
}
function getHorizontalThumbOffset2(ctx) {
  const { width = 0 } = ctx.thumbSize ?? {};
  if (ctx.isRtl) {
    const getValue2 = getValueTransformer2([ctx.max, ctx.min], [-width / 2, width / 2]);
    return -1 * parseFloat(getValue2(ctx.value).toFixed(2));
  }
  const getValue = getValueTransformer2([ctx.min, ctx.max], [-width / 2, width / 2]);
  return parseFloat(getValue(ctx.value).toFixed(2));
}
function getOffset2(ctx, percent) {
  if (ctx.thumbAlignment === "center") return `${percent}%`;
  const offset4 = ctx.isVertical ? getVerticalThumbOffset2(ctx) : getHorizontalThumbOffset2(ctx);
  return `calc(${percent}% - ${offset4}px)`;
}
function getThumbOffset2(ctx) {
  let percent = getValuePercent2(ctx.value, ctx.min, ctx.max) * 100;
  return getOffset2(ctx, percent);
}
function getVisibility2(ctx) {
  let visibility = "visible";
  if (ctx.thumbAlignment === "contain" && !ctx.hasMeasuredThumbSize) {
    visibility = "hidden";
  }
  return visibility;
}
function getThumbStyle2(ctx, index) {
  const placementProp = ctx.isVertical ? "bottom" : "insetInlineStart";
  return {
    visibility: getVisibility2(ctx),
    position: "absolute",
    transform: "var(--slider-thumb-transform)",
    [placementProp]: `var(--slider-thumb-offset-${index})`
  };
}
function getControlStyle2() {
  return {
    touchAction: "none",
    userSelect: "none",
    WebkitUserSelect: "none",
    position: "relative"
  };
}
function getRootStyle2(ctx) {
  const range2 = getRangeOffsets2(ctx);
  const offsetStyles = ctx.value.reduce((styles, value, index) => {
    const offset4 = getThumbOffset2({ ...ctx, value });
    return { ...styles, [`--slider-thumb-offset-${index}`]: offset4 };
  }, {});
  return {
    ...offsetStyles,
    "--slider-thumb-transform": ctx.isVertical ? "translateY(50%)" : ctx.isRtl ? "translateX(50%)" : "translateX(-50%)",
    "--slider-range-start": range2.start,
    "--slider-range-end": range2.end
  };
}
function getMarkerStyle2(ctx, value) {
  return {
    // @ts-expect-error
    visibility: getVisibility2(ctx),
    position: "absolute",
    pointerEvents: "none",
    // @ts-expect-error
    [ctx.isHorizontal ? "insetInlineStart" : "bottom"]: getThumbOffset2({ ...ctx, value }),
    translate: "var(--tx) var(--ty)",
    "--tx": ctx.isHorizontal ? ctx.isRtl ? "50%" : "-50%" : "0%",
    "--ty": !ctx.isHorizontal ? "50%" : "0%"
  };
}
function getMarkerGroupStyle2() {
  return {
    userSelect: "none",
    WebkitUserSelect: "none",
    pointerEvents: "none",
    position: "relative"
  };
}
var styleGetterFns2 = {
  getRootStyle: getRootStyle2,
  getControlStyle: getControlStyle2,
  getThumbStyle: getThumbStyle2,
  getRangeStyle: getRangeStyle2,
  getMarkerStyle: getMarkerStyle2,
  getMarkerGroupStyle: getMarkerGroupStyle2
};
var dom55 = createScope({
  ...styleGetterFns2,
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `slider:${ctx.id}`;
  },
  getThumbId: (ctx, index) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.thumb) == null ? void 0 : _b6.call(_a7, index)) ?? `slider:${ctx.id}:thumb:${index}`;
  },
  getHiddenInputId: (ctx, index) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.hiddenInput) == null ? void 0 : _b6.call(_a7, index)) ?? `slider:${ctx.id}:input:${index}`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `slider:${ctx.id}:control`;
  },
  getTrackId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.track) ?? `slider:${ctx.id}:track`;
  },
  getRangeId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.range) ?? `slider:${ctx.id}:range`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `slider:${ctx.id}:label`;
  },
  getValueTextId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.valueText) ?? `slider:${ctx.id}:value-text`;
  },
  getMarkerId: (ctx, value) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.marker) == null ? void 0 : _b6.call(_a7, value)) ?? `slider:${ctx.id}:marker:${value}`;
  },
  getRootEl: (ctx) => dom55.getById(ctx, dom55.getRootId(ctx)),
  getThumbEl: (ctx, index) => dom55.getById(ctx, dom55.getThumbId(ctx, index)),
  getHiddenInputEl: (ctx, index) => dom55.getById(ctx, dom55.getHiddenInputId(ctx, index)),
  getControlEl: (ctx) => dom55.getById(ctx, dom55.getControlId(ctx)),
  getElements: (ctx) => queryAll(dom55.getControlEl(ctx), "[role=slider]"),
  getFirstEl: (ctx) => dom55.getElements(ctx)[0],
  getRangeEl: (ctx) => dom55.getById(ctx, dom55.getRangeId(ctx)),
  getValueFromPoint(ctx, point) {
    const controlEl = dom55.getControlEl(ctx);
    if (!controlEl) return;
    const relativePoint = getRelativePoint2(point, controlEl);
    const percent = relativePoint.getPercentValue({
      orientation: ctx.orientation,
      dir: ctx.dir,
      inverted: { y: true }
    });
    return getPercentValue2(percent, ctx.min, ctx.max, ctx.step);
  },
  dispatchChangeEvent(ctx) {
    const valueArray = Array.from(ctx.value);
    valueArray.forEach((value, index) => {
      const inputEl = dom55.getHiddenInputEl(ctx, index);
      if (!inputEl) return;
      dispatchInputValueEvent2(inputEl, { value });
    });
  }
});
function normalizeValues(ctx, nextValues) {
  return nextValues.map((value, index, values) => {
    return constrainValue3({ ...ctx, value: values }, value, index);
  });
}
function getRangeAtIndex(ctx, index) {
  return getValueRanges2(ctx.value, ctx.min, ctx.max, ctx.minStepsBetweenThumbs)[index];
}
function constrainValue3(ctx, value, index) {
  const range2 = getRangeAtIndex(ctx, index);
  const snapValue = snapValueToStep2(value, ctx.min, ctx.max, ctx.step);
  return clampValue2(snapValue, range2.min, range2.max);
}
function decrement3(ctx, index, step) {
  const idx = index ?? ctx.focusedIndex;
  const range2 = getRangeAtIndex(ctx, idx);
  const nextValues = getPreviousStepValue2(idx, {
    ...range2,
    step: step ?? ctx.step,
    values: ctx.value
  });
  nextValues[idx] = clampValue2(nextValues[idx], range2.min, range2.max);
  return nextValues;
}
function increment3(ctx, index, step) {
  const idx = index ?? ctx.focusedIndex;
  const range2 = getRangeAtIndex(ctx, idx);
  const nextValues = getNextStepValue2(idx, {
    ...range2,
    step: step ?? ctx.step,
    values: ctx.value
  });
  nextValues[idx] = clampValue2(nextValues[idx], range2.min, range2.max);
  return nextValues;
}
function getClosestIndex(ctx, pointValue) {
  return getClosestValueIndex2(ctx.value, pointValue);
}
function assignArray(current, next3) {
  for (let i = 0; i < next3.length; i++) {
    const value = next3[i];
    current[i] = value;
  }
}
function connect20(state2, send, normalize2) {
  const ariaLabel = state2.context["aria-label"];
  const ariaLabelledBy = state2.context["aria-labelledby"];
  const sliderValue = state2.context.value;
  const focused = state2.matches("focus");
  const dragging = state2.matches("dragging");
  const disabled = state2.context.isDisabled;
  const invalid = state2.context.invalid;
  const interactive = state2.context.isInteractive;
  const isHorizontal = state2.context.orientation === "horizontal";
  const isVertical = state2.context.orientation === "vertical";
  function getValuePercentFn(value) {
    return getValuePercent2(value, state2.context.min, state2.context.max);
  }
  function getPercentValueFn(percent) {
    return getPercentValue2(percent, state2.context.min, state2.context.max, state2.context.step);
  }
  return {
    value: state2.context.value,
    dragging,
    focused,
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    getThumbValue(index) {
      return sliderValue[index];
    },
    setThumbValue(index, value) {
      send({ type: "SET_VALUE", index, value });
    },
    getValuePercent: getValuePercentFn,
    getPercentValue: getPercentValueFn,
    getThumbPercent(index) {
      return getValuePercentFn(sliderValue[index]);
    },
    setThumbPercent(index, percent) {
      const value = getPercentValueFn(percent);
      send({ type: "SET_VALUE", index, value });
    },
    getThumbMin(index) {
      return getRangeAtIndex(state2.context, index).min;
    },
    getThumbMax(index) {
      return getRangeAtIndex(state2.context, index).max;
    },
    increment(index) {
      send({ type: "INCREMENT", index });
    },
    decrement(index) {
      send({ type: "DECREMENT", index });
    },
    focus() {
      if (!interactive) return;
      send({ type: "FOCUS", index: 0 });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts58.label.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-invalid": dataAttr(invalid),
        "data-dragging": dataAttr(dragging),
        "data-focus": dataAttr(focused),
        id: dom55.getLabelId(state2.context),
        htmlFor: dom55.getHiddenInputId(state2.context, 0),
        onClick(event) {
          var _a7;
          if (!interactive) return;
          event.preventDefault();
          (_a7 = dom55.getFirstEl(state2.context)) == null ? void 0 : _a7.focus();
        },
        style: {
          userSelect: "none",
          WebkitUserSelect: "none"
        }
      });
    },
    getRootProps() {
      return normalize2.element({
        ...parts58.root.attrs,
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-dragging": dataAttr(dragging),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        id: dom55.getRootId(state2.context),
        dir: state2.context.dir,
        style: dom55.getRootStyle(state2.context)
      });
    },
    getValueTextProps() {
      return normalize2.element({
        ...parts58.valueText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        id: dom55.getValueTextId(state2.context)
      });
    },
    getTrackProps() {
      return normalize2.element({
        ...parts58.track.attrs,
        dir: state2.context.dir,
        id: dom55.getTrackId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-dragging": dataAttr(dragging),
        "data-orientation": state2.context.orientation,
        "data-focus": dataAttr(focused),
        style: { position: "relative" }
      });
    },
    getThumbProps(props210) {
      var _a7, _b6;
      const { index = 0, name } = props210;
      const value = sliderValue[index];
      const range2 = getRangeAtIndex(state2.context, index);
      const valueText = (_b6 = (_a7 = state2.context).getAriaValueText) == null ? void 0 : _b6.call(_a7, { value, index });
      const _ariaLabel = Array.isArray(ariaLabel) ? ariaLabel[index] : ariaLabel;
      const _ariaLabelledBy = Array.isArray(ariaLabelledBy) ? ariaLabelledBy[index] : ariaLabelledBy;
      return normalize2.element({
        ...parts58.thumb.attrs,
        dir: state2.context.dir,
        "data-index": index,
        "data-name": name,
        id: dom55.getThumbId(state2.context, index),
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-focus": dataAttr(focused && state2.context.focusedIndex === index),
        "data-dragging": dataAttr(dragging && state2.context.focusedIndex === index),
        draggable: false,
        "aria-disabled": ariaAttr(disabled),
        "aria-label": _ariaLabel,
        "aria-labelledby": _ariaLabelledBy ?? dom55.getLabelId(state2.context),
        "aria-orientation": state2.context.orientation,
        "aria-valuemax": range2.max,
        "aria-valuemin": range2.min,
        "aria-valuenow": sliderValue[index],
        "aria-valuetext": valueText,
        role: "slider",
        tabIndex: disabled ? void 0 : 0,
        style: dom55.getThumbStyle(state2.context, index),
        onPointerDown(event) {
          if (!interactive) return;
          send({ type: "THUMB_POINTER_DOWN", index });
          event.stopPropagation();
        },
        onBlur() {
          if (!interactive) return;
          send("BLUR");
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "FOCUS", index });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const step = getEventStep2(event) * state2.context.step;
          const keyMap2 = {
            ArrowUp() {
              if (isHorizontal) return;
              send({ type: "ARROW_INC", step, src: "ArrowUp" });
            },
            ArrowDown() {
              if (isHorizontal) return;
              send({ type: "ARROW_DEC", step, src: "ArrowDown" });
            },
            ArrowLeft() {
              if (isVertical) return;
              send({ type: "ARROW_DEC", step, src: "ArrowLeft" });
            },
            ArrowRight() {
              if (isVertical) return;
              send({ type: "ARROW_INC", step, src: "ArrowRight" });
            },
            PageUp() {
              send({ type: "ARROW_INC", step, src: "PageUp" });
            },
            PageDown() {
              send({ type: "ARROW_DEC", step, src: "PageDown" });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = getEventKey2(event, state2.context);
          const exec21 = keyMap2[key];
          if (exec21) {
            exec21(event);
            event.preventDefault();
            event.stopPropagation();
          }
        }
      });
    },
    getHiddenInputProps(props210) {
      const { index = 0, name } = props210;
      return normalize2.input({
        name: name ?? (state2.context.name ? state2.context.name + (state2.context.value.length > 1 ? "[]" : "") : void 0),
        form: state2.context.form,
        type: "text",
        hidden: true,
        defaultValue: state2.context.value[index],
        id: dom55.getHiddenInputId(state2.context, index)
      });
    },
    getRangeProps() {
      return normalize2.element({
        id: dom55.getRangeId(state2.context),
        ...parts58.range.attrs,
        dir: state2.context.dir,
        "data-dragging": dataAttr(dragging),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid),
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        style: dom55.getRangeStyle(state2.context)
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts58.control.attrs,
        dir: state2.context.dir,
        id: dom55.getControlId(state2.context),
        "data-dragging": dataAttr(dragging),
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        style: dom55.getControlStyle(),
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick2(event)) return;
          if (isModifierKey2(event)) return;
          const point = getEventPoint2(event);
          send({ type: "POINTER_DOWN", point });
          event.preventDefault();
          event.stopPropagation();
        }
      });
    },
    getMarkerGroupProps() {
      return normalize2.element({
        ...parts58.markerGroup.attrs,
        role: "presentation",
        dir: state2.context.dir,
        "aria-hidden": true,
        "data-orientation": state2.context.orientation,
        style: dom55.getMarkerGroupStyle()
      });
    },
    getMarkerProps(props210) {
      const style = dom55.getMarkerStyle(state2.context, props210.value);
      let markerState;
      const first3 = state2.context.value[0];
      const last3 = state2.context.value[state2.context.value.length - 1];
      if (props210.value < first3) {
        markerState = "under-value";
      } else if (props210.value > last3) {
        markerState = "over-value";
      } else {
        markerState = "at-value";
      }
      return normalize2.element({
        ...parts58.marker.attrs,
        id: dom55.getMarkerId(state2.context, props210.value),
        role: "presentation",
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        "data-value": props210.value,
        "data-disabled": dataAttr(disabled),
        "data-state": markerState,
        style
      });
    }
  };
}
var isEqualSize2 = (a, b) => {
  return (a == null ? void 0 : a.width) === (b == null ? void 0 : b.width) && (a == null ? void 0 : a.height) === (b == null ? void 0 : b.height);
};
function machine20(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "slider",
      initial: "idle",
      context: {
        thumbSize: null,
        thumbAlignment: "contain",
        min: 0,
        max: 100,
        step: 1,
        value: [0],
        origin: "start",
        orientation: "horizontal",
        dir: "ltr",
        minStepsBetweenThumbs: 0,
        disabled: false,
        readOnly: false,
        ...ctx,
        focusedIndex: -1,
        fieldsetDisabled: false
      },
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        isVertical: (ctx2) => ctx2.orientation === "vertical",
        isRtl: (ctx2) => ctx2.orientation === "horizontal" && ctx2.dir === "rtl",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.readOnly || ctx2.isDisabled),
        hasMeasuredThumbSize: (ctx2) => ctx2.thumbSize != null,
        valuePercent(ctx2) {
          return ctx2.value.map((value) => 100 * getValuePercent2(value, ctx2.min, ctx2.max));
        }
      },
      watch: {
        value: ["syncInputElements"]
      },
      entry: ["coarseValue"],
      activities: ["trackFormControlState", "trackThumbsSize"],
      on: {
        SET_VALUE: [
          {
            guard: "hasIndex",
            actions: "setValueAtIndex"
          },
          { actions: "setValue" }
        ],
        INCREMENT: {
          actions: "incrementThumbAtIndex"
        },
        DECREMENT: {
          actions: "decrementThumbAtIndex"
        }
      },
      states: {
        idle: {
          on: {
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setClosestThumbIndex", "setPointerValue", "focusActiveThumb"]
            },
            FOCUS: {
              target: "focus",
              actions: "setFocusedIndex"
            },
            THUMB_POINTER_DOWN: {
              target: "dragging",
              actions: ["setFocusedIndex", "focusActiveThumb"]
            }
          }
        },
        focus: {
          entry: "focusActiveThumb",
          on: {
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setClosestThumbIndex", "setPointerValue", "focusActiveThumb"]
            },
            THUMB_POINTER_DOWN: {
              target: "dragging",
              actions: ["setFocusedIndex", "focusActiveThumb"]
            },
            ARROW_DEC: {
              actions: ["decrementThumbAtIndex", "invokeOnChangeEnd"]
            },
            ARROW_INC: {
              actions: ["incrementThumbAtIndex", "invokeOnChangeEnd"]
            },
            HOME: {
              actions: ["setFocusedThumbToMin", "invokeOnChangeEnd"]
            },
            END: {
              actions: ["setFocusedThumbToMax", "invokeOnChangeEnd"]
            },
            BLUR: {
              target: "idle",
              actions: "clearFocusedIndex"
            }
          }
        },
        dragging: {
          entry: "focusActiveThumb",
          activities: "trackPointerMove",
          on: {
            POINTER_UP: {
              target: "focus",
              actions: "invokeOnChangeEnd"
            },
            POINTER_MOVE: {
              actions: "setPointerValue"
            }
          }
        }
      }
    },
    {
      guards: {
        hasIndex: (_ctx, evt) => evt.index != null
      },
      activities: {
        trackFormControlState(ctx2, _evt, { initialContext }) {
          return trackFormControl2(dom55.getRootEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set14.value(ctx2, initialContext.value);
            }
          });
        },
        trackPointerMove(ctx2, _evt, { send }) {
          return trackPointerMove2(dom55.getDoc(ctx2), {
            onPointerMove(info) {
              send({ type: "POINTER_MOVE", point: info.point });
            },
            onPointerUp() {
              send("POINTER_UP");
            }
          });
        },
        trackThumbsSize(ctx2) {
          if (ctx2.thumbAlignment !== "contain" || ctx2.thumbSize) return;
          return trackElementsSize2({
            getNodes: () => dom55.getElements(ctx2),
            observeMutation: true,
            callback(size4) {
              if (!size4 || isEqualSize2(ctx2.thumbSize, size4)) return;
              ctx2.thumbSize = size4;
            }
          });
        }
      },
      actions: {
        syncInputElements(ctx2) {
          ctx2.value.forEach((value, index) => {
            const inputEl = dom55.getHiddenInputEl(ctx2, index);
            dom55.setValue(inputEl, value);
          });
        },
        invokeOnChangeEnd(ctx2) {
          invoke10.valueChangeEnd(ctx2);
        },
        setClosestThumbIndex(ctx2, evt) {
          const pointValue = dom55.getValueFromPoint(ctx2, evt.point);
          if (pointValue == null) return;
          const focusedIndex = getClosestIndex(ctx2, pointValue);
          set14.focusedIndex(ctx2, focusedIndex);
        },
        setFocusedIndex(ctx2, evt) {
          set14.focusedIndex(ctx2, evt.index);
        },
        clearFocusedIndex(ctx2) {
          set14.focusedIndex(ctx2, -1);
        },
        setPointerValue(ctx2, evt) {
          const pointerValue = dom55.getValueFromPoint(ctx2, evt.point);
          if (pointerValue == null) return;
          const value = constrainValue3(ctx2, pointerValue, ctx2.focusedIndex);
          set14.valueAtIndex(ctx2, ctx2.focusedIndex, value);
        },
        focusActiveThumb(ctx2) {
          raf(() => {
            const thumbEl = dom55.getThumbEl(ctx2, ctx2.focusedIndex);
            thumbEl == null ? void 0 : thumbEl.focus({ preventScroll: true });
          });
        },
        decrementThumbAtIndex(ctx2, evt) {
          const value = decrement3(ctx2, evt.index, evt.step);
          set14.value(ctx2, value);
        },
        incrementThumbAtIndex(ctx2, evt) {
          const value = increment3(ctx2, evt.index, evt.step);
          set14.value(ctx2, value);
        },
        setFocusedThumbToMin(ctx2) {
          const { min: min4 } = getRangeAtIndex(ctx2, ctx2.focusedIndex);
          set14.valueAtIndex(ctx2, ctx2.focusedIndex, min4);
        },
        setFocusedThumbToMax(ctx2) {
          const { max: max4 } = getRangeAtIndex(ctx2, ctx2.focusedIndex);
          set14.valueAtIndex(ctx2, ctx2.focusedIndex, max4);
        },
        coarseValue(ctx2) {
          const value = normalizeValues(ctx2, ctx2.value);
          set14.value(ctx2, value);
        },
        setValueAtIndex(ctx2, evt) {
          const value = constrainValue3(ctx2, evt.value, evt.index);
          set14.valueAtIndex(ctx2, evt.index, value);
        },
        setValue(ctx2, evt) {
          const value = normalizeValues(ctx2, evt.value);
          set14.value(ctx2, value);
        }
      }
    }
  );
}
var invoke10 = {
  valueChange(ctx) {
    var _a7;
    (_a7 = ctx.onValueChange) == null ? void 0 : _a7.call(ctx, {
      value: Array.from(ctx.value)
    });
    dom55.dispatchChangeEvent(ctx);
  },
  valueChangeEnd(ctx) {
    var _a7;
    (_a7 = ctx.onValueChangeEnd) == null ? void 0 : _a7.call(ctx, {
      value: Array.from(ctx.value)
    });
  },
  focusChange(ctx) {
    var _a7;
    (_a7 = ctx.onFocusChange) == null ? void 0 : _a7.call(ctx, {
      value: Array.from(ctx.value),
      focusedIndex: ctx.focusedIndex
    });
  }
};
var set14 = {
  valueAtIndex: (ctx, index, value) => {
    if (isEqual3(ctx.value[index], value)) return;
    ctx.value[index] = value;
    invoke10.valueChange(ctx);
  },
  value: (ctx, value) => {
    if (isEqual3(ctx.value, value)) return;
    assignArray(ctx.value, value);
    invoke10.valueChange(ctx);
  },
  focusedIndex: (ctx, index) => {
    if (isEqual3(ctx.focusedIndex, index)) return;
    ctx.focusedIndex = index;
    invoke10.focusChange(ctx);
  }
};
var props47 = createProps30()([
  "aria-label",
  "aria-labelledby",
  "dir",
  "disabled",
  "form",
  "getAriaValueText",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "max",
  "min",
  "minStepsBetweenThumbs",
  "name",
  "onFocusChange",
  "onValueChange",
  "onValueChangeEnd",
  "orientation",
  "origin",
  "readOnly",
  "step",
  "thumbAlignment",
  "thumbAlignment",
  "thumbSize",
  "value"
]);
var splitProps47 = createSplitProps2(props47);
var thumbProps2 = createProps30()(["index", "name"]);
var splitThumbProps2 = createSplitProps2(thumbProps2);

// node_modules/@ark-ui/react/dist/components/slider/use-slider.js
var import_react475 = __toESM(require_react(), 1);
var useSlider = (props52 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react475.useId)(),
    dir,
    getRootNode: getRootNode2,
    value: props52.defaultValue,
    ...props52
  };
  const context = {
    ...initialContext,
    value: props52.value,
    onValueChange: useEvent(props52.onValueChange, { sync: true }),
    onValueChangeEnd: useEvent(props52.onValueChangeEnd),
    onFocusChange: useEvent(props52.onFocusChange)
  };
  const [state2, send] = useMachine(machine20(initialContext), {
    context
  });
  return connect20(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/slider/slider-root.js
var SliderRoot = (0, import_react477.forwardRef)((props52, ref36) => {
  const [useSliderProps, localProps] = createSplitProps3()(props52, [
    "aria-label",
    "aria-labelledby",
    "defaultValue",
    "disabled",
    "form",
    "getAriaValueText",
    "id",
    "ids",
    "invalid",
    "max",
    "min",
    "minStepsBetweenThumbs",
    "name",
    "onFocusChange",
    "onValueChange",
    "onValueChangeEnd",
    "orientation",
    "origin",
    "readOnly",
    "step",
    "thumbAlignment",
    "thumbAlignment",
    "thumbSize",
    "value"
  ]);
  const slider = useSlider(useSliderProps);
  const mergedProps = mergeProps3(slider.getRootProps(), localProps);
  return (0, import_jsx_runtime240.jsx)(SliderProvider, { value: slider, children: (0, import_jsx_runtime240.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
});
SliderRoot.displayName = "SliderRoot";

// node_modules/@ark-ui/react/dist/components/slider/slider-root-provider.js
var import_jsx_runtime241 = __toESM(require_jsx_runtime(), 1);
var import_react479 = __toESM(require_react(), 1);
var SliderRootProvider = (0, import_react479.forwardRef)(
  (props52, ref36) => {
    const [{ value: slider }, localProps] = createSplitProps3()(props52, ["value"]);
    const mergedProps = mergeProps3(slider.getRootProps(), localProps);
    return (0, import_jsx_runtime241.jsx)(SliderProvider, { value: slider, children: (0, import_jsx_runtime241.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
  }
);
SliderRootProvider.displayName = "SliderRootProvider";

// node_modules/@ark-ui/react/dist/components/slider/slider-thumb.js
var import_jsx_runtime242 = __toESM(require_jsx_runtime(), 1);
var import_react481 = __toESM(require_react(), 1);
var SliderThumb = (0, import_react481.forwardRef)((props52, ref36) => {
  const [thumbProps3, localProps] = createSplitProps3()(props52, ["index", "name"]);
  const slider = useSliderContext();
  const mergedProps = mergeProps3(slider.getThumbProps(thumbProps3), localProps);
  return (0, import_jsx_runtime242.jsx)(SliderThumbPropsProvider, { value: thumbProps3, children: (0, import_jsx_runtime242.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
});
SliderThumb.displayName = "SliderThumb";

// node_modules/@ark-ui/react/dist/components/slider/slider-track.js
var import_jsx_runtime243 = __toESM(require_jsx_runtime(), 1);
var import_react483 = __toESM(require_react(), 1);
var SliderTrack = (0, import_react483.forwardRef)((props52, ref36) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps3(slider.getTrackProps(), props52);
  return (0, import_jsx_runtime243.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
SliderTrack.displayName = "SliderTrack";

// node_modules/@ark-ui/react/dist/components/slider/slider-value-text.js
var import_jsx_runtime244 = __toESM(require_jsx_runtime(), 1);
var import_react485 = __toESM(require_react(), 1);
var SliderValueText = (0, import_react485.forwardRef)((props52, ref36) => {
  const { children, ...rest } = props52;
  const slider = useSliderContext();
  const mergedProps = mergeProps3(slider.getValueTextProps(), rest);
  return (0, import_jsx_runtime244.jsx)(ark.span, { ...mergedProps, ref: ref36, children: children || slider.value.join(", ") });
});
SliderValueText.displayName = "SliderValueText";

// node_modules/@ark-ui/react/dist/components/slider/slider.js
var slider_exports = {};
__export(slider_exports, {
  Context: () => SliderContext,
  Control: () => SliderControl,
  HiddenInput: () => SliderHiddenInput,
  Label: () => SliderLabel,
  Marker: () => SliderMarker,
  MarkerGroup: () => SliderMarkerGroup,
  Range: () => SliderRange,
  Root: () => SliderRoot,
  RootProvider: () => SliderRootProvider,
  Thumb: () => SliderThumb,
  Track: () => SliderTrack,
  ValueText: () => SliderValueText
});

// node_modules/@chakra-ui/react/dist/esm/components/slider/slider.js
var {
  withProvider: withProvider29,
  withContext: withContext45,
  useStyles: useSliderStyles,
  PropsProvider: PropsProvider44
} = createSlotRecipeContext({ key: "slider" });
var SliderRootProvider2 = withProvider29(slider_exports.RootProvider, "root", { forwardAsChild: true });
var SliderRoot2 = withProvider29(
  slider_exports.Root,
  "root",
  { forwardAsChild: true }
);
var SliderPropsProvider = PropsProvider44;
var SliderControl2 = withContext45(
  slider_exports.Control,
  "control",
  { forwardAsChild: true }
);
var SliderTrack2 = withContext45(
  slider_exports.Track,
  "track",
  { forwardAsChild: true }
);
var SliderRange2 = withContext45(
  slider_exports.Range,
  "range",
  { forwardAsChild: true }
);
var SliderThumb2 = withContext45(
  slider_exports.Thumb,
  "thumb",
  { forwardAsChild: true }
);
var SliderValueText2 = withContext45(slider_exports.ValueText, "valueText", { forwardAsChild: true });
var SliderLabel2 = withContext45(
  slider_exports.Label,
  "label",
  { forwardAsChild: true }
);
var SliderMarkerGroup2 = withContext45(slider_exports.MarkerGroup, "markerGroup", { forwardAsChild: true });
var SliderMarker2 = withContext45(
  slider_exports.Marker,
  "marker",
  { forwardAsChild: true }
);
var SliderMarkerIndicator = withContext45("div", "markerIndicator");
var SliderContext2 = slider_exports.Context;
var SliderHiddenInput2 = slider_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/slider/namespace.js
var namespace_exports35 = {};
__export(namespace_exports35, {
  Context: () => SliderContext2,
  Control: () => SliderControl2,
  HiddenInput: () => SliderHiddenInput2,
  Label: () => SliderLabel2,
  Marker: () => SliderMarker2,
  MarkerGroup: () => SliderMarkerGroup2,
  MarkerIndicator: () => SliderMarkerIndicator,
  PropsProvider: () => SliderPropsProvider,
  Range: () => SliderRange2,
  Root: () => SliderRoot2,
  RootProvider: () => SliderRootProvider2,
  Thumb: () => SliderThumb2,
  Track: () => SliderTrack2,
  ValueText: () => SliderValueText2
});

// node_modules/@chakra-ui/react/dist/esm/components/spacer/spacer.js
var Spacer = chakra("div", {
  base: {
    flex: 1,
    justifySelf: "stretch",
    alignSelf: "stretch"
  }
});
Spacer.displayName = "Spacer";

// node_modules/@chakra-ui/react/dist/esm/components/spinner/spinner.js
var { withContext: withContext46, PropsProvider: PropsProvider45 } = createRecipeContext({
  key: "spinner"
});
var Spinner = withContext46("span");
var SpinnerPropsProvider = PropsProvider45;

// node_modules/@chakra-ui/react/dist/esm/components/stack/h-stack.js
var import_jsx_runtime246 = __toESM(require_jsx_runtime(), 1);
var import_react487 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/stack/stack.js
var import_jsx_runtime245 = __toESM(require_jsx_runtime(), 1);
var import_react486 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/stack/get-separator-style.js
function getSeparatorStyles(options) {
  const { gap, direction } = options;
  const styles = {
    column: {
      marginY: gap,
      marginX: 0,
      borderInlineStartWidth: 0,
      borderTopWidth: "1px"
    },
    "column-reverse": {
      marginY: gap,
      marginX: 0,
      borderInlineStartWidth: 0,
      borderTopWidth: "1px"
    },
    row: {
      marginX: gap,
      marginY: 0,
      borderInlineStartWidth: "1px",
      borderTopWidth: 0
    },
    "row-reverse": {
      marginX: gap,
      marginY: 0,
      borderInlineStartWidth: "1px",
      borderTopWidth: 0
    }
  };
  return {
    "&": mapObject(direction, (value) => styles[value])
  };
}

// node_modules/@chakra-ui/react/dist/esm/components/stack/stack.js
function getValidChildren(children) {
  return import_react486.Children.toArray(children).filter(
    (child) => (0, import_react486.isValidElement)(child)
  );
}
var Stack = (0, import_react486.forwardRef)(
  function Stack2(props52, ref36) {
    const {
      direction = "column",
      align,
      justify,
      gap = "0.5rem",
      wrap: wrap50,
      children,
      separator,
      className,
      ...rest
    } = props52;
    const separatorStyle = (0, import_react486.useMemo)(
      () => getSeparatorStyles({ gap, direction }),
      [gap, direction]
    );
    const clones = (0, import_react486.useMemo)(() => {
      if (!separator) return children;
      return getValidChildren(children).map((child, index, arr) => {
        const key = typeof child.key !== "undefined" ? child.key : index;
        const sep = (0, import_react486.cloneElement)(separator, {
          css: [separatorStyle, separator.props.css]
        });
        return (0, import_jsx_runtime245.jsxs)(import_react486.Fragment, { children: [
          child,
          index === arr.length - 1 ? null : sep
        ] }, key);
      });
    }, [children, separator, separatorStyle]);
    return (0, import_jsx_runtime245.jsx)(
      chakra.div,
      {
        ref: ref36,
        display: "flex",
        alignItems: align,
        justifyContent: justify,
        flexDirection: direction,
        flexWrap: wrap50,
        gap: separator ? void 0 : gap,
        className: cx("chakra-stack", className),
        ...rest,
        children: clones
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/stack/h-stack.js
var HStack = (0, import_react487.forwardRef)(
  function HStack2(props52, ref36) {
    return (0, import_jsx_runtime246.jsx)(Stack, { align: "center", ...props52, direction: "row", ref: ref36 });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/stack/v-stack.js
var import_jsx_runtime247 = __toESM(require_jsx_runtime(), 1);
var import_react488 = __toESM(require_react(), 1);
var VStack = (0, import_react488.forwardRef)(
  function VStack2(props52, ref36) {
    return (0, import_jsx_runtime247.jsx)(Stack, { align: "center", ...props52, direction: "column", ref: ref36 });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/stack/stack-separator.js
var StackSeparator = chakra("div", {
  base: {
    borderWidth: 0,
    alignSelf: "stretch",
    borderColor: "inherit",
    width: "auto",
    height: "auto"
  }
});
StackSeparator.displayName = "StackSeparator";

// node_modules/@chakra-ui/react/dist/esm/components/stat/stat.js
var import_jsx_runtime248 = __toESM(require_jsx_runtime(), 1);
var {
  withProvider: withProvider30,
  withContext: withContext47,
  useStyles: useStatStyles,
  PropsProvider: PropsProvider46
} = createSlotRecipeContext({ key: "stat" });
var StatRoot = withProvider30(
  "dl",
  "root"
);
var StatPropsProvider = PropsProvider46;
var StatLabel = withContext47("dt", "label");
var StatValueText = withContext47(
  "dd",
  "valueText"
);
var StatHelpText = withContext47(
  "span",
  "helpText"
);
var StatValueUnit = withContext47(
  "span",
  "valueUnit"
);
var StatUpIndicator = withContext47(
  "span",
  "indicator",
  {
    defaultProps: {
      "data-type": "up",
      children: (0, import_jsx_runtime248.jsx)(ArrowUpIcon, {})
    }
  }
);
var StatDownIndicator = withContext47("span", "indicator", {
  defaultProps: {
    "data-type": "down",
    children: (0, import_jsx_runtime248.jsx)(ArrowDownIcon, {})
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/stat/namespace.js
var namespace_exports36 = {};
__export(namespace_exports36, {
  DownIndicator: () => StatDownIndicator,
  HelpText: () => StatHelpText,
  Label: () => StatLabel,
  PropsProvider: () => StatPropsProvider,
  Root: () => StatRoot,
  UpIndicator: () => StatUpIndicator,
  ValueText: () => StatValueText,
  ValueUnit: () => StatValueUnit
});

// node_modules/@chakra-ui/react/dist/esm/components/status/namespace.js
var namespace_exports37 = {};
__export(namespace_exports37, {
  Indicator: () => StatusIndicator,
  PropsProvider: () => StatusPropsProvider,
  Root: () => StatusRoot
});

// node_modules/@chakra-ui/react/dist/esm/components/status/status.js
var {
  withProvider: withProvider31,
  withContext: withContext48,
  useStyles: useStatusStyles,
  PropsProvider: PropsProvider47
} = createSlotRecipeContext({ key: "status" });
var StatusRoot = withProvider31(
  "div",
  "root"
);
var StatusPropsProvider = PropsProvider47;
var StatusIndicator = withContext48("div", "indicator");

// node_modules/@chakra-ui/react/dist/esm/components/steps/steps.js
var import_jsx_runtime261 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/steps/steps-completed-content.js
var import_jsx_runtime249 = __toESM(require_jsx_runtime(), 1);
var import_react490 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/steps/use-steps-context.js
var [StepsProvider, useStepsContext] = createContext({
  name: "StepsContext",
  hookName: "useStepsContext",
  providerName: "<StepsProvider />"
});

// node_modules/@ark-ui/react/dist/components/steps/steps-completed-content.js
var StepsCompletedContent = (0, import_react490.forwardRef)(
  (props52, ref36) => {
    const steps = useStepsContext();
    const mergedProps = mergeProps3(steps.getContentProps({ index: steps.count }), props52);
    return (0, import_jsx_runtime249.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
StepsCompletedContent.displayName = "StepsCompletedContent";

// node_modules/@ark-ui/react/dist/components/steps/steps-content.js
var import_jsx_runtime250 = __toESM(require_jsx_runtime(), 1);
var import_react492 = __toESM(require_react(), 1);
var StepsContent = (0, import_react492.forwardRef)((props52, ref36) => {
  const [itemProps17, localProps] = createSplitProps3()(props52, ["index"]);
  const steps = useStepsContext();
  const mergedProps = mergeProps3(steps.getContentProps(itemProps17), localProps);
  return (0, import_jsx_runtime250.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
StepsContent.displayName = "StepsContent";

// node_modules/@ark-ui/react/dist/components/steps/steps-context.js
var StepsContext = (props52) => {
  const context = useStepsContext();
  return props52.children(context);
};
StepsContext.displayName = "StepsContext";

// node_modules/@ark-ui/react/dist/components/steps/steps-indicator.js
var import_jsx_runtime251 = __toESM(require_jsx_runtime(), 1);
var import_react494 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/steps/use-steps-item-props-context.js
var [StepsItemPropsProvider, useStepsItemPropsContext] = createContext({
  name: "StepsItemPropsContext",
  hookName: "useStepsItemPropsContext",
  providerName: "<StepsItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/steps/steps-indicator.js
var StepsIndicator = (0, import_react494.forwardRef)((props52, ref36) => {
  const steps = useStepsContext();
  const itemProps17 = useStepsItemPropsContext();
  const mergedProps = mergeProps3(steps.getIndicatorProps(itemProps17), props52);
  return (0, import_jsx_runtime251.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
StepsIndicator.displayName = "StepsIndicator";

// node_modules/@ark-ui/react/dist/components/steps/steps-item.js
var import_jsx_runtime252 = __toESM(require_jsx_runtime(), 1);
var import_react496 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/steps/use-steps-item-context.js
var [StepsItemProvider, useStepsItemContext] = createContext({
  name: "StepsItemContext",
  hookName: "useStepsItemContext",
  providerName: "<StepsItem />"
});

// node_modules/@ark-ui/react/dist/components/steps/steps-item.js
var StepsItem = (0, import_react496.forwardRef)((props52, ref36) => {
  const [itemProps17, localProps] = createSplitProps3()(props52, ["index"]);
  const steps = useStepsContext();
  const mergedProps = mergeProps3(steps.getItemProps(itemProps17), localProps);
  const itemState = steps.getItemState(itemProps17);
  return (0, import_jsx_runtime252.jsx)(StepsItemPropsProvider, { value: itemProps17, children: (0, import_jsx_runtime252.jsx)(StepsItemProvider, { value: itemState, children: (0, import_jsx_runtime252.jsx)(ark.li, { ...mergedProps, ref: ref36 }) }) });
});
StepsItem.displayName = "StepsItem";

// node_modules/@ark-ui/react/dist/components/steps/steps-item-context.js
var StepsItemContext = (props52) => {
  return props52.children(useStepsItemContext());
};
StepsItemContext.displayName = "StepsItemContext";

// node_modules/@ark-ui/react/dist/components/steps/steps-list.js
var import_jsx_runtime253 = __toESM(require_jsx_runtime(), 1);
var import_react498 = __toESM(require_react(), 1);
var StepsList = (0, import_react498.forwardRef)((props52, ref36) => {
  const steps = useStepsContext();
  const mergedProps = mergeProps3(steps.getListProps(), props52);
  return (0, import_jsx_runtime253.jsx)(ark.ol, { ...mergedProps, ref: ref36 });
});
StepsList.displayName = "StepsList";

// node_modules/@ark-ui/react/dist/components/steps/steps-next-trigger.js
var import_jsx_runtime254 = __toESM(require_jsx_runtime(), 1);
var import_react500 = __toESM(require_react(), 1);
var StepsNextTrigger = (0, import_react500.forwardRef)(
  (props52, ref36) => {
    const steps = useStepsContext();
    const mergedProps = mergeProps3(steps.getNextTriggerProps(), props52);
    return (0, import_jsx_runtime254.jsx)(ark.button, { ...mergedProps, ref: ref36 });
  }
);
StepsNextTrigger.displayName = "StepsNextTrigger";

// node_modules/@ark-ui/react/dist/components/steps/steps-prev-trigger.js
var import_jsx_runtime255 = __toESM(require_jsx_runtime(), 1);
var import_react502 = __toESM(require_react(), 1);
var StepsPrevTrigger = (0, import_react502.forwardRef)(
  (props52, ref36) => {
    const steps = useStepsContext();
    const mergedProps = mergeProps3(steps.getPrevTriggerProps(), props52);
    return (0, import_jsx_runtime255.jsx)(ark.button, { ...mergedProps, ref: ref36 });
  }
);
StepsPrevTrigger.displayName = "StepsPrevTrigger";

// node_modules/@ark-ui/react/dist/components/steps/steps-progress.js
var import_jsx_runtime256 = __toESM(require_jsx_runtime(), 1);
var import_react504 = __toESM(require_react(), 1);
var StepsProgress = (0, import_react504.forwardRef)((props52, ref36) => {
  const steps = useStepsContext();
  const mergedProps = mergeProps3(steps.getProgressProps(), props52);
  return (0, import_jsx_runtime256.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
StepsProgress.displayName = "StepsProgress";

// node_modules/@ark-ui/react/dist/components/steps/steps-root.js
var import_jsx_runtime257 = __toESM(require_jsx_runtime(), 1);
var import_react508 = __toESM(require_react(), 1);

// node_modules/@zag-js/steps/node_modules/@zag-js/anatomy/dist/index.mjs
var createAnatomy3 = (name, parts64 = []) => ({
  parts: (...values) => {
    if (isEmpty3(parts64)) {
      return createAnatomy3(name, values);
    }
    throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
  },
  extendWith: (...values) => createAnatomy3(name, [...parts64, ...values]),
  rename: (newName) => createAnatomy3(newName, parts64),
  keys: () => parts64,
  build: () => [...new Set(parts64)].reduce(
    (prev3, part) => Object.assign(prev3, {
      [part]: {
        selector: [
          `&[data-scope="${toKebabCase3(name)}"][data-part="${toKebabCase3(part)}"]`,
          `& [data-scope="${toKebabCase3(name)}"][data-part="${toKebabCase3(part)}"]`
        ].join(", "),
        attrs: { "data-scope": toKebabCase3(name), "data-part": toKebabCase3(part) }
      }
    }),
    {}
  )
});
var toKebabCase3 = (value) => value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty3 = (v) => v.length === 0;

// node_modules/@zag-js/steps/node_modules/@zag-js/utils/dist/index.mjs
var fromLength = (length2) => Array.from(Array(length2).keys());
var isArrayLike5 = (value) => (value == null ? void 0 : value.constructor.name) === "Array";
var isArrayEqual5 = (a, b) => {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (!isEqual5(a[i], b[i])) return false;
  }
  return true;
};
var isEqual5 = (a, b) => {
  if (Object.is(a, b)) return true;
  if (a == null && b != null || a != null && b == null) return false;
  if (typeof (a == null ? void 0 : a.isEqual) === "function" && typeof (b == null ? void 0 : b.isEqual) === "function") {
    return a.isEqual(b);
  }
  if (typeof a === "function" && typeof b === "function") {
    return a.toString() === b.toString();
  }
  if (isArrayLike5(a) && isArrayLike5(b)) {
    return isArrayEqual5(Array.from(a), Array.from(b));
  }
  if (!(typeof a === "object") || !(typeof b === "object")) return false;
  const keys = Object.keys(b ?? /* @__PURE__ */ Object.create(null));
  const length2 = keys.length;
  for (let i = 0; i < length2; i++) {
    const hasKey = Reflect.has(a, keys[i]);
    if (!hasKey) return false;
  }
  for (let i = 0; i < length2; i++) {
    const key = keys[i];
    if (!isEqual5(a[key], b[key])) return false;
  }
  return true;
};
var fnToString5 = Function.prototype.toString;
var objectCtorString4 = fnToString5.call(Object);
function splitProps48(props52, keys) {
  const rest = {};
  const result = {};
  const keySet = new Set(keys);
  for (const key in props52) {
    if (keySet.has(key)) {
      result[key] = props52[key];
    } else {
      rest[key] = props52[key];
    }
  }
  return [result, rest];
}
var createSplitProps4 = (keys) => {
  return function split(props52) {
    return splitProps48(props52, keys);
  };
};
function compact6(obj) {
  if (!isPlainObject23(obj) || obj === void 0) {
    return obj;
  }
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact6(value);
    }
  }
  return filtered;
}
var isPlainObject23 = (value) => {
  return value && typeof value === "object" && value.constructor === Object;
};

// node_modules/@zag-js/steps/dist/index.mjs
var anatomy63 = createAnatomy3("steps").parts(
  "root",
  "list",
  "item",
  "trigger",
  "indicator",
  "separator",
  "content",
  "nextTrigger",
  "prevTrigger",
  "progress"
);
var parts59 = anatomy63.build();
var dom56 = createScope({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `steps:${ctx.id}`;
  },
  getListId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.list) ?? `steps:${ctx.id}:list`;
  },
  getTriggerId: (ctx, index) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.triggerId) == null ? void 0 : _b6.call(_a7, index)) ?? `steps:${ctx.id}:trigger:${index}`;
  },
  getContentId: (ctx, index) => {
    var _a7, _b6;
    return ((_b6 = (_a7 = ctx.ids) == null ? void 0 : _a7.contentId) == null ? void 0 : _b6.call(_a7, index)) ?? `steps:${ctx.id}:content:${index}`;
  }
});
function connect21(state2, send, normalize2) {
  const step = state2.context.step;
  const count = state2.context.count;
  const percent = state2.context.percent;
  const hasNextStep = state2.context.hasNextStep;
  const hasPrevStep = state2.context.hasPrevStep;
  const getItemState = (props210) => ({
    triggerId: dom56.getTriggerId(state2.context, props210.index),
    contentId: dom56.getContentId(state2.context, props210.index),
    current: props210.index === step,
    completed: props210.index < step,
    incomplete: props210.index > step,
    index: props210.index,
    first: props210.index === 0,
    last: props210.index === count - 1
  });
  const goToNextStep = () => {
    send({ type: "STEP.NEXT", src: "next.trigger.click" });
  };
  const goToPrevStep = () => {
    send({ type: "STEP.PREV", src: "prev.trigger.click" });
  };
  const resetStep = () => {
    send({ type: "STEP.RESET", src: "reset.trigger.click" });
  };
  const setStep = (value) => {
    send({ type: "STEP.SET", value, src: "api.setValue" });
  };
  return {
    value: step,
    count,
    percent,
    hasNextStep,
    hasPrevStep,
    goToNextStep,
    goToPrevStep,
    resetStep,
    getItemState,
    setStep,
    getRootProps() {
      return normalize2.element({
        ...parts59.root.attrs,
        id: dom56.getRootId(state2.context),
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        style: {
          "--percent": `${percent}%`
        }
      });
    },
    getListProps() {
      const arr = fromLength(state2.context.count);
      const triggerIds = arr.map((_, index) => dom56.getTriggerId(state2.context, index));
      return normalize2.element({
        ...parts59.list.attrs,
        dir: state2.context.dir,
        id: dom56.getListId(state2.context),
        role: "tablist",
        "aria-owns": triggerIds.join(" "),
        "aria-orientation": state2.context.orientation,
        "data-orientation": state2.context.orientation
      });
    },
    getItemProps(props210) {
      const itemState = getItemState(props210);
      return normalize2.element({
        ...parts59.item.attrs,
        dir: state2.context.dir,
        "aria-current": itemState.current ? "step" : void 0,
        "data-orientation": state2.context.orientation
      });
    },
    getTriggerProps(props210) {
      const itemState = getItemState(props210);
      return normalize2.button({
        ...parts59.trigger.attrs,
        id: itemState.triggerId,
        role: "tab",
        dir: state2.context.dir,
        tabIndex: !state2.context.linear || itemState.current ? 0 : -1,
        "aria-selected": itemState.current,
        "aria-controls": itemState.contentId,
        "data-state": itemState.current ? "open" : "closed",
        "data-orientation": state2.context.orientation,
        "data-complete": dataAttr(itemState.completed),
        "data-current": dataAttr(itemState.current),
        "data-incomplete": dataAttr(itemState.incomplete),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (state2.context.linear) return;
          send({ type: "STEP.SET", value: props210.index, src: "trigger.click" });
        }
      });
    },
    getContentProps(props210) {
      const itemState = getItemState(props210);
      return normalize2.element({
        ...parts59.content.attrs,
        dir: state2.context.dir,
        id: itemState.contentId,
        role: "tabpanel",
        tabIndex: 0,
        hidden: !itemState.current,
        "data-state": itemState.current ? "open" : "closed",
        "data-orientation": state2.context.orientation,
        "aria-labelledby": itemState.triggerId
      });
    },
    getIndicatorProps(props210) {
      const itemState = getItemState(props210);
      return normalize2.element({
        ...parts59.indicator.attrs,
        dir: state2.context.dir,
        "aria-hidden": true,
        "data-complete": dataAttr(itemState.completed),
        "data-current": dataAttr(itemState.current),
        "data-incomplete": dataAttr(itemState.incomplete)
      });
    },
    getSeparatorProps(props210) {
      const itemState = getItemState(props210);
      return normalize2.element({
        ...parts59.separator.attrs,
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        "data-complete": dataAttr(itemState.completed),
        "data-current": dataAttr(itemState.current),
        "data-incomplete": dataAttr(itemState.incomplete)
      });
    },
    getNextTriggerProps() {
      return normalize2.button({
        ...parts59.nextTrigger.attrs,
        dir: state2.context.dir,
        type: "button",
        disabled: !hasNextStep,
        onClick(event) {
          if (event.defaultPrevented) return;
          goToNextStep();
        }
      });
    },
    getPrevTriggerProps() {
      return normalize2.button({
        dir: state2.context.dir,
        ...parts59.prevTrigger.attrs,
        type: "button",
        disabled: !hasPrevStep,
        onClick(event) {
          if (event.defaultPrevented) return;
          goToPrevStep();
        }
      });
    },
    getProgressProps() {
      return normalize2.element({
        dir: state2.context.dir,
        ...parts59.progress.attrs,
        role: "progressbar",
        "aria-valuenow": percent,
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuetext": `${percent}% complete`,
        "data-complete": dataAttr(percent === 100)
      });
    }
  };
}
function machine21(userContext) {
  const ctx = compact6(userContext);
  return createMachine35(
    {
      id: "steps",
      initial: "idle",
      context: {
        step: 0,
        count: 1,
        linear: false,
        orientation: "horizontal",
        ...ctx
      },
      computed: {
        percent: (ctx2) => ctx2.step / ctx2.count * 100,
        hasNextStep: (ctx2) => ctx2.step < ctx2.count,
        hasPrevStep: (ctx2) => ctx2.step > 0
      },
      states: {
        idle: {
          on: {
            "STEP.SET": {
              actions: "setStep"
            },
            "STEP.NEXT": {
              actions: "goToNextStep"
            },
            "STEP.PREV": {
              actions: "goToPrevStep"
            },
            "STEP.RESET": {
              actions: "resetStep"
            }
          }
        }
      }
    },
    {
      actions: {
        goToNextStep(ctx2) {
          const value = Math.min(ctx2.step + 1, ctx2.count);
          set15.value(ctx2, value);
        },
        goToPrevStep(ctx2) {
          const value = Math.max(ctx2.step - 1, 0);
          set15.value(ctx2, value);
        },
        resetStep(ctx2) {
          set15.value(ctx2, 0);
        },
        setStep(ctx2, event) {
          const value = event.value;
          const inRange = value >= 0 && value < ctx2.count;
          if (!inRange) throw new RangeError(`Index ${value} is out of bounds`);
          set15.value(ctx2, value);
        }
      }
    }
  );
}
var set15 = {
  value(ctx, step) {
    var _a7;
    if (isEqual5(ctx.step, step)) return;
    ctx.step = step;
    (_a7 = ctx.onStepChange) == null ? void 0 : _a7.call(ctx, { step });
  }
};
var props48 = createProps30()([
  "count",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "linear",
  "onStepChange",
  "onStepComplete",
  "orientation",
  "step"
]);
var splitProps49 = createSplitProps4(props48);

// node_modules/@ark-ui/react/dist/components/steps/use-steps.js
var import_react506 = __toESM(require_react(), 1);
function useSteps(props52 = {}) {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react506.useId)(),
    dir,
    getRootNode: getRootNode2,
    step: props52.defaultStep,
    ...props52
  };
  const context = {
    ...initialContext,
    step: props52.step,
    onStepChange: useEvent(props52.onStepChange),
    onStepComplete: useEvent(props52.onStepComplete)
  };
  const [state2, send] = useMachine(machine21(initialContext), {
    context
  });
  return connect21(state2, send, normalizeProps);
}

// node_modules/@ark-ui/react/dist/components/steps/steps-root.js
var StepsRoot = (0, import_react508.forwardRef)((props52, ref36) => {
  const [useStepsProps, localProps] = createSplitProps3()(props52, [
    "defaultStep",
    "id",
    "ids",
    "count",
    "linear",
    "onStepChange",
    "onStepComplete",
    "orientation",
    "step"
  ]);
  const steps = useSteps(useStepsProps);
  const mergedProps = mergeProps3(steps.getRootProps(), localProps);
  return (0, import_jsx_runtime257.jsx)(StepsProvider, { value: steps, children: (0, import_jsx_runtime257.jsx)(ark.div, { ...mergedProps, ref: ref36 }) });
});
StepsRoot.displayName = "StepsRoot";

// node_modules/@ark-ui/react/dist/components/steps/steps-root-provider.js
var import_jsx_runtime258 = __toESM(require_jsx_runtime(), 1);
var import_react510 = __toESM(require_react(), 1);
var StepsRootProvider = (0, import_react510.forwardRef)(
  (props52, ref36) => {
    const [{ value: steps }, rootProps] = createSplitProps3()(props52, ["value"]);
    const mergedProps = mergeProps3(steps.getRootProps(), rootProps);
    return (0, import_jsx_runtime258.jsx)(StepsProvider, { value: steps, children: (0, import_jsx_runtime258.jsx)(ark.div, { ...mergedProps, ref: ref36, children: props52.children }) });
  }
);
StepsRootProvider.displayName = "StepsRootProvider";

// node_modules/@ark-ui/react/dist/components/steps/steps-separator.js
var import_jsx_runtime259 = __toESM(require_jsx_runtime(), 1);
var import_react512 = __toESM(require_react(), 1);
var StepsSeparator = (0, import_react512.forwardRef)((props52, ref36) => {
  const steps = useStepsContext();
  const itemProps17 = useStepsItemPropsContext();
  const mergedProps = mergeProps3(steps.getSeparatorProps(itemProps17), props52);
  return (0, import_jsx_runtime259.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
StepsSeparator.displayName = "StepsSeparator";

// node_modules/@ark-ui/react/dist/components/steps/steps-trigger.js
var import_jsx_runtime260 = __toESM(require_jsx_runtime(), 1);
var import_react514 = __toESM(require_react(), 1);
var StepsTrigger = (0, import_react514.forwardRef)((props52, ref36) => {
  const steps = useStepsContext();
  const itemProps17 = useStepsItemPropsContext();
  const mergedProps = mergeProps3(steps.getTriggerProps(itemProps17), props52);
  return (0, import_jsx_runtime260.jsx)(ark.button, { ...mergedProps, ref: ref36 });
});
StepsTrigger.displayName = "StepsTrigger";

// node_modules/@ark-ui/react/dist/components/steps/steps.js
var steps_exports = {};
__export(steps_exports, {
  CompletedContent: () => StepsCompletedContent,
  Content: () => StepsContent,
  Context: () => StepsContext,
  Indicator: () => StepsIndicator,
  Item: () => StepsItem,
  ItemContext: () => StepsItemContext,
  List: () => StepsList,
  NextTrigger: () => StepsNextTrigger,
  PrevTrigger: () => StepsPrevTrigger,
  Progress: () => StepsProgress,
  Root: () => StepsRoot,
  RootProvider: () => StepsRootProvider,
  Separator: () => StepsSeparator,
  Trigger: () => StepsTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/steps/steps.js
var import_react515 = __toESM(require_react(), 1);
var {
  withProvider: withProvider32,
  withContext: withContext49,
  useStyles: useStepsStyles,
  PropsProvider: PropsProvider48
} = createSlotRecipeContext({ key: "steps" });
var StepsRootProvider2 = withProvider32(steps_exports.RootProvider, "root", { forwardAsChild: true });
var StepsRoot2 = withProvider32(
  steps_exports.Root,
  "root",
  { forwardAsChild: true }
);
var StepsPropsProvider = PropsProvider48;
var StepsList2 = withContext49(
  steps_exports.List,
  "list",
  { forwardAsChild: true }
);
var StepsItem2 = withContext49(
  steps_exports.Item,
  "item",
  { forwardAsChild: true }
);
var StepsTrigger2 = withContext49(
  steps_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var StepsContent2 = withContext49(
  steps_exports.Content,
  "content",
  { forwardAsChild: true }
);
var StepsCompletedContent2 = withContext49(steps_exports.CompletedContent, "content");
var StepsNumber = (0, import_react515.forwardRef)(
  function StepsNumber2(props52, ref36) {
    return (0, import_jsx_runtime261.jsx)(steps_exports.ItemContext, { children: (api) => (0, import_jsx_runtime261.jsx)(chakra.div, { ref: ref36, ...props52, children: api.index + 1 }) });
  }
);
var StepsTitle = withContext49(
  "div",
  "title"
);
var StepsDescription = withContext49("div", "description");
var StepsSeparator2 = withContext49(
  steps_exports.Separator,
  "separator",
  { forwardAsChild: true }
);
var StepsStatus = (props52) => {
  return (0, import_jsx_runtime261.jsx)(steps_exports.ItemContext, { children: (api) => {
    if (api.current) return (0, import_jsx_runtime261.jsx)(import_jsx_runtime261.Fragment, { children: props52.current ?? props52.incomplete });
    if (api.completed) return (0, import_jsx_runtime261.jsx)(import_jsx_runtime261.Fragment, { children: props52.complete });
    return (0, import_jsx_runtime261.jsx)(import_jsx_runtime261.Fragment, { children: props52.incomplete ?? props52.current });
  } });
};
var StepsIndicator2 = withContext49(
  steps_exports.Indicator,
  "indicator",
  {
    forwardAsChild: true,
    defaultProps: {
      children: (0, import_jsx_runtime261.jsx)(StepsStatus, { complete: (0, import_jsx_runtime261.jsx)(CheckIcon, {}), incomplete: (0, import_jsx_runtime261.jsx)(StepsNumber, {}) })
    }
  }
);
var StepsNextTrigger2 = withContext49(steps_exports.NextTrigger, "nextTrigger", { forwardAsChild: true });
var StepsPrevTrigger2 = withContext49(steps_exports.PrevTrigger, "prevTrigger", { forwardAsChild: true });
var StepsContext2 = steps_exports.Context;
var StepsItemContext2 = steps_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/steps/namespace.js
var namespace_exports38 = {};
__export(namespace_exports38, {
  CompletedContent: () => StepsCompletedContent2,
  Content: () => StepsContent2,
  Context: () => StepsContext2,
  Description: () => StepsDescription,
  Indicator: () => StepsIndicator2,
  Item: () => StepsItem2,
  ItemContext: () => StepsItemContext2,
  List: () => StepsList2,
  NextTrigger: () => StepsNextTrigger2,
  Number: () => StepsNumber,
  PrevTrigger: () => StepsPrevTrigger2,
  PropsProvider: () => StepsPropsProvider,
  Root: () => StepsRoot2,
  RootProvider: () => StepsRootProvider2,
  Separator: () => StepsSeparator2,
  Status: () => StepsStatus,
  Title: () => StepsTitle,
  Trigger: () => StepsTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/switch/switch.js
var import_jsx_runtime268 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/switch/use-switch-context.js
var [SwitchProvider, useSwitchContext] = createContext({
  name: "SwitchContext",
  hookName: "useSwitchContext",
  providerName: "<SwitchProvider />"
});

// node_modules/@ark-ui/react/dist/components/switch/switch-context.js
var SwitchContext = (props52) => props52.children(useSwitchContext());

// node_modules/@ark-ui/react/dist/components/switch/switch-control.js
var import_jsx_runtime262 = __toESM(require_jsx_runtime(), 1);
var import_react517 = __toESM(require_react(), 1);
var SwitchControl = (0, import_react517.forwardRef)((props52, ref36) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps3(switchContext.getControlProps(), props52);
  return (0, import_jsx_runtime262.jsx)(ark.span, { ...mergedProps, ref: ref36 });
});
SwitchControl.displayName = "SwitchControl";

// node_modules/@ark-ui/react/dist/components/switch/switch-hidden-input.js
var import_jsx_runtime263 = __toESM(require_jsx_runtime(), 1);
var import_react519 = __toESM(require_react(), 1);
var SwitchHiddenInput = (0, import_react519.forwardRef)(
  (props52, ref36) => {
    const switchContext = useSwitchContext();
    const mergedProps = mergeProps3(switchContext.getHiddenInputProps(), props52);
    const field = useFieldContext();
    return (0, import_jsx_runtime263.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref36 });
  }
);
SwitchHiddenInput.displayName = "SwitchHiddenInput";

// node_modules/@ark-ui/react/dist/components/switch/switch-label.js
var import_jsx_runtime264 = __toESM(require_jsx_runtime(), 1);
var import_react521 = __toESM(require_react(), 1);
var SwitchLabel = (0, import_react521.forwardRef)((props52, ref36) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps3(switchContext.getLabelProps(), props52);
  return (0, import_jsx_runtime264.jsx)(ark.span, { ...mergedProps, ref: ref36 });
});
SwitchLabel.displayName = "SwitchLabel";

// node_modules/@ark-ui/react/dist/components/switch/switch-root.js
var import_jsx_runtime265 = __toESM(require_jsx_runtime(), 1);
var import_react525 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/node_modules/@zag-js/switch/dist/index.mjs
var anatomy64 = createAnatomy2("switch").parts("root", "label", "control", "thumb");
var parts60 = anatomy64.build();
var dom57 = createScope({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `switch:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.label) ?? `switch:${ctx.id}:label`;
  },
  getThumbId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.thumb) ?? `switch:${ctx.id}:thumb`;
  },
  getControlId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.control) ?? `switch:${ctx.id}:control`;
  },
  getHiddenInputId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.hiddenInput) ?? `switch:${ctx.id}:input`;
  },
  getRootEl: (ctx) => dom57.getById(ctx, dom57.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom57.getById(ctx, dom57.getHiddenInputId(ctx))
});
function connect22(state2, send, normalize2) {
  const disabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  const checked = state2.context.checked;
  const focused = !disabled && state2.context.focused;
  const focusVisible = !disabled && state2.context.focusVisible;
  const dataAttrs = {
    "data-active": dataAttr(state2.context.active),
    "data-focus": dataAttr(focused),
    "data-focus-visible": dataAttr(focusVisible),
    "data-readonly": dataAttr(readOnly),
    "data-hover": dataAttr(state2.context.hovered),
    "data-disabled": dataAttr(disabled),
    "data-state": state2.context.checked ? "checked" : "unchecked",
    "data-invalid": dataAttr(state2.context.invalid)
  };
  return {
    checked,
    disabled,
    focused,
    setChecked(checked2) {
      send({ type: "CHECKED.SET", checked: checked2, isTrusted: false });
    },
    toggleChecked() {
      send({ type: "CHECKED.TOGGLE", checked, isTrusted: false });
    },
    getRootProps() {
      return normalize2.label({
        ...parts60.root.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom57.getRootId(state2.context),
        htmlFor: dom57.getHiddenInputId(state2.context),
        onPointerMove() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: true } });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: false } });
        },
        onClick(event) {
          if (disabled) return;
          const target = getEventTarget(event);
          if (target === dom57.getHiddenInputEl(state2.context)) {
            event.stopPropagation();
          }
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        ...parts60.label.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom57.getLabelId(state2.context)
      });
    },
    getThumbProps() {
      return normalize2.element({
        ...parts60.thumb.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom57.getThumbId(state2.context),
        "aria-hidden": true
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts60.control.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom57.getControlId(state2.context),
        "aria-hidden": true
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        id: dom57.getHiddenInputId(state2.context),
        type: "checkbox",
        required: state2.context.required,
        defaultChecked: checked,
        disabled,
        "aria-labelledby": dom57.getLabelId(state2.context),
        "aria-invalid": state2.context.invalid,
        name: state2.context.name,
        form: state2.context.form,
        value: state2.context.value,
        style: visuallyHiddenStyle,
        onFocus() {
          const focusVisible2 = isFocusVisible();
          send({ type: "CONTEXT.SET", context: { focused: true, focusVisible: focusVisible2 } });
        },
        onBlur() {
          send({ type: "CONTEXT.SET", context: { focused: false, focusVisible: false } });
        },
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          const checked2 = event.currentTarget.checked;
          send({ type: "CHECKED.SET", checked: checked2, isTrusted: true });
        }
      });
    }
  };
}
var { not: not43 } = guards20;
function machine22(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "switch",
      initial: "ready",
      context: {
        checked: false,
        label: "switch",
        value: "on",
        disabled: false,
        ...ctx,
        fieldsetDisabled: false,
        focusVisible: false
      },
      computed: {
        isDisabled: (ctx2) => ctx2.disabled || ctx2.fieldsetDisabled
      },
      watch: {
        disabled: "removeFocusIfNeeded",
        checked: "syncInputElement"
      },
      activities: ["trackFormControlState", "trackPressEvent", "trackFocusVisible"],
      on: {
        "CHECKED.TOGGLE": [
          {
            guard: not43("isTrusted"),
            actions: ["toggleChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["toggleChecked"]
          }
        ],
        "CHECKED.SET": [
          {
            guard: not43("isTrusted"),
            actions: ["setChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["setChecked"]
          }
        ],
        "CONTEXT.SET": {
          actions: ["setContext"]
        }
      },
      states: {
        ready: {}
      }
    },
    {
      guards: {
        isTrusted: (_ctx, evt) => !!evt.isTrusted
      },
      activities: {
        trackPressEvent(ctx2) {
          if (ctx2.isDisabled) return;
          return trackPress2({
            pointerNode: dom57.getRootEl(ctx2),
            keyboardNode: dom57.getHiddenInputEl(ctx2),
            isValidKey: (event) => event.key === " ",
            onPress: () => ctx2.active = false,
            onPressStart: () => ctx2.active = true,
            onPressEnd: () => ctx2.active = false
          });
        },
        trackFocusVisible(ctx2) {
          if (ctx2.isDisabled) return;
          return trackFocusVisible2({ root: dom57.getRootNode(ctx2) });
        },
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl2(dom57.getHiddenInputEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "CHECKED.SET", checked: !!initialContext.checked, src: "form-reset" });
            }
          });
        }
      },
      actions: {
        setContext(ctx2, evt) {
          Object.assign(ctx2, evt.context);
        },
        syncInputElement(ctx2) {
          const inputEl = dom57.getHiddenInputEl(ctx2);
          if (!inputEl) return;
          inputEl.checked = !!ctx2.checked;
        },
        removeFocusIfNeeded(ctx2) {
          if (ctx2.disabled && ctx2.focused) {
            ctx2.focused = false;
          }
        },
        setChecked(ctx2, evt) {
          set16.checked(ctx2, evt.checked);
        },
        toggleChecked(ctx2, _evt) {
          set16.checked(ctx2, !ctx2.checked);
        },
        dispatchChangeEvent(ctx2) {
          const inputEl = dom57.getHiddenInputEl(ctx2);
          dispatchInputCheckedEvent2(inputEl, { checked: ctx2.checked });
        }
      }
    }
  );
}
var invoke11 = {
  change: (ctx) => {
    var _a7;
    (_a7 = ctx.onCheckedChange) == null ? void 0 : _a7.call(ctx, { checked: ctx.checked });
  }
};
var set16 = {
  checked: (ctx, checked) => {
    if (isEqual3(ctx.checked, checked)) return;
    ctx.checked = checked;
    invoke11.change(ctx);
  }
};
var props49 = createProps30()([
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "label",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
var splitProps50 = createSplitProps2(props49);

// node_modules/@ark-ui/react/dist/components/switch/use-switch.js
var import_react523 = __toESM(require_react(), 1);
var useSwitch = (props52 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react523.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    invalid: field == null ? void 0 : field.invalid,
    required: field == null ? void 0 : field.required,
    getRootNode: getRootNode2,
    checked: props52.defaultChecked,
    ...props52
  };
  const context = {
    ...initialContext,
    checked: props52.checked,
    onCheckedChange: useEvent(props52.onCheckedChange, { sync: true })
  };
  const [state2, send] = useMachine(machine22(initialContext), { context });
  return connect22(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/switch/switch-root.js
var SwitchRoot = (0, import_react525.forwardRef)((props52, ref36) => {
  const [switchProps, localProps] = createSplitProps3()(props52, [
    "checked",
    "defaultChecked",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "label",
    "name",
    "onCheckedChange",
    "readOnly",
    "required",
    "value"
  ]);
  const switchContext = useSwitch(switchProps);
  const mergedProps = mergeProps3(switchContext.getRootProps(), localProps);
  return (0, import_jsx_runtime265.jsx)(SwitchProvider, { value: switchContext, children: (0, import_jsx_runtime265.jsx)(ark.label, { ...mergedProps, ref: ref36 }) });
});
SwitchRoot.displayName = "SwitchRoot";

// node_modules/@ark-ui/react/dist/components/switch/switch-root-provider.js
var import_jsx_runtime266 = __toESM(require_jsx_runtime(), 1);
var import_react527 = __toESM(require_react(), 1);
var SwitchRootProvider = (0, import_react527.forwardRef)(
  (props52, ref36) => {
    const [{ value: api }, localProps] = createSplitProps3()(props52, ["value"]);
    const mergedProps = mergeProps3(api.getRootProps(), localProps);
    return (0, import_jsx_runtime266.jsx)(SwitchProvider, { value: api, children: (0, import_jsx_runtime266.jsx)(ark.label, { ...mergedProps, ref: ref36 }) });
  }
);
SwitchRootProvider.displayName = "SwitchRootProvider";

// node_modules/@ark-ui/react/dist/components/switch/switch-thumb.js
var import_jsx_runtime267 = __toESM(require_jsx_runtime(), 1);
var import_react529 = __toESM(require_react(), 1);
var SwitchThumb = (0, import_react529.forwardRef)((props52, ref36) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps3(switchContext.getThumbProps(), props52);
  return (0, import_jsx_runtime267.jsx)(ark.span, { ...mergedProps, ref: ref36 });
});
SwitchThumb.displayName = "SwitchThumb";

// node_modules/@ark-ui/react/dist/components/switch/switch.js
var switch_exports = {};
__export(switch_exports, {
  Context: () => SwitchContext,
  Control: () => SwitchControl,
  HiddenInput: () => SwitchHiddenInput,
  Label: () => SwitchLabel,
  Root: () => SwitchRoot,
  RootProvider: () => SwitchRootProvider,
  Thumb: () => SwitchThumb
});

// node_modules/@chakra-ui/react/dist/esm/components/switch/switch.js
var import_react530 = __toESM(require_react(), 1);
var {
  withProvider: withProvider33,
  withContext: withContext50,
  useStyles: useSwitchStyles,
  PropsProvider: PropsProvider49
} = createSlotRecipeContext({ key: "switch" });
var SwitchRootProvider2 = withProvider33(switch_exports.RootProvider, "root", { forwardAsChild: true });
var SwitchRoot2 = withProvider33(
  switch_exports.Root,
  "root",
  { forwardAsChild: true }
);
var SwitchPropsProvider = PropsProvider49;
var SwitchLabel2 = withContext50(
  switch_exports.Label,
  "label",
  { forwardAsChild: true }
);
var SwitchControl2 = withContext50(
  switch_exports.Control,
  "control",
  { forwardAsChild: true }
);
var SwitchThumb2 = withContext50(
  switch_exports.Thumb,
  "thumb",
  { forwardAsChild: true }
);
var SwitchIndicator = (0, import_react530.forwardRef)(function SwitchIndicator2(props52, ref36) {
  const api = useSwitchContext();
  const styles = useSwitchStyles();
  const { fallback: fallback5, children, ...rest } = props52;
  return (0, import_jsx_runtime268.jsx)(
    chakra.span,
    {
      ref: ref36,
      "data-checked": dataAttr31(api.checked),
      ...rest,
      css: [styles.indicator, props52.css],
      children: api.checked ? children : fallback5
    }
  );
});
var SwitchThumbIndicator = (0, import_react530.forwardRef)(function SwitchThumbIndicator2(props52, ref36) {
  const api = useSwitchContext();
  const { fallback: fallback5, children, ...rest } = props52;
  return (0, import_jsx_runtime268.jsx)(chakra.span, { ref: ref36, "data-checked": dataAttr31(api.checked), ...rest, children: api.checked ? children : fallback5 });
});
var SwitchContext2 = switch_exports.Context;
var SwitchHiddenInput2 = switch_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/switch/namespace.js
var namespace_exports39 = {};
__export(namespace_exports39, {
  Context: () => SwitchContext2,
  Control: () => SwitchControl2,
  HiddenInput: () => SwitchHiddenInput2,
  Indicator: () => SwitchIndicator,
  Label: () => SwitchLabel2,
  PropsProvider: () => SwitchPropsProvider,
  Root: () => SwitchRoot2,
  RootProvider: () => SwitchRootProvider2,
  Thumb: () => SwitchThumb2,
  ThumbIndicator: () => SwitchThumbIndicator
});

// node_modules/@chakra-ui/react/dist/esm/components/table/table.js
var import_jsx_runtime269 = __toESM(require_jsx_runtime(), 1);
var import_react531 = __toESM(require_react(), 1);
var {
  StylesProvider,
  ClassNamesProvider,
  useRecipeResult,
  withContext: withContext51,
  useStyles: useTableStyles,
  PropsProvider: PropsProvider50
} = createSlotRecipeContext({ key: "table" });
var TableRoot = (0, import_react531.forwardRef)(
  function TableRoot2({ native, ...props52 }, ref36) {
    const { styles, props: rootProps, classNames } = useRecipeResult(props52);
    const rootCss = (0, import_react531.useMemo)(() => {
      if (!native) return styles.root;
      return {
        ...styles.root,
        "& thead": styles.header,
        "& tbody": styles.body,
        "& tfoot": styles.footer,
        "& thead th": styles.columnHeader,
        "& tr": styles.row,
        "& td": styles.cell,
        "& caption": styles.caption
      };
    }, [styles, native]);
    return (0, import_jsx_runtime269.jsx)(ClassNamesProvider, { value: classNames, children: (0, import_jsx_runtime269.jsx)(StylesProvider, { value: styles, children: (0, import_jsx_runtime269.jsx)(
      chakra.table,
      {
        ref: ref36,
        ...rootProps,
        css: [rootCss, props52.css],
        className: cx(classNames == null ? void 0 : classNames["root"], props52.className)
      }
    ) }) });
  }
);
var TableRootPropsProvider = PropsProvider50;
var TableRow = withContext51(
  "tr",
  "row"
);
var TableScrollArea = chakra("div", {
  base: {
    display: "block",
    whiteSpace: "nowrap",
    WebkitOverflowScrolling: "touch",
    overflow: "auto",
    maxWidth: "100%"
  }
});
var TableHeader = withContext51("thead", "header");
var TableFooter = withContext51("tfoot", "footer");
var TableColumnHeader = withContext51("th", "columnHeader");
var TableCell = withContext51(
  "td",
  "cell"
);
var TableCaption = withContext51("caption", "caption", {
  defaultProps: {
    captionSide: "bottom"
  }
});
var TableBody = withContext51(
  "tbody",
  "body"
);
var TableColumnGroup = withContext51("colgroup");
var TableColumn = withContext51(
  "col"
);

// node_modules/@chakra-ui/react/dist/esm/components/table/namespace.js
var namespace_exports40 = {};
__export(namespace_exports40, {
  Body: () => TableBody,
  Caption: () => TableCaption,
  Cell: () => TableCell,
  Column: () => TableColumn,
  ColumnGroup: () => TableColumnGroup,
  ColumnHeader: () => TableColumnHeader,
  Footer: () => TableFooter,
  Header: () => TableHeader,
  Root: () => TableRoot,
  RootPropsProvider: () => TableRootPropsProvider,
  Row: () => TableRow,
  ScrollArea: () => TableScrollArea
});

// node_modules/@ark-ui/react/dist/components/tabs/tab-content.js
var import_jsx_runtime270 = __toESM(require_jsx_runtime(), 1);
var import_react533 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tabs/use-tabs-context.js
var [TabsProvider, useTabsContext] = createContext({
  name: "TabsContext",
  hookName: "useTabsContext",
  providerName: "<TabsProvider />"
});

// node_modules/@ark-ui/react/dist/components/tabs/tab-content.js
var TabContent = (0, import_react533.forwardRef)((props52, ref36) => {
  const [contentProps3, localProps] = createSplitProps3()(props52, ["value"]);
  const tabs = useTabsContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const presence = usePresence({
    ...renderStrategyProps,
    present: tabs.value === props52.value,
    immediate: true
  });
  const mergedProps = mergeProps3(
    tabs.getContentProps(contentProps3),
    presence.getPresenceProps(),
    localProps
  );
  return (0, import_jsx_runtime270.jsx)(PresenceProvider, { value: presence, children: presence.unmounted ? null : (0, import_jsx_runtime270.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref36) }) });
});
TabContent.displayName = "TabContent";

// node_modules/@ark-ui/react/dist/components/tabs/tab-indicator.js
var import_jsx_runtime271 = __toESM(require_jsx_runtime(), 1);
var import_react535 = __toESM(require_react(), 1);
var TabIndicator = (0, import_react535.forwardRef)((props52, ref36) => {
  const tabs = useTabsContext();
  const mergedProps = mergeProps3(tabs.getIndicatorProps(), props52);
  return (0, import_jsx_runtime271.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
TabIndicator.displayName = "TabIndicator";

// node_modules/@ark-ui/react/dist/components/tabs/tab-list.js
var import_jsx_runtime272 = __toESM(require_jsx_runtime(), 1);
var import_react537 = __toESM(require_react(), 1);
var TabList = (0, import_react537.forwardRef)((props52, ref36) => {
  const tabs = useTabsContext();
  const mergedProps = mergeProps3(tabs.getListProps(), props52);
  return (0, import_jsx_runtime272.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
TabList.displayName = "TabList";

// node_modules/@ark-ui/react/dist/components/tabs/tab-trigger.js
var import_jsx_runtime273 = __toESM(require_jsx_runtime(), 1);
var import_react539 = __toESM(require_react(), 1);
var TabTrigger = (0, import_react539.forwardRef)((props52, ref36) => {
  const [tabProps, localProps] = createSplitProps3()(props52, ["disabled", "value"]);
  const tabs = useTabsContext();
  const mergedProps = mergeProps3(tabs.getTriggerProps(tabProps), localProps);
  return (0, import_jsx_runtime273.jsx)(ark.button, { ...mergedProps, ref: ref36 });
});
TabTrigger.displayName = "TabTrigger";

// node_modules/@ark-ui/react/dist/components/tabs/tabs-context.js
var TabsContext = (props52) => props52.children(useTabsContext());

// node_modules/@ark-ui/react/dist/components/tabs/tabs-root.js
var import_jsx_runtime274 = __toESM(require_jsx_runtime(), 1);
var import_react543 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/node_modules/@zag-js/tabs/dist/index.mjs
var anatomy65 = createAnatomy2("tabs").parts("root", "list", "trigger", "content", "indicator");
var parts61 = anatomy65.build();
var dom58 = createScope({
  getRootId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.root) ?? `tabs:${ctx.id}`;
  },
  getListId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.list) ?? `tabs:${ctx.id}:list`;
  },
  getContentId: (ctx, id) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `tabs:${ctx.id}:content-${id}`;
  },
  getTriggerId: (ctx, id) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `tabs:${ctx.id}:trigger-${id}`;
  },
  getIndicatorId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.indicator) ?? `tabs:${ctx.id}:indicator`;
  },
  getListEl: (ctx) => dom58.getById(ctx, dom58.getListId(ctx)),
  getContentEl: (ctx, id) => dom58.getById(ctx, dom58.getContentId(ctx, id)),
  getTriggerEl: (ctx, id) => dom58.getById(ctx, dom58.getTriggerId(ctx, id)),
  getIndicatorEl: (ctx) => dom58.getById(ctx, dom58.getIndicatorId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom58.getListId(ctx));
    const selector = `[role=tab][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom58.getListEl(ctx), selector);
  },
  getFirstTriggerEl: (ctx) => first2(dom58.getElements(ctx)),
  getLastTriggerEl: (ctx) => last2(dom58.getElements(ctx)),
  getNextTriggerEl: (ctx, id) => nextById(dom58.getElements(ctx), dom58.getTriggerId(ctx, id), ctx.loopFocus),
  getPrevTriggerEl: (ctx, id) => prevById(dom58.getElements(ctx), dom58.getTriggerId(ctx, id), ctx.loopFocus),
  getSelectedContentEl: (ctx) => {
    if (!ctx.value) return;
    return dom58.getContentEl(ctx, ctx.value);
  },
  getSelectedTriggerEl: (ctx) => {
    if (!ctx.value) return;
    return dom58.getTriggerEl(ctx, ctx.value);
  },
  getOffsetRect: (el) => {
    return {
      left: (el == null ? void 0 : el.offsetLeft) ?? 0,
      top: (el == null ? void 0 : el.offsetTop) ?? 0,
      width: (el == null ? void 0 : el.offsetWidth) ?? 0,
      height: (el == null ? void 0 : el.offsetHeight) ?? 0
    };
  },
  getRectById: (ctx, id) => {
    const tab = itemById(dom58.getElements(ctx), dom58.getTriggerId(ctx, id));
    return dom58.resolveRect(dom58.getOffsetRect(tab));
  },
  resolveRect: (rect) => ({
    width: `${rect.width}px`,
    height: `${rect.height}px`,
    left: `${rect.left}px`,
    top: `${rect.top}px`
  })
});
function connect23(state2, send, normalize2) {
  const translations = state2.context.translations;
  const focused = state2.matches("focused");
  const isVertical = state2.context.orientation === "vertical";
  const isHorizontal = state2.context.orientation === "horizontal";
  const composite = state2.context.composite;
  const indicator = state2.context.indicatorState;
  function getTriggerState(props210) {
    return {
      selected: state2.context.value === props210.value,
      focused: state2.context.focusedValue === props210.value,
      disabled: !!props210.disabled
    };
  }
  return {
    value: state2.context.value,
    focusedValue: state2.context.focusedValue,
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    clearValue() {
      send({ type: "CLEAR_VALUE" });
    },
    setIndicatorRect(value) {
      const id = dom58.getTriggerId(state2.context, value);
      send({ type: "SET_INDICATOR_RECT", id });
    },
    syncTabIndex() {
      send("SYNC_TAB_INDEX");
    },
    selectNext(fromValue) {
      send({ type: "TAB_FOCUS", value: fromValue, src: "selectNext" });
      send({ type: "ARROW_NEXT", src: "selectNext" });
    },
    selectPrev(fromValue) {
      send({ type: "TAB_FOCUS", value: fromValue, src: "selectPrev" });
      send({ type: "ARROW_PREV", src: "selectPrev" });
    },
    focus() {
      var _a7;
      (_a7 = dom58.getSelectedTriggerEl(state2.context)) == null ? void 0 : _a7.focus();
    },
    getRootProps() {
      return normalize2.element({
        ...parts61.root.attrs,
        id: dom58.getRootId(state2.context),
        "data-orientation": state2.context.orientation,
        "data-focus": dataAttr(focused),
        dir: state2.context.dir
      });
    },
    getListProps() {
      return normalize2.element({
        ...parts61.list.attrs,
        id: dom58.getListId(state2.context),
        role: "tablist",
        dir: state2.context.dir,
        "data-focus": dataAttr(focused),
        "aria-orientation": state2.context.orientation,
        "data-orientation": state2.context.orientation,
        "aria-label": translations == null ? void 0 : translations.listLabel,
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          if (isComposingEvent(event)) return;
          const keyMap2 = {
            ArrowDown() {
              if (isHorizontal) return;
              send({ type: "ARROW_NEXT", key: "ArrowDown" });
            },
            ArrowUp() {
              if (isHorizontal) return;
              send({ type: "ARROW_PREV", key: "ArrowUp" });
            },
            ArrowLeft() {
              if (isVertical) return;
              send({ type: "ARROW_PREV", key: "ArrowLeft" });
            },
            ArrowRight() {
              if (isVertical) return;
              send({ type: "ARROW_NEXT", key: "ArrowRight" });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            },
            Enter() {
              send({ type: "ENTER" });
            }
          };
          let key = getEventKey2(event, state2.context);
          const exec21 = keyMap2[key];
          if (exec21) {
            event.preventDefault();
            exec21(event);
          }
        }
      });
    },
    getTriggerState,
    getTriggerProps(props210) {
      const { value, disabled } = props210;
      const triggerState = getTriggerState(props210);
      return normalize2.button({
        ...parts61.trigger.attrs,
        role: "tab",
        type: "button",
        disabled,
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        "data-disabled": dataAttr(disabled),
        "aria-disabled": disabled,
        "data-value": value,
        "aria-selected": triggerState.selected,
        "data-selected": dataAttr(triggerState.selected),
        "data-focus": dataAttr(triggerState.focused),
        "aria-controls": triggerState.selected ? dom58.getContentId(state2.context, value) : void 0,
        "data-ownedby": dom58.getListId(state2.context),
        "data-ssr": dataAttr(state2.context.ssr),
        id: dom58.getTriggerId(state2.context, value),
        tabIndex: triggerState.selected && composite ? 0 : -1,
        onFocus() {
          send({ type: "TAB_FOCUS", value });
        },
        onBlur(event) {
          const target = event.relatedTarget;
          if ((target == null ? void 0 : target.getAttribute("role")) !== "tab") {
            send({ type: "TAB_BLUR" });
          }
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (isSafari()) {
            event.currentTarget.focus();
          }
          send({ type: "TAB_CLICK", value });
        }
      });
    },
    getContentProps(props210) {
      const { value } = props210;
      const selected = state2.context.value === value;
      return normalize2.element({
        ...parts61.content.attrs,
        dir: state2.context.dir,
        id: dom58.getContentId(state2.context, value),
        tabIndex: composite ? 0 : -1,
        "aria-labelledby": dom58.getTriggerId(state2.context, value),
        role: "tabpanel",
        "data-ownedby": dom58.getListId(state2.context),
        "data-selected": dataAttr(selected),
        "data-orientation": state2.context.orientation,
        hidden: !selected
      });
    },
    getIndicatorProps() {
      var _a7, _b6, _c5, _d5;
      return normalize2.element({
        id: dom58.getIndicatorId(state2.context),
        ...parts61.indicator.attrs,
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        style: {
          "--transition-property": "left, right, top, bottom, width, height",
          "--left": (_a7 = indicator.rect) == null ? void 0 : _a7.left,
          "--top": (_b6 = indicator.rect) == null ? void 0 : _b6.top,
          "--width": (_c5 = indicator.rect) == null ? void 0 : _c5.width,
          "--height": (_d5 = indicator.rect) == null ? void 0 : _d5.height,
          position: "absolute",
          willChange: "var(--transition-property)",
          transitionProperty: "var(--transition-property)",
          transitionDuration: indicator.transition ? "var(--transition-duration, 150ms)" : "0ms",
          transitionTimingFunction: "var(--transition-timing-function)",
          [isHorizontal ? "left" : "top"]: isHorizontal ? "var(--left)" : "var(--top)"
        }
      });
    }
  };
}
var { not: not44 } = guards20;
function machine23(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      initial: "idle",
      context: {
        dir: "ltr",
        orientation: "horizontal",
        activationMode: "automatic",
        value: null,
        loopFocus: true,
        composite: true,
        ...ctx,
        focusedValue: ctx.value ?? null,
        ssr: true,
        indicatorState: {
          rendered: false,
          transition: false,
          rect: { left: "0px", top: "0px", width: "0px", height: "0px" }
        }
      },
      watch: {
        value: ["allowIndicatorTransition", "syncIndicatorRect", "syncTabIndex", "clickIfLink"],
        dir: ["syncIndicatorRect"],
        orientation: ["syncIndicatorRect"]
      },
      on: {
        SET_VALUE: {
          actions: "setValue"
        },
        CLEAR_VALUE: {
          actions: "clearValue"
        },
        SET_INDICATOR_RECT: {
          actions: "setIndicatorRect"
        },
        SYNC_TAB_INDEX: {
          actions: "syncTabIndex"
        }
      },
      created: ["syncFocusedValue"],
      entry: ["checkRenderedElements", "syncIndicatorRect", "syncTabIndex", "syncSsr"],
      exit: ["cleanupObserver"],
      states: {
        idle: {
          on: {
            TAB_FOCUS: {
              target: "focused",
              actions: "setFocusedValue"
            },
            TAB_CLICK: {
              target: "focused",
              actions: ["setFocusedValue", "setValue"]
            }
          }
        },
        focused: {
          on: {
            TAB_CLICK: {
              target: "focused",
              actions: ["setFocusedValue", "setValue"]
            },
            ARROW_PREV: [
              {
                guard: "selectOnFocus",
                actions: ["focusPrevTab", "selectFocusedTab"]
              },
              {
                actions: "focusPrevTab"
              }
            ],
            ARROW_NEXT: [
              {
                guard: "selectOnFocus",
                actions: ["focusNextTab", "selectFocusedTab"]
              },
              {
                actions: "focusNextTab"
              }
            ],
            HOME: [
              {
                guard: "selectOnFocus",
                actions: ["focusFirstTab", "selectFocusedTab"]
              },
              {
                actions: "focusFirstTab"
              }
            ],
            END: [
              {
                guard: "selectOnFocus",
                actions: ["focusLastTab", "selectFocusedTab"]
              },
              {
                actions: "focusLastTab"
              }
            ],
            ENTER: {
              guard: not44("selectOnFocus"),
              actions: "selectFocusedTab"
            },
            TAB_FOCUS: {
              actions: ["setFocusedValue"]
            },
            TAB_BLUR: {
              target: "idle",
              actions: "clearFocusedValue"
            }
          }
        }
      }
    },
    {
      guards: {
        selectOnFocus: (ctx2) => ctx2.activationMode === "automatic"
      },
      actions: {
        syncFocusedValue(ctx2) {
          if (ctx2.value != null && ctx2.focusedValue == null) {
            ctx2.focusedValue = ctx2.value;
          }
        },
        selectFocusedTab(ctx2) {
          raf(() => {
            const nullable = ctx2.deselectable && ctx2.value === ctx2.focusedValue;
            const value = nullable ? null : ctx2.focusedValue;
            set17.value(ctx2, value);
          });
        },
        setFocusedValue(ctx2, evt) {
          if (evt.value == null) return;
          set17.focusedValue(ctx2, evt.value);
        },
        clearFocusedValue(ctx2) {
          set17.focusedValue(ctx2, null);
        },
        setValue(ctx2, evt) {
          const nullable = ctx2.deselectable && ctx2.value === ctx2.focusedValue;
          const value = nullable ? null : evt.value;
          set17.value(ctx2, value);
        },
        clearValue(ctx2) {
          set17.value(ctx2, null);
        },
        focusFirstTab(ctx2) {
          raf(() => {
            var _a7;
            (_a7 = dom58.getFirstTriggerEl(ctx2)) == null ? void 0 : _a7.focus();
          });
        },
        focusLastTab(ctx2) {
          raf(() => {
            var _a7;
            (_a7 = dom58.getLastTriggerEl(ctx2)) == null ? void 0 : _a7.focus();
          });
        },
        focusNextTab(ctx2) {
          if (!ctx2.focusedValue) return;
          const triggerEl = dom58.getNextTriggerEl(ctx2, ctx2.focusedValue);
          raf(() => {
            if (ctx2.composite) {
              triggerEl == null ? void 0 : triggerEl.focus();
            } else if ((triggerEl == null ? void 0 : triggerEl.dataset.value) != null) {
              set17.focusedValue(ctx2, triggerEl.dataset.value);
            }
          });
        },
        focusPrevTab(ctx2) {
          if (!ctx2.focusedValue) return;
          const triggerEl = dom58.getPrevTriggerEl(ctx2, ctx2.focusedValue);
          raf(() => {
            if (ctx2.composite) {
              triggerEl == null ? void 0 : triggerEl.focus();
            } else if ((triggerEl == null ? void 0 : triggerEl.dataset.value) != null) {
              set17.focusedValue(ctx2, triggerEl.dataset.value);
            }
          });
        },
        checkRenderedElements(ctx2) {
          ctx2.indicatorState.rendered = !!dom58.getIndicatorEl(ctx2);
        },
        syncTabIndex(ctx2) {
          raf(() => {
            const contentEl = dom58.getSelectedContentEl(ctx2);
            if (!contentEl) return;
            const focusables = getFocusables(contentEl);
            if (focusables.length > 0) {
              contentEl.removeAttribute("tabindex");
            } else {
              contentEl.setAttribute("tabindex", "0");
            }
          });
        },
        cleanupObserver(ctx2) {
          var _a7;
          (_a7 = ctx2.indicatorCleanup) == null ? void 0 : _a7.call(ctx2);
        },
        allowIndicatorTransition(ctx2) {
          ctx2.indicatorState.transition = true;
        },
        setIndicatorRect(ctx2, evt) {
          const value = evt.id ?? ctx2.value;
          if (!ctx2.indicatorState.rendered || !value) return;
          const triggerEl = dom58.getTriggerEl(ctx2, value);
          if (!triggerEl) return;
          ctx2.indicatorState.rect = dom58.getRectById(ctx2, value);
          nextTick(() => {
            ctx2.indicatorState.transition = false;
          });
        },
        syncSsr(ctx2) {
          ctx2.ssr = false;
        },
        syncIndicatorRect(ctx2) {
          var _a7;
          (_a7 = ctx2.indicatorCleanup) == null ? void 0 : _a7.call(ctx2);
          const value = ctx2.value;
          if (!ctx2.indicatorState.rendered || !value) return;
          const triggerEl = dom58.getSelectedTriggerEl(ctx2);
          if (!triggerEl) return;
          ctx2.indicatorCleanup = trackElementRect2(triggerEl, {
            getRect(el) {
              return dom58.getOffsetRect(el);
            },
            onChange(rect) {
              ctx2.indicatorState.rect = dom58.resolveRect(rect);
              nextTick(() => {
                ctx2.indicatorState.transition = false;
              });
            }
          });
        },
        clickIfLink(ctx2) {
          clickIfLink2(dom58.getSelectedTriggerEl(ctx2));
        }
      }
    }
  );
}
var invoke12 = {
  change: (ctx) => {
    var _a7;
    if (ctx.value == null) return;
    (_a7 = ctx.onValueChange) == null ? void 0 : _a7.call(ctx, { value: ctx.value });
  },
  focusChange: (ctx) => {
    var _a7;
    if (ctx.focusedValue == null) return;
    (_a7 = ctx.onFocusChange) == null ? void 0 : _a7.call(ctx, { focusedValue: ctx.focusedValue });
  }
};
var set17 = {
  value: (ctx, value) => {
    if (isEqual3(value, ctx.value)) return;
    ctx.value = value;
    invoke12.change(ctx);
  },
  focusedValue: (ctx, value) => {
    if (isEqual3(value, ctx.focusedValue)) return;
    ctx.focusedValue = value;
    invoke12.focusChange(ctx);
  }
};
var props50 = createProps30()([
  "activationMode",
  "composite",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "loopFocus",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "translations",
  "deselectable",
  "value"
]);
var splitProps51 = createSplitProps2(props50);
var triggerProps2 = createProps30()(["disabled", "value"]);
var splitTriggerProps2 = createSplitProps2(triggerProps2);
var contentProps2 = createProps30()(["value"]);
var splitContentProps2 = createSplitProps2(contentProps2);

// node_modules/@ark-ui/react/dist/components/tabs/use-tabs.js
var import_react541 = __toESM(require_react(), 1);
var useTabs = (props52 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react541.useId)(),
    dir,
    getRootNode: getRootNode2,
    value: props52.defaultValue,
    ...props52
  };
  const context = {
    ...initialContext,
    value: props52.value,
    onValueChange: useEvent(props52.onValueChange, { sync: true }),
    onFocusChange: useEvent(props52.onFocusChange)
  };
  const [state2, send] = useMachine(machine23(initialContext), { context });
  return connect23(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/tabs/tabs-root.js
var TabsRoot = (0, import_react543.forwardRef)((props52, ref36) => {
  const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props52);
  const [useTabsProps, localprops] = createSplitProps3()(tabsProps, [
    "activationMode",
    "composite",
    "defaultValue",
    "deselectable",
    "id",
    "ids",
    "loopFocus",
    "onFocusChange",
    "onValueChange",
    "orientation",
    "translations",
    "value"
  ]);
  const tabs = useTabs(useTabsProps);
  const mergedProps = mergeProps3(tabs.getRootProps(), localprops);
  return (0, import_jsx_runtime274.jsx)(TabsProvider, { value: tabs, children: (0, import_jsx_runtime274.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime274.jsx)(ark.div, { ...mergedProps, ref: ref36 }) }) });
});
TabsRoot.displayName = "TabsRoot";

// node_modules/@ark-ui/react/dist/components/tabs/tabs-root-provider.js
var import_jsx_runtime275 = __toESM(require_jsx_runtime(), 1);
var import_react545 = __toESM(require_react(), 1);
var TabsRootProvider = (0, import_react545.forwardRef)((props52, ref36) => {
  const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props52);
  const [{ value: tabs }, localprops] = createSplitProps3()(tabsProps, ["value"]);
  const mergedProps = mergeProps3(tabs.getRootProps(), localprops);
  return (0, import_jsx_runtime275.jsx)(TabsProvider, { value: tabs, children: (0, import_jsx_runtime275.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime275.jsx)(ark.div, { ...mergedProps, ref: ref36 }) }) });
});
TabsRootProvider.displayName = "TabsRootProvider";

// node_modules/@ark-ui/react/dist/components/tabs/tabs.js
var tabs_exports = {};
__export(tabs_exports, {
  Content: () => TabContent,
  Context: () => TabsContext,
  Indicator: () => TabIndicator,
  List: () => TabList,
  Root: () => TabsRoot,
  RootProvider: () => TabsRootProvider,
  Trigger: () => TabTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/tabs/tabs.js
var {
  withProvider: withProvider34,
  withContext: withContext52,
  useStyles: useTabsStyles,
  PropsProvider: PropsProvider51
} = createSlotRecipeContext({ key: "tabs" });
var TabsRootProvider2 = withProvider34(tabs_exports.RootProvider, "root", { forwardAsChild: true });
var TabsRoot2 = withProvider34(
  tabs_exports.Root,
  "root",
  { forwardAsChild: true }
);
var TabsPropsProvider = PropsProvider51;
var TabsTrigger = withContext52(
  tabs_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var TabsContent = withContext52(
  tabs_exports.Content,
  "content",
  { forwardAsChild: true }
);
var TabsContentGroup = withContext52("div", "contentGroup");
var TabsList = withContext52(
  tabs_exports.List,
  "list",
  { forwardAsChild: true }
);
var TabsIndicator = withContext52(
  tabs_exports.Indicator,
  "indicator",
  { forwardAsChild: true }
);
var TabsContext2 = tabs_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/tabs/namespace.js
var namespace_exports41 = {};
__export(namespace_exports41, {
  Content: () => TabsContent,
  ContentGroup: () => TabsContentGroup,
  Context: () => TabsContext2,
  Indicator: () => TabsIndicator,
  List: () => TabsList,
  PropsProvider: () => TabsPropsProvider,
  Root: () => TabsRoot2,
  RootProvider: () => TabsRootProvider2,
  Trigger: () => TabsTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/tag/tag.js
var import_jsx_runtime276 = __toESM(require_jsx_runtime(), 1);
var {
  withProvider: withProvider35,
  withContext: withContext53,
  useStyles: useTagStyles,
  PropsProvider: PropsProvider52
} = createSlotRecipeContext({ key: "tag" });
var TagRoot = withProvider35(
  "div",
  "root"
);
var TagRootPropsProvider = PropsProvider52;
var TagLabel = withContext53(
  "span",
  "label"
);
var TagCloseTrigger = withContext53("button", "closeTrigger", { defaultProps: { children: (0, import_jsx_runtime276.jsx)(CloseIcon, {}) } });
var TagStartElement = withContext53("span", "startElement");
var TagEndElement = withContext53(
  "span",
  "endElement"
);

// node_modules/@chakra-ui/react/dist/esm/components/tag/namespace.js
var namespace_exports42 = {};
__export(namespace_exports42, {
  CloseTrigger: () => TagCloseTrigger,
  EndElement: () => TagEndElement,
  Label: () => TagLabel,
  Root: () => TagRoot,
  RootPropsProvider: () => TagRootPropsProvider,
  StartElement: () => TagStartElement
});

// node_modules/@chakra-ui/react/dist/esm/components/textarea/textarea.js
var { withContext: withContext54, PropsProvider: PropsProvider53 } = createRecipeContext({
  key: "textarea"
});
var Textarea = withContext54(
  field_exports.Textarea
);
var TextareaPropsProvider = PropsProvider53;

// node_modules/@chakra-ui/react/dist/esm/components/timeline/timeline.js
var {
  withProvider: withProvider36,
  withContext: withContext55,
  useStyles: useTimelineStyles,
  PropsProvider: PropsProvider54
} = createSlotRecipeContext({ key: "timeline" });
var TimelineRoot = withProvider36(
  "div",
  "root",
  { defaultProps: { role: "list" } }
);
var TimelineRootPropsProvider = PropsProvider54;
var TimelineItem = withContext55(
  "div",
  "item",
  { defaultProps: { role: "listitem" } }
);
var TimelineSeparator = withContext55("div", "separator");
var TimelineIndicator = withContext55("div", "indicator");
var TimelineContent = withContext55("div", "content");
var TimelineTitle = withContext55(
  "div",
  "title"
);
var TimelineDescription = withContext55("div", "description");
var TimelineConnector = withContext55("div", "connector");

// node_modules/@chakra-ui/react/dist/esm/components/timeline/namespace.js
var namespace_exports43 = {};
__export(namespace_exports43, {
  Connector: () => TimelineConnector,
  Content: () => TimelineContent,
  Description: () => TimelineDescription,
  Indicator: () => TimelineIndicator,
  Item: () => TimelineItem,
  Root: () => TimelineRoot,
  RootPropsProvider: () => TimelineRootPropsProvider,
  Separator: () => TimelineSeparator,
  Title: () => TimelineTitle
});

// node_modules/@chakra-ui/react/dist/esm/components/toast/toast.js
var import_jsx_runtime283 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/node_modules/@zag-js/toast/dist/index.mjs
var anatomy66 = createAnatomy2("toast").parts(
  "group",
  "root",
  "title",
  "description",
  "actionTrigger",
  "closeTrigger"
);
var parts62 = anatomy66.build();
var dom59 = createScope({
  getRegionId: (placement) => `toast-group:${placement}`,
  getRegionEl: (ctx, placement) => dom59.getById(ctx, `toast-group:${placement}`),
  getRootId: (ctx) => `toast:${ctx.id}`,
  getRootEl: (ctx) => dom59.getById(ctx, dom59.getRootId(ctx)),
  getTitleId: (ctx) => `toast:${ctx.id}:title`,
  getDescriptionId: (ctx) => `toast:${ctx.id}:description`,
  getCloseTriggerId: (ctx) => `toast${ctx.id}:close`
});
function getToastsByPlacement(toasts, placement) {
  return toasts.filter((toast) => toast.state.context.placement === placement);
}
var defaultTimeouts = {
  info: 5e3,
  error: 5e3,
  success: 2e3,
  loading: Infinity,
  DEFAULT: 5e3
};
function getToastDuration(duration, type) {
  return duration ?? defaultTimeouts[type] ?? defaultTimeouts.DEFAULT;
}
function getGroupPlacementStyle(ctx, placement) {
  var _a7;
  const offset4 = ctx.offsets;
  const computedOffset = typeof offset4 === "string" ? { left: offset4, right: offset4, bottom: offset4, top: offset4 } : offset4;
  const rtl = ctx.dir === "rtl";
  const computedPlacement = placement.replace("-start", rtl ? "-right" : "-left").replace("-end", rtl ? "-left" : "-right");
  const isRighty = computedPlacement.includes("right");
  const isLefty = computedPlacement.includes("left");
  const styles = {
    position: "fixed",
    pointerEvents: ctx.count > 0 ? void 0 : "none",
    display: "flex",
    flexDirection: "column",
    "--gap": `${ctx.gap}px`,
    "--first-height": `${((_a7 = ctx.heights[0]) == null ? void 0 : _a7.height) || 0}px`,
    zIndex: MAX_Z_INDEX
  };
  let alignItems = "center";
  if (isRighty) alignItems = "flex-end";
  if (isLefty) alignItems = "flex-start";
  styles.alignItems = alignItems;
  if (computedPlacement.includes("top")) {
    const offset22 = computedOffset.top;
    styles.top = `max(env(safe-area-inset-top, 0px), ${offset22})`;
  }
  if (computedPlacement.includes("bottom")) {
    const offset22 = computedOffset.bottom;
    styles.bottom = `max(env(safe-area-inset-bottom, 0px), ${offset22})`;
  }
  if (!computedPlacement.includes("left")) {
    const offset22 = computedOffset.right;
    styles.insetInlineEnd = `calc(env(safe-area-inset-right, 0px) + ${offset22})`;
  }
  if (!computedPlacement.includes("right")) {
    const offset22 = computedOffset.left;
    styles.insetInlineStart = `calc(env(safe-area-inset-left, 0px) + ${offset22})`;
  }
  return styles;
}
function getPlacementStyle(ctx, visible) {
  const [side] = ctx.placement.split("-");
  const sibling = !ctx.frontmost;
  const overlap = !ctx.stacked;
  const styles = {
    position: "absolute",
    pointerEvents: "auto",
    "--opacity": "0",
    "--remove-delay": `${ctx.removeDelay}ms`,
    "--duration": `${ctx.type === "loading" ? Number.MAX_SAFE_INTEGER : ctx.duration}ms`,
    "--initial-height": `${ctx.height}px`,
    "--offset": `${ctx.offset}px`,
    "--index": ctx.index,
    "--z-index": ctx.zIndex,
    "--lift-amount": "calc(var(--lift) * var(--gap))",
    "--y": "100%",
    "--x": "0"
  };
  const assign2 = (overrides) => Object.assign(styles, overrides);
  if (side === "top") {
    assign2({
      top: "0",
      "--sign": "-1",
      "--y": "-100%",
      "--lift": "1"
    });
  } else if (side === "bottom") {
    assign2({
      bottom: "0",
      "--sign": "1",
      "--y": "100%",
      "--lift": "-1"
    });
  }
  if (ctx.mounted) {
    assign2({
      "--y": "0",
      "--opacity": "1"
    });
    if (ctx.stacked) {
      assign2({
        "--y": "calc(var(--lift) * var(--offset))",
        "--height": "var(--initial-height)"
      });
    }
  }
  if (!visible) {
    assign2({
      "--opacity": "0",
      pointerEvents: "none"
    });
  }
  if (sibling && overlap) {
    assign2({
      "--base-scale": "var(--index) * 0.05 + 1",
      "--y": "calc(var(--lift-amount) * var(--index))",
      "--scale": "calc(-1 * var(--base-scale))",
      "--height": "var(--first-height)"
    });
    if (!visible) {
      assign2({
        "--y": "calc(var(--sign) * 40%)"
      });
    }
  }
  if (sibling && ctx.stacked && !visible) {
    assign2({
      "--y": "calc(var(--lift) * var(--offset) + var(--lift) * -100%)"
    });
  }
  if (ctx.frontmost && !visible) {
    assign2({
      "--y": "calc(var(--lift) * -100%)"
    });
  }
  return styles;
}
function getGhostBeforeStyle(ctx, visible) {
  const styles = {
    position: "absolute",
    inset: "0",
    scale: "1 2",
    pointerEvents: visible ? "none" : "auto"
  };
  const assign2 = (overrides) => Object.assign(styles, overrides);
  if (ctx.frontmost && !visible) {
    assign2({
      height: "calc(var(--initial-height) + 80%)"
    });
  }
  return styles;
}
function getGhostAfterStyle(_ctx, _visible) {
  return {
    position: "absolute",
    left: "0",
    height: "calc(var(--gap) + 2px)",
    bottom: "100%",
    width: "100%"
  };
}
function groupConnect(serviceOrState, send, normalize2) {
  function getState() {
    const result = isMachine2(serviceOrState) ? serviceOrState.getState() : serviceOrState;
    return result;
  }
  function getToastsByPlacementImpl(placement) {
    return getToastsByPlacement(getState().context.toasts, placement);
  }
  function isVisible3(id) {
    const toasts = getState().context.toasts;
    if (!toasts.length) return false;
    return !!toasts.find((toast) => toast.id == id);
  }
  function create(options) {
    const uid = `toast:${uuid3()}`;
    const id = options.id ? options.id : uid;
    if (isVisible3(id)) return id;
    send({ type: "ADD_TOAST", toast: { ...options, id } });
    return id;
  }
  function update(id, options) {
    if (!isVisible3(id)) return id;
    send({ type: "UPDATE_TOAST", id, toast: options });
    return id;
  }
  function upsert(options) {
    const { id } = options;
    const visible = id ? isVisible3(id) : false;
    if (visible && id != null) {
      return update(id, options);
    } else {
      return create(options);
    }
  }
  function dismiss(id) {
    if (id == null) {
      send("DISMISS_ALL");
    } else if (isVisible3(id)) {
      send({ type: "DISMISS_TOAST", id });
    }
  }
  return {
    getCount() {
      return getState().context.count;
    },
    getPlacements() {
      const toasts = getState().context.toasts;
      const placements2 = toasts.map((toast) => toast.state.context.placement);
      return Array.from(new Set(placements2));
    },
    getToastsByPlacement: getToastsByPlacementImpl,
    isVisible: isVisible3,
    create,
    update,
    upsert,
    dismiss,
    remove(id) {
      if (id == null) {
        send("REMOVE_ALL");
      } else if (isVisible3(id)) {
        send({ type: "REMOVE_TOAST", id });
      }
    },
    dismissByPlacement(placement) {
      const toasts = getToastsByPlacementImpl(placement);
      toasts.forEach((toast) => dismiss(toast.id));
    },
    loading(options) {
      return upsert({ ...options, type: "loading" });
    },
    success(options) {
      return upsert({ ...options, type: "success" });
    },
    error(options) {
      return upsert({ ...options, type: "error" });
    },
    promise(promise, options, shared = {}) {
      const id = upsert({ ...shared, ...options.loading, type: "loading" });
      runIfFn3(promise).then((response) => {
        const successOptions = runIfFn3(options.success, response);
        upsert({ ...shared, ...successOptions, id, type: "success" });
      }).catch((error) => {
        const errorOptions = runIfFn3(options.error, error);
        upsert({ ...shared, ...errorOptions, id, type: "error" });
      }).finally(() => {
        var _a7;
        (_a7 = options.finally) == null ? void 0 : _a7.call(options);
      });
      return id;
    },
    pause(id) {
      if (id == null) {
        send("PAUSE_ALL");
      } else if (isVisible3(id)) {
        send({ type: "PAUSE_TOAST", id });
      }
    },
    resume(id) {
      if (id == null) {
        send("RESUME_ALL");
      } else if (isVisible3(id)) {
        send({ type: "RESUME_TOAST", id });
      }
    },
    getGroupProps(options) {
      const { placement, label = "Notifications" } = options;
      const state2 = getState();
      const hotkeyLabel = state2.context.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
      const [side, align = "center"] = placement.split("-");
      return normalize2.element({
        ...parts62.group.attrs,
        dir: state2.context.dir,
        tabIndex: -1,
        "aria-label": `${placement} ${label} ${hotkeyLabel}`,
        id: dom59.getRegionId(placement),
        "data-placement": placement,
        "data-side": side,
        "data-align": align,
        "aria-live": "polite",
        role: "region",
        style: getGroupPlacementStyle(state2.context, placement),
        onMouseMove() {
          send({ type: "REGION.POINTER_ENTER", placement });
        },
        onMouseLeave() {
          send({ type: "REGION.POINTER_LEAVE", placement });
        },
        onFocus(event) {
          send({ type: "REGION.FOCUS", target: event.relatedTarget });
        },
        onBlur(event) {
          if (state2.context.isFocusWithin && !contains(event.currentTarget, event.relatedTarget)) {
            send({ type: "REGION.BLUR" });
          }
        }
      });
    },
    subscribe(fn) {
      const state2 = getState();
      return subscribe35(state2.context.toasts, () => {
        const toasts = getToastsByPlacementImpl(state2.context.placement);
        const contexts = toasts.map((toast) => toast.getState().context);
        fn(contexts);
      });
    }
  };
}
var { not: not45, and: and42, or: or27 } = guards20;
function createToastMachine(options) {
  const { type = "info", duration, id = "1", placement = "bottom", removeDelay = 200, ...restProps } = options;
  const ctx = compact4(restProps);
  const computedDuration = getToastDuration(duration, type);
  return createMachine35(
    {
      id,
      context: {
        id,
        type,
        remaining: computedDuration,
        duration: computedDuration,
        removeDelay,
        createdAt: Date.now(),
        placement,
        ...ctx,
        height: 0,
        offset: 0,
        frontmost: false,
        mounted: false,
        index: -1,
        zIndex: 0
      },
      initial: type === "loading" ? "visible:persist" : "visible",
      on: {
        UPDATE: [
          {
            guard: and42("hasTypeChanged", "isChangingToLoading"),
            target: "visible:persist",
            actions: ["setContext"]
          },
          {
            guard: or27("hasDurationChanged", "hasTypeChanged"),
            target: "visible:updating",
            actions: ["setContext"]
          },
          {
            actions: ["setContext"]
          }
        ],
        MEASURE: {
          actions: ["measureHeight"]
        }
      },
      entry: ["invokeOnVisible"],
      activities: ["trackHeight"],
      states: {
        "visible:updating": {
          tags: ["visible", "updating"],
          after: {
            0: "visible"
          }
        },
        "visible:persist": {
          tags: ["visible", "paused"],
          on: {
            RESUME: {
              guard: not45("isLoadingType"),
              target: "visible",
              actions: ["setCreatedAt"]
            },
            DISMISS: "dismissing"
          }
        },
        visible: {
          tags: ["visible"],
          after: {
            VISIBLE_DURATION: "dismissing"
          },
          on: {
            DISMISS: "dismissing",
            PAUSE: {
              target: "visible:persist",
              actions: "setRemainingDuration"
            }
          }
        },
        dismissing: {
          entry: "invokeOnDismiss",
          after: {
            REMOVE_DELAY: {
              target: "unmounted",
              actions: "notifyParentToRemove"
            }
          }
        },
        unmounted: {
          entry: "invokeOnUnmount",
          type: "final"
        }
      }
    },
    {
      activities: {
        trackHeight(ctx2, _evt, { self: self2 }) {
          let cleanup;
          raf(() => {
            const rootEl = dom59.getRootEl(ctx2);
            if (!rootEl) return;
            ctx2.mounted = true;
            const ghosts = queryAll(rootEl, "[data-ghost]");
            warn3(
              ghosts.length !== 2,
              "[toast] No ghost element found in toast. Render the `ghostBefore` and `ghostAfter` elements"
            );
            const syncHeight = () => {
              const originalHeight = rootEl.style.height;
              rootEl.style.height = "auto";
              const newHeight = rootEl.getBoundingClientRect().height;
              rootEl.style.height = originalHeight;
              ctx2.height = newHeight;
              self2.sendParent({ type: "UPDATE_HEIGHT", id: self2.id, height: newHeight, placement: ctx2.placement });
            };
            syncHeight();
            const win = dom59.getWin(ctx2);
            const observer = new win.MutationObserver(syncHeight);
            observer.observe(rootEl, { childList: true, subtree: true, characterData: true });
            cleanup = () => observer.disconnect();
          });
          return () => cleanup == null ? void 0 : cleanup();
        }
      },
      guards: {
        isChangingToLoading: (_, evt) => {
          var _a7;
          return ((_a7 = evt.toast) == null ? void 0 : _a7.type) === "loading";
        },
        isLoadingType: (ctx2) => ctx2.type === "loading",
        hasTypeChanged: (ctx2, evt) => {
          var _a7;
          return ((_a7 = evt.toast) == null ? void 0 : _a7.type) != null && evt.toast.type !== ctx2.type;
        },
        hasDurationChanged: (ctx2, evt) => {
          var _a7;
          return ((_a7 = evt.toast) == null ? void 0 : _a7.duration) != null && evt.toast.duration !== ctx2.duration;
        }
      },
      delays: {
        VISIBLE_DURATION: (ctx2) => ctx2.remaining,
        REMOVE_DELAY: (ctx2) => ctx2.removeDelay
      },
      actions: {
        measureHeight(ctx2, _evt, { self: self2 }) {
          raf(() => {
            const rootEl = dom59.getRootEl(ctx2);
            if (!rootEl) return;
            ctx2.mounted = true;
            const originalHeight = rootEl.style.height;
            rootEl.style.height = "auto";
            const newHeight = rootEl.getBoundingClientRect().height;
            rootEl.style.height = originalHeight;
            ctx2.height = newHeight;
            self2.sendParent({ type: "UPDATE_HEIGHT", id: self2.id, height: newHeight, placement: ctx2.placement });
          });
        },
        setRemainingDuration(ctx2) {
          ctx2.remaining -= Date.now() - ctx2.createdAt;
        },
        setCreatedAt(ctx2) {
          ctx2.createdAt = Date.now();
        },
        notifyParentToRemove(_ctx, _evt, { self: self2 }) {
          self2.sendParent({ type: "REMOVE_TOAST", id: self2.id });
        },
        invokeOnDismiss(ctx2) {
          var _a7;
          (_a7 = ctx2.onStatusChange) == null ? void 0 : _a7.call(ctx2, { status: "dismissing" });
        },
        invokeOnUnmount(ctx2) {
          var _a7;
          (_a7 = ctx2.onStatusChange) == null ? void 0 : _a7.call(ctx2, { status: "unmounted" });
        },
        invokeOnVisible(ctx2) {
          var _a7;
          (_a7 = ctx2.onStatusChange) == null ? void 0 : _a7.call(ctx2, { status: "visible" });
        },
        setContext(ctx2, evt) {
          var _a7, _b6;
          const duration2 = (_a7 = evt.toast) == null ? void 0 : _a7.duration;
          const type2 = ((_b6 = evt.toast) == null ? void 0 : _b6.type) ?? ctx2.type;
          const computedDuration2 = getToastDuration(duration2, type2);
          Object.assign(ctx2, {
            ...evt.toast,
            duration: computedDuration2,
            remaining: computedDuration2
          });
        }
      }
    }
  );
}
function groupMachine(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "toaster",
      initial: ctx.overlap ? "overlap" : "stack",
      context: {
        dir: "ltr",
        max: Number.MAX_SAFE_INTEGER,
        gap: 16,
        pauseOnPageIdle: false,
        hotkey: ["altKey", "KeyT"],
        offsets: "1rem",
        placement: "bottom",
        removeDelay: 200,
        ...ctx,
        toasts: [],
        lastFocusedEl: null,
        isFocusWithin: false,
        heights: []
      },
      computed: {
        count: (ctx2) => ctx2.toasts.length
      },
      activities: ["trackDocumentVisibility", "trackHotKeyPress"],
      watch: {
        toasts: ["collapsedIfEmpty", "setDismissableBranch"]
      },
      exit: ["removeToasts", "clearDismissableBranch", "clearLastFocusedEl"],
      on: {
        PAUSE_TOAST: {
          actions: ["pauseToast"]
        },
        PAUSE_ALL: {
          actions: ["pauseToasts"]
        },
        RESUME_TOAST: {
          actions: ["resumeToast"]
        },
        RESUME_ALL: {
          actions: ["resumeToasts"]
        },
        ADD_TOAST: {
          guard: "isWithinRange",
          actions: ["createToast", "syncToastIndex"]
        },
        UPDATE_TOAST: {
          actions: ["updateToast"]
        },
        DISMISS_TOAST: {
          actions: ["dismissToast"]
        },
        DISMISS_ALL: {
          actions: ["dismissToasts"]
        },
        REMOVE_TOAST: {
          actions: ["removeToast", "syncToastIndex", "syncToastOffset"]
        },
        REMOVE_ALL: {
          actions: ["removeToasts"]
        },
        UPDATE_HEIGHT: {
          actions: ["syncHeights", "syncToastOffset"]
        },
        "DOC.HOTKEY": {
          actions: ["focusRegionEl"]
        },
        "REGION.BLUR": [
          {
            guard: "isOverlapping",
            target: "overlap",
            actions: ["resumeToasts", "restoreLastFocusedEl"]
          },
          {
            actions: ["resumeToasts", "restoreLastFocusedEl"]
          }
        ]
      },
      states: {
        stack: {
          entry: ["expandToasts"],
          on: {
            "REGION.POINTER_LEAVE": [
              {
                guard: "isOverlapping",
                target: "overlap",
                actions: ["resumeToasts"]
              },
              {
                actions: ["resumeToasts"]
              }
            ],
            "REGION.OVERLAP": {
              target: "overlap"
            },
            "REGION.FOCUS": {
              actions: ["setLastFocusedEl", "pauseToasts"]
            },
            "REGION.POINTER_ENTER": {
              actions: ["pauseToasts"]
            }
          }
        },
        overlap: {
          entry: ["collapseToasts"],
          on: {
            "REGION.STACK": {
              target: "stack"
            },
            "REGION.POINTER_ENTER": {
              target: "stack",
              actions: ["pauseToasts"]
            },
            "REGION.FOCUS": {
              target: "stack",
              actions: ["setLastFocusedEl", "pauseToasts"]
            }
          }
        }
      }
    },
    {
      guards: {
        isWithinRange: (ctx2) => ctx2.toasts.length < ctx2.max,
        isOverlapping: (ctx2) => !!ctx2.overlap
      },
      activities: {
        trackHotKeyPress(ctx2, _evt, { send }) {
          const handleKeyDown = (event) => {
            const isHotkeyPressed = ctx2.hotkey.every((key) => event[key] || event.code === key);
            if (!isHotkeyPressed) return;
            send({ type: "DOC.HOTKEY" });
          };
          return addDomEvent2(document, "keydown", handleKeyDown, { capture: true });
        },
        trackDocumentVisibility(ctx2, _evt, { send }) {
          if (!ctx2.pauseOnPageIdle) return;
          const doc = dom59.getDoc(ctx2);
          return addDomEvent2(doc, "visibilitychange", () => {
            send(doc.visibilityState === "hidden" ? "PAUSE_ALL" : "RESUME_ALL");
          });
        }
      },
      actions: {
        setDismissableBranch(ctx2) {
          var _a7;
          const currentToasts = getToastsByPlacement(ctx2.toasts, ctx2.placement);
          const hasToasts = currentToasts.length > 0;
          if (!hasToasts) {
            (_a7 = ctx2._cleanup) == null ? void 0 : _a7.call(ctx2);
            return;
          }
          if (hasToasts && ctx2._cleanup) {
            return;
          }
          const groupEl = () => dom59.getRegionEl(ctx2, ctx2.placement);
          ctx2._cleanup = trackDismissableBranch2(groupEl, { defer: true });
        },
        clearDismissableBranch(ctx2) {
          var _a7;
          (_a7 = ctx2._cleanup) == null ? void 0 : _a7.call(ctx2);
        },
        focusRegionEl(ctx2) {
          queueMicrotask(() => {
            var _a7;
            (_a7 = dom59.getRegionEl(ctx2, ctx2.placement)) == null ? void 0 : _a7.focus();
          });
        },
        expandToasts(ctx2) {
          each(ctx2, (toast) => {
            toast.state.context.stacked = true;
          });
        },
        collapseToasts(ctx2) {
          each(ctx2, (toast) => {
            toast.state.context.stacked = false;
          });
        },
        collapsedIfEmpty(ctx2, _evt, { send }) {
          if (!ctx2.overlap || ctx2.toasts.length > 1) return;
          send("REGION.OVERLAP");
        },
        pauseToast(_ctx, evt, { self: self2 }) {
          self2.sendChild("PAUSE", evt.id);
        },
        pauseToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("PAUSE"));
        },
        resumeToast(_ctx, evt, { self: self2 }) {
          self2.sendChild("RESUME", evt.id);
        },
        resumeToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("RESUME"));
        },
        measureToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("MEASURE"));
        },
        createToast(ctx2, evt, { self: self2, getState }) {
          const options = {
            placement: ctx2.placement,
            duration: ctx2.duration,
            removeDelay: ctx2.removeDelay,
            ...evt.toast,
            dir: ctx2.dir,
            getRootNode: ctx2.getRootNode,
            stacked: getState().matches("stack")
          };
          const toast = createToastMachine(options);
          const actor = self2.spawn(toast);
          ctx2.toasts = [actor, ...ctx2.toasts];
        },
        updateToast(_ctx, evt, { self: self2 }) {
          self2.sendChild({ type: "UPDATE", toast: evt.toast }, evt.id);
        },
        dismissToast(_ctx, evt, { self: self2 }) {
          self2.sendChild("DISMISS", evt.id);
        },
        dismissToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("DISMISS"));
        },
        removeToast(ctx2, evt, { self: self2 }) {
          self2.stopChild(evt.id);
          ctx2.toasts = ctx2.toasts.filter((toast) => toast.id !== evt.id);
          ctx2.heights = ctx2.heights.filter((height) => height.id !== evt.id);
        },
        removeToasts(ctx2, _evt, { self: self2 }) {
          ctx2.toasts.forEach((toast) => self2.stopChild(toast.id));
          ctx2.toasts = [];
          ctx2.heights = [];
        },
        syncHeights(ctx2, evt) {
          const existing = ctx2.heights.find((height) => height.id === evt.id);
          if (existing) {
            existing.height = evt.height;
            existing.placement = evt.placement;
          } else {
            const newHeight = { id: evt.id, height: evt.height, placement: evt.placement };
            ctx2.heights = [newHeight, ...ctx2.heights];
          }
        },
        syncToastIndex(ctx2) {
          each(ctx2, (toast, index, toasts) => {
            toast.state.context.index = index;
            toast.state.context.frontmost = index === 0;
            toast.state.context.zIndex = toasts.length - index;
          });
        },
        syncToastOffset(ctx2, evt) {
          const placement = evt.placement ?? ctx2.placement;
          each({ ...ctx2, placement }, (toast) => {
            const heightIndex = Math.max(
              ctx2.heights.findIndex((height) => height.id === toast.id),
              0
            );
            const toastsHeightBefore = ctx2.heights.reduce((prev3, curr, reducerIndex) => {
              if (reducerIndex >= heightIndex) return prev3;
              return prev3 + curr.height;
            }, 0);
            toast.state.context.offset = heightIndex * ctx2.gap + toastsHeightBefore;
          });
        },
        setLastFocusedEl(ctx2, evt) {
          if (ctx2.isFocusWithin || !evt.target) return;
          ctx2.isFocusWithin = true;
          ctx2.lastFocusedEl = ref35(evt.target);
        },
        restoreLastFocusedEl(ctx2) {
          ctx2.isFocusWithin = false;
          if (!ctx2.lastFocusedEl) return;
          ctx2.lastFocusedEl.focus({ preventScroll: true });
          ctx2.lastFocusedEl = null;
        },
        clearLastFocusedEl(ctx2) {
          if (!ctx2.lastFocusedEl) return;
          ctx2.lastFocusedEl.focus({ preventScroll: true });
          ctx2.lastFocusedEl = null;
          ctx2.isFocusWithin = false;
        }
      }
    }
  );
}
function each(ctx, fn) {
  const currentToasts = getToastsByPlacement(ctx.toasts, ctx.placement);
  currentToasts.forEach(fn);
}
function connect24(state2, send, normalize2) {
  const visible = state2.hasTag("visible");
  const paused = state2.hasTag("paused");
  const placement = state2.context.placement;
  const type = state2.context.type;
  const [side, align = "center"] = placement.split("-");
  return {
    type,
    title: state2.context.title,
    description: state2.context.description,
    placement,
    visible,
    paused,
    pause() {
      send("PAUSE");
    },
    resume() {
      send("RESUME");
    },
    dismiss() {
      send("DISMISS");
    },
    getRootProps() {
      return normalize2.element({
        ...parts62.root.attrs,
        dir: state2.context.dir,
        id: dom59.getRootId(state2.context),
        "data-state": visible ? "open" : "closed",
        "data-type": type,
        "data-placement": placement,
        "data-align": align,
        "data-side": side,
        "data-mounted": dataAttr(state2.context.mounted),
        "data-paused": dataAttr(paused),
        "data-first": dataAttr(state2.context.frontmost),
        "data-sibling": dataAttr(!state2.context.frontmost),
        "data-stack": dataAttr(state2.context.stacked),
        "data-overlap": dataAttr(!state2.context.stacked),
        role: "status",
        "aria-atomic": "true",
        "aria-describedby": state2.context.description ? dom59.getDescriptionId(state2.context) : void 0,
        "aria-labelledby": state2.context.title ? dom59.getTitleId(state2.context) : void 0,
        tabIndex: 0,
        style: getPlacementStyle(state2.context, visible),
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (event.key == "Escape") {
            send("DISMISS");
            event.preventDefault();
          }
        }
      });
    },
    /* Leave a ghost div to avoid setting hover to false when transitioning out */
    getGhostBeforeProps() {
      return normalize2.element({
        "data-ghost": "before",
        style: getGhostBeforeStyle(state2.context, visible)
      });
    },
    /* Needed to avoid setting hover to false when in between toasts */
    getGhostAfterProps() {
      return normalize2.element({
        "data-ghost": "after",
        style: getGhostAfterStyle()
      });
    },
    getTitleProps() {
      return normalize2.element({
        ...parts62.title.attrs,
        id: dom59.getTitleId(state2.context)
      });
    },
    getDescriptionProps() {
      return normalize2.element({
        ...parts62.description.attrs,
        id: dom59.getDescriptionId(state2.context)
      });
    },
    getActionTriggerProps() {
      return normalize2.button({
        ...parts62.actionTrigger.attrs,
        type: "button",
        onClick(event) {
          var _a7, _b6;
          if (event.defaultPrevented) return;
          (_b6 = (_a7 = state2.context.action) == null ? void 0 : _a7.onClick) == null ? void 0 : _b6.call(_a7);
          send("DISMISS");
        }
      });
    },
    getCloseTriggerProps() {
      return normalize2.button({
        id: dom59.getCloseTriggerId(state2.context),
        ...parts62.closeTrigger.attrs,
        type: "button",
        "aria-label": "Dismiss notification",
        onClick(event) {
          if (event.defaultPrevented) return;
          send("DISMISS");
        }
      });
    }
  };
}
var group = {
  connect: groupConnect,
  machine: groupMachine
};

// node_modules/@ark-ui/react/dist/components/toast/create-toaster.js
var createToaster = (props52) => {
  const machine25 = group.machine({ id: "1", ...props52 });
  const api = group.connect(machine25, machine25.send, normalizeProps);
  return { ...api, machine: machine25 };
};

// node_modules/@ark-ui/react/dist/components/toast/toast-action-trigger.js
var import_jsx_runtime277 = __toESM(require_jsx_runtime(), 1);
var import_react548 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/toast/use-toast-context.js
var [ToastProvider, useToastContext] = createContext({
  name: "ToastContext",
  hookName: "useToastContext",
  providerName: "<ToastProvider />"
});

// node_modules/@ark-ui/react/dist/components/toast/toast-action-trigger.js
var ToastActionTrigger = (0, import_react548.forwardRef)(
  (props52, ref36) => {
    const toast = useToastContext();
    const mergedProps = mergeProps3(toast.getActionTriggerProps(), props52);
    return (0, import_jsx_runtime277.jsx)(ark.button, { ...mergedProps, ref: ref36 });
  }
);
ToastActionTrigger.displayName = "ToastActionTrigger";

// node_modules/@ark-ui/react/dist/components/toast/toast-close-trigger.js
var import_jsx_runtime278 = __toESM(require_jsx_runtime(), 1);
var import_react550 = __toESM(require_react(), 1);
var ToastCloseTrigger = (0, import_react550.forwardRef)(
  (props52, ref36) => {
    const toast = useToastContext();
    const mergedProps = mergeProps3(toast.getCloseTriggerProps(), props52);
    return (0, import_jsx_runtime278.jsx)(ark.button, { ...mergedProps, ref: ref36 });
  }
);
ToastCloseTrigger.displayName = "ToastCloseTrigger";

// node_modules/@ark-ui/react/dist/components/toast/toast-context.js
var ToastContext = (props52) => props52.children(useToastContext());

// node_modules/@ark-ui/react/dist/components/toast/toast-description.js
var import_jsx_runtime279 = __toESM(require_jsx_runtime(), 1);
var import_react552 = __toESM(require_react(), 1);
var ToastDescription = (0, import_react552.forwardRef)((props52, ref36) => {
  const toast = useToastContext();
  const mergedProps = mergeProps3(toast.getDescriptionProps(), props52);
  return (0, import_jsx_runtime279.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
ToastDescription.displayName = "ToastDescription";

// node_modules/@ark-ui/react/dist/components/toast/toast-root.js
var import_jsx_runtime280 = __toESM(require_jsx_runtime(), 1);
var import_react554 = __toESM(require_react(), 1);
var ToastRoot = (0, import_react554.forwardRef)((props52, ref36) => {
  const toast = useToastContext();
  const mergedProps = mergeProps3(toast.getRootProps(), props52);
  return (0, import_jsx_runtime280.jsxs)("div", { ...mergedProps, ref: ref36, children: [
    (0, import_jsx_runtime280.jsx)("div", { ...toast.getGhostBeforeProps() }),
    props52.children,
    (0, import_jsx_runtime280.jsx)("div", { ...toast.getGhostAfterProps() })
  ] });
});
ToastRoot.displayName = "ToastRoot";

// node_modules/@ark-ui/react/dist/components/toast/toast-title.js
var import_jsx_runtime281 = __toESM(require_jsx_runtime(), 1);
var import_react556 = __toESM(require_react(), 1);
var ToastTitle = (0, import_react556.forwardRef)((props52, ref36) => {
  const toast = useToastContext();
  const mergedProps = mergeProps3(toast.getTitleProps(), props52);
  return (0, import_jsx_runtime281.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
ToastTitle.displayName = "ToastTitle";

// node_modules/@ark-ui/react/dist/components/toast/toaster.js
var import_jsx_runtime282 = __toESM(require_jsx_runtime(), 1);
var import_react558 = __toESM(require_react(), 1);
var Toaster = (0, import_react558.forwardRef)((props52, ref36) => {
  const { toaster, children, ...rest } = props52;
  const [state2, send] = useMachine(toaster.machine);
  const placement = state2.context.placement;
  const api = group.connect(state2, send, normalizeProps);
  const toasts = api.getToastsByPlacement(placement);
  const mergedProps = mergeProps3(api.getGroupProps({ placement }), rest);
  return (0, import_jsx_runtime282.jsx)(ark.div, { ...mergedProps, ref: ref36, children: toasts.map((toast2) => (0, import_jsx_runtime282.jsx)(ToastActor, { value: toast2, children: (ctx) => children(ctx) }, toast2.id)) });
});
Toaster.displayName = "Toaster";
var ToastActor = (props52) => {
  const [state2, send] = useActor(props52.value);
  const api = connect24(state2, send, normalizeProps);
  return (0, import_jsx_runtime282.jsx)(ToastProvider, { value: api, children: props52.children(state2.context) });
};

// node_modules/@ark-ui/react/dist/components/toast/toast.js
var toast_exports = {};
__export(toast_exports, {
  ActionTrigger: () => ToastActionTrigger,
  CloseTrigger: () => ToastCloseTrigger,
  Context: () => ToastContext,
  Description: () => ToastDescription,
  Root: () => ToastRoot,
  Title: () => ToastTitle
});

// node_modules/@chakra-ui/react/dist/esm/components/toast/toast.js
var import_react559 = __toESM(require_react(), 1);
var {
  withProvider: withProvider37,
  withContext: withContext56,
  useStyles: useToastStyles
} = createSlotRecipeContext({ key: "toast" });
var Toaster2 = chakra(
  Toaster,
  {},
  { forwardAsChild: true }
);
var ToastRoot2 = withProvider37(
  toast_exports.Root,
  "root",
  { forwardAsChild: true }
);
var ToastCloseTrigger2 = withContext56(toast_exports.CloseTrigger, "closeTrigger", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime283.jsx)(CloseIcon, {})
  }
});
var ToastTitle2 = withContext56(
  toast_exports.Title,
  "title",
  { forwardAsChild: true }
);
var ToastDescription2 = withContext56(toast_exports.Description, "description", { forwardAsChild: true });
var ToastActionTrigger2 = withContext56(toast_exports.ActionTrigger, "actionTrigger", { forwardAsChild: true });
var iconMap2 = {
  warning: WarningIcon,
  success: CheckCircleIcon,
  error: WarningIcon
};
var ToastIndicator = (0, import_react559.forwardRef)(
  function ToastIndicator2(props52, ref36) {
    const api = useToastContext();
    const styles = useToastStyles();
    const Component = iconMap2[api.type];
    if (!Component) return null;
    return (0, import_jsx_runtime283.jsx)(Component, { ref: ref36, ...props52, css: [styles.indicator, props52.css] });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/toast/namespace.js
var namespace_exports44 = {};
__export(namespace_exports44, {
  ActionTrigger: () => ToastActionTrigger2,
  CloseTrigger: () => ToastCloseTrigger2,
  Description: () => ToastDescription2,
  Indicator: () => ToastIndicator,
  Root: () => ToastRoot2,
  Title: () => ToastTitle2
});

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-arrow.js
var import_jsx_runtime284 = __toESM(require_jsx_runtime(), 1);
var import_react561 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tooltip/use-tooltip-context.js
var [TooltipProvider, useTooltipContext] = createContext({
  name: "TooltipContext",
  hookName: "useTooltipContext",
  providerName: "<TooltipProvider />"
});

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-arrow.js
var TooltipArrow = (0, import_react561.forwardRef)((props52, ref36) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps3(tooltip.getArrowProps(), props52);
  return (0, import_jsx_runtime284.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
TooltipArrow.displayName = "TooltipArrow";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-arrow-tip.js
var import_jsx_runtime285 = __toESM(require_jsx_runtime(), 1);
var import_react563 = __toESM(require_react(), 1);
var TooltipArrowTip = (0, import_react563.forwardRef)((props52, ref36) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps3(tooltip.getArrowTipProps(), props52);
  return (0, import_jsx_runtime285.jsx)(ark.div, { ...mergedProps, ref: ref36 });
});
TooltipArrowTip.displayName = "TooltipArrowTip";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-content.js
var import_jsx_runtime286 = __toESM(require_jsx_runtime(), 1);
var import_react565 = __toESM(require_react(), 1);
var TooltipContent = (0, import_react565.forwardRef)((props52, ref36) => {
  const tooltip = useTooltipContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps3(tooltip.getContentProps(), presence.getPresenceProps(), props52);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime286.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref36) });
});
TooltipContent.displayName = "TooltipContent";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-context.js
var TooltipContext = (props52) => props52.children(useTooltipContext());

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-positioner.js
var import_jsx_runtime287 = __toESM(require_jsx_runtime(), 1);
var import_react567 = __toESM(require_react(), 1);
var TooltipPositioner = (0, import_react567.forwardRef)(
  (props52, ref36) => {
    const tooltip = useTooltipContext();
    const mergedProps = mergeProps3(tooltip.getPositionerProps(), props52);
    const presence = usePresenceContext();
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime287.jsx)(ark.div, { ...mergedProps, ref: ref36 });
  }
);
TooltipPositioner.displayName = "TooltipPositioner";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-root.js
var import_jsx_runtime288 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/node_modules/@zag-js/tooltip/dist/index.mjs
var anatomy67 = createAnatomy2("tooltip").parts("trigger", "arrow", "arrowTip", "positioner", "content");
var parts63 = anatomy67.build();
var dom60 = createScope({
  getTriggerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.trigger) ?? `tooltip:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.content) ?? `tooltip:${ctx.id}:content`;
  },
  getArrowId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.arrow) ?? `tooltip:${ctx.id}:arrow`;
  },
  getPositionerId: (ctx) => {
    var _a7;
    return ((_a7 = ctx.ids) == null ? void 0 : _a7.positioner) ?? `tooltip:${ctx.id}:popper`;
  },
  getTriggerEl: (ctx) => dom60.getById(ctx, dom60.getTriggerId(ctx)),
  getContentEl: (ctx) => dom60.getById(ctx, dom60.getContentId(ctx)),
  getPositionerEl: (ctx) => dom60.getById(ctx, dom60.getPositionerId(ctx)),
  getArrowEl: (ctx) => dom60.getById(ctx, dom60.getArrowId(ctx))
});
var store2 = proxy35({
  id: null,
  prevId: null,
  setId(val) {
    this.prevId = this.id;
    this.id = val;
  }
});
function connect25(state2, send, normalize2) {
  const id = state2.context.id;
  const hasAriaLabel = state2.context.hasAriaLabel;
  const open = state2.hasTag("open");
  const triggerId = dom60.getTriggerId(state2.context);
  const contentId = dom60.getContentId(state2.context);
  const disabled = state2.context.disabled;
  const popperStyles = getPlacementStyles2({
    ...state2.context.positioning,
    placement: state2.context.currentPlacement
  });
  return {
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts63.trigger.attrs,
        id: triggerId,
        dir: state2.context.dir,
        "data-expanded": dataAttr(open),
        "data-state": open ? "open" : "closed",
        "aria-describedby": open ? contentId : void 0,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!state2.context.closeOnClick) return;
          send({ type: "CLOSE", src: "trigger.click" });
        },
        onFocus(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (state2.event.src === "trigger.pointerdown") return;
          if (!isFocusVisible()) return;
          send({ type: "OPEN", src: "trigger.focus" });
        },
        onBlur(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (id === store2.id) {
            send({ type: "CLOSE", src: "trigger.blur" });
          }
        },
        onPointerDown(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!state2.context.closeOnPointerDown) return;
          if (id === store2.id) {
            send({ type: "CLOSE", src: "trigger.pointerdown" });
          }
        },
        onPointerMove(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (event.pointerType === "touch") return;
          send("POINTER_MOVE");
        },
        onPointerLeave() {
          if (disabled) return;
          send("POINTER_LEAVE");
        },
        onPointerCancel() {
          if (disabled) return;
          send("POINTER_LEAVE");
        }
      });
    },
    getArrowProps() {
      return normalize2.element({
        id: dom60.getArrowId(state2.context),
        ...parts63.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts63.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getPositionerProps() {
      return normalize2.element({
        id: dom60.getPositionerId(state2.context),
        ...parts63.positioner.attrs,
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts63.content.attrs,
        dir: state2.context.dir,
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: hasAriaLabel ? void 0 : "tooltip",
        id: hasAriaLabel ? void 0 : contentId,
        "data-placement": state2.context.currentPlacement,
        onPointerEnter() {
          send("CONTENT.POINTER_MOVE");
        },
        onPointerLeave() {
          send("CONTENT.POINTER_LEAVE");
        },
        style: {
          pointerEvents: state2.context.interactive ? "auto" : "none"
        }
      });
    }
  };
}
var { and: and43, not: not46 } = guards20;
function machine24(userContext) {
  const ctx = compact4(userContext);
  return createMachine35(
    {
      id: "tooltip",
      initial: ctx.open ? "open" : "closed",
      activities: ["trackFocusVisible"],
      context: {
        openDelay: 1e3,
        closeDelay: 500,
        closeOnPointerDown: true,
        closeOnEscape: true,
        interactive: false,
        closeOnScroll: true,
        closeOnClick: true,
        ...ctx,
        currentPlacement: void 0,
        hasPointerMoveOpened: false,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        }
      },
      computed: {
        hasAriaLabel: (ctx2) => !!ctx2["aria-label"]
      },
      watch: {
        disabled: ["closeIfDisabled"],
        open: ["toggleVisibility"]
      },
      states: {
        closed: {
          tags: ["closed"],
          entry: ["clearGlobalId"],
          on: {
            "CONTROLLED.OPEN": "open",
            OPEN: {
              target: "open",
              actions: ["invokeOnOpen"]
            },
            POINTER_LEAVE: {
              actions: ["clearPointerMoveOpened"]
            },
            POINTER_MOVE: [
              {
                guard: and43("noVisibleTooltip", not46("hasPointerMoveOpened")),
                target: "opening"
              },
              {
                guard: not46("hasPointerMoveOpened"),
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ]
          }
        },
        opening: {
          tags: ["closed"],
          activities: ["trackScroll", "trackPointerlockChange"],
          after: {
            OPEN_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            POINTER_LEAVE: [
              {
                guard: "isOpenControlled",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              }
            ],
            CLOSE: {
              target: "closed",
              actions: ["invokeOnClose"]
            }
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackEscapeKey", "trackScroll", "trackPointerlockChange", "trackPositioning"],
          entry: ["setGlobalId"],
          on: {
            "CONTROLLED.CLOSE": "closed",
            CLOSE: {
              target: "closed",
              actions: ["invokeOnClose"]
            },
            POINTER_LEAVE: [
              {
                guard: "isVisible",
                target: "closing",
                actions: ["clearPointerMoveOpened"]
              },
              // == group ==
              {
                guard: "isOpenControlled",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              }
            ],
            "CONTENT.POINTER_LEAVE": {
              guard: "isInteractive",
              target: "closing"
            },
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackStore", "trackPositioning"],
          after: {
            CLOSE_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          },
          on: {
            "CONTROLLED.CLOSE": "closed",
            "CONTROLLED.OPEN": "open",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            POINTER_MOVE: [
              {
                guard: "isOpenControlled",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ],
            "CONTENT.POINTER_MOVE": {
              guard: "isInteractive",
              target: "open"
            },
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        }
      }
    },
    {
      activities: {
        trackFocusVisible(ctx2) {
          return trackFocusVisible2({ root: dom60.getRootNode(ctx2) });
        },
        trackPositioning(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const getPositionerEl = () => dom60.getPositionerEl(ctx2);
          return getPlacement2(dom60.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackPointerlockChange(ctx2, _evt, { send }) {
          const onChange = () => send({ type: "CLOSE", src: "pointerlock:change" });
          return addDomEvent2(dom60.getDoc(ctx2), "pointerlockchange", onChange, false);
        },
        trackScroll(ctx2, _evt, { send }) {
          if (!ctx2.closeOnScroll) return;
          const triggerEl = dom60.getTriggerEl(ctx2);
          if (!triggerEl) return;
          const overflowParents = getOverflowAncestors(triggerEl);
          const cleanups2 = overflowParents.map((overflowParent) => {
            const onScroll = () => {
              send({ type: "CLOSE", src: "scroll" });
            };
            return addDomEvent2(overflowParent, "scroll", onScroll, { passive: true, capture: true });
          });
          return () => {
            cleanups2.forEach((fn) => fn == null ? void 0 : fn());
          };
        },
        trackStore(ctx2, _evt, { send }) {
          return subscribe35(store2, () => {
            if (store2.id !== ctx2.id) {
              send({ type: "CLOSE", src: "id.change" });
            }
          });
        },
        trackEscapeKey(ctx2, _evt, { send }) {
          if (!ctx2.closeOnEscape) return;
          const onKeyDown = (event) => {
            if (isComposingEvent(event)) return;
            if (event.key !== "Escape") return;
            event.stopPropagation();
            send({ type: "CLOSE", src: "keydown.escape" });
          };
          return addDomEvent2(dom60.getDoc(ctx2), "keydown", onKeyDown, true);
        }
      },
      actions: {
        setGlobalId(ctx2) {
          store2.setId(ctx2.id);
        },
        clearGlobalId(ctx2) {
          if (ctx2.id === store2.id) {
            store2.setId(null);
          }
        },
        invokeOnOpen(ctx2) {
          var _a7;
          (_a7 = ctx2.onOpenChange) == null ? void 0 : _a7.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a7;
          (_a7 = ctx2.onOpenChange) == null ? void 0 : _a7.call(ctx2, { open: false });
        },
        closeIfDisabled(ctx2, _evt, { send }) {
          if (!ctx2.disabled) return;
          send({ type: "CLOSE", src: "disabled.change" });
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom60.getPositionerEl(ctx2);
          getPlacement2(dom60.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        },
        setPointerMoveOpened(ctx2) {
          ctx2.hasPointerMoveOpened = true;
        },
        clearPointerMoveOpened(ctx2) {
          ctx2.hasPointerMoveOpened = false;
        }
      },
      guards: {
        noVisibleTooltip: () => store2.id === null,
        isVisible: (ctx2) => ctx2.id === store2.id,
        isInteractive: (ctx2) => ctx2.interactive,
        hasPointerMoveOpened: (ctx2) => !!ctx2.hasPointerMoveOpened,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      delays: {
        OPEN_DELAY: (ctx2) => ctx2.openDelay,
        CLOSE_DELAY: (ctx2) => ctx2.closeDelay
      }
    }
  );
}
var props51 = createProps30()([
  "aria-label",
  "closeDelay",
  "closeOnEscape",
  "closeOnPointerDown",
  "closeOnScroll",
  "closeOnClick",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "interactive",
  "onOpenChange",
  "open.controlled",
  "open",
  "openDelay",
  "positioning"
]);
var splitProps52 = createSplitProps2(props51);

// node_modules/@ark-ui/react/dist/components/tooltip/use-tooltip.js
var import_react569 = __toESM(require_react(), 1);
var useTooltip = (props52 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react569.useId)(),
    dir,
    getRootNode: getRootNode2,
    open: props52.defaultOpen,
    "open.controlled": props52.open !== void 0,
    ...props52
  };
  const context = {
    ...initialContext,
    onOpenChange: useEvent(props52.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine24(initialContext), { context });
  return connect25(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-root.js
var TooltipRoot = (props52) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props52);
  const tooltip = useTooltip(localProps);
  const presence = usePresence(mergeProps3({ present: tooltip.open }, presenceProps));
  return (0, import_jsx_runtime288.jsx)(TooltipProvider, { value: tooltip, children: (0, import_jsx_runtime288.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-root-provider.js
var import_jsx_runtime289 = __toESM(require_jsx_runtime(), 1);
var TooltipRootProvider = (props52) => {
  const [presenceProps, { value: tooltip, children }] = splitPresenceProps(props52);
  const presence = usePresence(mergeProps3({ present: tooltip.open }, presenceProps));
  return (0, import_jsx_runtime289.jsx)(TooltipProvider, { value: tooltip, children: (0, import_jsx_runtime289.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-trigger.js
var import_jsx_runtime290 = __toESM(require_jsx_runtime(), 1);
var import_react573 = __toESM(require_react(), 1);
var TooltipTrigger = (0, import_react573.forwardRef)((props52, ref36) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps3(tooltip.getTriggerProps(), props52);
  return (0, import_jsx_runtime290.jsx)(ark.button, { ...mergedProps, ref: ref36 });
});
TooltipTrigger.displayName = "TooltipTrigger";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip.js
var tooltip_exports = {};
__export(tooltip_exports, {
  Arrow: () => TooltipArrow,
  ArrowTip: () => TooltipArrowTip,
  Content: () => TooltipContent,
  Context: () => TooltipContext,
  Positioner: () => TooltipPositioner,
  Root: () => TooltipRoot,
  RootProvider: () => TooltipRootProvider,
  Trigger: () => TooltipTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/tooltip/tooltip.js
var {
  withRootProvider: withRootProvider7,
  withContext: withContext57,
  useStyles: useTooltipStyles,
  PropsProvider: PropsProvider55
} = createSlotRecipeContext({ key: "tooltip" });
var TooltipRootProvider2 = withRootProvider7(
  tooltip_exports.RootProvider
);
var TooltipRoot2 = withRootProvider7(tooltip_exports.Root);
var TooltipPropsProvider = PropsProvider55;
var TooltipTrigger2 = withContext57(tooltip_exports.Trigger, "trigger", { forwardAsChild: true });
var TooltipPositioner2 = withContext57(tooltip_exports.Positioner, "positioner", { forwardAsChild: true });
var TooltipContent2 = withContext57(
  tooltip_exports.Content,
  "content",
  { forwardAsChild: true }
);
var TooltipArrow2 = withContext57(
  tooltip_exports.Arrow,
  "arrow",
  { forwardAsChild: true }
);
var TooltipArrowTip2 = withContext57(tooltip_exports.ArrowTip, "arrowTip", { forwardAsChild: true });
var TooltipContext2 = tooltip_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/tooltip/namespace.js
var namespace_exports45 = {};
__export(namespace_exports45, {
  Arrow: () => TooltipArrow2,
  ArrowTip: () => TooltipArrowTip2,
  Content: () => TooltipContent2,
  Context: () => TooltipContext2,
  Positioner: () => TooltipPositioner2,
  PropsProvider: () => TooltipPropsProvider,
  Root: () => TooltipRoot2,
  RootProvider: () => TooltipRootProvider2,
  Trigger: () => TooltipTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/typography/heading.js
var { withContext: withContext58, PropsProvider: PropsProvider56 } = createRecipeContext({
  key: "heading"
});
var Heading = withContext58("h2");
var HeadingPropsProvider = PropsProvider56;

// node_modules/@chakra-ui/react/dist/esm/components/typography/text.js
var { withContext: withContext59, PropsProvider: PropsProvider57 } = createRecipeContext({
  key: "text"
});
var Text = withContext59("p");
var TextPropsProvider = PropsProvider57;

// node_modules/@chakra-ui/react/dist/esm/components/typography/em.js
var Em = chakra("em", {
  base: {
    fontStyle: "italic"
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/typography/strong.js
var Strong = chakra("strong", {
  base: { fontWeight: "semibold" }
});

// node_modules/@chakra-ui/react/dist/esm/components/visually-hidden/visually-hidden.js
var visuallyHiddenStyle9 = {
  border: "0",
  clip: "rect(0, 0, 0, 0)",
  height: "1px",
  width: "1px",
  margin: "-1px",
  padding: "0",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
};
var VisuallyHidden = chakra("span", {
  base: visuallyHiddenStyle9
});
VisuallyHidden.displayName = "VisuallyHidden";
export {
  AbsoluteCenter,
  namespace_exports as Accordion,
  AccordionContext2 as AccordionContext,
  AccordionItem2 as AccordionItem,
  AccordionItemBody,
  AccordionItemContent2 as AccordionItemContent,
  AccordionItemContext2 as AccordionItemContext,
  AccordionItemIndicator2 as AccordionItemIndicator,
  AccordionItemTrigger2 as AccordionItemTrigger,
  AccordionPropsProvider,
  AccordionRoot2 as AccordionRoot,
  AccordionRootProvider2 as AccordionRootProvider,
  namespace_exports2 as ActionBar,
  ActionBarCloseTrigger,
  ActionBarContent,
  ActionBarContext,
  ActionBarPositioner,
  ActionBarPropsProvider,
  ActionBarRoot,
  ActionBarRootProvider,
  ActionBarSelectionTrigger,
  ActionBarSeparator,
  namespace_exports3 as Alert,
  AlertContent,
  AlertDescription,
  AlertIndicator,
  AlertPropsProvider,
  AlertRoot,
  AlertTitle,
  AspectRatio,
  namespace_exports4 as Avatar,
  AvatarContext2 as AvatarContext,
  AvatarFallback2 as AvatarFallback,
  AvatarIcon,
  AvatarImage2 as AvatarImage,
  AvatarPropsProvider,
  AvatarRoot2 as AvatarRoot,
  Badge,
  BadgePropsProvider,
  Bleed,
  namespace_exports5 as Blockquote,
  BlockquoteCaption,
  BlockquoteContent,
  BlockquoteIcon,
  BlockquotePropsProvider,
  BlockquoteRoot,
  Box,
  namespace_exports6 as Breadcrumb,
  BreadcrumbCurrentLink,
  BreadcrumbEllipsis,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPropsProvider,
  BreadcrumbRoot,
  BreadcrumbSeparator,
  Button,
  namespace_exports7 as Card,
  CardBody,
  CardDescription,
  CardFooter,
  CardHeader,
  CardPropsProvider,
  CardRoot,
  CardTitle,
  Center,
  ChakraProvider,
  namespace_exports8 as Checkbox,
  namespace_exports9 as CheckboxCard,
  CheckboxCardAddon,
  CheckboxCardContent,
  CheckboxCardContext,
  CheckboxCardControl,
  CheckboxCardDescription,
  CheckboxCardHiddenInput,
  CheckboxCardIndicator,
  CheckboxCardLabel,
  CheckboxCardRoot,
  CheckboxCardRootPropsProvider,
  CheckboxCardRootProvider,
  CheckboxContext2 as CheckboxContext,
  CheckboxControl2 as CheckboxControl,
  CheckboxGroup2 as CheckboxGroup,
  CheckboxHiddenInput2 as CheckboxHiddenInput,
  CheckboxIndicator2 as CheckboxIndicator,
  CheckboxLabel2 as CheckboxLabel,
  CheckboxPropsProvider,
  CheckboxRoot2 as CheckboxRoot,
  Checkmark,
  Circle,
  ClientOnly,
  namespace_exports10 as Clipboard,
  ClipboardContext2 as ClipboardContext,
  ClipboardControl2 as ClipboardControl,
  ClipboardIndicator2 as ClipboardIndicator,
  ClipboardInput2 as ClipboardInput,
  ClipboardLabel2 as ClipboardLabel,
  ClipboardPropsProvider,
  ClipboardRoot2 as ClipboardRoot,
  ClipboardRootProvider2 as ClipboardRootProvider,
  ClipboardTrigger2 as ClipboardTrigger,
  Code,
  CodePropsProvider,
  namespace_exports11 as Collapsible,
  CollapsibleContent2 as CollapsibleContent,
  CollapsibleContext2 as CollapsibleContext,
  CollapsiblePropsProvider,
  CollapsibleRoot2 as CollapsibleRoot,
  CollapsibleRootProvider2 as CollapsibleRootProvider,
  CollapsibleTrigger2 as CollapsibleTrigger,
  Container,
  ContainerPropsProvider,
  namespace_exports12 as DataList,
  DataListItem,
  DataListItemLabel,
  DataListItemValue,
  DataListPropsProvider,
  DataListRoot,
  namespace_exports13 as Dialog,
  DialogActionTrigger,
  DialogBackdrop2 as DialogBackdrop,
  DialogBody,
  DialogCloseTrigger2 as DialogCloseTrigger,
  DialogContent2 as DialogContent,
  DialogContext2 as DialogContext,
  DialogDescription2 as DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogPositioner2 as DialogPositioner,
  DialogPropsProvider,
  DialogRoot2 as DialogRoot,
  DialogTitle2 as DialogTitle,
  DialogTrigger2 as DialogTrigger,
  namespace_exports14 as Drawer,
  DrawerActionTrigger,
  DrawerBackdrop,
  DrawerBody,
  DrawerCloseTrigger,
  DrawerContent,
  DrawerContext,
  DrawerDescription,
  DrawerFooter,
  DrawerHeader,
  DrawerPositioner,
  DrawerRoot,
  DrawerRootPropsProvider,
  DrawerRootProvider,
  DrawerTitle,
  DrawerTrigger,
  EMPTY_SLOT_STYLES,
  EMPTY_STYLES,
  namespace_exports15 as Editable,
  EditableArea2 as EditableArea,
  EditableCancelTrigger2 as EditableCancelTrigger,
  EditableContext2 as EditableContext,
  EditableControl2 as EditableControl,
  EditableEditTrigger2 as EditableEditTrigger,
  EditableInput2 as EditableInput,
  EditablePreview2 as EditablePreview,
  EditablePropsProvider,
  EditableRoot2 as EditableRoot,
  EditableRootProvider2 as EditableRootProvider,
  EditableSubmitTrigger2 as EditableSubmitTrigger,
  EditableTextarea,
  Em,
  namespace_exports16 as EmptyState,
  EmptyStateContent,
  EmptyStateDescription,
  EmptyStateIndicator,
  EmptyStatePropsProvider,
  EmptyStateRoot,
  EmptyStateTitle,
  EnvironmentProvider,
  namespace_exports17 as Field,
  FieldErrorIcon,
  FieldErrorText2 as FieldErrorText,
  FieldHelperText2 as FieldHelperText,
  FieldLabel2 as FieldLabel,
  FieldPropsProvider,
  FieldRequiredIndicator,
  FieldRoot2 as FieldRoot,
  namespace_exports18 as Fieldset,
  FieldsetContent,
  FieldsetContext2 as FieldsetContext,
  FieldsetErrorText2 as FieldsetErrorText,
  FieldsetHelperText2 as FieldsetHelperText,
  FieldsetLegend2 as FieldsetLegend,
  FieldsetRoot2 as FieldsetRoot,
  namespace_exports19 as FileUpload,
  FileUploadClearTrigger2 as FileUploadClearTrigger,
  FileUploadContext2 as FileUploadContext,
  FileUploadDropzone2 as FileUploadDropzone,
  FileUploadDropzoneContent,
  FileUploadItem2 as FileUploadItem,
  FileUploadItemContent,
  FileUploadItemDeleteTrigger2 as FileUploadItemDeleteTrigger,
  FileUploadItemGroup2 as FileUploadItemGroup,
  FileUploadItemName2 as FileUploadItemName,
  FileUploadItemPreview2 as FileUploadItemPreview,
  FileUploadItemPreviewImage2 as FileUploadItemPreviewImage,
  FileUploadItemSizeText2 as FileUploadItemSizeText,
  FileUploadLabel2 as FileUploadLabel,
  FileUploadPropsProvider,
  FileUploadRoot2 as FileUploadRoot,
  FileUploadRootProvider2 as FileUploadRootProvider,
  FileUploadTrigger2 as FileUploadTrigger,
  Flex,
  Float,
  For,
  FormatByte2 as FormatByte,
  FormatNumber2 as FormatNumber,
  Grid,
  GridItem,
  Group,
  HStack,
  Heading,
  HeadingPropsProvider,
  Highlight2 as Highlight,
  namespace_exports20 as HoverCard,
  HoverCardArrow2 as HoverCardArrow,
  HoverCardArrowTip2 as HoverCardArrowTip,
  HoverCardContent2 as HoverCardContent,
  HoverCardContext2 as HoverCardContext,
  HoverCardPositioner2 as HoverCardPositioner,
  HoverCardPropsProvider,
  HoverCardRoot2 as HoverCardRoot,
  HoverCardRootProvider2 as HoverCardRootProvider,
  HoverCardTrigger2 as HoverCardTrigger,
  Icon,
  IconButton,
  Image,
  Input,
  InputAddon,
  InputElement,
  InputPropsProvider,
  Kbd,
  Link,
  LinkBox,
  LinkOverlay,
  LinkPropsProvider,
  namespace_exports21 as List,
  ListIndicator,
  ListItem,
  ListRoot,
  ListRootPropsProvider,
  LocaleProvider,
  Mark,
  MarkPropsProvider,
  namespace_exports22 as Menu,
  MenuArrow2 as MenuArrow,
  MenuArrowTip2 as MenuArrowTip,
  MenuCheckboxItem2 as MenuCheckboxItem,
  MenuContent2 as MenuContent,
  MenuContext2 as MenuContext,
  MenuContextTrigger2 as MenuContextTrigger,
  MenuIndicator2 as MenuIndicator,
  MenuItem2 as MenuItem,
  MenuItemCommand,
  MenuItemContext2 as MenuItemContext,
  MenuItemGroup2 as MenuItemGroup,
  MenuItemGroupLabel2 as MenuItemGroupLabel,
  MenuItemIndicator2 as MenuItemIndicator,
  MenuItemText2 as MenuItemText,
  MenuPositioner2 as MenuPositioner,
  MenuPropsProvider,
  MenuRadioItem2 as MenuRadioItem,
  MenuRadioItemGroup2 as MenuRadioItemGroup,
  MenuRoot2 as MenuRoot,
  MenuRootProvider2 as MenuRootProvider,
  MenuSeparator2 as MenuSeparator,
  MenuTrigger2 as MenuTrigger,
  MenuTriggerItem2 as MenuTriggerItem,
  namespace_exports23 as NativeSelect,
  NativeSelectField,
  NativeSelectIndicator,
  NativeSelectPropsProvider,
  NativeSelectRoot,
  namespace_exports24 as NumberInput,
  NumberInputContext2 as NumberInputContext,
  NumberInputControl2 as NumberInputControl,
  NumberInputDecrementTrigger2 as NumberInputDecrementTrigger,
  NumberInputIncrementTrigger2 as NumberInputIncrementTrigger,
  NumberInputInput2 as NumberInputInput,
  NumberInputLabel2 as NumberInputLabel,
  NumberInputPropsProvider,
  NumberInputRoot2 as NumberInputRoot,
  NumberInputRootProvider2 as NumberInputRootProvider,
  NumberInputScrubber2 as NumberInputScrubber,
  NumberInputValueText2 as NumberInputValueText,
  namespace_exports25 as Pagination,
  PaginationContext2 as PaginationContext,
  PaginationEllipsis2 as PaginationEllipsis,
  PaginationItem2 as PaginationItem,
  PaginationNextTrigger2 as PaginationNextTrigger,
  PaginationPrevTrigger2 as PaginationPrevTrigger,
  PaginationPropsProvider,
  PaginationRoot2 as PaginationRoot,
  PaginationRootProvider2 as PaginationRootProvider,
  namespace_exports26 as PinInput,
  PinInputContext2 as PinInputContext,
  PinInputControl2 as PinInputControl,
  PinInputHiddenInput2 as PinInputHiddenInput,
  PinInputInput2 as PinInputInput,
  PinInputLabel2 as PinInputLabel,
  PinInputPropsProvider,
  PinInputRoot2 as PinInputRoot,
  PinInputRootProvider2 as PinInputRootProvider,
  namespace_exports27 as Popover,
  PopoverAnchor2 as PopoverAnchor,
  PopoverArrow2 as PopoverArrow,
  PopoverArrowTip2 as PopoverArrowTip,
  PopoverBody,
  PopoverCloseTrigger2 as PopoverCloseTrigger,
  PopoverContent2 as PopoverContent,
  PopoverContext2 as PopoverContext,
  PopoverDescription2 as PopoverDescription,
  PopoverFooter,
  PopoverHeader,
  PopoverPositioner2 as PopoverPositioner,
  PopoverPropsProvider,
  PopoverRoot2 as PopoverRoot,
  PopoverRootProvider2 as PopoverRootProvider,
  PopoverTitle2 as PopoverTitle,
  PopoverTrigger2 as PopoverTrigger,
  Portal,
  namespace_exports28 as Progress,
  namespace_exports29 as ProgressCircle,
  ProgressCircleCircle,
  ProgressCircleContext,
  ProgressCircleLabel,
  ProgressCirclePropsProvider,
  ProgressCircleRange2 as ProgressCircleRange,
  ProgressCircleRoot,
  ProgressCircleRootProvider,
  ProgressCircleTrack2 as ProgressCircleTrack,
  ProgressCircleValueText,
  ProgressContext2 as ProgressContext,
  ProgressLabel2 as ProgressLabel,
  ProgressPropsProvider,
  ProgressRange2 as ProgressRange,
  ProgressRoot2 as ProgressRoot,
  ProgressRootProvider2 as ProgressRootProvider,
  ProgressTrack2 as ProgressTrack,
  ProgressValueText2 as ProgressValueText,
  namespace_exports30 as RadioCard,
  RadioCardContext,
  RadioCardItem,
  RadioCardItemAddon,
  RadioCardItemContent,
  RadioCardItemControl,
  RadioCardItemDescription,
  RadioCardItemHiddenInput,
  RadioCardItemIndicator,
  RadioCardItemText,
  RadioCardLabel,
  RadioCardPropsProvider,
  RadioCardRoot,
  RadioCardRootProvider,
  namespace_exports31 as RadioGroup,
  RadioGroupContext2 as RadioGroupContext,
  RadioGroupItem2 as RadioGroupItem,
  RadioGroupItemControl2 as RadioGroupItemControl,
  RadioGroupItemHiddenInput2 as RadioGroupItemHiddenInput,
  RadioGroupItemIndicator2 as RadioGroupItemIndicator,
  RadioGroupItemText2 as RadioGroupItemText,
  RadioGroupLabel2 as RadioGroupLabel,
  RadioGroupPropsProvider,
  RadioGroupRoot2 as RadioGroupRoot,
  RadioGroupRootProvider2 as RadioGroupRootProvider,
  Radiomark,
  namespace_exports32 as RatingGroup,
  RatingGroupContext2 as RatingGroupContext,
  RatingGroupControl2 as RatingGroupControl,
  RatingGroupHiddenInput2 as RatingGroupHiddenInput,
  RatingGroupItem2 as RatingGroupItem,
  RatingGroupItemContext2 as RatingGroupItemContext,
  RatingGroupItemIndicator,
  RatingGroupLabel2 as RatingGroupLabel,
  RatingGroupPropsProvider,
  RatingGroupRoot2 as RatingGroupRoot,
  RatingGroupRootProvider2 as RatingGroupRootProvider,
  RecipePropsProvider,
  namespace_exports33 as SegmentGroup,
  SegmentGroupContext2 as SegmentGroupContext,
  SegmentGroupIndicator2 as SegmentGroupIndicator,
  SegmentGroupItem2 as SegmentGroupItem,
  SegmentGroupItemContext2 as SegmentGroupItemContext,
  SegmentGroupItemHiddenInput2 as SegmentGroupItemHiddenInput,
  SegmentGroupItemText2 as SegmentGroupItemText,
  SegmentGroupPropsProvider,
  SegmentGroupRoot2 as SegmentGroupRoot,
  SegmentGroupRootProvider2 as SegmentGroupRootProvider,
  namespace_exports34 as Select,
  SelectClearTrigger2 as SelectClearTrigger,
  SelectContent2 as SelectContent,
  SelectContext2 as SelectContext,
  SelectControl2 as SelectControl,
  SelectIndicator2 as SelectIndicator,
  SelectIndicatorGroup,
  SelectItem2 as SelectItem,
  SelectItemContext2 as SelectItemContext,
  SelectItemGroup2 as SelectItemGroup,
  SelectItemGroupLabel2 as SelectItemGroupLabel,
  SelectItemIndicator2 as SelectItemIndicator,
  SelectItemText2 as SelectItemText,
  SelectLabel2 as SelectLabel,
  SelectPositioner2 as SelectPositioner,
  SelectPropsProvider,
  SelectRoot2 as SelectRoot,
  SelectRootProvider2 as SelectRootProvider,
  SelectTrigger2 as SelectTrigger,
  SelectValueText2 as SelectValueText,
  Separator,
  SeparatorPropsProvider,
  Show,
  SimpleGrid,
  Skeleton,
  SkeletonPropsProvider,
  SkipNavContent,
  SkipNavLink,
  namespace_exports35 as Slider,
  SliderContext2 as SliderContext,
  SliderControl2 as SliderControl,
  SliderHiddenInput2 as SliderHiddenInput,
  SliderLabel2 as SliderLabel,
  SliderMarker2 as SliderMarker,
  SliderMarkerGroup2 as SliderMarkerGroup,
  SliderMarkerIndicator,
  SliderPropsProvider,
  SliderRange2 as SliderRange,
  SliderRoot2 as SliderRoot,
  SliderRootProvider2 as SliderRootProvider,
  SliderThumb2 as SliderThumb,
  SliderTrack2 as SliderTrack,
  SliderValueText2 as SliderValueText,
  Spacer,
  Span,
  Spinner,
  SpinnerPropsProvider,
  Square,
  Stack,
  StackSeparator,
  namespace_exports36 as Stat,
  StatDownIndicator,
  StatHelpText,
  StatLabel,
  StatPropsProvider,
  StatRoot,
  StatUpIndicator,
  StatValueText,
  StatValueUnit,
  namespace_exports37 as Status,
  StatusIndicator,
  StatusPropsProvider,
  StatusRoot,
  namespace_exports38 as Steps,
  StepsCompletedContent2 as StepsCompletedContent,
  StepsContent2 as StepsContent,
  StepsContext2 as StepsContext,
  StepsDescription,
  StepsIndicator2 as StepsIndicator,
  StepsItem2 as StepsItem,
  StepsItemContext2 as StepsItemContext,
  StepsList2 as StepsList,
  StepsNextTrigger2 as StepsNextTrigger,
  StepsNumber,
  StepsPrevTrigger2 as StepsPrevTrigger,
  StepsPropsProvider,
  StepsRoot2 as StepsRoot,
  StepsRootProvider2 as StepsRootProvider,
  StepsSeparator2 as StepsSeparator,
  StepsStatus,
  StepsTitle,
  StepsTrigger2 as StepsTrigger,
  Sticky,
  Strong,
  namespace_exports39 as Switch,
  SwitchContext2 as SwitchContext,
  SwitchControl2 as SwitchControl,
  SwitchHiddenInput2 as SwitchHiddenInput,
  SwitchIndicator,
  SwitchLabel2 as SwitchLabel,
  SwitchPropsProvider,
  SwitchRoot2 as SwitchRoot,
  SwitchRootProvider2 as SwitchRootProvider,
  SwitchThumb2 as SwitchThumb,
  SwitchThumbIndicator,
  namespace_exports40 as Table,
  TableBody,
  TableCaption,
  TableCell,
  TableColumn,
  TableColumnGroup,
  TableColumnHeader,
  TableFooter,
  TableHeader,
  TableRoot,
  TableRootPropsProvider,
  TableRow,
  TableScrollArea,
  namespace_exports41 as Tabs,
  TabsContent,
  TabsContentGroup,
  TabsContext2 as TabsContext,
  TabsIndicator,
  TabsList,
  TabsPropsProvider,
  TabsRoot2 as TabsRoot,
  TabsRootProvider2 as TabsRootProvider,
  TabsTrigger,
  namespace_exports42 as Tag,
  TagCloseTrigger,
  TagEndElement,
  TagLabel,
  TagRoot,
  TagRootPropsProvider,
  TagStartElement,
  Text,
  TextPropsProvider,
  Textarea,
  TextareaPropsProvider,
  Theme,
  namespace_exports43 as Timeline,
  TimelineConnector,
  TimelineContent,
  TimelineDescription,
  TimelineIndicator,
  TimelineItem,
  TimelineRoot,
  TimelineRootPropsProvider,
  TimelineSeparator,
  namespace_exports44 as Toast,
  ToastActionTrigger2 as ToastActionTrigger,
  ToastCloseTrigger2 as ToastCloseTrigger,
  ToastDescription2 as ToastDescription,
  ToastIndicator,
  ToastRoot2 as ToastRoot,
  ToastTitle2 as ToastTitle,
  Toaster2 as Toaster,
  namespace_exports45 as Tooltip,
  TooltipArrow2 as TooltipArrow,
  TooltipArrowTip2 as TooltipArrowTip,
  TooltipContent2 as TooltipContent,
  TooltipContext2 as TooltipContext,
  TooltipPositioner2 as TooltipPositioner,
  TooltipPropsProvider,
  TooltipRoot2 as TooltipRoot,
  TooltipRootProvider2 as TooltipRootProvider,
  TooltipTrigger2 as TooltipTrigger,
  VStack,
  VisuallyHidden,
  chakra,
  createContext3 as createContext,
  createIcon,
  createListCollection,
  createRecipeContext,
  createSlotRecipeContext,
  createSystem,
  createToaster,
  defaultBaseConfig,
  defaultConfig,
  defaultSystem,
  defineAnimationStyles,
  defineConditions,
  defineConfig,
  defineGlobalStyles,
  defineKeyframes,
  defineLayerStyles,
  defineRecipe,
  defineSemanticTokens,
  defineSlotRecipe,
  defineStyle,
  defineTextStyles,
  defineTokens,
  isValidSystem,
  mergeConfigs,
  mergeProps,
  mergeRefs,
  useAccordion,
  useAccordionContext,
  useAccordionItemContext,
  useAccordionStyles,
  usePopover as useActionBar,
  usePopoverContext as useActionBarContext,
  useActionBarStyles,
  useAlertStyles,
  useAvatar,
  useAvatarContext,
  useAvatarStyles,
  useBlockquoteStyles,
  useBreadcrumbStyles,
  useBreakpoint,
  useBreakpointValue,
  useCallbackRef,
  useCardStyles,
  useChakraContext,
  useCheckbox,
  useCheckbox as useCheckboxCard,
  useCheckboxContext as useCheckboxCardContext,
  useCheckboxCardStyles,
  useCheckboxContext,
  useCheckboxGroup,
  useCheckboxGroupContext,
  useCheckboxStyles,
  useClipboard,
  useClipboardContext,
  useClipboardStyles,
  useCollapsible,
  useCollapsibleContext,
  useCollapsibleStyles,
  useControllableProp,
  useControllableState,
  useDataListStyles,
  useDialog,
  useDialogContext,
  useDialogStyles,
  useDisclosure,
  useDialog as useDrawer,
  useDialogContext as useDrawerContext,
  useDrawerStyles,
  useEditable,
  useEditableContext,
  useEditableStyles,
  useEmptyStateStyles,
  useEnvironmentContext,
  useFieldContext,
  useFieldStyles,
  useFieldsetContext,
  useFileUpload,
  useFileUploadContext,
  useFileUploadStyles,
  useHighlight,
  useHoverCard,
  useHoverCardContext,
  useHoverCardStyles,
  useListStyles,
  useLocaleContext,
  useMediaQuery,
  useMenuContext,
  useMenuItemContext,
  useMenuStyles,
  useNativeSelectStyles,
  useNumberInput,
  useNumberInputContext,
  useNumberInputStyles,
  usePagination,
  usePaginationContext,
  usePaginationStyles,
  useParentRecipeProps,
  usePinInput,
  usePinInputContext,
  usePinInputStyles,
  usePopover,
  usePopoverContext,
  usePopoverStyles,
  useProgressCircleStyles,
  useProgressContext,
  useProgressStyles,
  useRadioGroupContext as useRadioCardContext,
  useRadioGroupItemContext as useRadioCardItemContext,
  useRadioCardStyles,
  useRadioGroupContext,
  useRadioGroupStyles,
  useRatingGroupContext,
  useRatingGroupItemContext,
  useRatingGroupStyles,
  useRecipe,
  useSegmentGroup,
  useSegmentGroupContext,
  useSegmentGroupItemContext,
  useSegmentGroupStyles,
  useSelect,
  useSelectContext,
  useSelectStyles,
  useSlider,
  useSliderContext,
  useSliderStyles,
  useSlotRecipe,
  useStatStyles,
  useStatusStyles,
  useStepsContext,
  useStepsStyles,
  useSwitch,
  useSwitchContext,
  useSwitchStyles,
  useTableStyles,
  useTabsStyles,
  useTagStyles,
  useTimelineStyles,
  useToastStyles,
  useToken,
  useTooltip,
  useTooltipContext,
  useTooltipStyles,
  visuallyHiddenStyle9 as visuallyHiddenStyle
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 7.5.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)

focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 7.6.0
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=@chakra-ui_react.js.map
